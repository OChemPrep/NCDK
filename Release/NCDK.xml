<?xml version="1.0"?>
<doc>
    <assembly>
        <name>NCDK</name>
    </assembly>
    <members>
        <member name="T:NCDK.Beam.AllCycles">
            <summary>
            Aromaticity perception using AllCycles.
            </summary>
        </member>
        <member name="F:NCDK.Beam.AllCycles.ps">
            <summary>Number of pi electrons for Sp2 atoms.</summary>
        </member>
        <member name="F:NCDK.Beam.AllCycles.PathEdge.u">
            <summary>End points of the edge.</summary>
        </member>
        <member name="F:NCDK.Beam.AllCycles.PathEdge.v">
            <summary>End points of the edge.</summary>
        </member>
        <member name="F:NCDK.Beam.AllCycles.PathEdge.ps">
            <summary>Number of pi electrons in the path.</summary>
        </member>
        <member name="T:NCDK.Beam.ArbitraryMatching">
            <summary>
            Simple matching greedily chooses edges and matches. The produced matching is
            not guaranteed to be maximum but provides a starting point for improvement
            through augmentation.
            </summary>
        </member>
        <member name="M:NCDK.Beam.ArbitraryMatching.Initial(NCDK.Beam.Graph,NCDK.Beam.Matching,System.Collections.BitArray)">
             <summary>
             Create an arbitrary matching on the subset of vertices ('s') of provided
             graph. The provided matching should be empty.
            
             <param name="g">graph to match</param>
             <param name="m">empty matching (presumed)</param>
             <param name="s">subset of vertices</param>
             <returns>number of vertices matched</returns>
             </summary>
        </member>
        <member name="M:NCDK.Beam.ArbitraryMatching.AugmentOnce(NCDK.Beam.Graph,NCDK.Beam.Matching,System.Int32,System.Collections.BitArray)">
             <summary>
             When precisely two vertices are unmatched we only need to find a single
             augmenting path. Rather than run through edmonds with blossoms etc we
             simple do a targest DFS for the path.
            
             <param name="g">graph</param>
             <param name="m">matching</param>
             <param name="nMatched">current matching cardinality must be |s|-nMathced == 2</param>
             <param name="s">subset size</param>
             <returns>new match cardinality</returns>
             </summary>
        </member>
        <member name="T:NCDK.Beam.Atom">
            <summary>
            Defines properties of a atom that can be encoded in SMILES. Atoms can be
            built using the <see cref="T:NCDK.Beam.AtomBuilder"/> class.
            </summary>
        </member>
        <member name="P:NCDK.Beam.Atom.Isotope">
            <summary>
            The isotope number of the atom. If the isotope is undefined (default) a
            value -1 is returned.
            </summary>
        </member>
        <member name="P:NCDK.Beam.Atom.Element">
            <summary>
            The element of the atom.
            </summary>
        </member>
        <member name="P:NCDK.Beam.Atom.Label">
            <summary>
            An label attached to an element (input only). Although invalid via the
            specification 'CCC[R]' etc can occur in the 'wild'. If found the parser
            provides an 'Unknown' element and a specified label. Not the labels are
            never written. By default the label is the element symbol.
            </summary>
        </member>
        <member name="M:NCDK.Beam.Atom.IsAromatic">
            <summary>
            Whether this atom is aromatic.
            </summary>
            <returns>atom is aromatic (true) or aliphatic (false)</returns>
        </member>
        <member name="P:NCDK.Beam.Atom.Charge">
            <summary>
            Formal charge of the atom.
            </summary>
        </member>
        <member name="P:NCDK.Beam.Atom.NumOfHydrogens">
            <summary>
            Number of hydrogens this atom has. This value defines atoms with an
            explicit hydrogen count of bracket atoms (e.g. [CH4]).
            </summary>
            <returns>hydrogen count</returns>
            <exception cref="T:System.InvalidOperationException">
            if element is part of the organic subset and the number of hydrogens is implied by the bond Order sum.
            </exception>
        </member>
        <member name="P:NCDK.Beam.Atom.AtomClass">
            <summary>
            The class of the atom is defined as an integer value. The atom class is
            specified for bracketed atoms and is prefixed by a colon.
            <para>[CH:1](C)([C])[H:2]</para>
            </summary>
        </member>
        <member name="M:NCDK.Beam.Atom.AsAromaticForm">
            <summary>
            Access an aromatic form of this atom. If the element can not be aromatic
            then the same atom is returned.
            </summary>
            <returns>the aromatic form of this atom (or if it can't be aromatic just this atom)</returns>
        </member>
        <member name="P:NCDK.Beam.Atom.Subset">
            <summary>
            (internal) Is the atom a member of the organic (aromatic/aliphatic)
            subset implementation?
            </summary>
        </member>
        <member name="M:NCDK.Beam.Atom.AsAliphaticForm">
            <summary>
            Access an aliphatic form of this atom. 
            </summary>
            <returns>the aliphatic form of this atom</returns>
        </member>
        <member name="M:NCDK.Beam.Atom.GetNumberOfHydrogens(NCDK.Beam.Graph,System.Int32)">
            <summary>
            (internal) The number of hydrogens this atom would have if it were vertex
            '<paramref name="u"/>' in the graph '<paramref name="g"/>'. If the atom is in the organic subset the value is
            computed - otherwise the labelled hydrogen count is returned.
            </summary>
            <seealso cref="M:NCDK.Beam.Graph.ImplHCount(System.Int32)"/>
        </member>
        <member name="P:NCDK.Beam.Atom.Token">
            <summary>
            (internal) The token to write for the atom when generating a SMILES
            string.
            </summary>
        </member>
        <member name="T:NCDK.Beam.AtomBuilder">
            <summary>
            A builder for <see cref="T:NCDK.Beam.Atom"/> instantiation.
            </summary>
            <example><code>
            // [C]
            Atom a = AtomBuilder.Aliphatic(Element.Carbon)
                                .Build();
            
            // [CH4]
            Atom a = AtomBuilder.Aliphatic(Element.Carbon)
                                .NumOfHydrogens(4)
                                .Build();
            
            // [13CH4]
            Atom a = AtomBuilder.Aliphatic(Element.Carbon)
                                .NumOfHydrogens(4)
                                .Isotope(13)
                                .Build();
            
            // [CH3-]
            Atom a = AtomBuilder.Aliphatic(Element.Carbon)
                                .NumOfHydrogens(3)
                                .Charge(-1)
                                .Build();
            
            // or
            Atom a = AtomBuilder.Aliphatic(Element.Carbon)
                                .NumOfHydrogens(3)
                                .Anion
                                .Build();
            
            // [CH4:1]
            Atom a = AtomBuilder.Aliphatic(Element.Carbon)
                                .NumOfHydrogens(4)
                                .AtomClass(1)
                                .Build();
            </code></example>
        </member>
        <member name="M:NCDK.Beam.AtomBuilder.Aliphatic(NCDK.Beam.Element)">
            <summary>
            Start building an aliphatic atom of the given element.
            </summary>
            <code>
            Atom a = AtomBuilder.Aliphatic(Element.Carbon)
                                .Build();
            </code>
            <param name="e">element type</param>
            <returns>an atom builder to configure additional properties</returns>
            <exception cref="T:System.ArgumentNullException">the element was null</exception>
        </member>
        <member name="M:NCDK.Beam.AtomBuilder.Aromatic(NCDK.Beam.Element)">
            <summary>
            Start building an aromatic atom of the given element.
            </summary>
            <example>
            Atom a = AtomBuilder.Aromatic(Element.Carbon)
            Atom a = AtomBuilder.AromaticElement.Carbon)
                                .Build();
            </example>
            <param name="e">element type</param>
            <returns>an atom builder to configure additional properties</returns> 
            <exception cref="T:System.ArgumentNullException">the element was null</exception>
            <exception cref="T:System.ArgumentException">the element cannot be aromatic</exception>
        </member>
        <member name="M:NCDK.Beam.AtomBuilder.Aliphatic(System.String)">
            <summary>
            Start building an aliphatic atom of the given element symbol. If an
            element of the symbol could not be found then the element type is set to
            <see cref="F:NCDK.Beam.Element.Unknown"/>.
            </summary>
            <example>
            Atom a = AtomBuilder.Aliphatic("C")
                                .Build();
            </example>
            <param name="symbol">symbol of an element</param>
            <returns>an atom builder to configure additional properties</returns>
            <exception cref="T:System.ArgumentNullException">the element was null</exception>
        </member>
        <member name="M:NCDK.Beam.AtomBuilder.Aromatic(System.String)">
             <summary>
             Start building an aromatic atom of the given element symbol. If an
             element of the symbol could not be found then the element type is set to
             <see cref="F:NCDK.Beam.Element.Unknown"/>.
             </summary>
            
             <example>
             Atom a = AtomBuilder.IsAromatic("C")
                                 .Build();
             </example>
             <param name="symbol">symbol of an element</param>
             <returns>an atom builder to configure additional properties</returns>
             <exception cref="T:System.ArgumentNullException">the element was null</exception>
             <exception cref="T:System.ArgumentException">the element cannot be aromatic</exception>
        </member>
        <member name="M:NCDK.Beam.AtomBuilder.Create(System.String)">
             <summary>
             Start building an aliphatic or aromatic atom of the given element symbol.
             If an element of the symbol could not be found then the element type is
             set to <see cref="F:NCDK.Beam.Element.Unknown"/>.
             </summary>
            
             <example>
             Atom a = AtomBuilder.Create("C") // aliphatic
                                 .Build();
             Atom a = AtomBuilder.Create("c") // aromatic
                                 .Build();
             </example>
            
             <param name="symbol">symbol of an element - lower case indicates the atom should 
             be aromatic</param>
             <returns>an atom builder to configure additional properties</returns>
             <exception cref="T:System.ArgumentNullException">the element was null</exception>
             <exception cref="T:System.ArgumentException">the element cannot be aromatic</exception>
        </member>
        <member name="M:NCDK.Beam.AtomBuilder.OfSymbolOrUnknown(System.String)">
            <summary>
            Get the element of the given symbol - if no symbol is found then the
            <see cref="F:NCDK.Beam.Element.Unknown"/> is returned.
            </summary>
            <param name="symbol">an atom symbol</param>
            <returns>the element of the given symbol (or Unknown)</returns>
        </member>
        <member name="M:NCDK.Beam.AtomBuilder.NumOfHydrogens(System.Int32)">
            <summary>
            Assign the given hydrogen count to the atom which will be created.
            </summary>
            <param name="hCount">number of hydrogens</param>
            <returns>an atom builder to configure additional properties</returns>
        </member>
        <member name="M:NCDK.Beam.AtomBuilder.Charge(System.Int32)">
            <summary>
            Assign the given formal charge to the atom which will be created.
            </summary>
            <param name="charge">formal-charge</param>
            <returns>an atom builder to configure additional properties</returns>
        </member>
        <member name="P:NCDK.Beam.AtomBuilder.Anion">
            <summary>
            Assign a formal-charge of -1 to the atom which will be created.
            </summary>
            <returns>an atom builder to configure additional properties</returns>
        </member>
        <member name="P:NCDK.Beam.AtomBuilder.Cation">
            <summary>
            Assign a formal-charge of +1 to the atom which will be created.
            </summary>
            <returns>an atom builder to configure additional properties</returns>
        </member>
        <member name="M:NCDK.Beam.AtomBuilder.Isotope(System.Int32)">
            <summary>
            Assign the isotope number to the atom which will be created. An isotope
            number of '-1' means unspecified (default).
            </summary>
            <param name="isotope">isotope number >= 0.</param>
            <returns>an atom builder to configure additional properties</returns>
        </member>
        <member name="M:NCDK.Beam.AtomBuilder.AtomClass(System.Int32)">
            <summary>
            Assign the atom class to the atom which will be created. A class of '0'
            means unspecified (default).
            </summary>
            <param name="c">atom class 1..n</param>
            <returns>an atom builder to configure additional properties</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">the atom class was negative</exception>
        </member>
        <member name="M:NCDK.Beam.AtomBuilder.Build">
            <summary>
            Create the atom with the configured attributed.
            </summary>
            <returns>an atom</returns>
        </member>
        <member name="M:NCDK.Beam.AtomBuilder.ExplicitHydrogen">
            <summary>
            Access an atom implementation which can be used for all explicit
            hydrogens.
            </summary>
            <returns>an explicit hydrogen to be used in assembly molecules</returns>
        </member>
        <member name="T:NCDK.Beam.AtomImpl">
            <summary>
            Internal atom implementations.
            </summary>
        </member>
        <member name="T:NCDK.Beam.BiconnectedComponents">
            <summary>
            see. http://en.wikipedia.org/wiki/Biconnected_component
            </summary>
        </member>
        <member name="T:NCDK.Beam.Bond">
            <summary>
            Enumeration of valid <see cref="T:NCDK.Beam.Edge"/> labels. The connections include all the
            valid undirected and directed bond types and <see cref="F:NCDK.Beam.Bond.Dot"/>. Opposed to the
            other types, <see cref="F:NCDK.Beam.Bond.Dot"/> indicates that two atoms are not connected.
            </summary>
            <remarks>
            <list type="table">
            <item>
            <term><see cref="T:NCDK.Beam.Bond"/></term>
            <term><see cref="P:NCDK.Beam.Bond.Token"/></term>
            <term><see cref="P:NCDK.Beam.Bond.Order"/></term>
            <term><see cref="M:NCDK.Beam.Bond.Inverse"/></term>
            </item>
            <item><term><see cref="F:NCDK.Beam.Bond.Dot"/></term><term>.</term><term>0</term><term></term></item>
            <item><term><see cref="F:NCDK.Beam.Bond.Implicit"/></term><term></term><term>undefined (2 or 3)</term><term></term></item>
            <item><term><see cref="F:NCDK.Beam.Bond.Single"/></term><term>-</term><term>2</term><term></term></item>
            <item><term><see cref="F:NCDK.Beam.Bond.Aromatic"/></term><term>:</term><term>3</term><term></term></item>
            <item><term><see cref="F:NCDK.Beam.Bond.Double"/></term><term>=</term><term>4</term><term></term></item>
            <item><term><see cref="F:NCDK.Beam.Bond.Triple"/></term><term>#</term><term>6</term><term></term></item>
            <item><term><see cref="F:NCDK.Beam.Bond.Quadruple"/></term><term>$</term><term>8</term><term></term></item>
            <item><term><see cref="F:NCDK.Beam.Bond.Up"/></term><term>/</term><term>2</term><term><see cref="F:NCDK.Beam.Bond.Down"/></term></item>
            <item><term><see cref="F:NCDK.Beam.Bond.Down"/></term><term>\</term><term>2</term><term><see cref="F:NCDK.Beam.Bond.Up"/></term></item>
            </list>
            </remarks>
            <seealso href="http://www.opensmiles.org/opensmiles.html#bonds">Bonds, OpenSMILES Specification</seealso>
        </member>
        <member name="F:NCDK.Beam.Bond.Dot">
            <summary>Atoms are not bonded. </summary>
        </member>
        <member name="F:NCDK.Beam.Bond.Implicit">
            <summary>Atoms are bonded by either a single or aromatic bond. </summary>
        </member>
        <member name="F:NCDK.Beam.Bond.ImplicitAromatic">
            <summary>An implicit bond which is delocalised. </summary>
        </member>
        <member name="F:NCDK.Beam.Bond.Single">
            <summary>Atoms are bonded by a single pair of electrons. </summary>
        </member>
        <member name="F:NCDK.Beam.Bond.Double">
            <summary>Atoms are bonded by two pairs of electrons. </summary>
        </member>
        <member name="F:NCDK.Beam.Bond.DoubleAromatic">
            <summary>A double bond which is delocalised. </summary>
        </member>
        <member name="F:NCDK.Beam.Bond.Triple">
            <summary>Atoms are bonded by three pairs of electrons. </summary>
        </member>
        <member name="F:NCDK.Beam.Bond.Quadruple">
            <summary>Atoms are bonded by four pairs of electrons. </summary>
        </member>
        <member name="F:NCDK.Beam.Bond.Aromatic">
            <summary>Atoms are bonded by a delocalized bond of an aromatic system. </summary>
        </member>
        <member name="F:NCDK.Beam.Bond.Up">
            <summary>
            Directional, single or aromatic bond (currently always single). The bond
            is relative to each endpoint such that the second endpoint is
            <i>above</i> the first or the first end point is <i>below</i> the
            second.
            </summary>
        </member>
        <member name="T:NCDK.Beam.Bond.Bond_Down">
            <summary>
            Directional, single or aromatic bond (currently always single). The bond
            is relative to each endpoint such that the second endpoint is
            <i>below</i> the first or the first end point is <i>above</i> the
            second.
            </summary>
        </member>
        <member name="F:NCDK.Beam.Bond.token">
            <summary>The token for the bond in the SMILES grammar. </summary>
        </member>
        <member name="P:NCDK.Beam.Bond.Token">
            <summary>
            The token of the bond in the SMILES grammar.
            </summary>
        </member>
        <member name="P:NCDK.Beam.Bond.Order">
            <summary>
            The Order of the bond.
            </summary>
        </member>
        <member name="M:NCDK.Beam.Bond.Inverse">
            <summary>
            Access the inverse of a directional bond <see cref="F:NCDK.Beam.Bond.Up"/>, <see cref="F:NCDK.Beam.Bond.Down"/>). If
            a bond is non-directional the same bond is returned.
            </summary>
            <returns>inverse of the bond</returns>
        </member>
        <member name="M:NCDK.Beam.Bond.CreateEdge(System.Int32,System.Int32)">
            <summary>
            Create an edge between the vertices <paramref name="u"/> and <paramref name="v"/> with this
            label.
            </summary>
            <example><code>Edge e = Bond.Implicit.CreateEdge(2, 3);</code></example>
            <param name="u">an end point of the edge</param>
            <param name="v">the other endpoint of the edge</param>
            <returns>a new edge labeled with this value</returns>
            <seealso cref="T:NCDK.Beam.Edge"/>
        </member>
        <member name="M:NCDK.Beam.Bond.ToString">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Beam.CharBuffer">
            <summary>
            A character buffer with utilities for sequential processing of characters.
            </summary>
        </member>
        <member name="F:NCDK.Beam.CharBuffer.cs">
            <summary>Characters stored in a fixed size array.</summary>
        </member>
        <member name="P:NCDK.Beam.CharBuffer.Position">
            <summary>Current position.</summary>
        </member>
        <member name="M:NCDK.Beam.CharBuffer.#ctor(System.Char[])">
            <summary>
            Internal constructor
            </summary>
            <param name="cs">array of characters</param>
        </member>
        <member name="M:NCDK.Beam.CharBuffer.HasRemaining">
            <summary>
            Determine if there are any characters remaining in the buffer. There are
            no characters remaining when the position has reached the end of the
            array.
            </summary>
            <returns>the position has reached the end of the array</returns>
        </member>
        <member name="M:NCDK.Beam.CharBuffer.Get">
            <summary>
            Access the next character in the buffer and progress the position.
            </summary>
            <returns>the next character</returns>
            <seealso cref="P:NCDK.Beam.CharBuffer.NextChar"/>
        </member>
        <member name="P:NCDK.Beam.CharBuffer.NextChar">
            <summary>
            Access the the next character in the buffer without progressing the
            position.
            </summary>
            <returns>the next character</returns>
            <seealso cref="M:NCDK.Beam.CharBuffer.Get"/>
        </member>
        <member name="M:NCDK.Beam.CharBuffer.NextIsDigit">
            <summary>
            Determine if the next character is a digit. The buffer is first checked
            to ensure there are characters remaining.
            </summary>
            <returns>whether there is a 'next' character and it is a digit</returns>.
        </member>
        <member name="M:NCDK.Beam.CharBuffer.GetAsDigit">
            <summary>
            Access the next character as a digit, the buffer position will progress.
            No check is made that there are characters remaining and the next
            character is a digit.
            </summary>
            <returns>the next character in the buffer as a digit</returns>.
            <see cref="M:NCDK.Beam.CharBuffer.NextIsDigit"/> 
        </member>
        <member name="M:NCDK.Beam.CharBuffer.GetNextAsDigit">
            <summary>
            Access the next character as a digit, the buffer position does not
            progress. No check is made that there are characters remaining and the
            next character is a digit.
            </summary>
            <returns>the next character in the buffer as a digit</returns>.
            <see cref="M:NCDK.Beam.CharBuffer.NextIsDigit"/> 
        </member>
        <member name="M:NCDK.Beam.CharBuffer.NextIs(System.Char)">
            <summary>
            Determine if the next character is <paramref name="c"/>.
            </summary>
            <param name="c">test if the next character is</param>
            <returns>whether there are characters remaining and the</returns>
        </member>
        <member name="M:NCDK.Beam.CharBuffer.GetIf(System.Char)">
            <summary>
            Progress the buffer if the next character is the same as the provided
            character.
            </summary>
            <param name="c">a character</param>
            <returns>whether the buffer progressed and the character matched</returns>
        </member>
        <member name="M:NCDK.Beam.CharBuffer.GetNumber">
            <summary>
            Get a sequence of digits from the buffer as a positive integer.  The
            buffer is progressed until the end of the number. If the characters do
            not represent a number then -1 is returned and the buffer is not
            progressed.
            </summary>
            <returns>the number read</returns>, &lt; 0 if no number read
        </member>
        <member name="M:NCDK.Beam.CharBuffer.GetNumber(System.Int32)">
            <summary>
            Get a sequence of specified digits from the buffer as a positive integer.
            The buffer is progressed until the end of the number. If the characters do
            not represent a number then -1 is returned and the buffer is not
            progressed.
            <param name="nDigits">the number of digits to read</param>
            <returns>the number read</returns>, &lt; 0 if no number read
            </summary>
        </member>
        <member name="M:NCDK.Beam.CharBuffer.Substr(System.Int32,System.Int32)">
            <summary>
            Obtain the string of characters 'from' - 'to' the specified indices.
            <param name="from">start index</param>
            <param name="to">  end index</param>
            <returns>the string between the indices</returns>
            </summary>
        </member>
        <member name="P:NCDK.Beam.CharBuffer.Length">
            <summary>
            The number of characters in the buffer.
            </summary>
            <returns>length of the buffer</returns>
        </member>
        <member name="M:NCDK.Beam.CharBuffer.IsDigit(System.Char)">
            <summary>
            Determine if the specified character 'c' is a digit (0-9).
            </summary>
            <param name="c">a character</param>
            <returns>the character is a digit</returns>
        </member>
        <member name="M:NCDK.Beam.CharBuffer.ToDigit(System.Char)">
            <summary>
            Convert the specified character to the corresponding integral digit.
            Note, no check is made as to whether the character is actually a digit
            which should be performed with <see cref="M:NCDK.Beam.CharBuffer.IsDigit(System.Char)"/>.
            </summary>
            <param name="c">a character</param>
            <returns>the digit for character</returns>
            <seealso cref="M:NCDK.Beam.CharBuffer.IsDigit(System.Char)"/>
        </member>
        <member name="M:NCDK.Beam.CharBuffer.FromString(System.String)">
            <summary>
            Create a buffer from a string.
            </summary>
            <param name="str">string</param>
            <returns>new char buffer</returns>
        </member>
        <member name="M:NCDK.Beam.CharBuffer.ToString">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Beam.Configuration">
            <summary>
            Enumeration of atom-based relative configurations. Each value defines a
            configuration of a given topology.
            </summary>
            <seealso href="http://www.opensmiles.org/opensmiles.html#chirality">Chirality, OpenSMILES</seealso>
        </member>
        <member name="F:NCDK.Beam.Configuration.Unknown">
            <summary>An atoms has Unknown/no configuration. </summary>
        </member>
        <member name="F:NCDK.Beam.Configuration.AntiClockwise">
            <summary>Shorthand for TH1, AL1, DB1, TB1 or OH1 configurations. </summary>
        </member>
        <member name="F:NCDK.Beam.Configuration.Clockwise">
            <summary>Shorthand for TH2, AL2, DB2, TB2 or OH2 configurations. </summary>
        </member>
        <member name="F:NCDK.Beam.Configuration.TH1">
            <summary>
            Tetrahedral, neighbors proceed anti-clockwise looking from the first
            atom.
            </summary>
        </member>
        <member name="F:NCDK.Beam.Configuration.TH2">
            <summary>Tetrahedral, neighbors proceed clockwise looking from the first atom. </summary>
        </member>
        <member name="F:NCDK.Beam.Configuration.DB1">
            <summary>
            Atom-based double bond configuration, neighbors proceed anti-clockwise in
            a plane. <i>Note - this configuration is currently specific to
            grins.</i>
            </summary>
        </member>
        <member name="F:NCDK.Beam.Configuration.DB2">
            <summary>
            Atom-based double bond configuration, neighbors proceed clockwise in a
            plane.<i>Note - this configuration is currently specific to grins.</i>
            </summary>
        </member>
        <member name="F:NCDK.Beam.Configuration.type">
            <summary>Type of configuration. </summary>
        </member>
        <member name="F:NCDK.Beam.Configuration.symbol">
            <summary>Symbol used to represent configuration </summary>
        </member>
        <member name="F:NCDK.Beam.Configuration.shorthand">
            <summary>Shorthand - often converted to this in output </summary>
        </member>
        <member name="F:NCDK.Beam.Configuration.tbs">
            <summary>Lookup tables for trigonal bipyramidal and octahedral </summary>
        </member>
        <member name="P:NCDK.Beam.Configuration.Shorthand">
            <summary>
            Access the shorthand for the configuration, if no shorthand is defined
            <see cref="F:NCDK.Beam.Configuration.Unknown"/> is returned.
            </summary>
            <value>the shorthand '@' or '@@'</value>
        </member>
        <member name="P:NCDK.Beam.Configuration.Symbol">
            <summary>
            Symbol of the chiral configuration.
            </summary>
        </member>
        <member name="P:NCDK.Beam.Configuration.Type">
            <summary>
            The general type of relative configuration this represents.
            </summary>
            <returns>type of the configuration</returns>
            <seealso cref="P:NCDK.Beam.Configuration.Type"/>
        </member>
        <member name="M:NCDK.Beam.Configuration.Read(NCDK.Beam.CharBuffer)">
            <summary>
            Read a chiral configuration from a character buffer and progress the
            buffer. If there is no configuration then <see cref="F:NCDK.Beam.Configuration.Unknown"/>
            is returned. Encountering an invalid permutation designator (e.g.
            &#64;TB21) or incomplete class (e.g. &#64;T) will throw an invalid smiles
            exception.
            </summary>
            <param name="buffer">a character buffer</param>
            <returns>the configuration</returns>
        </member>
        <member name="T:NCDK.Beam.Configuration.Types">
            <summary>Types of configuration.</summary>
        </member>
        <member name="T:NCDK.Beam.Configuration.DoubleBonds">
            <summary>Configurations for double-bond bond-based specification. </summary>
        </member>
        <member name="T:NCDK.Beam.Edge">
            <summary>
            An edge defines two vertex end points and an associated <see cref="P:NCDK.Beam.Edge.Bond"/> label.
            Edges are created from their <see cref="P:NCDK.Beam.Edge.Bond"/> label as follows.
            </summary>
            <example>
            an edge between the vertices 1 and 2 the bond label is implicit
            <code>
            Edge e = Bond.Implicit.CreateEdge(1, 2);
            </code>
            an edge between the vertices 5 and 3 the bond label is double
            <code>
            Edge e = Bond.Double.CreateEdge(1, 2);
            </code></example>
            <seealso cref="P:NCDK.Beam.Edge.Bond"/>
        </member>
        <member name="F:NCDK.Beam.Edge.u">
            <summary>Endpoints of the edge.</summary>
        </member>
        <member name="F:NCDK.Beam.Edge.v">
            <summary>Endpoints of the edge.</summary>
        </member>
        <member name="F:NCDK.Beam.Edge.xor">
            <summary>Endpoints of the edge.</summary>
        </member>
        <member name="P:NCDK.Beam.Edge.Bond">
            <summary>Label on the edge.</summary>
        </member>
        <member name="M:NCDK.Beam.Edge.Either">
            <summary>
            Access either endpoint of the edge. For directional bonds, the endpoint
            can be considered as relative to this vertex.
            </summary>
            <returns>either endpoint</returns>
        </member>
        <member name="M:NCDK.Beam.Edge.Other(System.Int32)">
            <summary>
            Given one endpoint, access the other endpoint of the edge.
            </summary>
            <param name="x">an endpoint of the edge</param>
            <returns>the other endpoint</returns>
        </member>
        <member name="M:NCDK.Beam.Edge.SetBond(NCDK.Beam.Bond)">
            <summary>
            Set the bond label.
            </summary>
            <param name="bond">the bond label</param>
        </member>
        <member name="M:NCDK.Beam.Edge.GetBond(System.Int32)">
            <summary>
            Access the bond label relative to a specified endpoint.
            </summary>
            <example><code>
            Edge e = Bond.Up.CreateEdge(2, 3);
            e.Bond(2); // Up
            e.Bond(3); // Down
            </code></example>
            <param name="x">endpoint to which the label is relative to</param>
            <returns>the bond label</returns>
        </member>
        <member name="M:NCDK.Beam.Edge.Inverse">
            <summary>
            Inverse of the edge label but keep the vertices the same.
            </summary>
            <returns>inverse edge</returns>
        </member>
        <member name="M:NCDK.Beam.Edge.InvalidEndpointMessage(System.Int32)">
            <summary>Helper method to print error message.</summary>
        </member>
        <member name="M:NCDK.Beam.Edge.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Beam.Edge.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Beam.Edge.ToString">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Beam.ElectronAssignment">
            <summary>
            Verifies delocalised electrons can be assigned to a structure without
            changing bond Orders. To check and assign the electrons please use <see cref="T:NCDK.Beam.Localise"/>
            or <see cref="M:NCDK.Beam.Graph.Kekule"/>. Although faster than assigning a Kekul√©
            structure the method is the same and returning a structure with specified
            bond Orders is usually preferred.
            </summary>
            <seealso cref="T:NCDK.Beam.Localise"/>
            <seealso cref="M:NCDK.Beam.Graph.Kekule"/>
        </member>
        <member name="M:NCDK.Beam.ElectronAssignment.ContainsOddCardinalitySubgraph(NCDK.Beam.Graph,System.Collections.BitArray)">
            <summary>
            Check if it is possible to assign electrons to the subgraph (specified by
            the set bits in of <paramref name="bs"/>). Each connected subset is counted up and
            checked for odd cardinality.
            </summary>
            <param name="g"> graph</param>
            <param name="bs">binary set indicated vertices for the subgraph</param>
            <returns>there is an odd cardinality subgraph</returns>
        </member>
        <member name="M:NCDK.Beam.ElectronAssignment.Visit(NCDK.Beam.Graph,System.Int32,System.Int32,System.Boolean[])">
            <summary>
            Determine the size the connected component using a depth-first-search.
            </summary>
            <param name="g">graph</param>
            <param name="v">vertex</param>
            <param name="c">count</param>
            <param name="visited">which vertices have been visited</param>
            <returns>size of the component from </returns><paramref name="v"/>
        </member>
        <member name="M:NCDK.Beam.ElectronAssignment.IsOdd(System.Int32)">
            <summary>
            Test if an a number, <paramref name="x"/> is odd.
            </summary>
            <param name="x">a number</param>
            <returns>the number is odd</returns>
        </member>
        <member name="M:NCDK.Beam.ElectronAssignment.Verify(NCDK.Beam.Graph)">
            <summary>
            Utility method to verify electrons can be assigned.
            </summary>
            <param name="g">graph to check</param>
            <returns>electrons could be assigned to delocalised structure</returns>
        </member>
        <member name="T:NCDK.Beam.ElectronDonation">
            <summary>
            Defines a model to determine the number of p electrons a particular element
            in a certain environment donates. There is no universally accepted 'correct'
            model and different models can produce very different results.
            </summary>
        </member>
        <member name="F:NCDK.Beam.ElectronDonation.DAYLIGHT">
            <summary>The Daylight model implementation.</summary>
        </member>
        <member name="M:NCDK.Beam.ElectronDonation.Contribution(System.Int32,NCDK.Beam.Graph,NCDK.Beam.ElectronDonation.Cycle,System.Collections.BitArray)">
             <summary>
             The number p electrons dominated by the atom label at vertex 'u' in the
             'cycle' of the graph 'g'. Additionally the 'cyclic' bit set indicates the
             vertices are members of any cycle.
            
             Depending on the perception method the 'cycle' may not be known in which
             case a runtime error will be thrown if it is needed for determining the
             donation. The cycle will be Unknown if the method use the donation model
             builds up the cycle iteratively counting the number of p electrons.
             </summary>
             <param name="u">the vertex under consideration</param>
             <param name="g">the graph the vertex is referring to</param>
             <param name="cycle"> the cycle under consideration</param>
             <param name="cyclic">all cyclic vertices</param>
             <returns>the number of p electrons contributed to if the element or -1 if
                     the vertex should not be used</returns>
        </member>
        <member name="P:NCDK.Beam.ElectronDonation.Daylight">
             <summary>
             The Daylight aromatic model (aprox).
            
             <returns>electron donation model</returns>
             </summary>
        </member>
        <member name="T:NCDK.Beam.ElectronDonation.Cycle">
            <summary>The cyclic vertices.</summary>
        </member>
        <member name="T:NCDK.Beam.ElectronDonation.DaylightImpl">
            <summary>
            Daylight donation model - interpreted from various sources and testing
            the Daylight Depict service, http://www.daylight.com/daycgi/depict.
            </summary>
        </member>
        <member name="M:NCDK.Beam.ElectronDonation.DaylightImpl.Contribution(System.Int32,NCDK.Beam.Graph,NCDK.Beam.ElectronDonation.Cycle,System.Collections.BitArray)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Beam.ElectronDonation.DaylightImpl.AcyclicContribution(NCDK.Beam.Atom,NCDK.Beam.Atom,System.Int32)">
             <summary>
             For a 'cyclic' atom double bonded to an 'acyclic' atom how many
             electrons should be donated?
            
             <param name="cyclic"> cyclic atom</param>
             <param name="acyclic">acyclic atom double bonded to the 'cyclic' atom</param>
             <param name="charge"> charge on the cyclic atom</param>
             <returns>number of donated electrons</returns>
             </summary>
        </member>
        <member name="T:NCDK.Beam.Element">
            <summary>
            Enumeration of valid OpenSMILES elements.
            </summary>
            <remarks>
            <para>Organic subsets</para>
            <para>
            Several of the elements belong to the organic
            subset. Atoms of an organic element type can be written just as their symbol
            (see. <see href="http://www.opensmiles.org/opensmiles.html#orgsbst">Organic Subset, OpenSMILES Specification</see>).
            </para>
            <list type="bullet">
            <item><see cref="F:NCDK.Beam.Element.Unknown"/> (*)</item> 
            <item><see cref="F:NCDK.Beam.Element.Boron"/></item>
            <item><see cref="F:NCDK.Beam.Element.Carbon"/></item>
            <item><see cref="F:NCDK.Beam.Element.Nitrogen"/></item>
            <item><see cref="F:NCDK.Beam.Element.Oxygen"/></item>
            <item><see cref="F:NCDK.Beam.Element.Fluorine"/></item> 
            <item><see cref="F:NCDK.Beam.Element.Phosphorus"/></item>
            <item><see cref="F:NCDK.Beam.Element.Sulfur"/></item> 
            <item><see cref="F:NCDK.Beam.Element.Chlorine"/></item>
            <item><see cref="F:NCDK.Beam.Element.Bromine"/></item> 
            <item><see cref="F:NCDK.Beam.Element.Iodine"/></item> 
            </list>
            </remarks>
            <example>
            <para>Usage</para>
            
            Elements can be created by either using the value directly or by looking up
            it's symbol. If the element may be aromatic the lower-case symbol can also be
            used. For example the variable 'e' in the three statements below all have the
            same value, <see cref="F:NCDK.Beam.Element.Carbon"/>.
            
            <code>
            Element e = Element.Carbon;
            Element e = Element.OfSymbol("C");
            Element e = Element.OfSymbol("c");
            </code>
            
            When the symbol is invalid the result wil be null.
            <code>
            Element e = Element.OfSymbol("R1"); // e = null
            </code>
            
            The <see cref="F:NCDK.Beam.Element.Unknown"/> element can be used to represent generic/alias
            atoms.
            <code>
            Element e = Element.Unknown;
            Element e = Element.OfSymbol("*");
            </code>
            
            To access the symbol of an already created element. Use <see cref="P:NCDK.Beam.Element.Symbol"/>.
            
            <code>
            IAtom    a = ...;
            Element e = a.Element;
            
            string  symbol = e.Symbol;
            </code>
            </example>
            <seealso href="http://www.opensmiles.org/opensmiles.html#inatoms">Atoms, OpenSMILES Specification</seealso>
        </member>
        <member name="F:NCDK.Beam.Element.Unknown">
            <summary>Unspecified/Unknown element (*)</summary>
        </member>
        <member name="F:NCDK.Beam.Element.atomicNumber">
            <summary>Atomic number of the elemnt.</summary>
        </member>
        <member name="F:NCDK.Beam.Element.symbol">
            <summary>The symbol of the element.</summary>
        </member>
        <member name="F:NCDK.Beam.Element.valence">
            <summary>
            Default valence information - only present if the atom is part of the
            organic subset.
            </summary>
        </member>
        <member name="F:NCDK.Beam.Element.elementMap">
            <summary>Look up of elements by symbol</summary>
        </member>
        <member name="P:NCDK.Beam.Element.Values">
            <summary>Lookup elements by atomic number.</summary>
        </member>
        <member name="F:NCDK.Beam.Element.defaults">
            <summary>Provide verification of valence/charge values.</summary>
        </member>
        <member name="P:NCDK.Beam.Element.Symbol">
            <summary>
            The symbol of the element.
            </summary>
        </member>
        <member name="P:NCDK.Beam.Element.AtomicNumber">
            <summary>
            The atomic number of the element. If the element is Unknown '0' is returned.
            </summary>
        </member>
        <member name="M:NCDK.Beam.Element.IsAromatic">
            <summary>
            Can the element be aromatic. This definition is very loose and includes
            elements which are not part of the Daylight, OpenSMILES specification. To
            test if ane element is aromatic by the specification use 
            <see cref="M:NCDK.Beam.Element.IsAromatic(NCDK.Beam.Element.AromaticSpecification)"/>.
            </summary>
            <returns>whether the element may be aromatic</returns>
        </member>
        <member name="M:NCDK.Beam.Element.IsAromatic(NCDK.Beam.Element.AromaticSpecification)">
            <summary>
            Can the element be aromatic in accordance with a given specification.
            </summary>
            <param name="spec">such <see cref="F:NCDK.Beam.Element.AromaticSpecification.Daylight"/>,
            <see cref="F:NCDK.Beam.Element.AromaticSpecification.OpenSmiles"/></param>
            <returns>the element is accepted as being aromatic by that scheme</returns>
        </member>
        <member name="M:NCDK.Beam.Element.IsOrganic">
            <summary>
            Is the element a member of the organic subset and can be written without
            brackets. If the element is both organic and aromatic is a member of the
            aromatic subset and can still be written without brackets.
            </summary>
            <returns>the element can be written without brackets</returns>
        </member>
        <member name="M:NCDK.Beam.Element.NumOfImplicitHydrogens(System.Int32)">
            <summary>
            Determine the number of implied hydrogens an organic (or aromatic) subset
            atom has based on it's bond Order sum. The valances for the organic
            elements (B, C, N, O, P, S, F, Cl, Br and I) are defined in the
            OpenSMILES specification.
            </summary>
            <param name="v"></param>
            <returns>the number of implied hydrogens</returns>
            <exception cref="T:System.InvalidOperationException">
            the element was not a member of the
            organic subset and did not have default valence information
            </exception>
        </member>
        <member name="M:NCDK.Beam.Element.NumOfAvailableElectrons(System.Int32)">
            <summary>
            Determine the number of available electrons which could be bonding to
            implicit hydrogens. This include electrons donated from the hydrogen.
            </summary>
            <remarks>
            The central carbon of <c>C-C=C</c> 6 bonded electrons - using SMILES
            default valence there must be 2 electrons involved in bonding an implicit
            hydrogen (i.e. there is a single bond to a hydrogen).
            </remarks>
            <param name="bondElectronSum">the sum of the bonded electrons</param>
            <returns>number of electrons which could be involved with bonds to hydrogen</returns>
        </member>
        <member name="M:NCDK.Beam.Element.NumOfAvailableDelocalisedElectrons(System.Int32)">
             <summary>
             Determine the number of available electrons which could be bonding to
             implicit hydrogens for an aromatic atom with delocalized bonds. This
             include electrons donated from the hydrogen.
             </summary>
             <remarks>
             Instead of checking higher valence states only the lowest is checked. For
             example nitrogen has valence 3 and 5 but in a delocalized system only the
             lowest (3) is used. The electrons which would allow bonding of implicit
             hydrogens in the higher valence states are donated to the aromatic system
             and thus cannot be <i>reached</i>. Using a generalisation that an
             aromatic bond as 3 electrons we reached the correct value for multi
             valence aromatic elements.
            
             <para>
                 c1c[nH]cn1    the aromatic subset nitrogen is bonded to two aromatic
                               nitrogen bond Order sum of 3 (6 electrons) there are
                               no implicit hydrogens
            
                 c1cc2ccccn2c1 the nitrogen has three aromatic bond 4.5 bond Order
                               (9 electrons) - as we only check the lowest valence
                               (3 - 4.5) &lt; 0 so there are 0 implicit hydrogens
            
                 c1ccpcc1      the phosphorus has 2 aromatic bond (bond Order sum 3)
                               and the lowest valence is '3' - there are no implicit
                               hydrogens
            
                 oc1ccscc1     the sulphur has two aromatic bonds (bond Order sum 3)
                               the lowest valence is '2' - 3 > 2 so there are no
                               implicit hydrogens
            
                 oc1ccscc1     the oxygen has a single aromatic bond, the default
                               valence of oxygen in the specification is '2' there
                               are no hydrogens (2 - 1.5 = 0.5).
             </para>
             </remarks>
             <param name="bondElectronSum">the sum of the bonded electrons</param>
             <returns>number of electrons which could be involved with bonds to hydrogen</returns>
        </member>
        <member name="M:NCDK.Beam.Element.Verify(System.Int32,System.Int32)">
            <summary>
            Verify whether the given valence and charge are 'normal' for the
            element.
            </summary>
            <param name="v">valence (bond Order Order sum)</param>
            <param name="q">charge</param>
            <returns>whether the valence and charge are valid</returns>
        </member>
        <member name="M:NCDK.Beam.Element.OfSymbol(System.String)">
            <summary>
            Given an element symbol, provide the element for that symbol. If no
            symbol was found then null is returned.
            </summary>
            <param name="symbol">the element symbol</param>
            <returns>element for the symbol, or null if none found</returns>
        </member>
        <member name="M:NCDK.Beam.Element.OfNumber(System.Int32)">
            <summary>
            Access an element by atomic number.
            </summary>
            <param name="elem">atomic number</param>
            <returns>the element for the atomic number</returns>
        </member>
        <member name="M:NCDK.Beam.Element.Read(NCDK.Beam.CharBuffer)">
            <summary>
            Read an element and progress the character buffer. If the element was not
            read then a 'null' element is returned.
            </summary>
            <param name="buffer">a character buffer</param>
            <returns>the element, or null</returns>
        </member>
        <member name="T:NCDK.Beam.Element.NeutralValence">
            <summary>A valence check which is only valid at netural charge</summary>
        </member>
        <member name="T:NCDK.Beam.Element.AromaticSpecification">
            <summary>
            Stores which elements the Daylight and OpenSMILES specification consider
            to be aromatic. The General scheme is what might be encountered 'in the
            wild'.
            </summary>
        </member>
        <member name="M:NCDK.Beam.Element.NumOfImplicitHydrogens(NCDK.Beam.Element,System.Int32)">
            <summary>
            Determine the implicit hydrogen count of an organic subset atom
            given its bonded valence. The number of implied hydrogens an 
            organic (or aromatic) subset atom has is based on it's bonded
            valence. The valances for the organic elements (B, C, N, O, P,
            S, F, Cl, Br and I) are defined in the OpenSMILES specification.
            </summary>
            <param name="elem">Element</param>
            <param name="v">bonded valence</param>
            <returns>hydrogen count >= 0</returns>
        </member>
        <member name="M:NCDK.Beam.Element.NumOfAromaticImplicitHydrogens(NCDK.Beam.Element,System.Int32)">
            <summary>
            Determine the implicit hydrogen count of an organic subset atom
            given its bonded valence. The number of implied hydrogens an 
            organic (or aromatic) subset atom has is based on it's bonded
            valence. The valances for the organic elements (B, C, N, O, P,
            S, F, Cl, Br and I) are defined in the OpenSMILES specification.
            For aromatic atoms we only check the first level.
            </summary>
            <param name="elem">Element</param>
            <param name="v">bonded valence</param>
            <returns>hydrogen count >= 0</returns>
        </member>
        <member name="T:NCDK.Beam.Function`2">
            <summary>
            Defines a function which can be applied to one type to produce another.
            </summary>
        </member>
        <member name="M:NCDK.Beam.Function`2.Apply(`0)">
            <summary>
            Apply the function to an instance of 's' and producing and instance 't'.
            </summary>
            <param name="s">input instance</param>
            <returns>output instance</returns>
        </member>
        <member name="T:NCDK.Beam.Generator">
            <summary>
            (internal) Generate a SMILES line notation for a given chemical graph.
            </summary>
        </member>
        <member name="M:NCDK.Beam.Generator.#ctor(NCDK.Beam.Graph,NCDK.Beam.Generator.RingNumbering)">
            <summary>
            Create a new generator the given chemical graph.
            </summary>
            <param name="g">chemical graph</param>
            <param name="rnums"></param>
        </member>
        <member name="M:NCDK.Beam.Generator.#ctor(NCDK.Beam.Graph,System.Int32[],NCDK.Beam.Generator.RingNumbering)">
            <summary>
            Create a new generator the given chemical graph.
            </summary>
            <param name="g">chemical graph</param>
            <param name="visitedAt">the index of the atom in the output</param>
            <param name="rnums"></param>
        </member>
        <member name="M:NCDK.Beam.Generator.Prepare(System.Int32,System.Int32)">
            <summary>
            First traversal of the molecule assigns ring bonds (numbered later) and
            configures topologies.
            </summary>
            <param name="u">the vertex to visit</param>
            <param name="p">the atom we came from</param>
        </member>
        <member name="M:NCDK.Beam.Generator.Write(System.Int32,System.Int32,NCDK.Beam.Bond)">
            <summary>
            Second traversal writes the bonds and atoms to the SMILES string.
            </summary>
            <param name="u">a vertex</param>
            <param name="p">previous vertex</param>
            <param name="b">the bond from the previous vertex to this vertex</param>
        </member>
        <member name="M:NCDK.Beam.Generator.CyclicEdge(System.Int32,System.Int32,NCDK.Beam.Bond)">
            <summary>
            Indicate that the edge connecting the vertices u and v forms a ring.
            </summary>
            <param name="u">a vertex</param>
            <param name="v">a vertex connected to u</param>
            <param name="b">bond type connecting u to v</param>
        </member>
        <member name="M:NCDK.Beam.Generator.AddRing(System.Int32,NCDK.Beam.Generator.RingClosure)">
            <summary>
            Add a ring closure to the the vertex 'u'.
            </summary>
            <param name="u"> a vertex</param>
            <param name="rc">ring closure</param>
        </member>
        <member name="M:NCDK.Beam.Generator.GetString">
            <summary>
            Access the generated SMILES string.
            </summary>
            <returns>smiles string</returns>
        </member>
        <member name="M:NCDK.Beam.Generator.Generate(NCDK.Beam.Graph)">
            <summary>
            Convenience method for generating a SMILES string for the specified chemical graph.
            </summary>
            <param name="g">the graph to generate the SMILE for</param>
            <returns>SMILES gor the provided chemical graph</returns>
        </member>
        <member name="M:NCDK.Beam.Generator.Generate(NCDK.Beam.Graph,System.Int32[])">
            <summary>
            Convenience method for generating a SMILES string for the specified chemical graph.
            </summary>
            <param name="g">the graph to generate the SMILE for</param>
            <param name="visitedAt">store when each atom was visited</param>
            <returns>SMILES gor the provided chemical graph</returns>
        </member>
        <member name="T:NCDK.Beam.Generator.RingNumbering">
            <summary>Defines how ring numbering proceeds.</summary>
        </member>
        <member name="M:NCDK.Beam.Generator.RingNumbering.Next">
             <summary>
             The next ring number in the sequence.
            
             <returns>ring number</returns>
             </summary>
        </member>
        <member name="M:NCDK.Beam.Generator.RingNumbering.Use(System.Int32)">
             <summary>
             Mark the specified ring number as used.
            
             <param name="rnum">ring number</param>
             </summary>
        </member>
        <member name="M:NCDK.Beam.Generator.RingNumbering.Free(System.Int32)">
             <summary>
             Mark the specified ring number as no longer used.
            
             <param name="rnum">ring number</param>
             </summary>
        </member>
        <member name="M:NCDK.Beam.Generator.RingNumbering.Reset">
            <summary>Reset ring number usage</summary>
        </member>
        <member name="T:NCDK.Beam.Generator.ReuseRingNumbering">
            <summary>Labelling of ring opening/closures always using the lowest ring number.</summary>
        </member>
        <member name="T:NCDK.Beam.Generator.IterativeRingNumbering">
            <summary>
            Iterative labelling of ring opening/closures. Once the number 99 has been
            used the number restarts using any free numbers.
            </summary>
        </member>
        <member name="T:NCDK.Beam.Graph">
            <summary>
            Defines a labelled graph with atoms as vertex labels and bonds as edge
            labels. Topological information around atoms can also be stored.
            </summary>
        </member>
        <member name="F:NCDK.Beam.Graph.HAS_AROM">
            <summary>
            Indicate the graph has one or aromatic atoms.
            </summary>
        </member>
        <member name="F:NCDK.Beam.Graph.atoms">
            <summary> The vertex labels, atoms.</summary>
        </member>
        <member name="F:NCDK.Beam.Graph.edges">
            <summary> Incidence list storage of edges with attached bond labels. .</summary>
        </member>
        <member name="F:NCDK.Beam.Graph.topologies">
            <summary> Topologies indexed by the atom which they describe.</summary>
        </member>
        <member name="F:NCDK.Beam.Graph.order">
            <summary> Vertex and edge counts.</summary>
        </member>
        <member name="F:NCDK.Beam.Graph.size">
            <summary> Vertex and edge counts.</summary>
        </member>
        <member name="F:NCDK.Beam.Graph.flags">
            <summary> Molecule flags.</summary>
        </member>
        <member name="P:NCDK.Beam.Graph.Title">
            <summary> Molecule title.</summary>
        </member>
        <member name="M:NCDK.Beam.Graph.#ctor(System.Int32)">
            <summary>
            Create a new chemical graph with expected size.
            </summary>
            <param name="expSize">expected size</param>
        </member>
        <member name="M:NCDK.Beam.Graph.#ctor(NCDK.Beam.Graph)">
            <summary>
            Copy constructor.
            </summary>
            <param name="org">original graph</param>
        </member>
        <member name="M:NCDK.Beam.Graph.SetAtom(System.Int32,NCDK.Beam.Atom)">
            <summary>
            (internal) - set the atom label at position 'i'.
            </summary>
            <param name="i">index</param>
            <param name="a">atom</param>
        </member>
        <member name="M:NCDK.Beam.Graph.EnsureCapacity">
            <summary> Resize the graph if we are at maximum capacity.</summary>
        </member>
        <member name="M:NCDK.Beam.Graph.AddAtom(NCDK.Beam.Atom)">
            <summary>
            Add an atom to the graph and return the index to which the atom was added.
            </summary>
            <param name="a">add an atom</param>
            <returns>index of the atom in the graph (vertex)</returns>
        </member>
        <member name="M:NCDK.Beam.Graph.GetAtom(System.Int32)">
            <summary>
            Access the atom at the specified index.
            </summary>
            <param name="i">index of the atom to access</param>
            <returns>the atom at that index</returns>
            <exception cref="T:System.ArgumentException">no atom exists</exception>"
        </member>
        <member name="M:NCDK.Beam.Graph.AddEdge(NCDK.Beam.Edge)">
            <summary>
            Add an labelled edge to the graph.
            </summary>
            <param name="e">new edge</param>
        </member>
        <member name="M:NCDK.Beam.Graph.Degree(System.Int32)">
            <summary>
            Access the degree of vertex 'u'.
            </summary>
            <param name="u">a vertex</param>
            <returns>the degree of the specified vertex</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">attempting to access the degree of an
            atom which does not exist</exception> 
        </member>
        <member name="M:NCDK.Beam.Graph.BondedValence(System.Int32)">
            <summary>
            Access the bonded valence of vertex 'u'. This valence exclude any implicit hydrogen counts.
            </summary>
            <param name="u">a vertex index</param>
            <returns>the bonded valence of the specified vertex</returns>
        </member>
        <member name="M:NCDK.Beam.Graph.GetEdges(System.Int32)">
            <summary>
            Access the edges of which vertex '<paramref name="u"/>' is an endpoint.
            </summary>
            <param name="u">a vertex</param>
            <returns>edges incident to '<paramref name="u"/>'</returns>
        </member>
        <member name="M:NCDK.Beam.Graph.Neighbors(System.Int32)">
            <summary>
            Access the vertices adjacent to '<paramref name="u"/>' in <b>sorted</b> Order. This
            convenience method is provided to assist in configuring atom-based stereo
            using the <see cref="M:NCDK.Beam.Graph.ConfigurationOf(System.Int32)"/> method. For general purpose
            access to the neighbors of a vertex the <see cref="M:NCDK.Beam.Graph.GetEdges(System.Int32)"/> is
            preferred.
            </summary>
            <param name="u">a vertex</param>
            <returns>fixed-size array of vertices</returns>
            <seealso cref="M:NCDK.Beam.Graph.ConfigurationOf(System.Int32)"/>
        </member>
        <member name="M:NCDK.Beam.Graph.Adjacent(System.Int32,System.Int32)">
            <summary>
            Determine if the vertices '<paramref name="u"/>' and '<paramref name="v"/>' are adjacent and there is an edge
            which connects them.
            </summary>
            <param name="u">a vertex</param>
            <param name="v">another vertex</param>
            <returns>whether they are adjacent</returns>
        </member>
        <member name="M:NCDK.Beam.Graph.ImplHCount(System.Int32)">
            <summary>
            The number of implied (or labelled) hydrogens for the vertex '<paramref name="u"/>'. Note
            the count does not include any bonded vertices which may also be
            hydrogen.
            </summary>
            <param name="u">the vertex to access the implicit h count for</param>.
            <returns>the number of implicit hydrogens</returns>
        </member>
        <member name="M:NCDK.Beam.Graph.CreateEdge(System.Int32,System.Int32)">
            <summary>
            Access the edge connecting two adjacent vertices.
            </summary>
            <param name="u">a vertex</param>
            <param name="v">another vertex </param>(adjacent to u)
            <returns>the edge connected u and v</returns>
            <exception cref="T:System.ArgumentException">u and v are not adjacent</exception>
        </member>
        <member name="M:NCDK.Beam.Graph.Replace(NCDK.Beam.Edge,NCDK.Beam.Edge)">
            <summary>
            Replace an edge in the graph.
            </summary>
            <param name="org">the original edge</param>
            <param name="rep">the replacement</param>
        </member>
        <member name="M:NCDK.Beam.Graph.AddTopology(NCDK.Beam.Topology)">
            <summary>
            Add a topology description to the graph. The topology describes the
            configuration around a given atom.
            </summary>
            <param name="t">topology</param> 
        </member>
        <member name="M:NCDK.Beam.Graph.TopologyOf(System.Int32)">
            <summary>
            Access the topology of the vertex 'u'. If no topology is defined then
            <see cref="P:NCDK.Beam.Topology.Unknown"/> is returned.
            </summary>
            <param name="u">a vertex to access the topology of</param>
            <returns>the topology of vertex 'u'</returns>
        </member>
        <member name="M:NCDK.Beam.Graph.ConfigurationOf(System.Int32)">
            <summary>
            Provides the stereo-configuration of the atom label at vertex 'u'. The
            configuration describes the relative-stereo as though the atoms were
            arranged by atom number. </summary>
            <remarks>
            <b>Further Explanation for Tetrahedral Centres</b>
            As an example the
            molecule O[C@]12CCCC[C@@]1(O)CCCC2 has two tetrahedral centres.
            <list type="number">
            <item>
            The first one is on vertex '1' and looking from vertex '0' the
            other neighbors [6, 11, 2] proceed anti-clockwise ('@') - note ring
            bonds. It is easy to see that if we use the natural Order of the molecule
            and Order the neighbor [2, 6, 11] the winding is still anti-clockwise and
            '<see cref="F:NCDK.Beam.Configuration.TH1"/>' is returned.
            </item>
            <item>
            The second centre is on vertex '6' and looking
            from vertex '5' the Ordering proceeds as [1, 7, 8] with clockwise
            winding. When we arrange the atoms by their natural Order we will now be
            looking from vertex '1' as it is the lowest. The other neighbors then
            proceed in the Order [5, 7, 8]. Drawing out the configuration it's clear
            that we look from vertex '1' instead of '5' the winding is now
            anti-clockwise and the configuration is also '<see cref="F:NCDK.Beam.Configuration.TH1"/>'.
            </item>
            </list>
            </remarks>
            <param name="u">a vertex in the graph</param>
            <returns>The configuration around</returns>
        </member>
        <member name="P:NCDK.Beam.Graph.Order">
            <summary>
            The Order is the number vertices in the graph, |V|.
            </summary>
        </member>
        <member name="P:NCDK.Beam.Graph.Size">
            <summary>
            The size is the number edges in the graph, |E|.
            </summary>
        </member>
        <member name="M:NCDK.Beam.Graph.FromSmiles(System.String)">
            <summary>
            Convenience method to create a graph from a provided SMILES string.
            </summary>
            <param name="smi">string containing SMILES line notation</param>.
            <returns>graph instance from the SMILES</returns>
            <exception cref="T:NCDK.Beam.InvalidSmilesException">if there was a syntax error while parsing the SMILES.</exception>
        </member>
        <member name="M:NCDK.Beam.Graph.ToSmiles">
            <summary>
            Convenience method to write a SMILES string for the current configuration
            of the molecule.
            </summary>
            <returns>the SMILES string for the molecule</returns>.
        </member>
        <member name="M:NCDK.Beam.Graph.ToSmiles(System.Int32[])">
            <summary>
            Generate a SMILES for the Graph. The <paramref name="visitedAt"/> is filled with
            the output rank of each vertex in the graph. This allows one to know
            the atom index when the SMILES in read in.
            </summary>
            <param name="visitedAt">vector to be filled with the output Order</param>
            <returns>the SMILES string</returns>
            <exception cref="T:NCDK.Beam.InvalidSmilesException">a SMILES string could not be generated</exception>"
        </member>
        <member name="M:NCDK.Beam.Graph.IsAromatic">
            <summary>
            Delocalise a kekul√© graph representation to one with <i>aromatic</i>
            bonds. The original graph remains unchanged.
            TODO: more explanation
            </summary>
            <returns>aromatic representation</returns>
        </member>
        <member name="M:NCDK.Beam.Graph.Resonate">
            <summary>
            Resonate bond assignments in conjugate rings such that two SMILES with
            the same Ordering have the same kekul√© assignment.
            </summary>
            <returns>(self) - the graph is mutated</returns>
        </member>
        <member name="M:NCDK.Beam.Graph.Kekule">
            <summary>
            Localise delocalized (aromatic) bonds in this molecule producing the Kekul√© form. 
            </summary>
            <remarks>
            The original graph is not modified.
            <code>
            Graph furan        = Graph.FromSmiles("o1cccc1");
            </code>
            If the graph could not be converted to a kekul√© representation then a
            checked exception is thrown. Graphs cannot be converted if their
            structures are erroneous and there is no valid way to assign the
            delocalised electrons. 
            <para>
            Some reasons are shown below.
            <list type="bullet">
            <item>
            <term>n1cncc1</term>
            <description>pyrole (incorrect) could be either C1C=NC=N1 or N1C=CN=C1</description>
            </item>
            <item>
            <term>[Hg+2][c-]1ccccc1</term>
            <description>Mercury(2+) ion benzenide (incorrect)</description>
            </item>
            <item>
            <term>[Hg+2].[c-]1ccccc1</term>
            <description>Mercury(2+) ion benzenide (correct)</description>
            </item>
            </list>
            </para>
            </remarks>
            <returns>kekul√© representation</returns>
            <exception cref="T:NCDK.Beam.InvalidSmilesException">molecule exploded on contact with reality</exception>"
        </member>
        <member name="M:NCDK.Beam.Graph.Assignable">
            <summary>
            Verify that electrons can be assigned to any delocalised (aromatic)
            bonds. This method is faster than doing a full kekulisation and allows
            versification of aromatic structures without localising the bond Orders.
            However the method of determining the Kekul√© structure is very similar
            and often is preferable to provide a molecule with defined bond Orders.
            </summary>
            <returns>electrons can be assigned</returns>
            <seealso cref="M:NCDK.Beam.Graph.Kekule"/>
        </member>
        <member name="M:NCDK.Beam.Graph.Permute(System.Int32[])">
            <summary>
            Permute the vertices of a graph using a given permutation.
            </summary>
            <example>
            <code>
            g = CNCO
            h = g.Permuate(new int[]{1, 0, 3, 2});
            h = NCOC
            </code>
            </example>
            <param name="p">a permutation mapping indicate the new index of each atom</param>
            <returns>a new chemical graph with the vertices permuted by the given Ordering</returns>
        </member>
        <member name="M:NCDK.Beam.Graph.GetAtoms">
             <summary>
             Access the atoms of the chemical graph.
             </summary>
             <example>
             <code>
             foreach (var a in g.GetAtoms()) 
             {
            
             }
             </code></example>
             <returns>iterable of atoms</returns>
        </member>
        <member name="P:NCDK.Beam.Graph.Edges">
            <summary>
            Access the edges of the chemical graph.
            </summary>
            <returns>iterable of edges</returns>
        </member>
        <member name="M:NCDK.Beam.Graph.Apply``1(NCDK.Beam.Function{NCDK.Beam.Graph,``0})">
            <summary>
            Apply a function to the chemical graph.
            </summary>
            <param name="f">  a function which transforms a graph into something</param>.
            <returns>the output of the function</returns>
        </member>
        <member name="M:NCDK.Beam.Graph.Sort(NCDK.Beam.Graph.EdgeComparator)">
            <summary>
            Sort the edges of the graph to visit in a specific Order. The graph is
            modified.
            
            <param name="comparator">Ordering on edges</param>
            <returns>the graph</returns>
            </summary>
        </member>
        <member name="T:NCDK.Beam.Graph.EdgeComparator">
            <summary>
            Defines a method for arranging the neighbors of an atom.
            </summary>
        </member>
        <member name="M:NCDK.Beam.Graph.EdgeComparator.Less(NCDK.Beam.Graph,System.Int32,NCDK.Beam.Edge,NCDK.Beam.Edge)">
            <summary>
            Should the edge, e, be visited before f.
            
            <param name="g">graph</param>
            <param name="u">the atom we are sorting from</param>
            <param name="e">an edge adjacent to u</param>
            <param name="f">an edge adjacent to u</param>
            <returns>edge e is less than edge f</returns>
            </summary>
        </member>
        <member name="T:NCDK.Beam.Graph.VisitHydrogenFirst">
            <summary>
            Sort the neighbors of each atom such that hydrogens are visited first and
            deuterium before tritium. 
            </summary>
        </member>
        <member name="T:NCDK.Beam.Graph.VisitHighOrderFirst">
            <summary>
            Visit high Order bonds before low Order bonds.
            </summary>
        </member>
        <member name="T:NCDK.Beam.Graph.CanOrderFirst">
            <summary>
            Arrange neighbors in canonical Order.
            </summary>
        </member>
        <member name="T:NCDK.Beam.GraphBuilder">
            <summary>
            Provides the ability to incrementally build up a chemical graph from atoms
            and their connections.
            </summary>
            <example><code>
            Graph g = GraphBuilder.Create(3)
                .Add(Carbon, 3)
                .Add(AtomBuilder.Aliphatic(Carbon)
                .NumOfHydrogens(2)
                .Build())
                .Add(Oxygen, 1)
                .Add(0, 1)
                .Add(1, 2)
                .Add(2, 3)
                .Build();
            </code></example>
        </member>
        <member name="F:NCDK.Beam.GraphBuilder.g">
            <summary>Current we just use the non-public methods of the actual graph object.</summary>
        </member>
        <member name="M:NCDK.Beam.GraphBuilder.#ctor(System.Int32)">
            <summary>
            Internal constructor.
            </summary>
            <param name="nAtoms">expected number of atoms</param>
        </member>
        <member name="M:NCDK.Beam.GraphBuilder.Add(NCDK.Beam.Element,System.Int32)">
            <summary>
            Add an aliphatic element with the specified number of carbons.
            </summary>
            <param name="e">element</param>
            <param name="hCount">number of hydrogens</param>
            <returns>graph builder for adding more atoms/connections</returns>
        </member>
        <member name="M:NCDK.Beam.GraphBuilder.Add(NCDK.Beam.Atom)">
            <summary>
            Add an atom to the graph.
            </summary>
            <param name="a">the atom to add</param>
            <returns>graph builder for adding more atoms/connections</returns>
        </member>
        <member name="M:NCDK.Beam.GraphBuilder.Add(NCDK.Beam.Edge)">
            <summary>
            Add an edge to the graph.
            </summary>
            <param name="e">the edge to add</param>
            <returns>graph builder for adding more atoms/connections</returns>
        </member>
        <member name="M:NCDK.Beam.GraphBuilder.Add(System.Int32,System.Int32)">
            <summary>
            Connect the vertices <paramref name="u"/> and <paramref name="v"/> with an <see cref="F:NCDK.Beam.Bond.Implicit"/> bond label.
            </summary>
            <param name="u">a vertex</param>
            <param name="v">another vertex</param>
            <returns>graph builder for adding more atoms/connections</returns>
        </member>
        <member name="M:NCDK.Beam.GraphBuilder.Add(System.Int32,System.Int32,NCDK.Beam.Bond)">
            <summary>
            Connect the vertices <paramref name="u"/> and <paramref name="v"/> with the specified bond label.
            </summary>
            <param name="u">a vertex</param>
            <param name="v">another vertex</param>
            <param name="b">bond</param>
            <returns>graph builder for adding more atoms/connections</returns>
        </member>
        <member name="M:NCDK.Beam.GraphBuilder.ConnectWithSingleBond(System.Int32,System.Int32)">
            <summary>
            Connect the vertices <paramref name="u"/> and <paramref name="v"/> with a single bond.
            </summary>
            <param name="u">a vertex</param>
            <param name="v">another vertex</param>
            <returns>graph builder for adding more atoms/connections</returns>
        </member>
        <member name="M:NCDK.Beam.GraphBuilder.IsAromaticBond(System.Int32,System.Int32)">
            <summary>
            Connect the vertices <paramref name="u"/> and <paramref name="v"/> with an aromatic bond.
            </summary>
            <param name="u">a vertex</param>
            <param name="v">another vertex</param>
            <returns>graph builder for adding more atoms/connections</returns>
        </member>
        <member name="M:NCDK.Beam.GraphBuilder.ConnectWithDoubleBond(System.Int32,System.Int32)">
            <summary>
            Connect the vertices <paramref name="u"/> and <paramref name="v"/> with a double bond.
            </summary>
            <param name="u">a vertex</param>
            <param name="v">another vertex</param>
            <returns>graph builder for adding more atoms/connections</returns>
        </member>
        <member name="M:NCDK.Beam.GraphBuilder.CreateTetrahedral(System.Int32)">
            <summary>
            Start building a tetrahedral configuration.
            </summary>
            <param name="u">the central atom</param>
            <returns>a <see cref="T:NCDK.Beam.GraphBuilder.TetrahedralBuilder"/> to create the stereo-configuration from </returns>
        </member>
        <member name="M:NCDK.Beam.GraphBuilder.Geometric(System.Int32,System.Int32)">
            <summary>Start building the geometric configuration of the double bond '<paramref name="u"/>' / '<paramref name="v"/>'.</summary>
        </member>
        <member name="M:NCDK.Beam.GraphBuilder.CreateExtendedTetrahedral(System.Int32)">
            <summary>
            Start building a extended tetrahedral configuration.
            </summary>
            <param name="u">the central atom</param>
            <returns>a <see cref="T:NCDK.Beam.GraphBuilder.ExtendedTetrahedralBuilder"/> to create the stereo-configuration from</returns>
                    
        </member>
        <member name="M:NCDK.Beam.GraphBuilder.AddTopology(System.Int32,NCDK.Beam.Topology)">
            <summary>
            (internal) Add a topology to the chemical graph. The topologies should be
            created using one of the configuration builders (e.g. <see cref="T:NCDK.Beam.GraphBuilder.TetrahedralBuilder"/>).
            </summary>
            <param name="u"></param>
            <param name="t">the topology to add</param>
        </member>
        <member name="M:NCDK.Beam.GraphBuilder.Build">
            <summary>
            Finalise and build the chemical graph.
            </summary>
            <returns>chemical graph instance</returns>
        </member>
        <member name="F:NCDK.Beam.GraphBuilder.TetrahedralBuilder.gb">
            <summary>
            Reference to the graph builder we came from - allows us to add the
            topology once the configuration as been built.
            </summary>
        </member>
        <member name="F:NCDK.Beam.GraphBuilder.TetrahedralBuilder.u">
            <summary>Central vertex.</summary>
        </member>
        <member name="F:NCDK.Beam.GraphBuilder.TetrahedralBuilder.v">
            <summary>The vertex we are looking from.</summary>
        </member>
        <member name="F:NCDK.Beam.GraphBuilder.TetrahedralBuilder.vs">
            <summary>The other neighbors</summary>
        </member>
        <member name="F:NCDK.Beam.GraphBuilder.TetrahedralBuilder.config">
            <summary>The configuration of the other neighbors</summary>
        </member>
        <member name="M:NCDK.Beam.GraphBuilder.TetrahedralBuilder.#ctor(NCDK.Beam.GraphBuilder,System.Int32)">
            <summary>
            (internal) - constructor for starting to configure a tetrahedral centre.
            </summary>
            <param name="gb">the graph builder (where we came from)</param>
            <param name="u"> the vertex to</param>
        </member>
        <member name="M:NCDK.Beam.GraphBuilder.TetrahedralBuilder.LookingFrom(System.Int32)">
            <summary>
            Indicate from which vertex the tetrahedral is being 'looked-at'.
            </summary>
            <param name="v">the vertex from which we are looking from</param>.
            <returns>tetrahedral builder for further configuration</returns>
        </member>
        <member name="M:NCDK.Beam.GraphBuilder.TetrahedralBuilder.Neighbors(System.Int32[])">
            <summary>
            Indicate the other neighbors of tetrahedral (excluding the vertex we
            are looking from). There should be exactly 3 neighbors.
            </summary>
            <param name="vs">the neighbors</param>
            <returns>tetrahedral builder for further configuration</returns>
            <exception cref="T:System.ArgumentException">when there was not exactly 3 neighbors</exception>
        </member>
        <member name="M:NCDK.Beam.GraphBuilder.TetrahedralBuilder.Neighbors(System.Int32,System.Int32,System.Int32)">
            <summary>
            Indicate the other neighbors of tetrahedral (excluding the vertex we
            are looking from).
            </summary>
            <param name="u">a neighbor</param>
            <param name="v">another neighbor</param>
            <param name="w">another neighbor</param>
            <returns>tetrahedral builder for further configuration</returns>
        </member>
        <member name="M:NCDK.Beam.GraphBuilder.TetrahedralBuilder.Parity(System.Int32)">
            <summary>
            Convenience method to specify the parity as odd (-1) for
            anti-clockwise or even (+1) for clockwise. The parity is translated
            in to 'TH1' and 'TH2' stereo specification.
            </summary>
            <param name="p">parity value</param>
            <returns>tetrahedral builder for further configuration</returns>
        </member>
        <member name="M:NCDK.Beam.GraphBuilder.TetrahedralBuilder.Winding(NCDK.Beam.Configuration)">
            <summary>
            Specify the winding of the <see cref="M:NCDK.Beam.GraphBuilder.TetrahedralBuilder.Neighbors(System.Int32,System.Int32,System.Int32)"/>.
            </summary>
            <param name="c">configuration <see cref="F:NCDK.Beam.Configuration.TH1"/>, <see cref="F:NCDK.Beam.Configuration.TH2"/>, 
            <see cref="F:NCDK.Beam.Configuration.AntiClockwise"/> or <see cref="F:NCDK.Beam.Configuration.Clockwise"/></param>
            <returns>tetrahedral builder for further configuration</returns>
        </member>
        <member name="M:NCDK.Beam.GraphBuilder.TetrahedralBuilder.Build">
            <summary>
            Finish configuring the tetrahedral centre and add it to the graph.
            </summary>
            <returns>the graph-builder to add more atoms/bonds or stereo elements</returns>
            <exception cref="T:System.InvalidOperationException">configuration was missing</exception>
        </member>
        <member name="F:NCDK.Beam.GraphBuilder.ExtendedTetrahedralBuilder.gb">
            <summary>
            Reference to the graph builder we came from - allows us to add the
            topology once the configuration as been built.
            </summary>
        </member>
        <member name="F:NCDK.Beam.GraphBuilder.ExtendedTetrahedralBuilder.u">
            <summary>Central vertex.</summary>
        </member>
        <member name="F:NCDK.Beam.GraphBuilder.ExtendedTetrahedralBuilder.v">
            <summary>The vertex we are looking from.</summary>
        </member>
        <member name="F:NCDK.Beam.GraphBuilder.ExtendedTetrahedralBuilder.vs">
            <summary>The other neighbors</summary>
        </member>
        <member name="F:NCDK.Beam.GraphBuilder.ExtendedTetrahedralBuilder.config">
            <summary>The configuration of the other neighbors</summary>
        </member>
        <member name="M:NCDK.Beam.GraphBuilder.ExtendedTetrahedralBuilder.#ctor(NCDK.Beam.GraphBuilder,System.Int32)">
            <summary>
            (internal) - constructor for starting to configure a tetrahedral centre.
            </summary>
            <param name="gb">the graph builder </param>(where we came from)
            <param name="u"> the vertex to</param>
        </member>
        <member name="M:NCDK.Beam.GraphBuilder.ExtendedTetrahedralBuilder.LookingFrom(System.Int32)">
            <summary>
            Indicate from which vertex the tetrahedral is being 'looked-at'.
            </summary>
            <param name="v">the vertex from which we are looking from</param>.
            <returns>tetrahedral builder for further configuration</returns>
        </member>
        <member name="M:NCDK.Beam.GraphBuilder.ExtendedTetrahedralBuilder.Neighbors(System.Int32[])">
            <summary>
            Indicate the other neighbors of tetrahedral (excluding the vertex we
            are looking from). There should be exactly 3 neighbors.
            </summary>
            <param name="vs">the neighbors</param>
            <returns>tetrahedral builder for further configuration</returns>
            <exception cref="T:System.ArgumentException">when there was not exactly 3 neighbors</exception>
        </member>
        <member name="M:NCDK.Beam.GraphBuilder.ExtendedTetrahedralBuilder.Neighbors(System.Int32,System.Int32,System.Int32)">
            <summary>
            Indicate the other neighbors of tetrahedral (excluding the vertex we
            are looking from).
            </summary>
            <param name="u">a neighbor</param>
            <param name="v">another neighbor</param>
            <param name="w">another neighbor</param>
            <returns>tetrahedral builder for further configuration</returns>
        </member>
        <member name="M:NCDK.Beam.GraphBuilder.ExtendedTetrahedralBuilder.Parity(System.Int32)">
            <summary>
            Convenience method to specify the parity as odd (-1) for
            anti-clockwise or even (+1) for clockwise. The parity is translated
            in to 'TH1' and 'TH2' stereo specification.
            </summary>
            <param name="p">parity value</param>
            <returns>tetrahedral builder for further configuration</returns>
        </member>
        <member name="M:NCDK.Beam.GraphBuilder.ExtendedTetrahedralBuilder.Winding(NCDK.Beam.Configuration)">
            <summary>
            Specify the winding of the <see cref="M:NCDK.Beam.GraphBuilder.ExtendedTetrahedralBuilder.Neighbors(System.Int32,System.Int32,System.Int32)"/>.
            </summary>
            <param name="c">configuration <see cref="F:NCDK.Beam.Configuration.TH1"/>, <see cref="F:NCDK.Beam.Configuration.TH2"/>, 
            <see cref="F:NCDK.Beam.Configuration.AntiClockwise"/> or <see cref="F:NCDK.Beam.Configuration.Clockwise"/></param>
            <returns>tetrahedral builder for further configuration</returns>
        </member>
        <member name="M:NCDK.Beam.GraphBuilder.ExtendedTetrahedralBuilder.Build">
            <summary>
            Finish configuring the tetrahedral centre and add it to the graph.
            </summary>
            <returns>the graph-builder to add more atoms/bonds or stereo elements</returns>
            <exception cref="T:System.InvalidOperationException">configuration was missing</exception>
        </member>
        <member name="T:NCDK.Beam.GraphBuilder.GeometricBuilder">
            <summary>Fluent assembly of a double-bond configuration.</summary>
        </member>
        <member name="F:NCDK.Beam.GraphBuilder.GeometricBuilder.gb">
            <summary>
            Reference to the graph builder we came from - allows us to add the
            double bond once the configuration as been built.
            </summary>
        </member>
        <member name="T:NCDK.Beam.IntSet">
            <summary>
            Abstraction allows simple definitions of integer sets. Generally for this
            library we are dealing with small bounded integer ranges (vertices of a
            graph) which are most efficiently represented as a binary set. For
            convenience the <see cref="M:NCDK.Beam.IntSet.AllOf(System.Int32[])"/> method can be used to construct a
            binary set from varargs.
            </summary>
        </member>
        <member name="M:NCDK.Beam.IntSet.Contains(System.Int32)">
            <summary>
            Determine if value 'x' is a member of this set.
            </summary>
            <param name="x">a value to</param>
            <returns>x is included in this set</returns>.
        </member>
        <member name="P:NCDK.Beam.IntSet.Universe">
            <summary>
            The universe is a set which includes every int value.
            </summary>
            <returns>int set with every item</returns>
        </member>
        <member name="P:NCDK.Beam.IntSet.IsEmpty">
            <summary>
            The empty set is a set which includes no int values.
            <returns>int set with no items</returns>
            </summary>
        </member>
        <member name="M:NCDK.Beam.IntSet.AllOf(System.Int32[])">
            <summary>
            Convenience method to create a set with the specified contents.
            </summary>
            <example><code>
                IntSet.AllOf(0, 2, 5); // a set with 0,2 and 5
            </code></example>
            <param name="xs">values</param>
            <returns>int set with specified items</returns>
        </member>
        <member name="M:NCDK.Beam.IntSet.NoneOf(System.Int32[])">
            <summary>
            Convenience method to create a set without the specified contents.
            </summary>
            <example><code>
                IntSet.NoneOf(0, 2, 5); // a set with all but 0,2 and 5
            </code></example>
            <param name="xs">values</param>
            <returns>int set without the specified items</returns>
        </member>
        <member name="M:NCDK.Beam.IntSet.FromBitArray(System.Collections.BitArray)">
            <summary>
            Create an set from a BitArray.
            </summary>
            <param name="s">bitset</param>
            <returns>int set which uses the bit set to test for membership</returns>
        </member>
        <member name="M:NCDK.Beam.IntSet.CreateComplement(NCDK.Beam.IntSet)">
            <summary>
            Make a complement of the specified set.
            </summary>
            <param name="set">a set</param>
            <returns>complement of the set</returns>
        </member>
        <member name="T:NCDK.Beam.IntSet.BinarySet">
            <summary>An integer set based on the contents of a bit set.</summary>
        </member>
        <member name="T:NCDK.Beam.IntSet.Complement">
            <summary>Complement of a set - invert any membership of the provided 'delegate'</summary>
        </member>
        <member name="F:NCDK.Beam.IntSet.UNIVERSE">
            <summary>The universe - every object is a member of the set.</summary>
        </member>
        <member name="T:NCDK.Beam.IntStack">
            <summary>
            A lightweight stack data structure for primitive 'int' types.
            </summary>
        </member>
        <member name="F:NCDK.Beam.IntStack.xs">
            <summary>Storage of values.</summary>
        </member>
        <member name="F:NCDK.Beam.IntStack.n">
            <summary>Number of items in the stack</summary>
        </member>
        <member name="M:NCDK.Beam.IntStack.#ctor(System.Int32)">
            <summary>
            Create a new stack with specified initial capacity.
            </summary>
            <param name="n">capacity of the stack</param>
        </member>
        <member name="M:NCDK.Beam.IntStack.Push(System.Int32)">
             <summary>
             Push the value <paramref name="x"/> on to the stack.
            
             <param name="x">value to push</param>
             </summary>
        </member>
        <member name="M:NCDK.Beam.IntStack.Pop">
             <summary>
             Access and remove the value on the top of the stack. No check is made as
             to whether the stack is empty.
            
             <returns>value on top of the stack</returns>
             </summary>
        </member>
        <member name="M:NCDK.Beam.IntStack.Peek">
             <summary>
             Access the value on top of the stack without removing it. No check is
             made as to whether the stack is empty.
            
             <returns>the last value added</returns>
             </summary>
        </member>
        <member name="P:NCDK.Beam.IntStack.IsEmpty">
             <summary>
             Determine if there are any items on the stack.
            
             <returns>whether the stack is empty</returns>
             </summary>
        </member>
        <member name="P:NCDK.Beam.IntStack.Count">
             <summary>
             Number of items on the stack.
            
             <returns>size</returns>
             </summary>
        </member>
        <member name="M:NCDK.Beam.IntStack.Clear">
            <summary>Remove all values from the stack.</summary>
        </member>
        <member name="T:NCDK.Beam.InvalidSmilesException">
            <summary>
            An exception thrown when parsing malformed SMILES.
            </summary>
        </member>
        <member name="M:NCDK.Beam.InvalidSmilesException.Display(NCDK.Beam.CharBuffer,System.Int32)">
            <summary>
            Displays the character buffer and marks on the next line the current position in the buffer.
            </summary>
            <remarks>
            invalid bracket atom:
            C[CCCC
              ^
            </remarks>
            <param name="buffer">a character buffer</param>
            <param name="offset"></param>
            <returns>a * 3 line string showing the buffer and it's current position</returns>
        </member>
        <member name="M:NCDK.Beam.InvalidSmilesException.InvalidBracketAtom(NCDK.Beam.CharBuffer)">
            <summary>
            Utility for invalid bracket atom error.
            </summary>
            <param name="buffer">the current buffer</param>
            <returns>the invalid smiles exception with buffer information</returns>
        </member>
        <member name="T:NCDK.Beam.Localise">
            <summary>
            Utility to localise aromatic bonds.
            </summary>
        </member>
        <member name="M:NCDK.Beam.Localise.Resonate(NCDK.Beam.Graph)">
            <summary>
            Resonate double bonds in a cyclic system such that given a molecule with the same ordering
            produces the same resonance assignment. This procedure provides a canonical Kekul√©
            representation for conjugated rings.
            </summary>
            <param name="g">graph</param>
            <returns>the input graph (same reference)</returns>
        </member>
        <member name="T:NCDK.Beam.Matching">
            <summary>
            Defines a matching on a graph. A matching or independent edge set is a set of
            edges without common vertices. A matching is perfect if every vertex in the
            graph is matched. Another way of thinking about the matching is that each
            vertex is incident to exactly one matched edge. 
            <para>
            This class provides storage and manipulation of a matching. A new match is
            added with <see cref="M:NCDK.Beam.Matching.Match(System.Int32,System.Int32)"/>, any existing match for the newly matched
            vertices is non-longer available. For convenience <see cref="M:NCDK.Beam.Matching.GetMatches"/> provides
            the current independent edge set.
            </para>
            </summary>
        </member>
        <member name="F:NCDK.Beam.Matching.UNMATCHED">
            <summary>Indicates an unmatched vertex.</summary>
        </member>
        <member name="F:NCDK.Beam.Matching.match">
            <summary>Storage of which each vertex is matched with.</summary>
        </member>
        <member name="M:NCDK.Beam.Matching.#ctor(System.Int32)">
            <summary>
            Create a matching of the given size.
            </summary>
            <param name="n">number of items</param>
        </member>
        <member name="M:NCDK.Beam.Matching.Unmatched(System.Int32)">
            <summary>
            Is the vertex v 'unmatched'.
            </summary>
            <param name="v">a vertex</param>
            <returns>the vertex has no matching</returns>
        </member>
        <member name="M:NCDK.Beam.Matching.Other(System.Int32)">
            <summary>
            Access the vertex matched with 'v'.
            </summary>
            <param name="v">a vertex</param>
            <returns>matched vertex</returns>
            <exception cref="T:System.ArgumentException">the vertex is currently unmatched</exception>
        </member>
        <member name="M:NCDK.Beam.Matching.Match(System.Int32,System.Int32)">
            <summary>
            Add the edge '{u,v}' to the matched edge set. Any existing matches for
            'u' or 'v' are removed from the matched set.
            </summary>
            <param name="u">a vertex</param>
            <param name="v">another vertex</param>
        </member>
        <member name="M:NCDK.Beam.Matching.GetMatches">
            <summary>
            Access the current non-redundant set of edges.
            </summary>
            <returns>matched pairs</returns>
        </member>
        <member name="M:NCDK.Beam.Matching.CreateEmpty(NCDK.Beam.Graph)">
            <summary>
            Allocate a matching with enough capacity for the given graph.
            </summary>
            <param name="g">a graph</param>
            <returns>matching</returns>
        </member>
        <member name="T:NCDK.Beam.MaximumMatching">
            <summary>
            Maximum matching in general graphs using Edmond's Blossom Algorithm. 
            </summary>
            <para>
            This implementation was adapted D Eppstein's python code 
            (<see href="http://www.ics.uci.edu/~eppstein/PADS/CardinalityMatching.py">src</see>)
            which provides efficient tree traversal and handling of blossoms. The
            implementation may be quite daunting as a general introduction to the ideas.
            Personally I found <see href="http://www.keithschwarz.com/interesting/">Keith Schwarz</see> 
            version very informative when starting to understand the workings. 
            </para>
            <para>
            An asymptotically better algorithm is described by Micali and Vazirani (1980)
            and is similar to bipartite matching (<see href="http://en.wikipedia.org/wiki/Hopcroft%E2%80%93Karp_algorithm">Hopkroft-Karp</see>)
            where by multiple augmenting paths are discovered at once. In general though
            this version is very fast - particularly if given an existing matching to
            start from. Even the very simple <see cref="T:NCDK.Beam.ArbitraryMatching"/> eliminates many
            loop iterations particularly at the start when all length 1 augmenting paths
            are discovered.
            </para>
            <seealso href="http://en.wikipedia.org/wiki/Blossom_algorithm">Blossom algorithm, Wikipedia</seealso>
            <seealso href="http://en.wikipedia.org/wiki/Hopcroft%E2%80%93Karp_algorithm">Hopkroft-Karp, Wikipedia</seealso>
            <seealso href="http://research.microsoft.com/apps/video/dl.aspx?id=171055">Presentation from Vazirani on his and Micali O(|E| * Sqrt(|V|)) algorithm</seealso>
        </member>
        <member name="F:NCDK.Beam.MaximumMatching.graph">
            <summary>The graph we are matching on.</summary>
        </member>
        <member name="F:NCDK.Beam.MaximumMatching.matching">
            <summary>The current matching.</summary>
        </member>
        <member name="F:NCDK.Beam.MaximumMatching.subset">
            <summary>Subset of vertices to be matched.</summary>
        </member>
        <member name="F:NCDK.Beam.MaximumMatching.even">
            <summary>Storage of the forest, even and odd levels</summary>
        </member>
        <member name="F:NCDK.Beam.MaximumMatching.odd">
            <summary>Storage of the forest, even and odd levels</summary>
        </member>
        <member name="F:NCDK.Beam.MaximumMatching.nil">
            <summary>Special 'nil' vertex.</summary>
        </member>
        <member name="F:NCDK.Beam.MaximumMatching.queue">
            <summary>Queue of 'even' (free) vertices to start paths from.</summary>
        </member>
        <member name="F:NCDK.Beam.MaximumMatching.uf">
            <summary>Union-Find to store blossoms.</summary>
        </member>
        <member name="F:NCDK.Beam.MaximumMatching.bridges">
            <summary>
            IDictionary stores the bridges of the blossom - indexed by with support
            vertices.
            </summary>
        </member>
        <member name="F:NCDK.Beam.MaximumMatching.path">
            <summary>Temporary array to fill with path information.</summary>
        </member>
        <member name="F:NCDK.Beam.MaximumMatching.vAncestors">
            <summary>
            Temporary bit sets when walking down 'trees' to check for
            paths/blossoms.
            </summary>
        </member>
        <member name="F:NCDK.Beam.MaximumMatching.wAncestors">
            <summary>
            Temporary bit sets when walking down 'trees' to check for
            paths/blossoms.
            </summary>
        </member>
        <member name="F:NCDK.Beam.MaximumMatching.nMatched">
            <summary>Number of matched vertices. </summary>
        </member>
        <member name="M:NCDK.Beam.MaximumMatching.Augment">
            <summary>
            Find an augmenting path an alternate it's matching. If an augmenting path
            was found then the search must be restarted. If a blossom was detected
            the blossom is contracted and the search continues.
            </summary>
            <returns>an augmenting path was found</returns>
        </member>
        <member name="M:NCDK.Beam.MaximumMatching.Check(System.Int32,System.Int32)">
            <summary>
            An edge was found which connects two 'even' vertices in the forest. If
            the vertices have the same root we have a blossom otherwise we have
            identified an augmenting path. This method checks for these cases and
            responds accordingly. 
            <para>
            If an augmenting path was found - then it's edges are alternated and the
            method returns true. Otherwise if a blossom was found - it is contracted
            and the search continues.
            </para>
            </summary>
            <param name="v">endpoint of an edge</param>
            <param name="w">another endpoint of an edge</param>
            <returns>a path was augmented</returns>
        </member>
        <member name="M:NCDK.Beam.MaximumMatching.Parent(System.Collections.BitArray,System.Int32)">
            <summary>
            Access the next ancestor in a tree of the forest. Note we go back two
            places at once as we only need check 'even' vertices.
            </summary>
            <param name="ancestors">temporary set which fills up the path we traversed</param>
            <param name="curr">     the current even vertex in the tree</param>
            <returns>the next 'even' vertex</returns>
        </member>
        <member name="M:NCDK.Beam.MaximumMatching.Blossom(System.Int32,System.Int32,System.Int32)">
            <summary>
            Create a new blossom for the specified 'bridge' edge.
            </summary>
            <param name="v">adjacent to w</param>
            <param name="w">adjacent to v</param>
            <param name="base_">connected to the stem (common ancestor of v and w)</param>
        </member>
        <member name="M:NCDK.Beam.MaximumMatching.BlossomSupports(System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates the blossom 'supports' for the specified blossom 'bridge' edge
            (v, w). We travel down each side to the base of the blossom ('base')
            collapsing vertices and point any 'odd' vertices to the correct 'bridge'
            edge. We do this by indexing the birdie to each vertex in the 'bridges'
            map.
            </summary>
            <param name="v">an endpoint of the blossom bridge</param>
            <param name="w">another endpoint of the blossom bridge</param>
            <param name="base">the base of the blossom</param>
        </member>
        <member name="M:NCDK.Beam.MaximumMatching.Augment(System.Int32)">
            <summary>
            Augment all ancestors in the tree of vertex 'v'.
            </summary>
            <param name="v">the leaf to augment from</param>
        </member>
        <member name="M:NCDK.Beam.MaximumMatching.BuildPath(System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Builds the path backwards from the specified 'start' vertex until the
            'goal'. If the path reaches a blossom then the path through the blossom
            is lifted to the original graph.
            </summary>
            <param name="path">path storage</param>
            <param name="i">offset (in path)</param>
            <param name="start">start vertex</param>
            <param name="goal">end vertex</param>
            <returns>the number of items set to the <paramref name="path"/>[].</returns>
        </member>
        <member name="M:NCDK.Beam.MaximumMatching.Maximise(NCDK.Beam.Graph,NCDK.Beam.Matching,System.Int32,NCDK.Beam.IntSet)">
            <summary>
            Utility to maximise an existing matching of the provided graph.
            </summary>
            <param name="g">a graph</param>
            <param name="m">matching on the graph, will me modified</param>
            <param name="n">current matching cardinality</param>
            <param name="s">subset of vertices to match</param>
            <returns>the maximal matching on the graph</returns>
        </member>
        <member name="M:NCDK.Beam.MaximumMatching.Maximise(NCDK.Beam.Graph,NCDK.Beam.Matching,System.Int32)">
            <summary>
            Utility to maximise an existing matching of the provided graph.
            </summary>
            <param name="g">a graph</param>
            <param name="m">matching on the graph</param>
            <param name="n"></param>
            <returns>the maximal matching on the graph</returns>
        </member>
        <member name="M:NCDK.Beam.MaximumMatching.Maximal(NCDK.Beam.Graph)">
            <summary>
            Utility to get the maximal matching of the specified graph.
            </summary>
            <param name="g">a graph</param>
            <returns>the maximal matching on the graph</returns>
        </member>
        <member name="T:NCDK.Beam.MaximumMatching.FixedSizeQueue">
            <summary>
            Utility class provides a fixed size queue. Enough space is allocated for
            every vertex in the graph. Any new vertices are added at the 'end' index
            and 'polling' a vertex advances the 'start'.
            </summary>
        </member>
        <member name="M:NCDK.Beam.MaximumMatching.FixedSizeQueue.#ctor(System.Int32)">
            <summary>
            Create a queue of size 'n'.
            </summary>
            <param name="n">size of the queue</param>
        </member>
        <member name="M:NCDK.Beam.MaximumMatching.FixedSizeQueue.Enqueue(System.Int32)">
            <summary>
            Add an element to the queue.
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:NCDK.Beam.MaximumMatching.FixedSizeQueue.Poll">
            <summary>
            Poll the first element from the queue.
            </summary>
            <returns>the first element</returns>.
        </member>
        <member name="M:NCDK.Beam.MaximumMatching.FixedSizeQueue.IsEmpty">
            <summary>
            The queue is empty.
            </summary>
        </member>
        <member name="M:NCDK.Beam.MaximumMatching.FixedSizeQueue.Clear">
            <summary>Reset the queue.</summary>
        </member>
        <member name="M:NCDK.Beam.MaximumMatching.Reverse(System.Int32[],System.Int32,System.Int32)">
            <summary>Utility to reverse a section of a fixed size array</summary>
        </member>
        <member name="T:NCDK.Beam.Parser">
            <summary>
            Parse a SMILES string and create a <see cref="T:NCDK.Beam.Graph"/>. A new parser should be
            created for each invocation, for convenience <see cref="M:NCDK.Beam.Parser.Parse(System.String)"/> is
            provided.
            </summary>
            <example><code>
            Graph g = Parser.Parse("CCO");
            </code></example>
        </member>
        <member name="F:NCDK.Beam.Parser.stack">
            <summary>Keep track of branching.</summary>
        </member>
        <member name="F:NCDK.Beam.Parser.g">
            <summary>Molecule being loaded.</summary>
        </member>
        <member name="F:NCDK.Beam.Parser.rings">
            <summary>Keep track of ring information.</summary>
        </member>
        <member name="F:NCDK.Beam.Parser.arrangement">
            <summary>Local arrangement for ring openings.</summary>
        </member>
        <member name="F:NCDK.Beam.Parser.bond">
            <summary>Current bond.</summary>
        </member>
        <member name="F:NCDK.Beam.Parser.configuration">
            <summary>Current configuration.</summary>
        </member>
        <member name="F:NCDK.Beam.Parser.start">
            <summary>
            Which vertices start a new run of tokens. This includes the first vertex
            and all vertices which immediately follow a 'dot' bond. These are
            required to correctly store atom topologies.
            </summary>
        </member>
        <member name="F:NCDK.Beam.Parser.openRings">
            <summary>Number of open rings - all rings should be closed.</summary>
        </member>
        <member name="F:NCDK.Beam.Parser.strict">
            <summary>Strict parsing.</summary>
        </member>
        <member name="M:NCDK.Beam.Parser.#ctor(NCDK.Beam.CharBuffer,System.Boolean)">
            <summary>
            Create a new parser for the specified buffer.
            </summary>
            <param name="buffer">character buffer holding a SMILES string</param>
            <param name="strict"></param>
            <exception cref="T:NCDK.Beam.InvalidSmilesException">if the SMILES could not be parsed</exception>"
        </member>
        <member name="M:NCDK.Beam.Parser.#ctor(System.String)">
            <summary>
            Create a new (loose) parser for the specified string.
            </summary>
            <param name="str">SMILES string</param>
            <exception cref="T:NCDK.Beam.InvalidSmilesException">thrown if the SMILES could not be parsed</exception>
        </member>
        <member name="M:NCDK.Beam.Parser.GetStrict(System.String)">
            <summary>
            Strict parsing of the provided SMILES string. The strict parser will
            throw more exceptions for unusual input.
            </summary>
            <param name="str">the SMILES string to process</param>
            <returns>a graph created with the strict parser</returns>
        </member>
        <member name="M:NCDK.Beam.Parser.Losse(System.String)">
            <summary>
            Loose parsing of the provided SMILES string. The loose parser is more
            relaxed and will allow abnormal aromatic elements (e.g. 'te') as well as
            bare 'H', 'D' and 'T' for hydrogen and it's isotopes. Note the hydrogen
            and isotopes are replaced with their correct bracket equivalent.
            </summary>
            <param name="str">the SMILES string to process</param>
            <returns>a graph created with the loose parser</returns>
        </member>
        <member name="M:NCDK.Beam.Parser.Molecule">
            <summary>
            Access the molecule created by the parser.
            </summary>
            <returns>the chemical graph for the parsed smiles string</returns>
        </member>
        <member name="M:NCDK.Beam.Parser.CreateTopologies(NCDK.Beam.CharBuffer)">
            <summary>
            Create the topologies (stereo configurations) for the chemical graph. The
            topologies define spacial arrangement around atoms.
            </summary>
        </member>
        <member name="M:NCDK.Beam.Parser.AddTopology(System.Int32,NCDK.Beam.Configuration)">
            <summary>
            Add a topology for vertex 'u' with configuration 'c'. If the atom 'u' was
            involved in a ring closure the local arrangement is used instead of the
            Order in the graph. The configuration should be explicit '@TH1' or '@TH2'
            instead of '@' or '@@'.
            </summary>
            <param name="u">a vertex</param>
            <param name="c">explicit configuration of that vertex</param>
            <seealso cref="M:NCDK.Beam.Topology.ToExplicit(NCDK.Beam.Graph,System.Int32,NCDK.Beam.Configuration)"/>
        </member>
        <member name="M:NCDK.Beam.Parser.AddAtom(NCDK.Beam.Atom,NCDK.Beam.CharBuffer)">
            <summary>
            Add an atom and bond with the atom on the stack (if available and non-dot bond).
            </summary>
            <param name="a">an atom to add</param>
            <param name="buffer"></param>
        </member>
        <member name="M:NCDK.Beam.Parser.ReadSmiles(NCDK.Beam.CharBuffer)">
            <summary>
            Read a molecule from the character buffer.
            </summary>
            <param name="buffer">a character buffer</param>
            <exception cref="T:NCDK.Beam.InvalidSmilesException">invalid grammar</exception>
        </member>
        <member name="M:NCDK.Beam.Parser.ReadBracketAtom(NCDK.Beam.CharBuffer)">
            <summary>
            Read a bracket atom from the buffer. A bracket atom optionally defines
            isotope, chirality, hydrogen count, formal charge and the atom class.
            <para>
            bracket_atom ::= '[' isotope? symbol chiral? hcount? charge? class? ']'
            </para>
            </summary>
            <param name="buffer">a character buffer</param>
            <returns>a bracket atom</returns>
            <exception cref="T:NCDK.Beam.InvalidSmilesException">if the bracket atom did not match the grammar, invalid symbol, missing closing bracket or invalid chiral specification.</exception>
        </member>
        <member name="M:NCDK.Beam.Parser.ReadHydrogens(NCDK.Beam.CharBuffer)">
            <summary>
            Read the hydrogen count and progress the provided buffer. The hydrogen
            count is specified by a 'H' an 0 or more digits. A 'H' without digits is
            intercepted as 'H1'. When there is no 'H' or 'H0' is specified then the
            the hydrogen count is 0.
            </summary>
            <param name="buffer">a character buffer</param>
            <returns>the hydrogen count, 0 if none</returns>
        </member>
        <member name="M:NCDK.Beam.Parser.ReadCharge(NCDK.Beam.CharBuffer)">
            <summary>
            Read a charge value and progress the provide buffer. The charge value is
            present in bracket atoms either directly after the symbol, the chiral
            specification or the hydrogen count. The specification of charge by
            concatenated signs (e.g. ++, --) and other bad form (e.g. '++-1') is
            intercepted.
            </summary>
            <seealso href="http://www.opensmiles.org/opensmiles.html#charge">Charge -OpenSMILES Specification</seealso >
            <param name="buffer">a character buffer</param>
            <returns>the formal charge value</returns>, 0 if none present
        </member>
        <member name="M:NCDK.Beam.Parser.ReadCharge(System.Int32,NCDK.Beam.CharBuffer)">
            <summary>
            Internal method for parsing charge, to allow concatenated signs (--, ++)
            the method recursively invokes increment or decrementing an accumulator.
            </summary>
            <param name="acc">   accumulator</param>
            <param name="buffer">a character buffer</param>
            <returns>the charge value</returns>
        </member>
        <member name="M:NCDK.Beam.Parser.ReadClass(NCDK.Beam.CharBuffer)">
            <summary>
            Read the atom class of a bracket atom and progress the buffer (if read).
            The atom class is the last attribute of the bracket atom and is
            identified by a ':' followed by one or more digits. The atom class may be
            padded such that ':005' and ':5' are equivalent.
            </summary>
            <seealso href="http://www.opensmiles.org/opensmiles.html#atomclass">Atom Class - OpenSMILES Specification</seealso >
            <param name="buffer">a character buffer</param>
            <returns>the atom class, or 0</returns>
        </member>
        <member name="M:NCDK.Beam.Parser.Ring(System.Int32,NCDK.Beam.CharBuffer)">
            <summary>
            Handle the ring open/closure of the specified ring number 'rnum'.
            </summary>
            <param name="rnum">ring number</param>
            <param name="buffer"></param>
            <exception cref="T:NCDK.Beam.InvalidSmilesException">bond types did not match on ring closure</exception>
        </member>
        <member name="M:NCDK.Beam.Parser.OpenRing(System.Int32)">
            <summary>
            Open the ring bond with the specified 'rnum'.
            </summary>
            <param name="rnum">ring number</param>
        </member>
        <member name="M:NCDK.Beam.Parser.CreateArrangement(System.Int32)">
            <summary>
            Create the current local arrangement for vertex 'u' - if the arrangment
            already exists then that arrangement is used.
            </summary>
            <param name="u">vertex to get the arrangement around</param>
            <returns>current local arrangement</returns>
        </member>
        <member name="M:NCDK.Beam.Parser.CloseRing(System.Int32,NCDK.Beam.CharBuffer)">
            <summary>
            Close the ring bond with the specified 'rnum'.
            </summary>
            <param name="rnum">ring number</param>
            <param name="buffer"></param>
            <exception cref="T:NCDK.Beam.InvalidSmilesException">bond types did not match</exception>
        </member>
        <member name="M:NCDK.Beam.Parser.DecideBond(NCDK.Beam.Bond,NCDK.Beam.Bond,NCDK.Beam.CharBuffer)">
            <summary>
            Decide the bond to use for a ring bond. The bond symbol can be present on
            either or both bonded atoms. This method takes those bonds, chooses the
            correct one or reports an error if there is a conflict.
            </summary>
            <remarks>
            Equivalent SMILES:
            <list type="bullet">
            <item>C=1CCCCC=1</item>
            <item>C=1CCCCC1    (preferred)</item>
            <item>C1CCCCC=1</item>
            </list>
            </remarks>
            <param name="a">a bond</param>
            <param name="b">other bond</param>
            <param name="buffer"></param>
            <returns>the bond to use for this edge</returns>
            <exception cref="T:NCDK.Beam.InvalidSmilesException">ring bonds did not match</exception>
        </member>
        <member name="M:NCDK.Beam.Parser.Parse(System.String)">
            <summary>
            Convenience method for parsing a SMILES string.
            </summary>
            <param name="str">SMILES string</param>
            <returns>the chemical graph for the provided SMILES notation</returns>
            <exception cref="T:NCDK.Beam.InvalidSmilesException">thrown if the SMILES could not be interpreted</exception>
        </member>
        <member name="T:NCDK.Beam.Parser.RingBond">
            <summary>
            Hold information about ring open/closures. The ring bond can optionally
            specify the bond type.
            </summary>
        </member>
        <member name="T:NCDK.Beam.Parser.LocalArrangement">
            <summary>
            Hold information on the local arrangement around an atom. The arrangement
            is normally identical to the Order loaded unless the atom is involved in
            a ring closure. This is particularly important for stereo specification
            where the ring bonds should be in the Order listed. This class stores the
            local arrangement by setting a negated 'rnum' as a placeholder and then
            replacing it once the connected atom has been read. Although this could
            be stored directly on the graph (negated edge) it allows us to keep all
            edges in sorted Order.
            </summary>
        </member>
        <member name="M:NCDK.Beam.Parser.LocalArrangement.#ctor">
            <summary>New local arrangement.</summary>
        </member>
        <member name="M:NCDK.Beam.Parser.LocalArrangement.Add(System.Int32)">
            <summary>
            Append a vertex to the arrangement.
            </summary>
            <param name="v">vertex to append</param>
        </member>
        <member name="M:NCDK.Beam.Parser.LocalArrangement.Replace(System.Int32,System.Int32)">
            <summary>
            Replace the vertex 'u' with 'v'. Allows us to use negated values as placeholders.
            </summary>
            <example><code>
            LocalArrangement la = new LocalArrangement();
            la.Add(1);
            la.Add(-2);
            la.Add(-1);
            la.Add(5);
            la.Replace(-1, 4);
            la.Replace(-2, 6);
            la.ToArray() = {1, 6, 4, 5}
            </code></example>
            <param name="u">negated vertex</param>
            <param name="v">new vertex</param>
        </member>
        <member name="M:NCDK.Beam.Parser.LocalArrangement.ToArray">
            <summary>
            Access the local arrange of vertices.
            </summary>
            <returns>array of vertices and there Order around an atom</returns>.
        </member>
        <member name="T:NCDK.Beam.Topology">
            <summary>
            Defines the relative topology around a vertex (atom).
            </summary>
        </member>
        <member name="P:NCDK.Beam.Topology.Atom">
            <summary>
            The vertex/atom which this topology describes.
            </summary>
            <exception cref="T:System.ArgumentException">Unknown topology</exception>
        </member>
        <member name="P:NCDK.Beam.Topology.Configuration">
            <summary>
            The configuration of the topology.
            </summary>
        </member>
        <member name="M:NCDK.Beam.Topology.ConfigurationOf(System.Int32[])">
            <summary>
            The configuration of the topology when it's carriers have the specified
            ranks.
            </summary>
            <param name="rank"></param>
            <returns>configuration for this topology</returns>
        </member>
        <member name="P:NCDK.Beam.Topology.Type">
            <summary>
            What type of configuration is defined by this topology (e.g. Tetrahedral,
            DoubleBond etc).
            </summary>
            <returns>the type of the configuration</returns>
        </member>
        <member name="M:NCDK.Beam.Topology.OrderBy(System.Int32[])">
            <summary>
            Arrange the topology relative to a given ranking of vertices.
            </summary>
            <param name="rank">Ordering of vertices</param>
            <returns>a new topology with the neighbors arranged by the given rank</returns>
        </member>
        <member name="M:NCDK.Beam.Topology.Transform(System.Int32[])">
            <summary>
            Transform the topology to one with the given <paramref name="mapping"/>.
            </summary>
            <param name="mapping">the mapping used to transform the topology</param>
            <returns>a new topology with it's vertices mapped</returns>
        </member>
        <member name="M:NCDK.Beam.Topology.Parity(System.Int32[],System.Int32[])">
            <summary>
            Compute the permutation parity of the vertices <paramref name="vs"/> for the
            given <paramref name="rank"/>. The parity defines the oddness or evenness of a
            permutation and is the number of inversions (swaps) one would need to
            make to place the 'vs' in the Order specified by rank.
            </summary>
            <param name="vs">  array of vertices</param>
            <param name="rank">rank of vertices</param>, |R| = Max(vs) + 1
            <returns>sign of the permutation, -1=odd or 1=even</returns>
            <seealso href="http://en.wikipedia.org/wiki/Parity_of_a_permutation">Parity of a Permutation</seealso>
        </member>
        <member name="M:NCDK.Beam.Topology.Sort(System.Int32[],System.Int32[])">
            <summary>
            Sorts the array <paramref name="vs"/> into the Order given by the <paramref name="rank"/>.
            </summary>
            <param name="vs">vertices to sort</param>
            <param name="rank">rank of vertices</param>
            <returns>sorted array (cpy of vs)</returns>
        </member>
        <member name="P:NCDK.Beam.Topology.Unknown">
            <summary>
            Specify Unknown configuration on atom - there is no vertex data stored.
            </summary>
            <returns>Unknown topology</returns>
        </member>
        <member name="M:NCDK.Beam.Topology.CreateTetrahedral(System.Int32,System.Int32[],NCDK.Beam.Configuration)">
            <summary>
            Define tetrahedral topology of the given configuration.
            </summary>
            <param name="u">central atom</param>
            <param name="vs">vertices surrounding u, the first is the vertex we are looking from</param>
            <param name="configuration">the tetrahedral configuration, @TH1, @TH2, @ or @@</param>
            <returns>topology instance for that configuration</returns>
            <seealso cref="P:NCDK.Beam.Topology.Configuration"/>
        </member>
        <member name="M:NCDK.Beam.Topology.CreateTrigonal(System.Int32,System.Int32[],NCDK.Beam.Configuration)">
            <summary>
            Define trigonal topology of the given configuration.
            </summary>
            <param name="u">central atom</param>
            <param name="vs">vertices surrounding u, the first is the vertex we are looking from</param>
            <param name="configuration">the trigonal configuration, @DB1, @Db1, @ or @@</param>
            <returns>topology instance for that configuration</returns>
            <seealso cref="P:NCDK.Beam.Topology.Configuration"/>
        </member>
        <member name="M:NCDK.Beam.Topology.ToExplicit(NCDK.Beam.Graph,System.Int32,NCDK.Beam.Configuration)">
            <summary>
            Convert an implicit configuration ('@' or '@@') c, to an explicit one
            (e.g. @TH1).
            </summary>
            <remarks>
            Implicit Valence Explicit Example
            <pre>
            @ 4       @TH1     O[C@H](N)C or O[C@]([H])(N)C
            @@ 4       @TH2     O[C@@H](N)C or O[C@@]([H])(N)C
            @ 3       @TH1     C[S@](N)=O
            @@ 3       @TH2     C[S@@](N)=O
            @ 2       @AL1     OC=[C@]=CO
            @ 2       @AL2     OC=[C@@]=CO
            @ 5       @TB1     S[As@](F)(Cl)(Br)C=O
            @@ 5       @TB2     S[As@@](F)(Cl)(Br)C=O
            @ 5       @OH1     S[Co@@](F)(Cl)(Br)(I)C=O
            @@ 5       @OH2     O=C[Co@](F)(Cl)(Br)(I)S
            </pre>
            </remarks>
            <param name="g">chemical graph</param>
            <param name="u">the atom to which the configuration is associated</param>
            <param name="c">implicit configuration (<see cref="F:NCDK.Beam.Configuration.AntiClockwise"/> or <see cref="F:NCDK.Beam.Configuration.Clockwise"/>)</param>
            <returns>an explicit configuration or <see cref="F:NCDK.Beam.Configuration.Unknown"/></returns>
        </member>
        <member name="P:NCDK.Beam.Topology.Tetrahedral.Atom">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.Beam.Topology.Tetrahedral.Configuration">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Beam.Topology.Tetrahedral.OrderBy(System.Int32[])">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Beam.Topology.Tetrahedral.Transform(System.Int32[])">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.Beam.Topology.ExtendedTetrahedral.Atom">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.Beam.Topology.ExtendedTetrahedral.Configuration">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Beam.Topology.ExtendedTetrahedral.OrderBy(System.Int32[])">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Beam.Topology.ExtendedTetrahedral.Transform(System.Int32[])">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.Beam.Topology.Trigonal.Atom">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.Beam.Topology.Trigonal.Configuration">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Beam.Topology.Trigonal.OrderBy(System.Int32[])">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Beam.Topology.Trigonal.Transform(System.Int32[])">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Beam.Tuple">
            <summary>
            A simple utility class for storing two primitive integers.
            </summary>
        </member>
        <member name="M:NCDK.Beam.Tuple.First">
            <summary>
            Access the first value of the tuple.
            </summary>
            <returns>value</returns>
        </member>
        <member name="M:NCDK.Beam.Tuple.Second">
            <summary>
            Access the second value of the tuple.
            </summary>
            <returns>value</returns>
        </member>
        <member name="M:NCDK.Beam.Tuple.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Beam.Tuple.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Beam.Tuple.ToString">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Beam.Tuple.Of(System.Int32,System.Int32)">
            <summary>
            Create a new tuple for the provided values.
            </summary>
            <param name="fst">a value</param>
            <param name="snd">another value</param>
            <returns>a tuple of the two values</returns>
        </member>
        <member name="T:NCDK.Beam.UnionFind">
            <summary>
            Fixed size Union-Find/Disjoint-Set implementation.
            </summary>
            <example><code>
            UnionFind uf = new UnionFind(11);
            uf.Join(0, 1);
            uf.Join(1, 10);
            uf.Connected(0, 10); // are 0 and 10 joint?
            uf.Find(10);         // id for the set to which '10' belongs
            </code></example>
        </member>
        <member name="F:NCDK.Beam.UnionFind.forest">
            <summary>
            Each element is either a connected (negative), points to another element.
            The size of the set is indicated by the size of the negation on the
            connected.
            </summary>
        </member>
        <member name="M:NCDK.Beam.UnionFind.#ctor(System.Int32)">
            <summary>
            Create a new UnionFind data structure with enough space for 'n'
            elements.
            </summary>
            <param name="n">number of elements</param>
        </member>
        <member name="M:NCDK.Beam.UnionFind.Find(System.Int32)">
            <summary>
            Find the identifier of the set to which 'u' belongs.
            </summary>
            <param name="u">an element</param>
            <returns>the connected</returns>
        </member>
        <member name="M:NCDK.Beam.UnionFind.Union(System.Int32,System.Int32)">
            <summary>
            Join the sets containing 'u' and 'v'.
            </summary>
            <param name="u">an element</param>
            <param name="v">another element</param>
        </member>
        <member name="M:NCDK.Beam.UnionFind.Join(System.Int32,System.Int32)">
            <summary>
            Join two disjoint sets. The larger set is appended onto the smaller set.
            </summary>
            <param name="sRoot">root of a set (small)</param>
            <param name="lRoot">root of another set (large)</param>
        </member>
        <member name="M:NCDK.Beam.UnionFind.Connected(System.Int32,System.Int32)">
            <summary>
            Are the elements 'u' and 'v' in the same set.
            </summary>
            <param name="u">an element</param>
            <param name="v">another element</param>
            <returns>the elements are in the same set.</returns>
        </member>
        <member name="M:NCDK.Beam.UnionFind.Clear">
            <summary>
            Clear any joint sets - all items are once disjoint and are singletons.
            </summary>
        </member>
        <member name="T:NCDK.Beam.AbstractFunction`2">
            <summary>
            Provides ability to compose functions.
            </summary>
            <typeparam name="S"></typeparam>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:NCDK.Beam.AbstractFunction`2.With``1(NCDK.Beam.Function{`1,``0})">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Beam.AddDirectionalLabels">
            <summary>
            Given a molecule with bond-based double bond configurations - add directional labels to edges
            which do not have it assigned.For example the molecule <pre>NC(/C)=C\C</pre>
            has no directional
            label between the nitrogen and the carbon.Applying this procedure will 'fill-in' missing
            directional information on the edge - <pre>N/C(/C)=C\C</pre>.
            </summary>
            <remarks>
            If required the directional labels in conjugated systems may be adjusted to allow for
            full-specification. Attempting to assign a directional label to the central carbon of 
            <pre>F/C=C(/F)C(/F)=C/F</pre> creates a conflict. This conflict will be resolved by flipping the labels on
            the second double-bond - <pre>F/C=C(/F)\C(\F)=C\F</pre>.
            </remarks>
        </member>
        <member name="M:NCDK.Beam.AddDirectionalLabels.Apply(NCDK.Beam.Graph)">
            <summary>
            Transform all implicit up/down to their explicit type. The original graph is unmodified
            </summary>
            <param name="g">a chemical graph</param>
            <returns>new chemical graph but with all explicit bonds</returns>
        </member>
        <member name="M:NCDK.Beam.AddDirectionalLabels.ReplaceImplWithExpl(NCDK.Beam.Graph,NCDK.Beam.Edge,System.Collections.Generic.IDictionary{NCDK.Beam.Edge,NCDK.Beam.Edge})">
            <summary>
            Given a double bond edge traverse the neighbors of both endpoints and
            accumulate any explicit replacements in the 'acc' accumulator.
            </summary>
            <param name="g">  the chemical graph</param>
            <param name="e">  a edge in the graph </param>('double bond type')
            <param name="acc">accumulator for new edges</param>
            <exception cref="T:NCDK.Beam.InvalidSmilesException">thrown if the edge could not be converted</exception>
        </member>
        <member name="M:NCDK.Beam.AddDirectionalLabels.ReplaceImplWithExpl(NCDK.Beam.Graph,NCDK.Beam.Edge,System.Int32,System.Collections.Generic.IDictionary{NCDK.Beam.Edge,NCDK.Beam.Edge})">
            <summary>
            Given a double bond edge traverse the neighbors of one of the endpoints
            and accumulate any explicit replacements in the <paramref name="acc"/> accumulator.
            </summary>
            <param name="g">the chemical graph</param>
            <param name="e">a edge in the graph ('double bond type')</param>
            <param name="u">a endpoint of the edge <paramref name="e"/></param>
            <param name="acc">accumulator for new edges</param>
            <returns>does the edge <paramref name="e"/> need to be reconsidered later</returns>
            <exception cref="T:NCDK.Beam.InvalidSmilesException">thrown if the edge could not be converted</exception>
        </member>
        <member name="T:NCDK.Beam.ExplicitToImplicit">
            <summary>
            Convert a chemical graph with explicit  single or aromatic edge labels to one with implicit edge labels.
            </summary>
        </member>
        <member name="M:NCDK.Beam.ExplicitToImplicit.Apply(NCDK.Beam.Graph)">
            <summary>
            Transform all explicit to implicit bonds. The original graph is
            unmodified.
            </summary>
            <param name="g">a chemical graph</param>
            <returns>new chemical graph but with all explicit bonds</returns>
        </member>
        <member name="M:NCDK.Beam.ExplicitToImplicit.ToImplicitEdge(NCDK.Beam.Graph,NCDK.Beam.Edge)">
            <summary>
            Given a chemical graph and an edge in that graph, return the implicit
            form of that edge. Neither the graph or the edge is modified, if the edge
            is already explicit then 'e' is returned.
            </summary>
            <param name="g">chemical graph</param>
            <param name="e">an edge of g</param>
            <returns>the edge with specified explicit bond type</returns>
        </member>
        <member name="M:NCDK.Beam.ExplicitToImplicit.GetBondType(NCDK.Beam.Atom,NCDK.Beam.Atom,NCDK.Beam.Bond)">
            <summary>
            Given two atoms which are explicit connected determine the implicit bond
            type. If both atoms are aromatic but connected by a single bond the bond
            type is <see cref="F:NCDK.Beam.Bond.Single"/> otherwise it is implicit.
            </summary>
            <param name="u">an atom</param>
            <param name="v">another atom </param>(connected to u)
            <param name="b">explicit bond type</param>
            <returns>the bond type</returns>
        </member>
        <member name="T:NCDK.Beam.FromSubsetAtoms">
            <summary>
            Given a chemical graph with 0 or more atoms. Convert that graph to one where
            all atoms are fully specified bracket atoms.
            </summary>
        </member>
        <member name="T:NCDK.Beam.FromTrigonalTopology">
            <summary>
            Given a chemical graph with atom-centric double bond stereo configurations
            (trigonal topology) - remove the topology but add in direction up/down edge
            labels.
            </summary>
        </member>
        <member name="T:NCDK.Beam.Functions">
            <summary>
            Collection of utilities for transforming chemical graphs.
            </summary>
        </member>
        <member name="M:NCDK.Beam.Functions.#ctor">
            non-instantiable
        </member>
        <member name="M:NCDK.Beam.Functions.Randomise(NCDK.Beam.Graph)">
            <summary>
            Randomise the atom Order of the provided chemical graph.
            </summary>
            <param name="g">chemical graph</param>
            <returns>a copy of the original graph with the Order of the atoms randomised</returns>
        </member>
        <member name="M:NCDK.Beam.Functions.Reverse(NCDK.Beam.Graph)">
            <summary>
            Reverse the atom Order of the provided chemical graph.
            </summary>
            <param name="g">chemical graph</param>
            <returns>a copy of the original graph with the Order of the atoms reversed</returns>
        </member>
        <member name="M:NCDK.Beam.Functions.AtomBasedDBStereo(NCDK.Beam.Graph)">
            <summary>
            Convert any directional bond based stereo configuration to atom-based
            specification.
            </summary>
            <param name="g">chemical graph graph</param>
            <returns>a copy of the original graph but with directional bonds removed
                    and atom-based double-bond stereo configruation.</returns>
        </member>
        <member name="M:NCDK.Beam.Functions.BondBasedDBStereo(NCDK.Beam.Graph)">
            <summary>
            Convert a graph with atom-based double-bond stereo configuration to
            bond-based specification (direction Up and Down bonds).
            </summary>
            <param name="g">chemical graph graph</param>
            <returns>a copy of the original graph but with bond-based
                    stereo-chemistry</returns>
        </member>
        <member name="M:NCDK.Beam.Functions.Expand(NCDK.Beam.Graph)">
            <summary>
            Expand a graph with organic subsets to one with specified atom
            properties.
            </summary>
            <param name="g">a chemical graph</param>
            <returns>the chemical graph expanded</returns>
        </member>
        <member name="M:NCDK.Beam.Functions.Collapse(NCDK.Beam.Graph)">
            <summary>
            Collapse a graph with specified atom properties to one with organic
            subset atoms.
            </summary>
            <param name="g">a chemical graph</param>
            <returns>the chemical graph expanded</returns>
        </member>
        <member name="M:NCDK.Beam.Functions.Canonicalize(NCDK.Beam.Graph,System.Int64[])">
            <summary>
            Apply the labeling <paramref name="labels"/> to the graph <paramref name="g"/>. The labels
            are converted to a permutation which is then applied to the Graph and
            rearrange it's vertex Order.
            </summary>
            <param name="g">the graph to permute</param>
            <param name="labels">the vertex labels - for example from a cannibalisation algorithm</param>
            <returns>a copy of the original graph with it's vertices permuted by the labelling</returns>
        </member>
        <member name="T:NCDK.Beam.ImplicitToExplicit">
            <summary>
            Convert a chemical graph with implicit edge labels to one with explicit
            single or aromatic edge labels.
            </summary>
        </member>
        <member name="M:NCDK.Beam.ImplicitToExplicit.Apply(NCDK.Beam.Graph)">
            <summary>
            Transform all implicit to explicit bonds. The original graph is
            unmodified
            </summary>
            <param name="g">a chemical graph</param>
            <returns>new chemical graph but with all explicit bonds</returns>
        </member>
        <member name="M:NCDK.Beam.ImplicitToExplicit.ToExplicitEdge(NCDK.Beam.Graph,NCDK.Beam.Edge)">
            <summary>
            Given a chemical graph and an edge in that graph, return the explicit
            form of that edge. Neither the graph or the edge is modified, if the edge
            is already explicit then '<paramref name="e"/>' is returned.
            </summary>
            <param name="g">chemical graph</param>
            <param name="e">an edge of g</param>
            <returns>the edge with specified explicit bond type</returns>
        </member>
        <member name="M:NCDK.Beam.ImplicitToExplicit.Type(NCDK.Beam.Atom,NCDK.Beam.Atom)">
            <summary>
            Given two atoms which are implicitly connected determine the explicit
            bond type. The type is 'aromatic' if both atoms are aromatic, if either
            or both atoms are non-aromatic then the bond type is 'single'.
            </summary>
            <param name="u">an atom</param>
            <param name="v">another atom </param>(connected to u)
            <returns>the bond type</returns>
        </member>
        <member name="T:NCDK.Beam.NormaliseDirectionalLabels">
            <summary>
            Normalise directional labels such that the first label is always a '/'. Given 
            a molecule with directional bonds "F\C=C\F" the labels are normalised 
            to be "F/C=C/F".
            </summary>
        </member>
        <member name="T:NCDK.Beam.RemoveUpDownBonds">
            <summary>
            Given a molecule with explict double bond configurations remove redundant
            Up/Down bond. For example the removing redundant up/down labels from of
            "N/C(/C)=C\C" produces "N/C(C)=C\C".
            </summary>
        </member>
        <member name="M:NCDK.Beam.RemoveUpDownBonds.RemoveRedundant(NCDK.Beam.Graph,NCDK.Beam.Edge,System.Int32[],System.Collections.Generic.IDictionary{NCDK.Beam.Edge,NCDK.Beam.Edge})">
            <summary>
            Given a double bond edge traverse the neighbors of both endpoints and
            accumulate any explicit replacements in the 'acc' accumulator.
            </summary>
            <param name="g">  the chemical graph</param>
            <param name="e">  a edge in the graph </param>('double bond type')
            <param name="ordering"></param>
            <param name="acc">accumulator for new edges</param>
            <exception cref="T:NCDK.Beam.InvalidSmilesException">thrown if the edge could not be converted</exception>
        </member>
        <member name="M:NCDK.Beam.RemoveUpDownBonds.ReplaceImplWithExpl(NCDK.Beam.Graph,NCDK.Beam.Edge,System.Int32,System.Int32[],System.Collections.Generic.IDictionary{NCDK.Beam.Edge,NCDK.Beam.Edge})">
            <summary>
            Given a double bond edge traverse the neighbors of one of the endpoints
            and accumulate any explicit replacements in the 'acc' accumulator.
            </summary>
            <param name="g">  the chemical graph</param>
            <param name="e">  a edge in the graph </param>('double bond type')
            <param name="u">  a endpoint of the edge 'e'</param>
            <param name="ordering"></param>
            <param name="acc">accumulator for new edges</param>
            <exception cref="T:NCDK.Beam.InvalidSmilesException">thrown if the edge could not be converted</exception>
        </member>
        <member name="T:NCDK.Beam.ToSubsetAtoms">
            <summary>
            Given a chemical graph with 0 or more atoms. Convert that graph to one where
            fully specified bracket atoms which can be specified as organic subsets.
            </summary>
        </member>
        <member name="T:NCDK.Beam.ToTrigonalTopology">
            <summary>
            Convert direction (up/down) bonds to trigonal topology (double bond atom
            centric stereo specification).
            </summary>
            <remarks>
            <code>
               F/C=C/F -> F/[C@H]=[C@H]F
               F/C=C\F -> F/[C@H]=[C@@H]F
               F\C=C/F -> F/[C@@H]=[C@H]F
               F\C=C\F -> F/[C@@H]=[C@@H]F
            </code>
            </remarks>
        </member>
        <member name="T:NCDK.BondOrder">
            <summary>
            A list of permissible bond orders.
            </summary>
        </member>
        <member name="T:NCDK.BondOrder.O">
            <summary>
            The <see cref="P:NCDK.BondOrder.Ordinal"/> values of <see cref="T:NCDK.BondOrder"/>.
            </summary>
            <seealso cref="T:NCDK.BondOrder"/>
        </member>
        <member name="P:NCDK.BondOrder.Ordinal">
            <summary>
            The ordinal of this enumeration constant. The list is in <see cref="T:NCDK.BondOrder.O"/>.
            </summary>
            <seealso cref="T:NCDK.BondOrder.O"/>
        </member>
        <member name="M:NCDK.BondOrder.ToString">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.BondOrder.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.BondOrder.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.BondOrder.CompareTo(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.BondOrder.CompareTo(NCDK.BondOrder)">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.BondOrder.Numeric">
            <summary>
            A numeric value for the number of bonded electron pairs.
            </summary>
        </member>
        <member name="T:NCDK.BondStereo">
            <summary>
            Enumeration of possible stereo types of two-atom bonds. The
            Stereo type defines not just define the stereochemistry, but also the
            which atom is the stereo center for which the Stereo is defined.
            The first atom in the IBond (index = 0) is the <i>start</i> atom, while
            the second atom (index = 1) is the <i>end</i> atom.
            </summary>
        </member>
        <member name="T:NCDK.BondStereo.O">
            <summary>
            The <see cref="P:NCDK.BondStereo.Ordinal"/> values of <see cref="T:NCDK.BondStereo"/>.
            </summary>
            <seealso cref="T:NCDK.BondStereo"/>
        </member>
        <member name="P:NCDK.BondStereo.Ordinal">
            <summary>
            The ordinal of this enumeration constant. The list is in <see cref="T:NCDK.BondStereo.O"/>.
            </summary>
            <seealso cref="T:NCDK.BondStereo.O"/>
        </member>
        <member name="M:NCDK.BondStereo.ToString">
            <inheritdoc/>
        </member>
        <member name="F:NCDK.BondStereo.None">
            <summary>
            A bond for which there is no stereochemistry.
            </summary>
        </member>
        <member name="F:NCDK.BondStereo.Up">
            <summary>
            A bond pointing up of which the start atom is the stereocenter and the end atom is above the drawing plane.
            </summary>
        </member>
        <member name="F:NCDK.BondStereo.UpInverted">
            <summary>
            A bond pointing up of which the end atom is the stereocenter and the start atom is above the drawing plane.
            </summary>
        </member>
        <member name="F:NCDK.BondStereo.Down">
            <summary>
            A bond pointing down of which the start atom is the stereocenter and the end atom is below the drawing plane.
            </summary>
        </member>
        <member name="F:NCDK.BondStereo.DownInverted">
            <summary>
            A bond pointing down of which the end atom is the stereocenter and the start atom is below the drawing plane.
            </summary>
        </member>
        <member name="F:NCDK.BondStereo.UpOrDown">
            <summary>
            A bond for which there is stereochemistry, we just do not know if it is UP or Down. The start atom is the stereocenter.
            </summary>
        </member>
        <member name="F:NCDK.BondStereo.UpOrDownInverted">
            <summary>
            A bond for which there is stereochemistry, we just do not know if it is UP or Down. The end atom is the stereocenter.
            </summary>
        </member>
        <member name="F:NCDK.BondStereo.EOrZ">
            <summary>
            Indication that this double bond has a fixed, but unknown E/Z configuration.
            </summary>
        </member>
        <member name="F:NCDK.BondStereo.E">
            <summary>
            Indication that this double bond has a E configuration.
            </summary>
        </member>
        <member name="F:NCDK.BondStereo.Z">
            <summary>
            Indication that this double bond has a Z configuration.
            </summary>
        </member>
        <member name="F:NCDK.BondStereo.EZByCoordinates">
            <summary>
            Indication that this double bond has a fixed configuration, defined by the 2D and/or 3D coordinates.
            </summary>
        </member>
        <member name="M:NCDK.BondStereo.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.BondStereo.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.BondStereo.CompareTo(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.BondStereo.CompareTo(NCDK.BondStereo)">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Common.Collections.DictionaryEqualityComparer`2">
            <summary>
            <see langword="null"/> key and value is not supported.
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="V"></typeparam>
        </member>
        <member name="T:NCDK.Common.Hash.Crc32">
            <summary>
            Implements a 32-bit CRC hash algorithm compatible with Zip etc.
            </summary>
            <remarks>
            Crc32 should only be used for backward compatibility with older file formats
            and algorithms. It is not secure enough for new applications.
            If you need to call multiple times for the same data either use the HashAlgorithm
            interface or remember that the result of one Compute call needs to be ~ (XOR) before
            being passed in as the seed for the next Compute call.
            </remarks>
        </member>
        <member name="T:NCDK.Common.Mathematics.BitsStreamGenerator">
            <summary> 
            Base class for random number generators that generates bits streams.
            </summary>
        </member>
        <member name="F:NCDK.Common.Mathematics.BitsStreamGenerator.nextGaussian">
            <summary>Next gaussian.</summary>
        </member>
        <member name="M:NCDK.Common.Mathematics.BitsStreamGenerator.#ctor">
            <summary> Creates a new random number generator.</summary>
        </member>
        <member name="M:NCDK.Common.Mathematics.BitsStreamGenerator.SetSeed(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Common.Mathematics.BitsStreamGenerator.SetSeed(System.Int32[])">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Common.Mathematics.BitsStreamGenerator.SetSeed(System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Common.Mathematics.BitsStreamGenerator.Next(System.Int32)">
            <summary>Generate next pseudorandom number.
            </summary>
            <remarks>
            <para>This method is the core generation algorithm. It is used by all the
            public generation methods for the various primitive types <see cref="M:NCDK.Common.Mathematics.BitsStreamGenerator.NextBool"/>,
            <see cref="M:NCDK.Common.Mathematics.BitsStreamGenerator.NextBytes(System.Byte[])"/>, <see cref="M:NCDK.Common.Mathematics.BitsStreamGenerator.NextDouble"/>,
            <see cref="M:NCDK.Common.Mathematics.BitsStreamGenerator.NextFloat"/>, <see cref="M:NCDK.Common.Mathematics.BitsStreamGenerator.NextGaussian"/>, <see cref="M:NCDK.Common.Mathematics.BitsStreamGenerator.Next"/>,
            <see cref="M:NCDK.Common.Mathematics.BitsStreamGenerator.Next(System.Int32)"/> and <see cref="M:NCDK.Common.Mathematics.BitsStreamGenerator.NextLong"/>.</para>
            </remarks>
            <param name="bits">number of random bits to produce</param>
            <returns>random bits generated</returns>
        </member>
        <member name="M:NCDK.Common.Mathematics.BitsStreamGenerator.NextBool">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Common.Mathematics.BitsStreamGenerator.NextBytes(System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Common.Mathematics.BitsStreamGenerator.NextDouble">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Common.Mathematics.BitsStreamGenerator.NextFloat">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Common.Mathematics.BitsStreamGenerator.NextGaussian">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Common.Mathematics.BitsStreamGenerator.Next">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Common.Mathematics.BitsStreamGenerator.NextInt(System.Int32)">
            <summary>
            <inheritdoc/>
            </summary>
            <remarks>
            <para>This default implementation is copied from Apache Harmony java.util.Random (r929253).</para>
            <note type="note">
            <para>If n is a power of 2, this method returns <c>(int) ((n * (long) Next(31)) >> 31)}</c>.</para>
            <item>If n is not a power of 2, what is returned is <c>Next(31) % n</c>
            with <c>Next(31)</c> values rejected (i.e. regenerated) until a
            value that is larger than the remainder of <c>int.MaxValue / n</c>
            is generated. Rejection of this initial segment is necessary to ensure
            a uniform distribution.</item></note>
            </remarks>
        </member>
        <member name="M:NCDK.Common.Mathematics.BitsStreamGenerator.NextLong">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Common.Mathematics.BitsStreamGenerator.Clear">
            <summary>
            Clears the cache used by the default implementation of <see cref="F:NCDK.Common.Mathematics.BitsStreamGenerator.nextGaussian"/>.
            </summary>
        </member>
        <member name="M:NCDK.Common.Primitives.Ints.Compare(System.Int32,System.Int32)">
            <summary>
            Compares the two specified <see cref="T:System.Int32"/> values. The sign of the value returned is the same as
            that of <c><paramref name="a"/>.CompareTo(<paramref name="b"/>)</c>.
            <para><b>Note for Java 7 and later:</b> this method should be treated as deprecated; use the
            equivalent <see cref="M:System.Int32.CompareTo(System.Int32)"/> method instead.</para>
            </summary>
            <param name="a">the first <see cref="T:System.Int32"/> to compare</param>
            <param name="b">the second <see cref="T:System.Int32"/> to compare</param>
            <returns>a negative value if <paramref name="a"/> is less than <paramref name="b"/>; a positive value if <paramref name="a"/> is greater than <paramref name="b"/>; or zero if they are equal</returns>
        </member>
        <member name="M:NCDK.Common.Primitives.Ints.EnsureCapacity(System.Int32[],System.Int32,System.Int32)">
            <summary>
            Returns an array containing the same values as <paramref name="array"/>, but
            guaranteed to be of a specified minimum length. If <paramref name="array"/> already
            has a length of at least <paramref name="minLength"/>, it is returned directly.
            Otherwise, a new array of size <paramref name="array"/> + <paramref name="padding"/> is returned,
            containing the values of <paramref name="array"/>, and zeroes in the remaining places.
            </summary>
            <param name="array">the source array</param>
            <param name="minLength">the minimum length the returned array must guarantee</param>
            <param name="padding">an extra amount to "grow" the array by if growth is necessary</param>
            <returns>an array containing the values of <paramref name="array"/>, with guaranteed minimum length <paramref name="minLength"/></returns>
            <exception cref="T:System.ArgumentException">if <paramref name="minLength"/> or <paramref name="padding"/> is negative</exception>
        </member>
        <member name="M:NCDK.Common.Primitives.Ints.HighestOneBit(System.Int32)">
            <summary>
            Returns an <see cref="T:System.Int32"/> value with at most a single one-bit, in the
            position of the highest-order("leftmost") one-bit in the specified
            <see cref="T:System.Int32"/> value.Returns zero if the specified value has no
            one-bits in its two's complement binary representation, that is, if it
            is equal to zero.
            </summary>
            <param name="i"></param>
            <returns>an <see cref="T:System.Int32"/> value with a single one-bit, in the position
            of the highest-order one-bit in the specified value, or zero if
            the specified value is itself equal to zero.
            </returns>
        </member>
        <member name="M:NCDK.Common.Primitives.Ints.NumberOfLeadingZeros(System.Int32)">
            <summary>
            Returns the number of zero bits preceding the highest-order
            ("leftmost") one-bit in the two's complement binary representation
            of the specified <see cref="T:System.Int32"/> value.  Returns 32 if the
            specified value has no one-bits in its two's complement representation,
            in other words if it is equal to zero.
            </summary>
            <remarks>
            <para>Note that this method is closely related to the logarithm base 2.
            For all positive <see cref="T:System.Int32"/> values x:
            <list type="bullet">
            <item>floor(log<sub>2</sub>(x)) = <c>31 - numberOfLeadingZeros(x)</c></item>
            <item>ceil(log<sub>2</sub>(x)) = <c>32 - numberOfLeadingZeros(x - 1)</c></item>
            </list> 
            </para>
            </remarks>
            <param name="i"></param>
            <returns>the number of zero bits preceding the highest-order
                ("leftmost") one-bit in the two's complement binary representation
                of the specified <see cref="T:System.Int32"/> value, or 32 if the value
                is equal to zero.</returns>
        </member>
        <member name="M:NCDK.Common.Primitives.Longs.BitCount(System.Int64)">
            <summary>
            Returns the number of one-bits in the two's complement binary
            representation of the specified <see cref="T:System.Int64"/> value.  This function is
            sometimes referred to as the <i>population count</i>.
            </summary>
            <param name="i"></param>
            <returns>the number of one-bits in the two's complement binary representation of the specified <see cref="T:System.Int64"/> value.</returns>
        </member>
        <member name="T:NCDK.Common.Util.StreamTokenizer">
            <summary>
            The <see cref="T:NCDK.Common.Util.StreamTokenizer"/> class takes an input stream and
            parses it into "tokens", allowing the tokens to be
            Read one at a time. The parsing process is controlled by a table
            and a number of flags that can be set to various states. The
            stream tokenizer can recognize identifiers, numbers, quoted
            strings, and various comment styles.
            <para>
            Each byte Read from the input stream is regarded as a character
            in the range <c>'\u0000'</c> through <c>'\u00FF'</c>.
            The character value is used to look up five possible attributes of
            the character: <i>white space</i>, <i>alphabetic</i>,
            <i>numeric</i>, <i>string quote</i>, and <i>comment character</i>.
            Each character can have zero or more of these attributes.
            </para>
            <para>
            In addition, an instance has four flags. These flags indicate:
            <list type="bulett">
            <item>Whether line terminators are to be returned as tokens or treated as white space that merely separates tokens.</item>
            <item>Whether C-style comments are to be recognized and skipped.</item>
            <item>Whether C++-style comments are to be recognized and skipped.</item>
            <item>Whether the characters of identifiers are converted to lowercase.</item>
            </list>
            </para>
            <para>
            A typical application first constructs an instance of this class,
            sets up the syntax tables, and then repeatedly loops calling the
            <see cref="M:NCDK.Common.Util.StreamTokenizer.NextToken"/> method in each iteration of the loop until
            it returns the value <see cref="F:NCDK.Common.Util.StreamTokenizer.TT_EOF"/>.
            </para>
            </summary>
        </member>
        <member name="F:NCDK.Common.Util.StreamTokenizer.peekc">
            <summary>
            The next character to be considered by the nextToken method.  May also
            be NEED_CHAR to indicate that a new character should be Read, or SKIP_LF
            to indicate that a new character should be Read and, if it is a '\n'
            character, it should be discarded and a second new character should be
            Read.
            </summary>
        </member>
        <member name="F:NCDK.Common.Util.StreamTokenizer.eolIsSignificantP">
            <summary> The line number of the last token Read </summary>
        </member>
        <member name="P:NCDK.Common.Util.StreamTokenizer.TType">
            <summary>
            After a call to the <see cref="M:NCDK.Common.Util.StreamTokenizer.NextToken"/> method, this field
            contains the type of the token just Read. For a single character
            token, its value is the single character, converted to an integer.
            For a quoted string token, its value is the quote character.
            Otherwise, its value is one of the following:
            <list type="bullet">
                <item><see cref="F:NCDK.Common.Util.StreamTokenizer.TT_WORD"/> indicates that the token is a word.</item>
                <item><see cref="F:NCDK.Common.Util.StreamTokenizer.TT_NUMBER"/> indicates that the token is a number.</item>
                <item><see cref="F:NCDK.Common.Util.StreamTokenizer.TT_EOL"/> indicates that the end of line has been Read.
                The field can only have this value if the <see cref="M:NCDK.Common.Util.StreamTokenizer.EolIsSignificant(System.Boolean)"/> 
                method has been called with the argument <see langword="true"/>.</item>
                <item><see cref="F:NCDK.Common.Util.StreamTokenizer.TT_EOL"/> indicates that the end of the input stream has been reached.</item>
            </list>
            The initial value of this field is -4.
            </summary>
        </member>
        <member name="F:NCDK.Common.Util.StreamTokenizer.TT_EOF">
            <summary>
            A constant indicating that the end of the stream has been Read.
            </summary>
        </member>
        <member name="F:NCDK.Common.Util.StreamTokenizer.TT_EOL">
            <summary>
            A constant indicating that the end of the line has been Read.
            </summary>
        </member>
        <member name="F:NCDK.Common.Util.StreamTokenizer.TT_NUMBER">
            <summary>
            A constant indicating that a number token has been Read.
            </summary>
        </member>
        <member name="F:NCDK.Common.Util.StreamTokenizer.TT_WORD">
            <summary>
            A constant indicating that a word token has been Read.
            </summary>
        </member>
        <member name="F:NCDK.Common.Util.StreamTokenizer.TT_NOTHING">
            <summary>
            A constant indicating that no token has been Read, used for
            initializing ttype.  FIXME This could be made public and
            made available as the part of the API in a future release.
            </summary>
        </member>
        <member name="P:NCDK.Common.Util.StreamTokenizer.StringValue">
            <summary>
            If the current token is a word token, this field contains a
            string giving the characters of the word token. When the current
            token is a quoted string token, this field contains the body of
            the string.
            <para>
            The current token is a word when the value of the
            <see cref="P:NCDK.Common.Util.StreamTokenizer.TType"/> field is <see cref="F:NCDK.Common.Util.StreamTokenizer.TT_WORD"/>. The current token is
            a quoted string token when the value of the <see cref="P:NCDK.Common.Util.StreamTokenizer.TType"/> field is
            a quote character.
            </para>
            <para>
            The initial value of this field is null.
            </para>
            </summary>
            <seealso cref="M:NCDK.Common.Util.StreamTokenizer.QuoteChar(System.Int32)"/>
            <seealso cref="F:NCDK.Common.Util.StreamTokenizer.TT_WORD"/>
            <seealso cref="P:NCDK.Common.Util.StreamTokenizer.TType"/>
        </member>
        <member name="P:NCDK.Common.Util.StreamTokenizer.NumberValue">
            <summary>
            If the current token is a number, this field contains the value
            of that number. The current token is a number when the value of
            the <see cref="P:NCDK.Common.Util.StreamTokenizer.TType"/> field is <see cref="F:NCDK.Common.Util.StreamTokenizer.TT_NUMBER"/>.
            </summary>
            <value>The initial value of this field is 0.0.</value>
        </member>
        <member name="M:NCDK.Common.Util.StreamTokenizer.#ctor">
            <summary> Private constructor that initializes everything except the streams. </summary>
        </member>
        <member name="M:NCDK.Common.Util.StreamTokenizer.#ctor(System.IO.TextReader)">
            <summary>
            Create a tokenizer that parses the given character stream.
            </summary>
            <param name="r">a Reader object providing the input stream.</param>
        </member>
        <member name="M:NCDK.Common.Util.StreamTokenizer.ResetSyntax">
            <summary>
            Resets this tokenizer's syntax table so that all characters are
            "ordinary." See the <see cref="M:NCDK.Common.Util.StreamTokenizer.OrdinaryChar(System.Int32)"/> method
            for more information on a character being ordinary.
            </summary>
        </member>
        <member name="M:NCDK.Common.Util.StreamTokenizer.WordChars(System.Int32,System.Int32)">
            <summary>
            Specifies that all characters <i>c</i> in the range
            <c>low &lt;= <i>c</i> &lt;= high</c>
            are word constituents. A word token consists of a word constituent
            followed by zero or more word constituents or number constituents.
            </summary>
            <param name="low">the low end of the range.</param>
            <param name="hi">the high end of the range.</param>
        </member>
        <member name="M:NCDK.Common.Util.StreamTokenizer.WhiteSpaceChars(System.Int32,System.Int32)">
            <summary>
            Specifies that all characters <i>c</i> in the range
            <c>low &lt;= <i>c</i> &lt;= high</c>
            are white space characters. White space characters serve only to
            separate tokens in the input stream.
            <para>
            Any other attribute settings for the characters in the specified
            range are cleared.
            </para>
            </summary>
            <param name="low">the low end of the range.</param>
            <param name="hi">the high end of the range.</param>
        </member>
        <member name="M:NCDK.Common.Util.StreamTokenizer.OrdinaryChars(System.Int32,System.Int32)">
            <summary>
            Specifies that all characters <i>c</i> in the range
            <c>low &lt;= <i>c</i> &lt;= high</c>
            are "ordinary" in this tokenizer. See the
            <see cref="M:NCDK.Common.Util.StreamTokenizer.OrdinaryChar(System.Int32)"/> method for more information on a
            character being ordinary.
            </summary>
            <param name="low">the low end of the range.</param>
            <param name="hi">the high end of the range.</param>
            <seealso cref="M:NCDK.Common.Util.StreamTokenizer.OrdinaryChar(System.Int32)"/>
        </member>
        <member name="M:NCDK.Common.Util.StreamTokenizer.OrdinaryChar(System.Int32)">
            <summary>
            Specifies that the character argument is "ordinary"
            in this tokenizer. It removes any special significance the
            character has as a comment character, word component, string
            delimiter, white space, or number character. When such a character
            is encountered by the parser, the parser treats it as a
            single-character token and sets <see cref="P:NCDK.Common.Util.StreamTokenizer.TType"/> field to the
            character value.
            <para>Making a line terminator character "ordinary" may interfere
            with the ability of a <see cref="T:NCDK.Common.Util.StreamTokenizer"/> to count
            lines. The <see cref="P:NCDK.Common.Util.StreamTokenizer.LineNumber"/> method may no longer reflect
            the presence of such terminator characters in its line count.
            </para>
            </summary>
            <param name="ch">the character.</param>
        </member>
        <member name="M:NCDK.Common.Util.StreamTokenizer.CommentChar(System.Int32)">
            <summary>
            Specified that the character argument starts a single-line
            comment. All characters from the comment character to the end of
            the line are ignored by this stream tokenizer.
            <para>Any other attribute settings for the specified character are cleared.</para>
            </summary>
            <param name="ch">the character.</param>
        </member>
        <member name="M:NCDK.Common.Util.StreamTokenizer.QuoteChar(System.Int32)">
            <summary>
            Specifies that matching pairs of this character delimit string
            constants in this tokenizer.
            <para>
            When the <see cref="M:NCDK.Common.Util.StreamTokenizer.NextToken"/> method encounters a string
            constant, the <see cref="P:NCDK.Common.Util.StreamTokenizer.TType"/> field is set to the string
            delimiter and the <c>sval</c> field is set to the body of
            the string.
            </para>
            <para>
            If a string quote character is encountered, then a string is
            recognized, consisting of all characters after (but not including)
            the string quote character, up to (but not including) the next
            occurrence of that same string quote character, or a line
            terminator, or end of file. The usual escape sequences such as
            <c>"\n"</c> and <c>"\t"</c> are recognized and
            converted to single characters as the string is parsed.
            </para>
            <para>
            Any other attribute settings for the specified character are cleared.
            </para>
            </summary>
            <param name="ch">the character.</param>
        </member>
        <member name="M:NCDK.Common.Util.StreamTokenizer.ParseNumbers">
            <summary>
            Specifies that numbers should be parsed by this tokenizer. The
            syntax table of this tokenizer is modified so that each of the twelve
            characters:
            <pre>
                 0 1 2 3 4 5 6 7 8 9 . -
            </pre>
            has the "numeric" attribute.
            <para>
            When the parser encounters a word token that has the format of a
            double precision floating-point number, it treats the token as a
            number rather than a word, by setting the <see cref="P:NCDK.Common.Util.StreamTokenizer.TType"/>
            field to the value <see cref="F:NCDK.Common.Util.StreamTokenizer.TT_NUMBER"/> and putting the numeric
            value of the token into the <see cref="P:NCDK.Common.Util.StreamTokenizer.NumberValue"/> field.
            </para>
            </summary>
        </member>
        <member name="M:NCDK.Common.Util.StreamTokenizer.EolIsSignificant(System.Boolean)">
            <summary>
            Determines whether or not ends of line are treated as tokens.
            If the flag argument is true, this tokenizer treats end of lines
            as tokens; the <see cref="M:NCDK.Common.Util.StreamTokenizer.NextToken"/> method returns
            <see cref="F:NCDK.Common.Util.StreamTokenizer.TT_EOL"/> and also sets the <see cref="P:NCDK.Common.Util.StreamTokenizer.TType"/> field to
            this value when an end of line is Read.
            <para>
            A line is a sequence of characters ending with either a
            carriage-return character (<c>'\r'</c>) or a newline
            character (<c>'\n'</c>). In addition, a carriage-return
            character followed immediately by a newline character is treated
            as a single end-of-line token.
            </para>
            <para>
            If the <paramref name="flag"/> is false, end-of-line characters are 
            treated as white space and serve only to separate tokens.
            </para>
            </summary>
            <param name="flag"><see langword="true"/> indicates that end-of-line characters
            are separate tokens; <see langword="false"/> indicates that end-of-line characters are white space.</param>
        </member>
        <member name="P:NCDK.Common.Util.StreamTokenizer.SlashStarComments">
            <summary>
            Determines whether or not the tokenizer recognizes C-style comments.
            If the flag argument is <see langword="true"/>, this stream tokenizer
            recognizes C-style comments. All text between successive
            occurrences of <c>/*</c> and <c>*/</c> are discarded.
            <para>
            If the flag argument is <see langword="false"/>, then C-style comments
            are not treated specially.</para>
            </summary>
        </member>
        <member name="P:NCDK.Common.Util.StreamTokenizer.SlashSlashComments">
            <summary>
            Determines whether or not the tokenizer recognizes C++-style comments.
            If the flag argument is <see langword="true"/>, this stream tokenizer
            recognizes C++-style comments. Any occurrence of two consecutive
            slash characters (<c>'/'</c>) is treated as the beginning of
            a comment that extends to the end of the line.
            <para>
            If the flag argument is <see langword="false"/>, then C++-style
            comments are not treated specially.</para>
            </summary>
        </member>
        <member name="P:NCDK.Common.Util.StreamTokenizer.LowerCaseMode">
            <summary>
            Determines whether or not word token are automatically lowercased.
            If the flag argument is <see langword="true"/>, then the value in the
            <see cref="P:NCDK.Common.Util.StreamTokenizer.StringValue"/> field is lowercased whenever a word token is
            returned (the <see cref="P:NCDK.Common.Util.StreamTokenizer.TType"/> field has the
            value <see cref="F:NCDK.Common.Util.StreamTokenizer.TT_WORD"/> by the <see cref="M:NCDK.Common.Util.StreamTokenizer.NextToken"/> method
            of this tokenizer.
            <para>
            If the flag argument is <see langword="false"/>, then the
            <see cref="P:NCDK.Common.Util.StreamTokenizer.StringValue"/> field is not modified.</para>
            </summary>
        </member>
        <member name="M:NCDK.Common.Util.StreamTokenizer.Read">
            <summary>Read the next character</summary>
        </member>
        <member name="M:NCDK.Common.Util.StreamTokenizer.NextToken">
            <summary>
            Parses the next token from the input stream of this tokenizer.
            The type of the next token is returned in the <see cref="P:NCDK.Common.Util.StreamTokenizer.TType"/>
            field. Additional information about the token may be in the
            <see cref="P:NCDK.Common.Util.StreamTokenizer.NumberValue"/> field or the <see cref="P:NCDK.Common.Util.StreamTokenizer.StringValue"/> field of this
            tokenizer.
            <para>
            Typical clients of this
            class first set up the syntax tables and then sit in a loop
            calling <see cref="M:NCDK.Common.Util.StreamTokenizer.NextToken"/> to parse successive tokens until <see cref="F:NCDK.Common.Util.StreamTokenizer.TT_EOF"/>
            is returned.</para>
            </summary>
            <returns>the value of the <see cref="P:NCDK.Common.Util.StreamTokenizer.TType"/> field.</returns>
        </member>
        <member name="M:NCDK.Common.Util.StreamTokenizer.PushBack">
            <summary>
            Causes the next call to the <see cref="M:NCDK.Common.Util.StreamTokenizer.NextToken"/>  method of this
            tokenizer to return the current value in the <see cref="P:NCDK.Common.Util.StreamTokenizer.TType"/>
            field, and not to modify the value in the<see cref="P:NCDK.Common.Util.StreamTokenizer.NumberValue"/> or
            <see cref="P:NCDK.Common.Util.StreamTokenizer.StringValue"/> field.
            </summary>
        </member>
        <member name="M:NCDK.Common.Util.StreamTokenizer.ToString">
            <summary>
            Returns the string representation of the current stream token and
            the line number it occurs on.
            <para>The precise string returned is unspecified, although the following
            example can be considered typical:
            <pre>
                Token['a'], line 10
            </pre>
            </para>
            </summary>
            <returns>a string representation of the token</returns>
        </member>
        <member name="T:NCDK.Config.Elements">
            <summary>
            Enumeration of chemical elements. Data is taken from the Blue Obelisk Data
            Repository, version 3. This enumeration is auto-generated with utilities
            found in the 'cdk-build-utils' project.
            </summary>
        </member>
        <member name="P:NCDK.Config.Elements.Values">
            <summary>
            Lookup elements by atomic number.
            </summary>
        </member>
        <member name="P:NCDK.Config.Elements.AtomicNumber">
            <summary>
            The atomic number of the element. An <see cref="F:NCDK.Config.Elements.Unknown"/> element
            has an atomic number of '0'.
            </summary>
        </member>
        <member name="P:NCDK.Config.Elements.Period">
            <summary>
            Return the period in the periodic table this element belongs to. If
            the element is <see cref="F:NCDK.Config.Elements.Unknown"/> it's period is 0.
            </summary>
        </member>
        <member name="P:NCDK.Config.Elements.Group">
            <summary>
            Return the group in the periodic table this element belongs to. If
            the element does not belong to a group then it's group is '0'.
            </summary>
        </member>
        <member name="P:NCDK.Config.Elements.Symbol">
            <summary>
            The element symbol, C for carbon, N for nitrogen, Na for sodium, etc. An
            <see cref="F:NCDK.Config.Elements.Unknown"/> element has no symbol.
            </summary>
        </member>
        <member name="P:NCDK.Config.Elements.CovalentRadius">
            <summary>
            Covalent radius (<i>r<sub>cov</sub></i>), van der Waals radius
            (<i>r<sub>w</sub></i>) and Pauling electronegativity.
            </summary>
            <seealso href="http://en.wikipedia.org/wiki/Covalent_radius">Covalent radius</seealso>
        </member>
        <member name="P:NCDK.Config.Elements.Electronegativity">
            <summary>
            Electronegativity, symbol œá, is a chemical property that describes
            the tendency of an atom or a functional group to attract electrons
            (or electron density) towards itself. This method provides access to the
            Pauling electronegativity value for a chemical element. If no value is
            available <see langword="null"/> is returned.
            </summary>
            <seealso href="http://en.wikipedia.org/wiki/Electronegativity#Pauling_electronegativity">Pauling Electronegativity</seealso>
        </member>
        <member name="F:NCDK.Config.Elements.instance">
            <summary>
            An <see cref="T:NCDK.IElement"/> instance of this element.
            </summary>
        </member>
        <member name="F:NCDK.Config.Elements.symbolMap">
            <summary>
            Lookup elements by symbol / name.
            </summary>
        </member>
        <member name="M:NCDK.Config.Elements.#ctor(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Nullable{System.Double},System.Nullable{System.Double},System.Nullable{System.Double})">
            <summary>
            Internal constructor.
            </summary>
            <param name="name">name</param>
            <param name="number">atomic number</param>
            <param name="symbol">symbol</param>
            <param name="period">periodic table period</param>
            <param name="group">periodic table group</param>
            <param name="rCov">covalent radius</param>
            <param name="rW">van der Waals radius</param>
            <param name="electronegativity">Pauling electronegativity</param>
        </member>
        <member name="M:NCDK.Config.Elements.ToIElement">
            <summary>
            Access an  <see cref="T:NCDK.IElement"/> instance of the chemical element.
            </summary>
            <returns>an instance</returns>
        </member>
        <member name="M:NCDK.Config.Elements.OfNumber(System.Int32)">
            <summary>
            Obtain the element with the specified atomic number. If no element had
            the specified atomic number then <see cref="F:NCDK.Config.Elements.Unknown" /> is returned.
            </summary>
            <example>
            <!-- No matching elements were found for the following include tag --><include file="IncludeExamples.xml" path="Comments/Codes[@id=&quot;NCDK.Config.Elements.cs+OfNumber&quot;]/*" />
            </example>
            <param name="number">number atomic number</param>
            <returns>an element, or <see cref="F:NCDK.Config.Elements.Unknown" /></returns>
        </member>
        <member name="M:NCDK.Config.Elements.OfString(System.String)">
            <summary>
            Obtain the element with the specified symbol or name. If no element had
            the specified symbol or name then <see cref="F:NCDK.Config.Elements.Unknown" /> is returned. The
            input is case-insensitive.
            </summary>
            <example>
            <!-- No matching elements were found for the following include tag --><include file="IncludeExamples.xml" path="Comments/Codes[@id=&quot;NCDK.Config.Elements.cs+OfString&quot;]/*" />
            </example>
            <param name="str">input string</param>
            <returns>an element, or <see cref="F:NCDK.Config.Elements.Unknown" /></returns>
        </member>
        <member name="T:NCDK.Config.Isotope.IsotopeHandler">
            <summary>
            Reads an isotope list in CML2 format. 
            An example definition is:
            <![CDATA[
            <isotopeList id = "H">
              <isotope id="H1" isotopeNumber="1" elementTyp="H">
                <abundance dictRef="cdk:relativeAbundance">100.0</abundance>
                <scalar dictRef="cdk:exactMass">1.00782504</scalar>
                <scalar dictRef="cdk:atomicNumber">1</scalar>
              </isotope>
              <isotope id="H2" isotopeNumber="2" elementTyp="H">
                <abundance dictRef="cdk:relativeAbundance">0.015</abundance>
                <scalar dictRef="cdk:exactMass">2.01410179</scalar>
                <scalar dictRef="cdk:atomicNumber">1</scalar>
              </isotope>
            </isotopeList>   
            ]]>
            </summary>
        </member>
        <member name="M:NCDK.Config.Isotope.IsotopeHandler.#ctor(NCDK.IChemObjectBuilder)">
            <summary>
            Constructs an IsotopeHandler used by the IsotopeReader.
            </summary>
            <param name="builder">The <see cref="T:NCDK.IChemObjectBuilder"/> used to create new <see cref="T:NCDK.IIsotope"/>'s.</param>
        </member>
        <member name="P:NCDK.Config.Isotope.IsotopeHandler.Isotopes">
            <summary>
            The isotopes read from the XML file.
            </summary>
        </member>
        <member name="T:NCDK.Config.Isotope.IsotopeReader">
            <summary>
            Reader that instantiates an XML parser and customized handler to process
            the isotope information in the CML2 isotope data file. The Reader first
            tries to instantiate a JAXP XML parser available from Sun JVM 1.4.0 and
            later. If not found it tries the Aelfred2 parser, and as last try the
            Xerces parser.
            </summary>
        </member>
        <member name="M:NCDK.Config.Isotope.IsotopeReader.#ctor(System.IO.Stream,NCDK.IChemObjectBuilder)">
            <summary>
            Instantiates a new reader that parses the XML from the given <paramref name="input"/>.
            </summary>
            <param name="input"><see cref="T:System.IO.Stream"/> with the XML source</param>
            <param name="builder">The <see cref="T:NCDK.IChemObjectBuilder"/> used to create new <see cref="T:NCDK.IIsotope"/>'s.</param>
        </member>
        <member name="M:NCDK.Config.Isotope.IsotopeReader.ReadIsotopes">
            <summary>
            Triggers the XML parsing of the data file and returns the read Isotopes.
            It turns of XML validation before parsing.
            </summary>
            <returns>a List of Isotope's. Returns an empty list is some reading error occurred.</returns>
        </member>
        <member name="T:NCDK.Config.XMLIsotopeFactory">
            <summary>
            Used to store and return data of a particular isotope. As this class is a
            singleton class, one gets an instance with:
            <code>                IsotopeFactory ifac = XMLIsotopeFactory.GetInstance(new ChemObject().Builder);
</code>
            </summary>
            <remarks>
            Data about the isotopes are read from the NCDK.Config.Data.isotopes.xml resource.
            Part of the data in this file was collected from
            the website <see href="http://www.webelements.org">webelements.org</see>.
            </remarks>
            <example>
            The use of this class is exemplified as follows. To get information
            about the major isotope of hydrogen, one can use this code:
            <code>                IsotopeFactory factory = XMLIsotopeFactory.GetInstance(Default.ChemObjectBuilder.Instance);
                IIsotope major = factory.GetMajorIsotope("H");
</code>
            </example>
        </member>
        <member name="M:NCDK.Config.XMLIsotopeFactory.#ctor(NCDK.IChemObjectBuilder)">
            <summary>
            Private constructor for the IsotopeFactory object.
            </summary>
            <param name="builder">The builder from which we the factory will be generated</param>
            <exception cref="T:System.IO.IOException">A problem with reading the isotopes.xml file</exception>
        </member>
        <member name="M:NCDK.Config.XMLIsotopeFactory.GetInstance(NCDK.IChemObjectBuilder)">
            <summary>
            Returns an IsotopeFactory instance.
            </summary>
            <param name="builder">ChemObjectBuilder used to construct the Isotope's</param>
            <returns>The instance value</returns>
            <exception cref="T:System.IO.IOException">if isotopic data files could not be read.</exception>"
        </member>
        <member name="T:NCDK.Config.AtomType.AtomTypeReader">
            <summary>
            XML Reader for the CDKBasedAtomTypeConfigurator.
            </summary>
            <seealso cref="T:NCDK.Config.CDKBasedAtomTypeConfigurator"/>
        </member>
        <member name="M:NCDK.Config.AtomType.AtomTypeReader.#ctor(System.IO.Stream)">
            <summary>
            Instantiates the XML based AtomTypeReader.
            </summary>
            <param name="input">The Reader to read the IAtomType's from.</param>
        </member>
        <member name="M:NCDK.Config.AtomType.AtomTypeReader.#ctor(System.IO.TextReader)">
            <summary>
            Instantiates the XML based AtomTypeReader.
            </summary>
            <param name="input">The Reader to read the IAtomType's from.</param>
        </member>
        <member name="M:NCDK.Config.AtomType.AtomTypeReader.ReadAtomTypes(NCDK.IChemObjectBuilder)">
            <summary>
            Reads the atom types from the data file.
            </summary>
            <param name="builder">The <see cref="T:NCDK.IChemObjectBuilder"/> used to create new <see cref="T:NCDK.IAtomType"/>'s.</param>
            <returns><see cref="T:System.Collections.Generic.IEnumerable`1"/> with atom types. Is empty if some reading error occurred.</returns>
        </member>
        <member name="T:NCDK.Config.AtomType.OWLAtomTypeMappingHandler">
            <summary>
            SAX Handler for the <see cref="T:NCDK.Config.AtomType.OWLAtomTypeMappingReader"/>.
            </summary>
        </member>
        <member name="M:NCDK.Config.AtomType.OWLAtomTypeMappingHandler.#ctor">
            <summary>
            Constructs a new OWLAtomTypeMappingHandler.
            </summary>
        </member>
        <member name="M:NCDK.Config.AtomType.OWLAtomTypeMappingHandler.GetAtomTypeMappings">
            <summary>
            Returns a <see cref="T:System.Collections.Generic.IDictionary`2"/> with atom type mappings.
            </summary>
            <returns>a <see cref="T:System.Collections.Generic.IDictionary`2"/> with the atom type name of the source schema as key, and the atom type name of the target schema as values.</returns>
        </member>
        <member name="T:NCDK.Config.AtomType.OWLAtomTypeMappingReader">
            <summary>
            XML Reader for the <see cref="T:NCDK.Config.OWLBasedAtomTypeConfigurator"/>.
            </summary>
        </member>
        <member name="M:NCDK.Config.AtomType.OWLAtomTypeMappingReader.#ctor(System.IO.TextReader)">
            <summary>
            Instantiates the XML based AtomTypeReader.
            </summary>
            <param name="input">The Reader to read the IAtomType's from.</param>
        </member>
        <member name="M:NCDK.Config.AtomType.OWLAtomTypeMappingReader.ReadAtomTypeMappings">
            <summary>
            Reads the atom type mappings from the data file.
            </summary>
            <returns>a <see cref="T:System.Collections.Generic.IDictionary`2"/> with atom type mappings. <see langword="null"/>, if some reading error occurred.</returns>
        </member>
        <member name="T:NCDK.Config.ImmutableAtomType">
            <summary>
            An immutable <see cref="T:NCDK.IAtomType"/> implementation to support the <see cref="T:NCDK.Config.AtomTypeFactory"/>.
            </summary>
        </member>
        <member name="T:NCDK.Config.NaturalElement">
            <summary>
            A read-only class used by <see cref="T:NCDK.Config.Elements"/> for the natural elements. This class is not to be used than by only <see cref="T:NCDK.Config.Elements"/>.
            </summary>
        </member>
        <member name="T:NCDK.Config.IsotopeFactory">
            <summary>
            Used to store and return data of a particular isotope.
            </summary>
        </member>
        <member name="P:NCDK.Config.IsotopeFactory.Count">
            <summary>
            The number of isotopes defined by this class. The classes
            <see cref="T:NCDK.Config.Isotopes"/> extends this class and is to be used to get isotope
            information.
            </summary>
        </member>
        <member name="M:NCDK.Config.IsotopeFactory.Add(NCDK.IIsotope)">
            <summary>
            Protected methods only to be used by classes extending this class to add an <see cref="T:NCDK.IIsotope"/>.
            </summary>
            <param name="isotope"></param>
        </member>
        <member name="M:NCDK.Config.IsotopeFactory.GetIsotopes(System.String)">
            <summary>
            Gets all isotopes known to the IsotopeFactory for the given element symbol.
            </summary>
            <param name="symbol">An element symbol to search for</param>
            <returns><see cref="T:NCDK.IIsotope"/>s that matches the given element symbol</returns>
        </member>
        <member name="M:NCDK.Config.IsotopeFactory.GetIsotopes">
            <summary>
            Gets all isotopes known to the <see cref="T:NCDK.Config.IsotopeFactory"/>.
            </summary>
            <returns>All isotopes</returns>
        </member>
        <member name="M:NCDK.Config.IsotopeFactory.GetIsotopes(System.Double,System.Double)">
            <summary>
            Gets an array of all isotopes matching the searched exact mass within a certain difference.
            </summary>
            <param name="exactMass">search mass</param>
            <param name="difference">mass the isotope is allowed to differ from the search mass</param>
            <returns>All isotopes</returns>
        </member>
        <member name="M:NCDK.Config.IsotopeFactory.GetIsotope(System.String,System.Int32)">
            <summary>
            Get isotope based on element symbol and mass number.
            </summary>
            <param name="symbol">the element symbol</param>
            <param name="massNumber">the mass number</param>
            <returns>the corresponding isotope</returns>
        </member>
        <member name="M:NCDK.Config.IsotopeFactory.GetIsotope(System.String,System.Double,System.Double)">
            <summary>
            Get an isotope based on the element symbol and exact mass.
            </summary>
            <param name="symbol">the element symbol</param>
            <param name="exactMass">the mass number</param>
            <param name="tolerance">allowed difference from provided exact mass</param>
            <returns>the corresponding isotope</returns>
        </member>
        <member name="M:NCDK.Config.IsotopeFactory.GetMajorIsotope(System.Int32)">
            <summary>
            Returns the most abundant (major) isotope with a given atomic number.
            </summary>
            <remarks>
            The isotope's abundance is for atoms with atomic number 60 and smaller
            defined as a number that is proportional to the 100 of the most abundant
            isotope. For atoms with higher atomic numbers, the abundance is defined
            as a percentage.
            </remarks>
            <param name="atomicNumber">The atomicNumber for which an isotope is to be returned</param>
            <returns>The isotope corresponding to the given atomic number</returns>
            <seealso cref="M:NCDK.Config.IsotopeFactory.GetMajorIsotope(System.String)"/>
        </member>
        <member name="M:NCDK.Config.IsotopeFactory.IsElement(System.String)">
            <summary>
            Checks whether the given element exists.
            </summary>
            <param name="elementName">The element name to test</param>
            <returns><see langword="true"/> is the element exists, <see langword="false"/> otherwise</returns>
        </member>
        <member name="M:NCDK.Config.IsotopeFactory.GetMajorIsotope(System.String)">
            <summary>
            Returns the most abundant (major) isotope whose symbol equals element.
            </summary>
            <param name="symbol">the symbol of the element in question</param>
            <returns>The Major Isotope value</returns>
        </member>
        <member name="M:NCDK.Config.IsotopeFactory.GetElement(System.String)">
            <summary>
            Returns an <see cref="T:NCDK.IElement"/> with a given element symbol.
            </summary>
            <param name="symbol">The element symbol for the requested element</param>
            <returns>The configured element</returns>
        </member>
        <member name="M:NCDK.Config.IsotopeFactory.GetElement(System.Int32)">
            <summary>
            Returns an element according to a given atomic number.
            </summary>
            <param name="atomicNumber">The elements atomic number</param>
            <returns>The <see cref="T:NCDK.IElement"/> of the given atomic number</returns>
        </member>
        <member name="M:NCDK.Config.IsotopeFactory.GetElementSymbol(System.Int32)">
            <summary>
            Returns the symbol matching the element with the given atomic number.
            </summary>
            <param name="atomicNumber">The elements atomic number</param>
            <returns>The symbol of the given atomic number</returns>
        </member>
        <member name="M:NCDK.Config.IsotopeFactory.Configure(NCDK.IAtom)">
            <summary>
            Configures an atom. Finds the correct element type
            by looking at the atoms element symbol.
            </summary>
            <param name="atom">The atom to be configured</param>
            <returns>The configured atom</returns>
            <exception cref="T:System.ArgumentException">If the element symbol is not recognised</exception>
        </member>
        <member name="M:NCDK.Config.IsotopeFactory.Configure(NCDK.IAtom,NCDK.IIsotope)">
            <summary>
            Configures an atom to have all the data of the given isotope.
            </summary>
            <param name="atom">The atom to be configure</param>
            <param name="isotope">The isotope to read the data from</param>
            <returns>The configured atom</returns>
        </member>
        <member name="M:NCDK.Config.IsotopeFactory.ConfigureAtoms(NCDK.IAtomContainer)">
            <summary>
            Configures atoms in an <see cref="T:NCDK.IAtomContainer"/> to carry all the correct data according to their element type.
            </summary>
            <param name="container">The <see cref="T:NCDK.IAtomContainer"/> to be configured</param>
        </member>
        <member name="M:NCDK.Config.IsotopeFactory.GetNaturalMass(NCDK.IElement)">
            <summary>
            Gets the natural mass of this element, defined as average of masses of isotopes, weighted by abundance.
            </summary>
            <param name="element">the element in question</param>
            <returns>The natural mass value</returns>
        </member>
        <member name="T:NCDK.Config.Isotopes">
            <summary>
            List of isotopes. Data is taken from the <see href="https://github.com/egonw/bodr">Blue Obelisk Data Repository</see>,
            <see href="https://github.com/egonw/bodr/releases/tag/BODR-10">version 10</see> <token>cdk-cite-BODR10</token>.
            The data set is described in the first Blue Obelisk paper <token>cdk-cite-Guha2006</token>.
            </summary>
            <remarks>
            <para>The <pre>isotopes.dat</pre> file that is used by this class is a binary class
            of this data, improving loading times over the BODR XML representation. It is created
            from the original BODR files using tools from the <pre>cdk-build-util</pre>
            repository.</para>
            </remarks>
        </member>
        <member name="P:NCDK.Config.Isotopes.Instance">
            <summary>
            A singleton instance of this class.
            </summary>
            <exception cref="T:System.IO.IOException">when reading of the data file did not work</exception>
        </member>
        <member name="M:NCDK.Config.Isotopes.GetIsotopes(System.String)">
            <summary>
            Gets an array of all isotopes known to the IsotopeFactory for the given element symbol.
            </summary>
            <param name="symbol">An element symbol to search for</param>
            <returns>Isotopes that matches the given element symbol</returns>
        </member>
        <member name="M:NCDK.Config.Isotopes.GetIsotopes">
            <summary>
            Gets a array of all isotopes known to the IsotopeFactory.
            </summary>
            <returns>An array of all isotopes</returns>
        </member>
        <member name="M:NCDK.Config.Isotopes.GetIsotopes(System.Double,System.Double)">
            <summary>
            Gets an array of all isotopes matching the searched exact mass within a certain difference.
            </summary>
            <param name="exactMass">search mass</param>
            <param name="difference">mass the isotope is allowed to differ from the search mass</param>
            <returns>All isotopes</returns>
        </member>
        <member name="M:NCDK.Config.Isotopes.GetIsotope(System.String,System.Int32)">
            <summary>
            Get isotope based on element symbol and mass number.
            </summary>
            <param name="symbol">the element symbol</param>
            <param name="massNumber">the mass number</param>
            <returns>the corresponding isotope</returns>
        </member>
        <member name="M:NCDK.Config.Isotopes.GetIsotope(System.String,System.Double,System.Double)">
            <summary>
            Get an isotope based on the element symbol and exact mass.
            </summary>
            <param name="symbol">the element symbol</param>
            <param name="exactMass">the mass number</param>
            <param name="tolerance">allowed difference from provided exact mass</param>
            <returns>the corresponding isotope</returns>
        </member>
        <member name="M:NCDK.Config.Isotopes.GetMajorIsotope(System.Int32)">
            <summary>
            Returns the most abundant (major) isotope with a given atomic number.
            </summary>
            <remarks>
            The isotope's abundance is for atoms with atomic number 60 and smaller
            defined as a number that is proportional to the 100 of the most abundant
            isotope. For atoms with higher atomic numbers, the abundance is defined
            as a percentage.
            </remarks>
            <param name="atomicNumber">The atomic number for which an isotope is to be returned</param>
            <returns>The isotope corresponding to the given atomic number</returns>
        </member>
        <member name="M:NCDK.Config.Isotopes.GetMajorIsotope(System.String)">
            <summary>
            Returns the most abundant (major) isotope whose symbol equals element.
            </summary>
            <param name="symbol">the symbol of the element in question</param>
            <returns>The major isotope value</returns>
        </member>
        <member name="T:NCDK.Config.BODRIsotope">
            <summary>
            A read-only class used by <see cref="T:NCDK.Config.Isotopes"/> for the natural elements. This class is not to be used than by only <see cref="T:NCDK.Config.Isotopes"/>.
            </summary>
        </member>
        <member name="T:NCDK.Config.Fragments.EStateFragments">
            <summary>
            A class representing the 79 E-state atom types in terms of SMARTS.
            </summary>
            <remarks>
            These fragments were originally described in <token>cdk-cite-HALL1995</token> and were
            converted into SMARTS forms by the <see href="http://www.rdkit.org">RDKit</see> project
            </remarks>
        </member>
        <member name="F:NCDK.Config.Fragments.EStateFragments.NAMES">
            <summary>
            The names of the fragments.
            </summary>
            <remarks>
            See <see href="http://www.edusoft-lc.com/molconn/manuals/350/appV.html">here</see> for the corresponding chemical groups
            </remarks>
        </member>
        <member name="F:NCDK.Config.Fragments.EStateFragments.SMARTS">
            <summary>
            The SMARTS patterns.
            </summary>
        </member>
        <member name="P:NCDK.Config.Fragments.EStateFragments.Names">
            <summary>
            The fragment names.
            </summary>
        </member>
        <member name="P:NCDK.Config.Fragments.EStateFragments.Smarts">
            <summary>
            The SMARTS patterns.
            </summary>
        </member>
        <member name="T:NCDK.IO.Iterator.DefaultEnumerableChemObjectReader`1">
            <summary>
            Abstract class that EnumerableChemObjectReader's can implement to have it
            take care of basic stuff, like managing the ReaderListeners.
            </summary>
        </member>
        <member name="M:NCDK.IO.Iterator.DefaultEnumerableChemObjectReader`1.Remove">
            <summary>
            File IO generally does not support removing of entries.
            </summary>
        </member>
        <member name="P:NCDK.IO.Iterator.DefaultEnumerableChemObjectReader`1.ErrorHandler">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.IO.Iterator.DefaultEnumerableChemObjectReader`1.HandleError(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.IO.Iterator.DefaultEnumerableChemObjectReader`1.HandleError(System.String,System.Exception)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.IO.Iterator.DefaultEnumerableChemObjectReader`1.HandleError(System.String,System.Int32,System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.IO.Iterator.DefaultEnumerableChemObjectReader`1.HandleError(System.String,System.Int32,System.Int32,System.Int32,System.Exception)">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.IO.Iterator.IEnumerableMDLConformerReader">
            <summary>
            Iterate over conformers of a collection of molecules stored in SDF format.
            </summary>
            <remarks>
            <para>
            This class is analogous to the <see cref="T:NCDK.IO.Iterator.EnumerableSDFReader" /> except that
            rather than return a single <see cref="T:NCDK.IAtomContainer" /> at each iteration this
            class will return all the conformers for a given molecule at each iteration.
            </para>
            <para>
            The class assumes that the molecules are stored in SDF format and that all conformers for a given
            molecule are in sequential order.
            </para>
            <para>
            Currently, the code uses the title of each molecule in the SD file to perform te conformer check
            and so it is important that all conformers for a given molecule have the same title field, but
            different from the title fields of conformers of other molecules. In
            the future the class will allow the user to perform the check using either the title or a more
            rigorous (but more time-consuming) graph isomorphism check.
            </para>
            </remarks>
            <example>
            <code>                string filename = "/Users/rguha/conf2.sdf";
                using (var srm = new FileStream(filename, FileMode.Open))
                {
                    IEnumerableMDLConformerReader reader = new IEnumerableMDLConformerReader(srm, Default.ChemObjectBuilder.Instance);
                    foreach (var cc in reader)
                    {
                        // do something 
                    }
                }
                // do something with this set of conformers
</code>
            </example>
        </member>
        <member name="T:NCDK.IO.Iterator.EnumerablePCCompoundXMLReader">
            <summary>
            Iterating PubChem PCCompound ASN.1 XML reader.
            </summary>
            <seealso cref="T:NCDK.IO.PCCompoundASNReader"/>
        </member>
        <member name="M:NCDK.IO.Iterator.EnumerablePCCompoundXMLReader.#ctor(System.IO.TextReader,NCDK.IChemObjectBuilder)">
            <summary>
            Constructs a new EnumerablePCCompoundXMLReader that can read Molecule from a given Reader and IChemObjectBuilder.
            </summary>
            <param name="input">The input stream</param>
            <param name="builder">The builder</param>
            <exception cref="T:System.Exception">if there is an error in setting up the XML parser</exception>
        </member>
        <member name="M:NCDK.IO.Iterator.EnumerablePCCompoundXMLReader.#ctor(System.IO.Stream,NCDK.IChemObjectBuilder)">
            <summary>
            Constructs a new EnumerablePCCompoundXLReader that can read Molecule from a given Stream and IChemObjectBuilder.
            </summary>
            <param name="ins">The input stream</param>
            <param name="builder">The builder. In general, use <see cref="T:NCDK.Default.ChemObjectBuilder"/></param>
            <exception cref="T:System.Exception">if there is a problem creating an InputStreamReader</exception>
        </member>
        <member name="T:NCDK.IO.Iterator.EnumerablePCSubstancesXMLReader">
            <summary>
            Iterating PubChem PC-Substances ASN.1 XML reader.
            </summary>
        </member>
        <member name="M:NCDK.IO.Iterator.EnumerablePCSubstancesXMLReader.#ctor(System.IO.TextReader,NCDK.IChemObjectBuilder)">
            <summary>
            Constructs a new EnumerablePCSubstancesXMLReader that can read 
            </summary>
            <param name="input">The input stream</param>
            <param name="builder">The builder</param>
            <exception cref="T:System.IO.IOException">if there is error in getting the <see cref="T:NCDK.Config.IsotopeFactory"/></exception>
            <event cref="T:System.Exception">if there is an error in setting up the XML parser</event>
        </member>
        <member name="M:NCDK.IO.Iterator.EnumerablePCSubstancesXMLReader.#ctor(System.IO.Stream,NCDK.IChemObjectBuilder)">
            <summary>
            Constructs a new EnumerablePCSubstancesXMLReader that can read Molecule from a given Stream and IChemObjectBuilder.
            </summary>
            <param name="ins">The input stream</param>
            <param name="builder">The builder. In general, use <see cref="T:NCDK.IChemObjectBuilder"/></param>
            <exception cref="T:System.Exception">if there is a problem creating an <see cref="T:System.IO.StreamReader"/></exception>
        </member>
        <member name="T:NCDK.IO.Iterator.EnumerableSDFReader">
            <summary>
            Iterating MDL SDF reader. It allows to iterate over all molecules
            in the SD file, without reading them into memory first. Suitable
            for (very) large SDF files. For parsing the molecules in the
            SD file, it uses the <see cref="T:NCDK.IO.MDLV2000Reader" /> or
            <see cref="T:NCDK.IO.MDLV3000Reader" /> reader; it does <b>not</b> work
            for SDF files with MDL formats prior to the V2000 format.
            </summary>
            <example>
            <code>                using (var srm = new FileStream("../zinc-structures/ZINC_subset3_3D_charged_wH_maxmin1000.sdf", FileMode.Open))
                {
                    EnumerableSDFReader reader = new EnumerableSDFReader(srm, Default.ChemObjectBuilder.Instance);
                    foreach (var molecule in reader)
                    {
                        // do something
                    }
                }
</code>
            </example>
            <seealso cref="T:NCDK.IO.MDLV2000Reader" />
            <seealso cref="T:NCDK.IO.MDLV3000Reader" />
        </member>
        <member name="F:NCDK.IO.Iterator.EnumerableSDFReader.readerTypeMap">
            <summary>
            map of MDL formats to their type
            </summary>
        </member>
        <member name="M:NCDK.IO.Iterator.EnumerableSDFReader.#ctor(System.IO.TextReader,NCDK.IChemObjectBuilder)">
            <summary>
            Constructs a new EnumerableMDLReader that can read Molecule from a given Reader.
            </summary>
            <param name="input">The Reader to read from</param>
            <param name="builder">The builder</param>
        </member>
        <member name="M:NCDK.IO.Iterator.EnumerableSDFReader.#ctor(System.IO.Stream,NCDK.IChemObjectBuilder)">
            <summary>
            Constructs a new <see cref="T:NCDK.IO.Iterator.EnumerableSDFReader"/> that can read Molecule from a given Stream.
            </summary>
            <param name="input">The Stream to read from</param>
            <param name="builder">The builder</param>
        </member>
        <member name="M:NCDK.IO.Iterator.EnumerableSDFReader.#ctor(System.IO.Stream,NCDK.IChemObjectBuilder,System.Boolean)">
            <summary>
            Constructs a new EnumerableMDLReader that can read Molecule from a given a
            Stream. This constructor allows specification of whether the reader will
            skip 'null' molecules. If skip is set to false and a broken/corrupted molecule
            is read the iterating reader will stop at the broken molecule. However if
            skip is set to true then the reader will keep trying to read more molecules
            until the end of the file is reached.
            </summary>
            <param name="input">the <see cref="T:System.IO.Stream"/> to read from</param>
            <param name="builder">builder to use</param>
            <param name="skip">whether to skip null molecules</param>
        </member>
        <member name="M:NCDK.IO.Iterator.EnumerableSDFReader.#ctor(System.IO.TextReader,NCDK.IChemObjectBuilder,System.Boolean)">
            <summary>
            Constructs a new EnumerableMDLReader that can read Molecule from a given a
            Reader. This constructor allows specification of whether the reader will
            skip 'null' molecules. If skip is set to false and a broken/corrupted molecule
            is read the iterating reader will stop at the broken molecule. However if
            skip is set to true then the reader will keep trying to read more molecules
            until the end of the file is reached.
            </summary>
            <param name="input">the <see cref="T:System.IO.TextReader"/> to read from</param>
            <param name="builder">builder to use</param>
            <param name="skip">whether to skip null molecules</param>
        </member>
        <member name="M:NCDK.IO.Iterator.EnumerableSDFReader.GetReader(NCDK.IO.Formats.IChemFormat,System.IO.TextReader)">
            <summary>
            Method will return an appropriate reader for the provided format. Each reader is stored
            in a map, if no reader is available for the specified format a new reader is created. The
            <see cref="P:NCDK.IO.IChemObjectReader.ErrorHandler"/> and
            <see cref="P:NCDK.IO.IChemObjectReader.ReaderMode"/> are set.
            </summary>
            <param name="format">The format to obtain a reader for</param>
            <returns>instance of a reader appropriate for the provided format</returns>
        </member>
        <member name="P:NCDK.IO.Iterator.EnumerableSDFReader.Skip">
            <summary>
            Indicate whether the reader should skip over SDF records
            that cause problems. If true the reader will fetch the next
            molecule
            </summary>
        </member>
        <member name="T:NCDK.IO.Iterator.EnumerableSMILESReader">
            <summary>
            Iterating SMILES file reader. It allows to iterate over all molecules
            in the SMILES file, without being read into memory all. Suitable
            for very large SMILES files. These SMILES files are expected to have one
            molecule on each line. If a line could not be parsed and empty molecule is
            returned and the property <see cref="F:NCDK.IO.Iterator.EnumerableSMILESReader.BadSmilesInput"/> is set to the attempted
            input. The error is also logged.
            
            <para>For parsing each SMILES it still uses the normal <see cref="T:NCDK.IO.SMILESReader"/>.</para>
            </summary>
            <seealso cref="T:NCDK.IO.SMILESReader"/>
        </member>
        <member name="F:NCDK.IO.Iterator.EnumerableSMILESReader.BadSmilesInput">
            <summary>Store the problem input as a property.</summary>
        </member>
        <member name="M:NCDK.IO.Iterator.EnumerableSMILESReader.#ctor(System.IO.TextReader,NCDK.IChemObjectBuilder)">
            <summary>
            Constructs a new EnumerableSMILESReader that can read Molecule from a given Reader.
            </summary>
            <param name="input">The Reader to read from</param>
            <param name="builder">The builder to use</param>
            <seealso cref="T:NCDK.Default.ChemObjectBuilder"/>
            <seealso cref="T:NCDK.Silent.ChemObjectBuilder"/>
        </member>
        <member name="M:NCDK.IO.Iterator.EnumerableSMILESReader.#ctor(System.IO.Stream,NCDK.IChemObjectBuilder)">
            <summary>
            Constructs a new <see cref="T:NCDK.IO.Iterator.EnumerableSMILESReader"/> that can read Molecule from a given <see cref="T:System.IO.Stream"/>  and <see cref="T:NCDK.IChemObjectBuilder"/> .
            </summary>
            <param name="input">The input stream</param>
            <param name="builder">The builder</param>
        </member>
        <member name="P:NCDK.IO.Iterator.EnumerableSMILESReader.Format">
            <summary>
            Get the format for this reader.
            </summary>
            <returns>An instance of <see cref="T:NCDK.IO.Formats.SMILESFormat"/></returns>
        </member>
        <member name="M:NCDK.IO.Iterator.EnumerableSMILESReader.GetEnumerator">
            <summary>
            Checks whether there is another molecule to read.
            </summary>
            <returns>true if there are molecules to read, false otherwise</returns>
        </member>
        <member name="M:NCDK.IO.Iterator.EnumerableSMILESReader.Suffix(System.String)">
            <summary>
            Obtain the suffix after a line containing SMILES. The suffix follows
            any ' ' or '\t' termination characters.
            </summary>
            <param name="line">input line</param>
            <returns>the suffix - or an empty line</returns>
        </member>
        <member name="M:NCDK.IO.Iterator.EnumerableSMILESReader.ReadSmiles(System.String)">
            <summary>
            Read the SMILES given in the input line - or return an empty container.
            </summary>
            <param name="line">input line</param>
            <returns>the read container (or an empty one)</returns>
        </member>
        <member name="T:NCDK.IO.Iterator.IEnumerableChemObjectReader`1">
            <summary>
            Interface for an iterating molecule reader. It allows to iterate over all molecules
            in specific file format (e.g. SDF), without reading them into memory first. Suitable
            for very large files, with thousands of molecules.
            </summary>
            <seealso cref="T:NCDK.IO.IChemObjectIO"/>
        </member>
        <member name="T:NCDK.IO.Iterator.EnumerablePCCompoundASNReader">
            <summary>
            Iterating PubChem PCCompound ASN reader.
            </summary>
        </member>
        <member name="M:NCDK.IO.Iterator.EnumerablePCCompoundASNReader.#ctor(System.IO.TextReader,NCDK.IChemObjectBuilder)">
            <summary>
            Constructs a new EnumerablePCCompoundASNReader that can read Molecule from a given Reader.
            </summary>
            <param name="input"> The Reader to read from</param>
            <param name="builder"></param>
        </member>
        <member name="M:NCDK.IO.Iterator.EnumerablePCCompoundASNReader.#ctor(System.IO.Stream,NCDK.IChemObjectBuilder)">
            <summary>
            Constructs a new <see cref="T:NCDK.IO.Iterator.EnumerablePCCompoundASNReader"/> that can read molecule from a given <see cref="T:System.IO.Stream"/> and <see cref="T:NCDK.IChemObjectBuilder"/>.
            </summary>
            <param name="ins">The input stream</param>
            <param name="builder">The builder</param>
        </member>
        <member name="T:NCDK.IO.NCDKSourceCodeWriter">
            <summary>
            Converts a Molecule into NCDK source code that would build the same
            molecule. 
            </summary>
            <example>
            <code>                using (var stringWriter = new StringWriter())
                {
                    using (var writer = new NCDKSourceCodeWriter(stringWriter))
                    {
                        writer.Write(molecule);
                    }
                    Console.Out.Write(stringWriter.ToString());
                }
</code>
            </example>
        </member>
        <member name="T:NCDK.IO.ChemObjectIO">
            <summary>
            Provides some basic functionality for readers and writers. This includes
            managing the <see cref="T:NCDK.IO.Listener.IChemObjectIOListener"/>'s and managing of <see cref="T:NCDK.IO.Setting.IOSetting"/>'s.
            The IOSettings are managed via the <see cref="T:NCDK.IO.Setting.SettingManager`1"/> class with most
            method's wrapped to more descriptive method names (e.g. 
            <see cref="T:NCDK.IO.Setting.SettingManager`1"/>[<see cref="T:System.String"/>]  is invoked by <see cref="P:NCDK.IO.ChemObjectIO.IOSettings"/>[<see cref="T:System.String"/>]).
            </summary>
        </member>
        <member name="F:NCDK.IO.ChemObjectIO.listeners">
            <summary>
            Holder of reader event listeners.
            </summary>
        </member>
        <member name="M:NCDK.IO.ChemObjectIO.FireIOSettingQuestion(NCDK.IO.Setting.IOSetting)">
            <summary>
            Fires <see cref="M:NCDK.IO.Listener.IChemObjectIOListener.ProcessIOSettingQuestion(NCDK.IO.Setting.IOSetting)"/> for all managed listeners.
            </summary>
            <param name="setting">the setting to process</param>
        </member>
        <member name="T:NCDK.IO.CIFReader">
             <summary>
             This is not a reader for the CIF and mmCIF crystallographic formats.
             It is able, however, to extract some content from such files.
             It's very ad hoc, not written
             using any dictionary. So please complain if something is not working.
             In addition, the things it does read are considered experimental.
            
             <para>The CIF example on the IUCR website has been tested, as well as Crambin (1CRN)
             in the PDB database.</para>
             </summary>
        </member>
        <member name="M:NCDK.IO.CIFReader.#ctor(System.IO.TextReader)">
            <summary>
            Create an CIF like file reader.
            </summary>
            <param name="input">source of CIF data</param>
        </member>
        <member name="M:NCDK.IO.CIFReader.Read``1(``0)">
            <summary>
            Read a ChemFile from input.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="obj"></param>
            <returns>the content in a ChemFile object</returns>
        </member>
        <member name="M:NCDK.IO.CIFReader.ReadChemFile(NCDK.IChemFile)">
            <summary>
            Read the ShelX from input. Each ShelX document is expected to contain one crystal structure.
            </summary>
            <param name="file"></param>
            <returns>a ChemFile with the coordinates, charges, vectors, etc.</returns>
        </member>
        <member name="M:NCDK.IO.CIFReader.ParseIntoDouble(System.String)">
            <summary>
            Process double in the format: '.071(1)'.
            </summary>
        </member>
        <member name="T:NCDK.IO.CMLReader">
            <summary>
            Reads a molecule in CML 1.X and 2.0 format.
            CML is an XML based application <token>cdk-cite-PMR99</token>, and this Reader applies the method described in <token>cdk-cite-WIL01</token>.
            </summary>
        </member>
        <member name="M:NCDK.IO.CMLReader.#ctor(System.IO.Stream)">
            <summary>
             Reads CML from stream.
            </summary>
            <param name="input">Stream to read.</param>
        </member>
        <member name="M:NCDK.IO.CMLReader.#ctor(System.String)">
            <summary>
            Define this <see cref="T:NCDK.IO.CMLReader"/> to take the input.
            </summary>
            <param name="url">Points to the file to be read</param>
        </member>
        <member name="M:NCDK.IO.CMLReader.Read``1(``0)">
            <summary>
            Read a IChemObject from input.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="obj"></param>
            <returns>The content in a ChemFile object</returns>
        </member>
        <member name="T:NCDK.IO.CMLWriter">
            <summary>
            Serializes a <see cref="T:NCDK.IAtomContainerSet" /> or a <see cref="T:NCDK.IAtomContainer" /> object to CML 2 code.
            Chemical Markup Language is an XML-based file format <token>cdk-cite-PMR99</token>.
            Output can be redirected to other Writer objects like <see cref="T:System.IO.StringWriter" />
            and <see cref="T:System.IO.StreamWriter" />. 
            </summary>
            <example>
            <code>                using (var output = new FileStream("molecule.cml", FileMode.Create))
                using (CMLWriter cmlwriter = new CMLWriter(output))
                {
                    cmlwriter.Write(molecule);
                }
</code>
            For atoms it outputs: coordinates, element type and formal charge.
            For bonds it outputs: order, atoms (2, or more) and wedges.
            </example>
        </member>
        <member name="M:NCDK.IO.CMLWriter.#ctor(System.IO.TextWriter)">
            <summary>
            Constructs a new CMLWriter class. Output will be stored in the Writer
            class given as parameter. The CML code will be valid CML code with a
            XML header. Only one object can be stored.
            </summary>
            <param name="writer">Writer to redirect the output to.</param>
        </member>
        <member name="M:NCDK.IO.CMLWriter.Write(NCDK.IChemObject)">
            <summary>
            Serializes the IChemObject to CML and redirects it to the output Writer.
            </summary>
            <param name="obj">A Molecule of AtomContaineSet object</param>
        </member>
        <member name="T:NCDK.IO.CML.CDKConvention">
            <summary>
            This is an implementation for the CDK convention.
            </summary>
        </member>
        <member name="T:NCDK.IO.CML.CMLCoreModule">
             <summary>
             Core CML 1.x and 2.x elements are parsed by this class (see <token>cdk-cite-WIL01</token>).
            
             <para>Please file a bug report if this parser fails to parse
             a certain element or attribute value in a valid CML document.</para>
             </summary>
        </member>
        <member name="M:NCDK.IO.CML.CMLCoreModule.NewMolecule">
            <summary>
            Clean all data about parsed data.
            </summary>
        </member>
        <member name="M:NCDK.IO.CML.CMLCoreModule.NewMoleculeData">
            <summary>
            Clean all data about the molecule itself.
            </summary>
        </member>
        <member name="M:NCDK.IO.CML.CMLCoreModule.NewFormulaData">
            <summary>
            Clean all data about read formulas.
            </summary>
        </member>
        <member name="M:NCDK.IO.CML.CMLCoreModule.NewAtomData">
            <summary>
            Clean all data about read atoms.
            </summary>
        </member>
        <member name="M:NCDK.IO.CML.CMLCoreModule.NewBondData">
            <summary>
            Clean all data about read bonds.
            </summary>
        </member>
        <member name="M:NCDK.IO.CML.CMLCoreModule.NewCrystalData">
            <summary>
            Clean all data about read bonds.
            </summary>
        </member>
        <member name="T:NCDK.IO.CML.CMLHandler">
            <summary>
            SAX2 implementation for CML XML fragment reading. CML Core is supported as well is the CRML module.
            <para>Data is stored into the Chemical Document Object which is passed when
            instantiating this class. This makes it possible that programs that do not
            use CDK for internal data storage, use this CML library.
            </para>
            </summary>
        </member>
        <member name="M:NCDK.IO.CML.CMLHandler.#ctor(NCDK.IChemFile)">
            <summary>
            Constructor for the CMLHandler.
            </summary>
            <param name="chemFile">The document in which data is stored</param>
        </member>
        <member name="M:NCDK.IO.CML.CMLHandler.CharacterData(System.Xml.Linq.XElement)">
            <summary>
            Implementation of the characters() procedure overwriting the DefaultHandler interface.
            </summary>
            <param name="element">element to handle</param>
        </member>
        <member name="M:NCDK.IO.CML.CMLHandler.EndDocument">
            <summary>
            Calling this procedure signals the end of the XML document.
            </summary>
        </member>
        <member name="T:NCDK.IO.CML.CMLModuleStack">
            <summary>
            Low weight alternative to Sun's Stack class.
            </summary>
        </member>
        <member name="M:NCDK.IO.CML.CMLModuleStack.Push(NCDK.IO.CML.ICMLModule)">
            <summary>
            Adds an entry to the stack.
            </summary>
        </member>
        <member name="M:NCDK.IO.CML.CMLModuleStack.Pop">
            <summary>
            Retrieves and deletes to last added entry.
            </summary>
            <seealso cref="P:NCDK.IO.CML.CMLModuleStack.Current"/>
        </member>
        <member name="P:NCDK.IO.CML.CMLModuleStack.Current">
            <summary>
            Returns the last added entry.
            </summary>
            <seealso cref="M:NCDK.IO.CML.CMLModuleStack.Pop"/>
        </member>
        <member name="M:NCDK.IO.CML.CMLModuleStack.ToString">
            <summary>
            Returns a string representation of the stack.
            </summary>
        </member>
        <member name="M:NCDK.IO.CML.CMLModuleStack.EndsWith(NCDK.IO.CML.ICMLModule)">
            <summary>
            Convenience method to check the last added elements.
            </summary>
        </member>
        <member name="M:NCDK.IO.CML.CMLModuleStack.EndsWith(NCDK.IO.CML.ICMLModule,NCDK.IO.CML.ICMLModule)">
            <summary>
            Convenience method to check the last two added elements.
            </summary>
        </member>
        <member name="M:NCDK.IO.CML.CMLModuleStack.EndsWith(NCDK.IO.CML.ICMLModule,NCDK.IO.CML.ICMLModule,NCDK.IO.CML.ICMLModule)">
            <summary>
            Convenience method to check the last three added elements.
            </summary>
        </member>
        <member name="M:NCDK.IO.CML.CMLReactionModule.GetMoleculeFromID(System.Collections.Generic.IEnumerable{NCDK.IAtomContainer},System.String)">
            <summary>
            Get the IAtomContainer contained in a IAtomContainerSet object with a ID.
            </summary>
            <param name="molSet">Molecules</param>
            <param name="id">The ID the look</param>
            <returns>The IAtomContainer with the ID</returns>
        </member>
        <member name="T:NCDK.IO.CML.CMLResolver">
            <summary>
            This class resolves DOCTYPE declaration for Chemical Markup Language (CML)
            files and uses a local version for validation. More information about
            CML can be found at <see href="http://www.xml-cml.org/">http://www.xml-cml.org/</see>.
            </summary>
        </member>
        <member name="M:NCDK.IO.CML.CMLResolver.GetCMLType(System.String)">
            <summary>
            Returns an InputSource of the appropriate CML DTD. It accepts
            two CML DTD names: cml1_0.dtd and cml1_0_1.dtd. Returns null
            for any other name.
            </summary>
            <param name="type">the name of the CML DTD version</param>
            <returns>the InputSource to the CML DTD</returns>
        </member>
        <member name="T:NCDK.IO.CML.CMLStack">
            <summary>
            Low weight alternative to Sun's Stack class.
            </summary>
        </member>
        <member name="M:NCDK.IO.CML.CMLStack.ToString">
            <returns>A string representation of the stack.</returns>
        </member>
        <member name="M:NCDK.IO.CML.CMLStack.EndsWith(System.String)">
            <summary>
            Convenience method to check the last added elements.
            </summary>
            <param name="lastElement"></param>
            <returns></returns>
        </member>
        <member name="M:NCDK.IO.CML.CMLStack.EndsWith(System.String,System.String)">
            <summary>
            Convenience method to check the last two added elements.
            </summary>
            <param name="oneButLast"></param>
            <param name="lastElement"></param>
            <returns></returns>
        </member>
        <member name="M:NCDK.IO.CML.CMLStack.EndsWith(System.String,System.String,System.String)">
            <summary>
            Convenience method to check the last three added elements.
            </summary>
        </member>
        <member name="T:NCDK.IO.CML.ICMLModule">
            <summary>
            This interface describes the procedures classes must implement to be plugable into the <see cref="T:NCDK.IO.CML.CMLHandler"/>.
            </summary>
        </member>
        <member name="T:NCDK.IO.CML.MDLMolConvention">
            <summary>
            Implementation of the MDLMol Covention for CML.
            </summary>
        </member>
        <member name="T:NCDK.IO.CML.OtherNamespace">
            <summary>
            Modules that ignore all content, for use in XML in namespaces other than CML.
            </summary>
        </member>
        <member name="M:NCDK.IO.CML.OtherNamespace.StartDocument">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.IO.CML.OtherNamespace.EndDocument">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.IO.CML.OtherNamespace.StartElement(NCDK.IO.CML.CMLStack,System.Xml.Linq.XElement)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.IO.CML.OtherNamespace.EndElement(NCDK.IO.CML.CMLStack,System.Xml.Linq.XElement)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.IO.CML.OtherNamespace.ReturnChemFile">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.IO.CML.OtherNamespace.Inherit(NCDK.IO.CML.ICMLModule)">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.IO.CML.PDBConvention">
            <summary>
            Implements the PDB convention used by PDB2CML.
            </summary>
            <remarks>
            <para>This is a lousy implementation, though. Problems that will arise:
            <list type="bullet">
              <item>when this new convention is adopted in the root element no
                currentFrame was set. This is done when &lt;list sequence=""&gt; is found</item>
              <item>multiple sequences are not yet supported</item>
              <item>the frame is now added when the doc is ended, which will result in problems
                but work for one sequence files made by PDB2CML v.??</item>
            </list>
            </para>
            <para>What is does:
            <list type="bullet">
              <item>work for now</item>
              <item>give an idea on the API of the plugable CML import filter
                (a real one will be made)</item>
              <item>read CML files generated with Steve Zara's PDB 2 CML converter
                (of which version 1999 produces invalid CML 1.0)</item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="T:NCDK.IO.CML.PMPConvention">
            <summary>
             Implementation of the PMPMol Covention for CML.
            <para>PMP stands for PolyMorph Predictor and is a module
             of Cerius2 (tm).</para>
            </summary>
        </member>
        <member name="T:NCDK.IO.CML.MDMoleculeConvention">
            <summary>
            Implements a Convention for parsing an MDMolecule from CML.
            </summary>
        </member>
        <member name="M:NCDK.IO.CML.MDMoleculeConvention.StartElement(NCDK.IO.CML.CMLStack,System.Xml.Linq.XElement)">
            <summary>
            Add parsing of elements in mdmolecule:
            <list type="bullet">
              <item>mdmolecule</item>
              <list type="bullet">
                <item>chargeGroup</item>
                <list type="bullet">
                  <item>id</item>
                  <item>cgNumber</item>
                  <item>atomArray</item>
                  <item>switchingAtom</item>
                </list>
              </list>
              <item>residue</item>
              <list type="bullet">
                <item>id</item>
                <item>title</item>
                <item>resNumber</item>
                <item>atomArray</item>
              </list>
            </list>
            </summary>
            <param name="xpath"></param>
            <param name="element"></param>
        </member>
        <member name="M:NCDK.IO.CML.MDMoleculeConvention.EndElement(NCDK.IO.CML.CMLStack,System.Xml.Linq.XElement)">
            <summary>
            Finish up parsing of elements in mdmolecule.
            </summary>
            <param name="xpath"></param>
            <param name="element"></param>
        </member>
        <member name="T:NCDK.IO.CrystClustWriter">
            <summary>
            Rather stupid file format used for storing crystal information.
            </summary>
        </member>
        <member name="M:NCDK.IO.CrystClustWriter.#ctor(System.IO.TextWriter)">
            <summary>
            Constructs a new CrystClustWriter class. Output will be stored in the Writer  class given as parameter.
            </summary>
            <param name="output">Writer to redirect the output to.</param>
        </member>
        <member name="M:NCDK.IO.CrystClustWriter.Write(NCDK.IChemObject)">
            <summary>
            Serializes the IChemObject to CrystClust format and redirects it to the output Writer.
            </summary>
            <param name="obj">A Molecule of MoleculeSet object</param>
        </member>
        <member name="F:NCDK.IO.CrystClustWriter.disposedValue">
            <summary>
            Flushes the output and closes this object.
            </summary>
        </member>
        <member name="M:NCDK.IO.CrystClustWriter.WriteCrystal(NCDK.ICrystal)">
            <summary>
            Writes a single frame to the Writer.
            </summary>
            <remarks>
            Format:
            <list type="table">
            <listheader>
            <term>line</term>
            <term>data</term>
            </listheader>
            <term><item>1</item><item>spacegroup</item></term>
            <term><item>2,3,4</item><item>cell parameter: a</item></term>
            <term><item>5,6,7</item><item>b</item></term>
            <term><item>8,9,10</item><item>c</item></term>
            <term><item>11</item><item>number of atoms</item></term>
            <term><item>12</item><item>number of asym. units</item></term>
            <term><item>13-16</item><item>atomtype: charge, atomcoord x, y, z</item></term>
            <term><item>17-20</item><item>idem second atom</item></term>
            <term><item>21-24</item><item>idem third atom etc</item></term>
            </list>            
            </remarks>
            <param name="crystal">the Crystal to serialize</param>
        </member>
        <member name="T:NCDK.IO.CTXReader">
            <summary>
            Reader that extracts information from the IDENT, NAME, ATOMS and BONDS blocks in CTX files.
            </summary>
        </member>
        <member name="T:NCDK.IO.DefaultChemObjectReader">
            <summary>
            Abstract class that ChemObjectReader's can implement to have it
            take care of basic stuff, like managing the ReaderListeners.
            </summary>
        </member>
        <member name="F:NCDK.IO.DefaultChemObjectReader.frameReadEvent">
            <summary>
            An event to be sent to listeners when a frame is read.
            </summary>
        </member>
        <member name="M:NCDK.IO.DefaultChemObjectReader.FireFrameRead">
            <summary>
            Sends a frame read event to the registered ReaderListeners.
            </summary>
        </member>
        <member name="T:NCDK.IO.DefaultChemObjectWriter">
            <summary>
            Abstract class that ChemObjectReader's can implement to have it
            take care of basic stuff, like managing the ReaderListeners.
            </summary>
        </member>
        <member name="T:NCDK.IO.FormatFactory">
            <summary>
            A factory for recognizing chemical file formats. Formats
            of GZiped files can be detected too.
            </summary>
            <example>
            <code>                StringReader stringReader = new StringReader("&lt;molecule/&gt;");
                IChemFormat format = new FormatFactory().GuessFormat(stringReader);
</code>
            </example>
        </member>
        <member name="M:NCDK.IO.FormatFactory.#ctor">
            <summary>
            Constructs a ReaderFactory which tries to detect the format in the
            first 65536 chars.
            </summary>
        </member>
        <member name="M:NCDK.IO.FormatFactory.#ctor(System.Int32)">
            <summary>
            Constructs a ReaderFactory which tries to detect the format in the
            first given number of chars.
            </summary>
            <param name="headerLength">length of the header in number of chars</param>
        </member>
        <member name="M:NCDK.IO.FormatFactory.RegisterFormat(NCDK.IO.Formats.IChemFormatMatcher)">
            <summary>
            Registers a format for detection.
            </summary>
        </member>
        <member name="P:NCDK.IO.FormatFactory.Formats">
            <summary>
            Returns the list of recognizable formats.
            </summary>
            <returns><see cref="T:System.Collections.Generic.IList`1"/> of <see cref="T:NCDK.IO.Formats.IChemFormat"/>s.</returns>
        </member>
        <member name="M:NCDK.IO.FormatFactory.GuessFormat(System.IO.TextReader)">
            <summary>
            Creates a string of the Class name of the <see cref="T:NCDK.IChemObject"/> reader
            for this file format. The input is read line-by-line
            until a line containing an identifying string is
            found.
            <para>The ReaderFactory detects more formats than the CDK
            has Readers for.</para>
            <para>This method is not able to detect the format of gziped files.
            Use <see cref="M:NCDK.IO.FormatFactory.GuessFormat(System.IO.Stream)"/> instead for such files.</para>
            </summary>
            <returns>The guessed <see cref="T:NCDK.IO.Formats.IChemFormat"/> or <see langword="null"/> if the file format is not recognized.</returns>
            <exception cref="T:System.ArgumentNullException">if the input is null</exception>
            <seealso cref="M:NCDK.IO.FormatFactory.GuessFormat(System.IO.Stream)"/>
        </member>
        <member name="P:NCDK.IO.Formats.ABINITFormat.FormatName">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.ABINITFormat.MIMEType">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.ABINITFormat.PreferredNameExtension">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.ABINITFormat.NameExtensions">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.ABINITFormat.ReaderClassName">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.ABINITFormat.WriterClassName">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.IO.Formats.ABINITFormat.Matches(System.Int32,System.String)">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.ABINITFormat.IsXmlBased">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.ABINITFormat.SupportedDataFeatures">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.ABINITFormat.RequiredDataFeatures">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.IO.Formats.AbstractResourceFormat">
            <summary>
            An abstract class providing <see cref="M:NCDK.IO.Formats.AbstractResourceFormat.GetHashCode"/> and <see cref="M:NCDK.IO.Formats.AbstractResourceFormat.Equals(System.Object)"/> for
            <see cref="T:NCDK.IO.Formats.IResourceFormat"/>s. As <see cref="T:NCDK.IO.Formats.IResourceFormat"/>s are stateless this implementation uses the class for equality testing.
            </summary>
        </member>
        <member name="P:NCDK.IO.Formats.Aces2Format.FormatName">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.Aces2Format.MIMEType">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.Aces2Format.PreferredNameExtension">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.Aces2Format.NameExtensions">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.Aces2Format.ReaderClassName">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.Aces2Format.WriterClassName">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.IO.Formats.Aces2Format.Matches(System.Int32,System.String)">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.Aces2Format.IsXmlBased">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.Aces2Format.SupportedDataFeatures">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.Aces2Format.RequiredDataFeatures">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.ADFFormat.FormatName">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.ADFFormat.MIMEType">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.ADFFormat.PreferredNameExtension">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.ADFFormat.NameExtensions">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.ADFFormat.ReaderClassName">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.ADFFormat.WriterClassName">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.IO.Formats.ADFFormat.Matches(System.Int32,System.String)">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.ADFFormat.IsXmlBased">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.ADFFormat.SupportedDataFeatures">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.ADFFormat.RequiredDataFeatures">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.AlchemyFormat.FormatName">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.AlchemyFormat.MIMEType">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.AlchemyFormat.PreferredNameExtension">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.AlchemyFormat.NameExtensions">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.AlchemyFormat.ReaderClassName">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.AlchemyFormat.WriterClassName">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.AlchemyFormat.IsXmlBased">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.AlchemyFormat.SupportedDataFeatures">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.AlchemyFormat.RequiredDataFeatures">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.IO.Formats.BSFormat">
            <summary>
            See <see href="http://www.orc.uni-linz.ac.at/mueller/ball_and_stick.shtml">here</see>. 
            </summary>
        </member>
        <member name="T:NCDK.IO.Formats.CacaoCartesianFormat">
            <summary>
            See <see href="http://www.chembio.uoguelph.ca/oakley/310/cacao/cacao.htm">here</see>.
            </summary>
        </member>
        <member name="T:NCDK.IO.Formats.CacaoInternalFormat">
            <summary>
            See <see href="http://www.chembio.uoguelph.ca/oakley/310/cacao/cacao.htm">here</see>.
            </summary>
        </member>
        <member name="T:NCDK.IO.Formats.CDKOWLFormat">
            <summary>
            Serializes a CDK model into the Web Ontology Language using the N3 format.
            </summary>
        </member>
        <member name="P:NCDK.IO.Formats.ChemDrawFormat.FormatName">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.ChemDrawFormat.MIMEType">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.ChemDrawFormat.PreferredNameExtension">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.ChemDrawFormat.NameExtensions">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.ChemDrawFormat.ReaderClassName">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.ChemDrawFormat.WriterClassName">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.ChemDrawFormat.IsXmlBased">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.ChemDrawFormat.SupportedDataFeatures">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.ChemDrawFormat.RequiredDataFeatures">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.IO.Formats.ChemtoolFormat">
            <summary>
            See <see href="http://ruby.chemie.uni-freiburg.de/~martin/chemtool/chemtool.html">here</see>.
            </summary>
        </member>
        <member name="P:NCDK.IO.Formats.CIFFormat.FormatName">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.CIFFormat.MIMEType">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.CIFFormat.PreferredNameExtension">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.CIFFormat.NameExtensions">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.CIFFormat.ReaderClassName">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.CIFFormat.WriterClassName">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.IO.Formats.CIFFormat.Matches(System.Int32,System.String)">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.CIFFormat.IsXmlBased">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.CIFFormat.SupportedDataFeatures">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.CIFFormat.RequiredDataFeatures">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.IO.Formats.CMLFormat">
            <summary>
            See <see href="http://en.wikipedia.org/wiki/Chemical_Markup_Language">here</see>.
            </summary>
        </member>
        <member name="P:NCDK.IO.Formats.CMLFormat.FormatName">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.CMLFormat.MIMEType">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.CMLFormat.PreferredNameExtension">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.CMLFormat.NameExtensions">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.CMLFormat.ReaderClassName">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.CMLFormat.WriterClassName">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.IO.Formats.CMLFormat.Matches(System.Int32,System.String)">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.CMLFormat.IsXmlBased">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.CMLFormat.SupportedDataFeatures">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.CMLFormat.RequiredDataFeatures">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.CMLRSSFormat.FormatName">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.CMLRSSFormat.MIMEType">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.CMLRSSFormat.PreferredNameExtension">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.CMLRSSFormat.NameExtensions">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.CMLRSSFormat.ReaderClassName">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.CMLRSSFormat.WriterClassName">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.CMLRSSFormat.IsXmlBased">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.CMLRSSFormat.SupportedDataFeatures">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.CMLRSSFormat.RequiredDataFeatures">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.IO.Formats.CRK2DFormat">
            <summary>
            See <see href="http://crk.sourceforge.net/">here</see>.
            </summary>
        </member>
        <member name="T:NCDK.IO.Formats.CRK3DFormat">
            <summary>
            See <see href="http://crk.sourceforge.net/">here</see>.
            </summary>
        </member>
        <member name="T:NCDK.IO.Formats.DOCK5Format">
            <summary>
            See <see href="http://dock.compbio.ucsf.edu">here</see>.
            </summary>
        </member>
        <member name="T:NCDK.IO.Formats.GamessFormat">
            <summary>
            See <see href="http://www.msg.ameslab.gov/GAMESS/doc.menu.html">here</see>.
            </summary>
        </member>
        <member name="P:NCDK.IO.Formats.GamessFormat.FormatName">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.GamessFormat.MIMEType">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.GamessFormat.PreferredNameExtension">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.GamessFormat.NameExtensions">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.GamessFormat.ReaderClassName">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.GamessFormat.WriterClassName">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.IO.Formats.GamessFormat.Matches(System.Int32,System.String)">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.GamessFormat.IsXmlBased">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.GamessFormat.SupportedDataFeatures">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.GamessFormat.RequiredDataFeatures">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.IO.Formats.Gaussian03Format">
            <summary>
            See <see href="http://www.gaussian.com/g_ur/m_input.htm">here</see>.
            </summary>
        </member>
        <member name="P:NCDK.IO.Formats.Gaussian03Format.FormatName">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.Gaussian03Format.MIMEType">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.Gaussian03Format.PreferredNameExtension">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.Gaussian03Format.NameExtensions">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.Gaussian03Format.ReaderClassName">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.Gaussian03Format.WriterClassName">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.IO.Formats.Gaussian03Format.Matches(System.Int32,System.String)">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.Gaussian03Format.IsXmlBased">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.Gaussian03Format.SupportedDataFeatures">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.Gaussian03Format.RequiredDataFeatures">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.Gaussian92Format.FormatName">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.Gaussian92Format.MIMEType">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.Gaussian92Format.PreferredNameExtension">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.Gaussian92Format.NameExtensions">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.Gaussian92Format.ReaderClassName">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.Gaussian92Format.WriterClassName">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.IO.Formats.Gaussian92Format.Matches(System.Int32,System.String)">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.Gaussian92Format.IsXmlBased">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.Gaussian92Format.SupportedDataFeatures">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.Gaussian92Format.RequiredDataFeatures">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.IO.Formats.Gaussian94Format.Matches(System.Int32,System.String)">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.IO.Formats.GaussianInputFormat">
            <summary>
            See <see href="http://www.gaussian.com/g_ur/m_input.htm">here</see>.
            </summary>
        </member>
        <member name="P:NCDK.IO.Formats.GaussianInputFormat.IsXmlBased">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.GaussianInputFormat.SupportedDataFeatures">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.GaussianInputFormat.RequiredDataFeatures">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.IO.Formats.GhemicalMMFormat">
            <summary>
            See<see href="http://www.uku.fi/~thassine/ghemical/">here</see>.
            </summary>
        </member>
        <member name="T:NCDK.IO.Formats.GROMOS96Format">
            <summary>
            See <see href="http://www.igc.ethz.ch/gromos/">here</see>.
            </summary>
        </member>
        <member name="T:NCDK.IO.Formats.HINFormat">
            <summary>
            See <see href="http://www.hyper.com/">here</see>.
            </summary>
        </member>
        <member name="P:NCDK.IO.Formats.HINFormat.FormatName">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.HINFormat.MIMEType">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.HINFormat.PreferredNameExtension">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.HINFormat.NameExtensions">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.HINFormat.ReaderClassName">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.HINFormat.WriterClassName">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.IO.Formats.HINFormat.Matches(System.Int32,System.String)">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.HINFormat.IsXmlBased">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.HINFormat.SupportedDataFeatures">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.HINFormat.RequiredDataFeatures">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.IO.Formats.IChemFormat">
            <summary>
            This class is the interface that all ChemFormat's should implement.
            </summary>
        </member>
        <member name="P:NCDK.IO.Formats.IChemFormat.ReaderClassName">
            <summary>
            Returns the class name of the CDK Reader for this format.
            </summary>
            <returns><see langword="null"/> if no CDK Reader is available.</returns>
        </member>
        <member name="P:NCDK.IO.Formats.IChemFormat.WriterClassName">
            <summary>
            Returns the class name of the CDK Writer for this format.
            </summary>
            <returns><see langword="null"/> if no CDK Writer is available.</returns>
        </member>
        <member name="P:NCDK.IO.Formats.IChemFormat.SupportedDataFeatures">
            <summary>
            Returns an integer indicating the data features that this
            format supports. The integer is composed as explained in
            DataFeatures. May be set to DataFeatures.None as default.
            </summary>
            <seealso cref="T:NCDK.Tools.DataFeatures"/>
        </member>
        <member name="P:NCDK.IO.Formats.IChemFormat.RequiredDataFeatures">
            <summary>
            Returns an integer indicating the data features that this
            format requires. For example, the XYZ format requires 3D
            coordinates.
            </summary>
            <seealso cref="T:NCDK.Tools.DataFeatures"/>
        </member>
        <member name="T:NCDK.IO.Formats.IChemFormatMatcher">
            <summary>
            This interface is used for classes that are able to match a certain
            chemical file format. For example: Chemical Markup Language, PDB etc.
            </summary>
        </member>
        <member name="M:NCDK.IO.Formats.IChemFormatMatcher.Matches(System.Collections.Generic.IList{System.String})">
            <summary>
            Method that checks whether the given lines are part of the format read by
            this reader.
            </summary>
            <param name="lines">lines of the input to be checked</param>
            <returns>whether the format matched and when it matched</returns>
        </member>
        <member name="T:NCDK.IO.Formats.MatchResult">
            <summary>
            Simple class holds whether a format matcher matched, when it matched and
            what the format was. The result is comparable to be prioritised (lower
            match position being favoured).
            </summary>
        </member>
        <member name="F:NCDK.IO.Formats.MatchResult.NO_MATCH">
            <summary>Convenience method for indicating a format did not match.</summary>
        </member>
        <member name="F:NCDK.IO.Formats.MatchResult.matched">
            <summary>Did the format match.</summary>
        </member>
        <member name="F:NCDK.IO.Formats.MatchResult.position">
            <summary>When did the format match.</summary>
        </member>
        <member name="F:NCDK.IO.Formats.MatchResult.format">
            <summary>Which format matched.</summary>
        </member>
        <member name="P:NCDK.IO.Formats.MatchResult.IsMatched">
            <summary>
            Did the chem format match.
            </summary>
            <returns>whether the format matched</returns>
        </member>
        <member name="P:NCDK.IO.Formats.MatchResult.Format">
            <summary>
            What was the format which matched if there was a match <see cref="P:NCDK.IO.Formats.MatchResult.IsMatched"/>.
            </summary>
            <returns>the format which matched</returns>
            <exception cref="T:System.InvalidOperationException">there was no match</exception>
        </member>
        <member name="M:NCDK.IO.Formats.MatchResult.CompareTo(NCDK.IO.Formats.MatchResult)">
            <summary>
            Compares the match result with another, results with lower position
            are ordered before those with higher position.
            </summary>
        </member>
        <member name="T:NCDK.IO.Formats.InChIFormat">
            <summary>
            See <see href="http://www.iupac.org/inchi/">here</see>.
            </summary>
        </member>
        <member name="P:NCDK.IO.Formats.InChIFormat.FormatName">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.InChIFormat.MIMEType">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.InChIFormat.PreferredNameExtension">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.InChIFormat.NameExtensions">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.InChIFormat.ReaderClassName">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.InChIFormat.WriterClassName">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.IO.Formats.InChIFormat.Matches(System.Int32,System.String)">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.InChIFormat.IsXmlBased">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.InChIFormat.SupportedDataFeatures">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.InChIFormat.RequiredDataFeatures">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.IO.Formats.IResourceFormat">
            <summary>
            This class is the interface that all ResourceFormat's should implement.
            An implementation is supposed to be a singleton class, so it should have
            only private constructors, and implement the Instance method.
            </summary>
        </member>
        <member name="P:NCDK.IO.Formats.IResourceFormat.FormatName">
            <summary>
            Returns a one-lined format name of the format.
            </summary>
        </member>
        <member name="P:NCDK.IO.Formats.IResourceFormat.PreferredNameExtension">
            <summary>
            Returns the preferred resource name extension.
            </summary>
        </member>
        <member name="P:NCDK.IO.Formats.IResourceFormat.NameExtensions">
            <summary>
            Returns an array of common resource name extensions.
            </summary>
        </member>
        <member name="P:NCDK.IO.Formats.IResourceFormat.MIMEType">
             <summary>
             Returns the accepted MIME type for this format.
            
             <returns>null if no MIME type has been accepted on</returns>
             </summary>
        </member>
        <member name="P:NCDK.IO.Formats.IResourceFormat.IsXmlBased">
             <summary>
             Indicates if the format is an XML-based language.
            
             <returns>if the format is XML-based.</returns>
             </summary>
        </member>
        <member name="T:NCDK.IO.Formats.JaguarFormat">
            <summary>
            See <see href="http://www.schrodinger.com/">here</see>.
            </summary>
        </member>
        <member name="T:NCDK.IO.Formats.MDLFormat">
            <summary>
            See <see href="http://www.mdl.com/downloads/public/ctfile/ctfile.jsp">here</see>.
            </summary>
        </member>
        <member name="P:NCDK.IO.Formats.MDLFormat.FormatName">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.MDLFormat.MIMEType">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.MDLFormat.PreferredNameExtension">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.MDLFormat.NameExtensions">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.MDLFormat.ReaderClassName">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.MDLFormat.WriterClassName">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.IO.Formats.MDLFormat.Matches(System.Int32,System.String)">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.MDLFormat.IsXmlBased">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.MDLFormat.SupportedDataFeatures">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.MDLFormat.RequiredDataFeatures">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.IO.Formats.MDLRXNFormat">
            <summary>
            See <see href="http://www.mdl.com/downloads/public/ctfile/ctfile.jsp">here</see>.
            </summary>
        </member>
        <member name="P:NCDK.IO.Formats.MDLRXNFormat.FormatName">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.MDLRXNFormat.MIMEType">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.MDLRXNFormat.PreferredNameExtension">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.MDLRXNFormat.NameExtensions">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.MDLRXNFormat.ReaderClassName">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.MDLRXNFormat.WriterClassName">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.IO.Formats.MDLRXNFormat.Matches(System.Int32,System.String)">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.MDLRXNFormat.IsXmlBased">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.MDLRXNFormat.SupportedDataFeatures">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.MDLRXNFormat.RequiredDataFeatures">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.IO.Formats.MDLRXNV3000Format">
            <summary>
            See <see href="http://www.mdl.com/downloads/public/ctfile/ctfile.jsp">here</see>.
            </summary>
        </member>
        <member name="P:NCDK.IO.Formats.MDLV2000Format.FormatName">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.MDLV2000Format.MIMEType">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.MDLV2000Format.PreferredNameExtension">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.MDLV2000Format.NameExtensions">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.MDLV2000Format.ReaderClassName">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.MDLV2000Format.WriterClassName">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.IO.Formats.MDLV2000Format.Matches(System.Int32,System.String)">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.MDLV2000Format.IsXmlBased">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.MDLV2000Format.SupportedDataFeatures">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.MDLV2000Format.RequiredDataFeatures">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.MDLV3000Format.FormatName">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.MDLV3000Format.MIMEType">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.MDLV3000Format.PreferredNameExtension">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.MDLV3000Format.NameExtensions">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.MDLV3000Format.ReaderClassName">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.MDLV3000Format.WriterClassName">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.IO.Formats.MDLV3000Format.Matches(System.Int32,System.String)">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.MDLV3000Format.IsXmlBased">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.MDLV3000Format.SupportedDataFeatures">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.MDLV3000Format.RequiredDataFeatures">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.IO.Formats.MMODFormat">
            <summary>
            See <see href="http://www.ch.ic.ac.uk/local/organic/t2_mmod.html">here</see>.
            </summary>
        </member>
        <member name="T:NCDK.IO.Formats.Mol2Format">
            <summary>
            See <see href="http://www.tripos.com/data/support/mol2.pdf">here</see>.
            </summary>
        </member>
        <member name="P:NCDK.IO.Formats.Mol2Format.FormatName">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.Mol2Format.MIMEType">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.Mol2Format.PreferredNameExtension">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.Mol2Format.NameExtensions">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.Mol2Format.ReaderClassName">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.Mol2Format.WriterClassName">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.IO.Formats.Mol2Format.Matches(System.Int32,System.String)">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.Mol2Format.IsXmlBased">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.Mol2Format.SupportedDataFeatures">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.Mol2Format.RequiredDataFeatures">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.MoSSOutputFormat.FormatName">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.MoSSOutputFormat.MIMEType">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.MoSSOutputFormat.PreferredNameExtension">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.MoSSOutputFormat.NameExtensions">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.MoSSOutputFormat.ReaderClassName">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.MoSSOutputFormat.WriterClassName">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.IO.Formats.MoSSOutputFormat.Matches(System.Int32,System.String)">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.MoSSOutputFormat.IsXmlBased">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.MoSSOutputFormat.SupportedDataFeatures">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.MoSSOutputFormat.RequiredDataFeatures">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.IO.Formats.MPQCFormat">
            <summary>
            See <see href="http://www.mpqc.org/mpqc-html/mpqcinp.html">here</see>.
            </summary>
        </member>
        <member name="T:NCDK.IO.Formats.NWChemFormat">
            <summary>
            See <see href="http://www.emsl.pnl.gov/docs/nwchem/">here</see>.
            </summary>
        </member>
        <member name="T:NCDK.IO.Formats.PCModelFormat">
            <summary>
            See <see href="http://www.serenasoft.com/">here</see>.
            </summary>
                // @author Miguel Rojas
        </member>
        <member name="T:NCDK.IO.Formats.PDBFormat">
            <summary>
            See <see href="http://www.rcsb.org/pdb/docs/format/pdbguide2.2/guide2.2_frame.html">here</see>.
            </summary>
        </member>
        <member name="P:NCDK.IO.Formats.PDBFormat.FormatName">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.PDBFormat.MIMEType">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.PDBFormat.PreferredNameExtension">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.PDBFormat.NameExtensions">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.PDBFormat.ReaderClassName">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.PDBFormat.WriterClassName">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.IO.Formats.PDBFormat.Matches(System.Int32,System.String)">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.PDBFormat.IsXmlBased">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.PDBFormat.SupportedDataFeatures">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.PDBFormat.RequiredDataFeatures">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.IO.Formats.PDBMLFormat">
            <summary>
            XML version of the PDB format.
            See <see href="http://pdbml.rcsb.org/">here</see>.
            </summary>
        </member>
        <member name="P:NCDK.IO.Formats.PMPFormat.FormatName">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.PMPFormat.MIMEType">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.PMPFormat.PreferredNameExtension">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.PMPFormat.NameExtensions">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.PMPFormat.ReaderClassName">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.PMPFormat.WriterClassName">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.IO.Formats.PMPFormat.Matches(System.Int32,System.String)">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.PMPFormat.IsXmlBased">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.PMPFormat.SupportedDataFeatures">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.PMPFormat.RequiredDataFeatures">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.IO.Formats.POVRayFormat">
            <summary>
            See <see href="http://www.povray.org/">here</see>.
            </summary>
        </member>
        <member name="T:NCDK.IO.Formats.PQSChemFormat">
            <summary>
            See <see href="http://www.pqs-chem.com/">here</see>.
            </summary>
        </member>
        <member name="T:NCDK.IO.Formats.PubChemFormat">
            <summary>
            See <see href="http://ftp.ncbi.nlm.nih.gov/pubchem/data_spec/pubchem.xsd">here</see>.
            </summary>
        </member>
        <member name="T:NCDK.IO.Formats.QChemFormat">
            <summary>
            See <see href="http://www.q-chem.com/">here</see>.
            </summary>
        </member>
        <member name="T:NCDK.IO.Formats.RGroupQueryFormat">
            <summary>
            Format for Symyx RGfiles (Rgroup query files).
            </summary>
        </member>
        <member name="T:NCDK.IO.Formats.SDFFormat">
            <summary>
            See <see href="http://www.mdl.com/downloads/public/ctfile/ctfile.jsp">here</see>.
            </summary>
        </member>
        <member name="P:NCDK.IO.Formats.SDFFormat.FormatName">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.SDFFormat.MIMEType">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.SDFFormat.PreferredNameExtension">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.SDFFormat.NameExtensions">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.SDFFormat.ReaderClassName">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.SDFFormat.WriterClassName">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.IO.Formats.SDFFormat.Matches(System.Int32,System.String)">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.SDFFormat.IsXmlBased">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.SDFFormat.SupportedDataFeatures">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.SDFFormat.RequiredDataFeatures">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.IO.Formats.ShelXFormat">
            <summary>
            See <see href="http://shelx.uni-ac.gwdg.de/SHELX/">here</see>.
            </summary>
        </member>
        <member name="T:NCDK.IO.Formats.SimpleChemFormatMatcher">
            <summary>
            A simple line matcher which delegates format matching to the previous
            per-line implementation.
            </summary>
        </member>
        <member name="M:NCDK.IO.Formats.SimpleChemFormatMatcher.Matches(System.Int32,System.String)">
            <summary>
            Check whether a given line at a specified position (line number) could
            belong to this format.
            </summary>
            <param name="lineNumber">the line number of <paramref name="line"/></param>
            <param name="line">the contents at the given <paramref name="lineNumber"/></param>
            <returns>this line in this position could indicate a format match</returns>
        </member>
        <member name="M:NCDK.IO.Formats.SimpleChemFormatMatcher.Matches(System.Collections.Generic.IList{System.String})">
            <summary>
            Simple implementation, runs the lines one-by-one through <see cref="M:NCDK.IO.Formats.SimpleChemFormatMatcher.Matches(System.Int32,System.String)"/> and returns true if any line matches.
            </summary>
            <param name="lines">lines of the input to be checked</param>
            <returns>runs the lines</returns>
        </member>
        <member name="T:NCDK.IO.Formats.SMARTSFormat">
            <summary>
            See <see href="http://www.daylight.com/dayhtml/doc/theory/theory.smarts.html">here</see>.
            </summary>
        </member>
        <member name="P:NCDK.IO.Formats.SMARTSFormat.FormatName">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.SMARTSFormat.MIMEType">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.SMARTSFormat.PreferredNameExtension">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.SMARTSFormat.NameExtensions">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.SMARTSFormat.ReaderClassName">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.SMARTSFormat.WriterClassName">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.SMARTSFormat.IsXmlBased">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.SMARTSFormat.SupportedDataFeatures">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.SMARTSFormat.RequiredDataFeatures">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.IO.Formats.SMILESFormat">
            <summary>
            See <see href="http://www.daylight.com/smiles/f_smiles.html">here</see>.
            </summary>
        </member>
        <member name="P:NCDK.IO.Formats.SMILESFormat.FormatName">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.SMILESFormat.MIMEType">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.SMILESFormat.PreferredNameExtension">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.SMILESFormat.NameExtensions">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.SMILESFormat.ReaderClassName">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.SMILESFormat.WriterClassName">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.SMILESFormat.IsXmlBased">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.SMILESFormat.SupportedDataFeatures">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.SMILESFormat.RequiredDataFeatures">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.IO.Formats.SybylDescriptorFormat">
            <summary>
            See <see href="http://dx.doi.org/10.1021/ci034207y">here</see>.
            </summary>
        </member>
        <member name="T:NCDK.IO.Formats.TinkerMM2Format">
            <summary>
            See <see href="http://dasher.wustl.edu/tinker/">here</see>.
            </summary>
        </member>
        <member name="T:NCDK.IO.Formats.TinkerXYZFormat">
            <summary>
            See <see href="http://dasher.wustl.edu/tinker/">here</see>.
            </summary>
        </member>
        <member name="T:NCDK.IO.Formats.TurboMoleFormat">
            <summary>
            See <see href="http://www.cosmologic.de/turbomole.html">here</see>.
            </summary>
        </member>
        <member name="P:NCDK.IO.Formats.VASPFormat.FormatName">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.VASPFormat.MIMEType">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.VASPFormat.PreferredNameExtension">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.VASPFormat.NameExtensions">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.VASPFormat.ReaderClassName">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.VASPFormat.WriterClassName">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.IO.Formats.VASPFormat.Matches(System.Int32,System.String)">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.VASPFormat.IsXmlBased">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.VASPFormat.SupportedDataFeatures">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.VASPFormat.RequiredDataFeatures">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.IO.Formats.ViewmolFormat">
            <summary>
            See <see href="http://viewmol.sourceforge.net/">here</see>.
            </summary>
        </member>
        <member name="P:NCDK.IO.Formats.XYZFormat.FormatName">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.XYZFormat.MIMEType">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.XYZFormat.PreferredNameExtension">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.XYZFormat.NameExtensions">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.XYZFormat.ReaderClassName">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.XYZFormat.WriterClassName">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.XYZFormat.IsXmlBased">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.XYZFormat.SupportedDataFeatures">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.IO.Formats.XYZFormat.RequiredDataFeatures">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.IO.Formats.YasaraFormat">
            <summary>
            See <see href="http://www.yasara.org/">here</see>.
            </summary>
        </member>
        <member name="T:NCDK.IO.Formats.ZindoFormat">
            <summary>
            See <see href="http://www.sinica.edu.tw/~scimath/msi/insight2K/zindo/C_Files.html">here</see>.
            </summary>
        </member>
        <member name="T:NCDK.IO.GamessReader">
            <summary>
            A reader for GAMESS log file.
            </summary>
            <remarks>
            <para>
            <b>Expected behaviour</b>:
            The "GamessReader" object is able to read GAMESS output log file format.
            </para>
            <para>
            <b>Limitations</b>: This reader was developed from a small set of
            example log files, and therefore, is not guaranteed to properly read all
            GAMESS output. If you have problems, please contact the author of this code,
            not the developers of GAMESS.
            </para>
            <para>
            <b>Implementation</b>
            Available Feature(s):
            <list type="bullet">
                <item><b>Molecular coordinates</b>: Each set of coordinates is added to the ChemFile in the order they are found.</item>
            </list> 
            </para>
            <para>
            Unavailable Feature(s):
            <list type="bullet">
            <!--    <item><b>GAMESS version number</b>: The version number can be retrieved.</item> -->
            <!--    <item><b>Point group symmetry information</b>: The point group is associated with the set of molecules.</item> -->
            <!--    <item><b>MOPAC charges</b>: The point group is associated with the set of molecules.</item> -->
                <item><b>Energies</b>: They are associated with the previously read set of coordinates.</item>
                <item><b>Normal coordinates of vibrations</b>: They are associated with the previously read set of coordinates.</item>
            </list> 
            </para>
            <para>
            <b>References</b>:
            <see href="http://www.msg.ameslab.gov/GAMESS/GAMESS.html">GAMESS</see> is a
            quantum chemistry program by Gordon research group at Iowa State University.
            </para>
            </remarks>
        </member>
        <member name="F:NCDK.IO.GamessReader.BohrUnit">
            <summary>
            bool constant used to specify that the coordinates are given in Bohr units.
            </summary>
        </member>
        <member name="F:NCDK.IO.GamessReader.BohrToAngstrom">
            <summary>
            Double constant that contains the conversion factor from Bohr unit to
            √Öngstrom unit.
            </summary>
        </member>
        <member name="F:NCDK.IO.GamessReader.AngstromUnit">
            <summary>
            bool constant used to specify that the coordinates are given in √Öngstrom units.
            </summary>
        </member>
        <member name="F:NCDK.IO.GamessReader.input">
            <summary>
            The "TextReader" object used to read data from the "file system" file.
            </summary>
            <see cref="M:NCDK.IO.GamessReader.#ctor(System.IO.TextReader)"/>
        </member>
        <member name="M:NCDK.IO.GamessReader.#ctor(System.IO.TextReader)">
            <summary>
            Constructs a new "GamessReader" object given a "Reader" object as input.
            <para>The "Reader" object may be an instantiable object from the "Reader" hierarchy.</para>
            <para>For more detail about the "Reader" objects that are really accepted
            by this "GamessReader" see <see cref="M:NCDK.IO.GamessReader.Accepts(System.Type)"/> method
            documentation.</para>
            </summary>
            <param name="inputReader">The "Reader" object given as input parameter.</param>
            <seealso cref="M:NCDK.IO.GamessReader.Accepts(System.Type)"/>
            <seealso cref="T:System.IO.TextReader"/>
        </member>
        <member name="M:NCDK.IO.GamessReader.ReadChemFile(NCDK.IChemFile)">
            <summary>
            Reads data from the "file system" file through the use of the "input"
            field, parses data and feeds the ChemFile object with the extracted data.
            </summary>
            <returns>A ChemFile containing the data parsed from input.</returns>
            <exception cref="T:System.IO.IOException">   may be thrown buy the <c>this.input.ReadLine()</c> instruction.</exception>
            <seealso cref="F:NCDK.IO.GamessReader.input"/>
        </member>
        <member name="M:NCDK.IO.GamessReader.ReadCoordinates(NCDK.IAtomContainer,System.Boolean)">
            <summary>
            Reads a set of coordinates from the "file system" file through the use of
            the "input" field, scales coordinate to angstr???m unit, builds each atom with
            the right associated coordinates, builds a new molecule with these atoms
            and returns the complete molecule.
            </summary>
            <remarks>
            <para><b>Implementation</b>:
            Dummy atoms are ignored.</para>
            </remarks>
            <param name="molecule"></param>
            <param name="coordinatesUnits">The unit in which coordinates are given.</param>
            <exception cref="T:System.IO.IOException">may be thrown by the "input" object.</exception>
            <seealso cref="F:NCDK.IO.GamessReader.input"/>
        </member>
        <member name="M:NCDK.IO.GamessReader.IdentifyAtomicSymbol(System.Int32)">
            <summary>
            Identifies the atomic symbol of an atom given its default atomic number.
            <para>
            <b>Implementation</b>:
            This is not a definitive method. It will probably be replaced with a
            more appropriate one. Be advised that as it is not a definitive version,
            it only recognise atoms from Hydrogen (1) to Argon (18).
            </para>
            </summary>
            <param name="atomicNumber">The atomic number of an atom.</param>
            <returns>The Symbol corresponding to the atom or "null" is the atom was not recognised.</returns>
        </member>
        <member name="M:NCDK.IO.GamessReader.ScalesCoordinatesUnits(System.Boolean)">
            <summary>
            Scales coordinates to √Öngstr√∂m unit if they are given in Bohr unit.
            If coordinates are already given in √Öngstr√∂m unit, then no modifications
            are performed.
            </summary>
            <param name="coordinatesUnits"><see cref="F:NCDK.IO.GamessReader.BohrUnit"/> if coordinates are given in Bohr unit and <see cref="F:NCDK.IO.GamessReader.AngstromUnit"/> if they are given in √Öngstr√∂m unit.</param>
            <returns>The scaling conversion factor: 1 if no scaling is needed and <see cref="F:NCDK.IO.GamessReader.BohrToAngstrom"/> if scaling has to be performed.</returns>
            <seealso cref="F:NCDK.IO.GamessReader.BohrToAngstrom"/>
            <seealso cref="F:NCDK.IO.GamessReader.BohrUnit"/>
            <seealso cref="F:NCDK.IO.GamessReader.AngstromUnit"/>
        </member>
        <member name="T:NCDK.IO.Gaussian03Reader">
            <summary>
            A reader for Gaussian03 output.
            Gaussian 03 is a quantum chemistry program
            by Gaussian, Inc. (<see href="http://www.gaussian.com/">http://www.gaussian.com/</see>).
            <para>
            Molecular coordinates, energies, and normal coordinates of
            vibrations are read. Each set of coordinates is added to the
            ChemFile in the order they are found. Energies and vibrations
            are associated with the previously read set of coordinates.
            </para>
            <para>
            This reader was developed from a small set of
            example output files, and therefore, is not guaranteed to
            properly read all Gaussian03 output. If you have problems,
            please contact the author of this code, not the developers
            of Gaussian03.
            </para>
            <para>
            This code was adaptated by Jonathan from Gaussian98Reader written by
            Bradley, and ported to CDK by Egon.
            </para>
            </summary>
        </member>
        <member name="M:NCDK.IO.Gaussian03Reader.ReadCoordinates(NCDK.IChemModel)">
            <summary>
            Reads a set of coordinates into ChemModel.
            </summary>
            <param name="model">the destination ChemModel</param>
            <exception cref="T:System.IO.IOException">if an I/O error occurs</exception>
        </member>
        <member name="M:NCDK.IO.Gaussian03Reader.ReadPartialCharges(NCDK.IChemModel)">
            <summary>
            Reads partial atomic charges and add the to the given ChemModel.
            </summary>
        </member>
        <member name="T:NCDK.IO.Gaussian98Reader">
            <summary>
            A reader for Gaussian98 output. 
            <para>Gaussian 98 is a quantum chemistry program
            by Gaussian, Inc. (<see href="http://www.gaussian.com/">http://www.gaussian.com/</see>).
            </para>
            <para>Molecular coordinates, energies, and normal coordinates of vibrations are
            read. Each set of coordinates is added to the ChemFile in the order they are
            found. Energies and vibrations are associated with the previously read set
            of coordinates.
            </para>
            <para>
            This reader was developed from a small set of example output files, and
            therefore, is not guaranteed to properly read all Gaussian98 output. If you
            have problems, please contact the author of this code, not the developers of
            Gaussian98.</para>
            </summary>
        </member>
        <member name="F:NCDK.IO.Gaussian98Reader.readOptimizedStructureOnly">
            <summary>
            Customizable setting
            </summary>
        </member>
        <member name="M:NCDK.IO.Gaussian98Reader.#ctor(System.IO.TextReader)">
            <summary>
            Create an Gaussian98 output reader.
            </summary>
            <param name="input">source of Gaussian98 data</param>
        </member>
        <member name="M:NCDK.IO.Gaussian98Reader.ReadChemFile(NCDK.IChemFile)">
            <summary>
            Read the Gaussian98 output.
            </summary>
            <param name="chemFile"></param>
            <returns>a ChemFile with the coordinates, energies, and vibrations.</returns>
        </member>
        <member name="M:NCDK.IO.Gaussian98Reader.ReadCoordinates(NCDK.IChemModel)">
            <summary>
            Reads a set of coordinates into ChemFrame.
            </summary>
            <param name="model"></param>
        </member>
        <member name="M:NCDK.IO.Gaussian98Reader.ReadPartialCharges(NCDK.IChemModel)">
            <summary>
            Reads partial atomic charges and add the to the given ChemModel.
            </summary>
            <param name="model"></param>
        </member>
        <member name="M:NCDK.IO.Gaussian98Reader.ReadNMRData(NCDK.IChemModel,System.String)">
            <summary>
            Reads NMR nuclear shieldings.
            </summary>
            <param name="model"></param>
            <param name="labelLine"></param>
        </member>
        <member name="M:NCDK.IO.Gaussian98Reader.ParseLevelOfTheory(System.String)">
            <summary>
            Select the theory and basis set from the first archive line.
            </summary>
            <param name="line"></param>
            <returns></returns>
        </member>
        <member name="T:NCDK.IO.GhemicalMMReader">
            <summary>
            Reads Ghemical (<see href="http://www.uku.fi/~thassine/ghemical/">http://www.uku.fi/~thassine/ghemical/</see>) molecular mechanics (*.mm1gp) files.
            </summary>
        </member>
        <member name="T:NCDK.IO.HINReader">
            <summary>
            Reads an object from HIN formated input.
            </summary>
        </member>
        <member name="M:NCDK.IO.HINReader.#ctor(System.IO.TextReader)">
            <summary>
            Construct a new reader from a Reader type object
            </summary>
            <param name="input">reader from which input is read</param>
        </member>
        <member name="M:NCDK.IO.HINReader.Read``1(``0)">
            <summary>
            Reads the content from a HIN input. It can only return a
            IChemObject of type ChemFile
            </summary>
            <param name="obj">class must be of type ChemFile</param>
            <seealso cref="T:NCDK.IChemFile"/>
        </member>
        <member name="M:NCDK.IO.HINReader.ReadChemFile(NCDK.IChemFile)">
            <summary>
             Private method that actually parses the input to read a ChemFile
             object. In its current state it is able to read all the molecules
             (if more than one is present) in the specified HIN file. These are
             placed in a MoleculeSet object which in turn is placed in a ChemModel
             which in turn is placed in a ChemSequence object and which is finally
             placed in a ChemFile object and returned to the user.
            </summary>
            <returns>A ChemFile containing the data parsed from input.</returns>
        </member>
        <member name="T:NCDK.IO.HINWriter">
            <summary>
            Writer that outputs in the HIN format.
            </summary>
        </member>
        <member name="M:NCDK.IO.HINWriter.#ctor(System.IO.TextWriter)">
            <summary>
            Constructor.
            </summary>
            <param name="output">the stream to write the HIN file to.</param>
        </member>
        <member name="F:NCDK.IO.HINWriter.disposedValue">
            <summary>
            Flushes the output and closes this object.
            </summary>
        </member>
        <member name="M:NCDK.IO.HINWriter.WriteAtomContainer(NCDK.IEnumerableChemObject{NCDK.IAtomContainer})">
            <summary>
            writes all the molecules supplied in a MoleculeSet class to
            a single HIN file. You can also supply a single Molecule object
            as well
            </summary>
            <param name="som">the set of molecules to write</param>
            <exception cref="T:System.IO.IOException">if there is a problem writing the molecule</exception>
        </member>
        <member name="T:NCDK.IO.IChemObjectIO">
            <summary>
            This class is the interface that all IO readers should implement.
            Programs need only care about this interface for any kind of IO.
            Currently, database IO and file IO is supported.
            
            The easiest way to implement a new <see cref="T:NCDK.IO.IChemObjectReader"/> is to
            subclass the <see cref="T:NCDK.IO.DefaultChemObjectReader"/>.
            </summary>
            <seealso cref="T:NCDK.IO.DefaultChemObjectReader"/>
        </member>
        <member name="P:NCDK.IO.IChemObjectIO.Format">
            <summary>
            Returns the <see cref="T:NCDK.IO.Formats.IResourceFormat"/> class for this IO class.
            </summary>
        </member>
        <member name="M:NCDK.IO.IChemObjectIO.Accepts(System.Type)">
            <summary>
            Returns whether the given <see cref="T:NCDK.IChemObject"/> can be read or written.
            </summary>
            <param name="type"> classObject <see cref="T:NCDK.IChemObject"/> of which is tested if it can be handled.</param>
            <returns>true, if the <see cref="T:NCDK.IChemObject"/> can be handled.</returns>
        </member>
        <member name="M:NCDK.IO.IChemObjectIO.Close">
            <summary>
            Closes this IChemObjectIO's resources.
            </summary>
            <exception cref="T:System.IO.IOException">when the wrapper IO class cannot be closed.</exception>
        </member>
        <member name="P:NCDK.IO.IChemObjectIO.IOSettings">
            <summary>
             Access a named setting managed by this reader/writer.
            </summary>
        </member>
        <member name="P:NCDK.IO.IChemObjectIO.Listeners">
            <summary>
            Access all the listeners for this ChemObject Reader or Writer.
            </summary>
        </member>
        <member name="F:NCDK.IO.ChemObjectReaderModes.Relaxed">
            <summary>Only fail on serious format problems</summary>
        </member>
        <member name="F:NCDK.IO.ChemObjectReaderModes.Strict">
            <summary>Fail on any format problem</summary>
        </member>
        <member name="T:NCDK.IO.IChemObjectReader">
             <summary>
             This interface specifies the common functionality all IO readers should provide.
            
             IO readers should not implement this interface directly, but rather implement
             one of its child interfaces: <see cref="T:NCDK.IO.ISimpleChemObjectReader"/> or <see cref="T:NCDK.IO.Iterator.IEnumerableChemObjectReader`1"/>.
             These sub-interfaces specify the information access methods:
             a simple Read() method for the <see cref="T:NCDK.IO.ISimpleChemObjectReader"/> and
             more advanced iterator based access for the <see cref="T:NCDK.IO.Iterator.IEnumerableChemObjectReader`1"/> (suitable for large files)
             </summary>
             <seealso cref="T:NCDK.IO.ISimpleChemObjectReader"/>
             <seealso cref="T:NCDK.IO.Iterator.IEnumerableChemObjectReader`1"/>
        </member>
        <member name="P:NCDK.IO.IChemObjectReader.ReaderMode">
            <summary>
            The reader mode. If <see cref="F:NCDK.IO.ChemObjectReaderModes.Strict"/>, then the reader will fail on
            any problem in the format of the read file, instead of trying to
            recover from that.
            </summary>
        </member>
        <member name="P:NCDK.IO.IChemObjectReader.ErrorHandler">
            <summary>
            An error handler that is sent events when file format issues occur.
            </summary>
        </member>
        <member name="M:NCDK.IO.IChemObjectReader.HandleError(System.String)">
            <summary>
            Redirects an error message to the <see cref="T:NCDK.IO.IChemObjectReaderErrorHandler"/>.
            Throws an <see cref="T:NCDK.CDKException"/> when in Strict <see cref="T:NCDK.IO.ChemObjectReaderModes"/>.
            </summary>
            <param name="message">the error message.</param>
        </member>
        <member name="M:NCDK.IO.IChemObjectReader.HandleError(System.String,System.Exception)">
            <summary>
            Redirects an error message to the <see cref="T:NCDK.IO.IChemObjectReaderErrorHandler"/>.
            Throws an <see cref="T:NCDK.CDKException"/> when in Strict <see cref="T:NCDK.IO.ChemObjectReaderModes"/>.
            </summary>
            <param name="message">the error message.</param>
            <param name="exception">the corresponding <see cref="T:System.Exception"/>.</param>
        </member>
        <member name="M:NCDK.IO.IChemObjectReader.HandleError(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            Redirects an error message to the <see cref="T:NCDK.IO.IChemObjectReaderErrorHandler"/>.
            Throws an <see cref="T:NCDK.CDKException"/> when in Strict <see cref="T:NCDK.IO.ChemObjectReaderModes"/>.
            </summary>
            <param name="message">the error message.</param>
            <param name="row">Row in the file where the error is found.</param>
            <param name="colStart">Start column in the file where the error is found.</param>
            <param name="colEnd">End column in the file where the error is found.</param>
        </member>
        <member name="M:NCDK.IO.IChemObjectReader.HandleError(System.String,System.Int32,System.Int32,System.Int32,System.Exception)">
            <summary>
            Redirects an error message to the <see cref="T:NCDK.IO.IChemObjectReaderErrorHandler"/>.
            Throws an <see cref="T:NCDK.CDKException"/> when in <see cref="F:NCDK.IO.ChemObjectReaderModes.Strict"/>.
            </summary>
            <param name="message">the error message.</param>
            <param name="exception">the corresponding <see cref="T:System.Exception"/>.</param>
            <param name="row">Row in the file where the error is found.</param>
            <param name="colStart">Start column in the file where the error is found.</param>
            <param name="colEnd">End column in the file where the error is found.</param>
        </member>
        <member name="T:NCDK.IO.IChemObjectReaderErrorHandler">
            <summary>
            Interface for classes aimed to handle <see cref="T:NCDK.IO.IChemObjectReader"/> errors.
            </summary>
        </member>
        <member name="M:NCDK.IO.IChemObjectReaderErrorHandler.HandleError(System.String)">
            <summary>
            Method that should react on an error message send by an
            <see cref="T:NCDK.IO.IChemObjectReader"/>.
            </summary>
            <param name="message">Error found while reading.</param>
        </member>
        <member name="M:NCDK.IO.IChemObjectReaderErrorHandler.HandleError(System.String,System.Exception)">
            <summary>
            Method that should react on an error message send by an
            <see cref="T:NCDK.IO.IChemObjectReader"/>.
            </summary>
            <param name="message">Error found while reading.</param>
            <param name="exception">Exception thrown while reading.</param>
        </member>
        <member name="M:NCDK.IO.IChemObjectReaderErrorHandler.HandleError(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            Method that should react on an error message send by an
            <see cref="T:NCDK.IO.IChemObjectReader"/>.
            </summary>
            <param name="message">Error found while reading.</param>
            <param name="row">Row in the file where the error is found.</param>
            <param name="colStart">Start column in the file where the error is found.</param>
            <param name="colEnd">End column in the file where the error is found.</param>
        </member>
        <member name="M:NCDK.IO.IChemObjectReaderErrorHandler.HandleError(System.String,System.Int32,System.Int32,System.Int32,System.Exception)">
            <summary>
            Method that should react on an error message send by an
            <see cref="T:NCDK.IO.IChemObjectReader"/>.
            </summary>
            <param name="message">Error found while reading.</param>
            <param name="row"></param>
            <param name="colStart">Start column in the file where the error is found.</param>
            <param name="colEnd">End column in the file where the error is found.</param>
            <param name="exception">Exception thrown while reading.</param>
        </member>
        <member name="T:NCDK.IO.IChemObjectWriter">
            <summary>
            This class is the interface that all IO writers should implement.
            Programs need only care about this interface for any kind of IO.
            <para>
            Currently, database IO and file IO is supported. Internet IO is expected.</para>
            </summary>
        </member>
        <member name="M:NCDK.IO.IChemObjectWriter.Write(NCDK.IChemObject)">
            <summary>
            Writes the content of "object" to output.
            </summary>
            <param name="obj">the object of which the content is outputted</param>
            <exception cref="T:NCDK.CDKException">is thrown if the output does not support the data in the object</exception>
        </member>
        <member name="T:NCDK.IO.Setting.ISetting">
            <summary>
            A simple setting that can be managed by the SettingManager.Currently the only
            required method is <see cref="P:NCDK.IO.Setting.ISetting.Name"/> and provides the key with which setting are
            added and retrieved with.    
            </summary>
            <seealso cref="T:NCDK.IO.Setting.SettingManager`1"/>
        </member>
        <member name="P:NCDK.IO.Setting.ISetting.Name">
            <summary>
            The name of the setting.
            </summary>
        </member>
        <member name="T:NCDK.IO.Setting.BooleanIOSetting">
            <summary>
            An class for a reader setting which must be of type string.
            </summary>
        </member>
        <member name="P:NCDK.IO.Setting.BooleanIOSetting.Setting">
            <summary>
            Sets the setting for a certain question. The setting
            is a bool, and it accepts only "true" and "false".
            </summary>
        </member>
        <member name="T:NCDK.IO.Setting.IntegerIOSetting">
            <summary>
            An class for a reader setting which must be of type string.
            </summary>
        </member>
        <member name="P:NCDK.IO.Setting.IntegerIOSetting.Setting">
            <summary>
            Sets the setting for a certain question. The setting
            is a bool, and it accepts only "true" and "false".
            </summary>
        </member>
        <member name="T:NCDK.IO.Setting.IOSetting">
            <summary>
            An interface for reader settings. It is subclassed by implementations,
            one for each type of field, e.g. IntReaderSetting.
            </summary>
        </member>
        <member name="M:NCDK.IO.Setting.IOSetting.#ctor(System.String,NCDK.IO.Setting.IOSetting.Importance,System.String,System.String)">
            <summary>
            The default constructor that sets this field. All textual
            information is supposed to be English. Localization is taken care
            off by the ReaderConfigurator.
            </summary>
            <param name="name">Name of the setting</param>
            <param name="level">Level at which question is asked</param>
            <param name="question">Question that is popped to the user when the ReaderSetting needs setting</param>
            <param name="defaultSetting">The default setting, used if not overwritten by a user</param>
        </member>
        <member name="P:NCDK.IO.Setting.IOSetting.Setting">
            <summary>
            The setting for a certain question. It will throw a CDKException when the setting is not valid.
            </summary>
        </member>
        <member name="T:NCDK.IO.Setting.OptionIOSetting">
            <summary>
            An class for a reader setting which must be found in the list of possible settings.
            </summary>
        </member>
        <member name="M:NCDK.IO.Setting.OptionIOSetting.#ctor(System.String,NCDK.IO.Setting.IOSetting.Importance,System.String,System.Collections.Generic.List{System.String},System.String)">
            <summary>
            OptionIOSetting is IOSetting for which the value must be in the list of possible options.
            </summary>
            <param name="name"></param>
            <param name="level"></param>
            <param name="question"></param>
            <param name="settings"></param>
            <param name="defaultSetting"></param>
        </member>
        <member name="M:NCDK.IO.Setting.OptionIOSetting.SetSetting(System.String)">
            <summary>
            Sets the setting for a certain question.
            </summary>
            <param name="setting"></param>
            <exception cref="T:NCDK.CDKException">when the setting is not valid.</exception>
        </member>
        <member name="M:NCDK.IO.Setting.OptionIOSetting.SetSetting(System.Int32)">
            <summary>
            Sets the setting for a certain question. 
            The first setting is setting 1.
            </summary>
            <param name="setting"></param>
            <exception cref="T:NCDK.CDKException">when the setting is not valid.</exception>
        </member>
        <member name="M:NCDK.IO.Setting.OptionIOSetting.GetOptions">
            <summary>
            Returns a Vector of Strings containing all possible options.
            </summary>
            <returns></returns>
        </member>
        <member name="T:NCDK.IO.Setting.SettingManager`1">
            <summary>
            Provides dynamic management of settings. This
            was created with the intention of managing <see cref="T:NCDK.IO.Setting.IOSetting" />'s for <see cref="T:NCDK.IO.IChemObjectIO" /> 
            however it could be recycled for other purposes where dynamic settings are required.
            Settings are stored in a <see cref="T:System.Collections.Generic.IDictionary`2" /> using the name of the setting as the key. The name is
            normalised (lowercase and whitespace removal) to allow 'fuzzy' setting access. This means
            that character case differences do not affect the retrieval of objects.
            </summary>
            <example>
            <code>                // create the manager and add a setting
                var manager = new SettingManager&lt;BooleanIOSetting&gt;();
                manager.Add(new BooleanIOSetting("Sample", IOSetting.Importance.Medium, "This is a sample?", "true"));

                // check the setting is present (case insensitive)
                if (manager.Has("sample"))
                {
                    // access requiring multiple lines of code
                    BooleanIOSetting setting = manager["sample"];
                    string v1 = setting.Setting;
                    // single line access (useful for conditional statements)
                    string v2 = manager["sample"].Setting;
                }
</code>
            </example>
            <typeparam name="T">the type of setting that will be managed (e.g. IOSetting).</typeparam>
            <seealso cref="T:NCDK.IO.Setting.ISetting" />
            <seealso cref="T:NCDK.IO.Setting.IOSetting" />
        </member>
        <member name="F:NCDK.IO.Setting.SettingManager`1.regex_WhiteSpace">
            <summary>
            Uses to remove white space from names.
            </summary>
            <seealso cref="M:NCDK.IO.Setting.SettingManager`1.MakeKey(NCDK.IO.Setting.ISetting)"/>
            <seealso cref="M:NCDK.IO.Setting.SettingManager`1.MakeKey(System.String)"/>
        </member>
        <member name="F:NCDK.IO.Setting.SettingManager`1.settings">
            <summary>
            Settings are stored in a map of name -> instance.
            </summary>
        </member>
        <member name="M:NCDK.IO.Setting.SettingManager`1.MakeKey(System.String)">
            <summary>
            Generate a simple key for the given name. This method normalises the name by
            converting to lower case and replacing spaces with '.' (e.g. "Buffer Size" is
            converted to "buffer.size").
            </summary>
            <param name="name">the name of a setting</param>
            <returns>keyed setting name</returns>
        </member>
        <member name="M:NCDK.IO.Setting.SettingManager`1.MakeKey(NCDK.IO.Setting.ISetting)">
            <summary>
            Generate a simple key for the given setting. This method is a convenience
            method for <see cref="M:NCDK.IO.Setting.SettingManager`1.MakeKey(System.String)"/>
            </summary>
            <param name="setting">setting the setting to which a key will be generated for</param>
            <returns>the keyed name for the setting</returns>
        </member>
        <member name="M:NCDK.IO.Setting.SettingManager`1.Add``1(``0)">
             <summary>
             Add a setting to the manager and return the instance to use. If a 'new' setting is added
             to the manager which matches the name and class of an previously added 'original' setting,
             the original setting will be returned. Otherwise the new setting is returned. This allows
             the add to be used in assignments as follows:
             </summary>
             <example>
             <code>                var manager = new SettingManager&lt;BooleanIOSetting&gt;();
                BooleanIOSetting setting1 = manager.Add(new BooleanIOSetting("use.3d", importance, some, some));
                BooleanIOSetting setting2 = manager.Add(new BooleanIOSetting("use.3d", importance, some, some));

                // setting1 == setting2 and so changing a field in setting1 will also change the field
                // in setting2
</code>
             If the names are not equal or the names are equal but the classes are not the new setting
             is added and returned.
            </example>
             <typeparam name="TT" />
             <param name="setting">the setting to add</param>
             <returns>usable setting</returns>
        </member>
        <member name="P:NCDK.IO.Setting.SettingManager`1.Item(System.String)">
            <summary>
            Access the setting stored for given name. If not setting is found the provided
            name an <see cref="T:System.ArgumentException" /> will be thrown. The method is generic
            to allow simplified access to settings. This however means that if the incorrect
            type is provided a <see cref="T:System.InvalidCastException" /> may be thrown.
            </summary>
            <example>
            <code>                var manager = new SettingManager&lt;BooleanIOSetting&gt;();
                manager.Add(new BooleanIOSetting("name", importance, some, some));

                BooleanIOSetting setting1 = manager["Name"]; // okay
                // OptionIOSetting setting2 = manager["Name"]; // failed to compile
</code>
            </example>
            <param name="name">name of the setting to retrieve</param>
            <returns>instance of the setting for the provided name</returns>
        </member>
        <member name="M:NCDK.IO.Setting.SettingManager`1.Has(System.String)">
            <summary>
            Determines whether the manager currently holds a setting of
            the provided name.
            </summary>
            <param name="name">name of the setting</param>
            <returns>whether the manager currently contains the desired setting</returns>
        </member>
        <member name="P:NCDK.IO.Setting.SettingManager`1.Settings">
            <summary>
            Access a collection of all settings in the manager.
            </summary>
            <returns>collection of managed settings</returns>
        </member>
        <member name="T:NCDK.IO.Setting.StringIOSetting">
            <summary>
            An class for a reader setting which must be of type string.
            </summary>
        </member>
        <member name="P:NCDK.IO.Setting.StringIOSetting.Setting">
            <summary>
            Sets the setting for a certain question. The setting
            is of type string, and any string is accepted.
            </summary>
        </member>
        <member name="T:NCDK.IO.ISimpleChemObjectReader">
            <summary>
            This class is the interface that all IO readers should implement.
            Programs need only care about this interface for any kind of IO.
            Currently, database IO and file IO is supported.
            <para>
            The easiest way to implement a new ChemObjectReader is to
            subclass the DefaultChemObjectReader.
            </para>
            <para>
            I don't know how this should be enforced, but a Reader should
            also provide an empty constructor so that ClassLoader/Instance
            can be used to instantiate a ChemObjectReader.
            </para>
            </summary>
            <seealso cref="T:NCDK.IO.DefaultChemObjectReader"/>
        </member>
        <member name="M:NCDK.IO.ISimpleChemObjectReader.Read``1(``0)">
            <summary>
            Reads an IChemObject of type "object" from input. The constructor
            of the actual implementation may take a Reader as input to get
            a very flexible reader that can read from string, files, etc.
            </summary>
            <param name="obj">the type of object to return</param>
            <returns>returns an object of that contains the content (or part) of the input content</returns>
            <exception cref="T:NCDK.CDKException">it is thrown if the type of information is not available from the input</exception>
        </member>
        <member name="T:NCDK.IO.Listener.IChemObjectIOListener">
            <summary>
            Allows monitoring of progress of file reader activities.
            </summary>
        </member>
        <member name="M:NCDK.IO.Listener.IChemObjectIOListener.ProcessIOSettingQuestion(NCDK.IO.Setting.IOSetting)">
            <summary>
            Prompted when the IO filter needs information to process the
            file. The ReaderListener may redirect this question to the
            user, disregard it (and let the Reader take the default),
            or answer it itself.
            </summary>
        </member>
        <member name="T:NCDK.IO.Listener.IReaderListener">
            <summary>
            Allows monitoring of progress of file reader activities.
            </summary>
        </member>
        <member name="M:NCDK.IO.Listener.IReaderListener.FrameRead(NCDK.IO.ReaderEvent)">
            <summary>
            Indicates that a new frame has been read.
            </summary>
            <param name="event">information about the event.</param>
        </member>
        <member name="T:NCDK.IO.Listener.IWriterListener">
            <summary>
            Allows monitoring of progress of writing activities.
            </summary>
        </member>
        <member name="T:NCDK.IO.Listener.PropertiesListener">
            <summary>
            Answers the questions by looking up the values in a Properties
            object. The question names match the property field names.
            If no answer is found in the Property object, or if the value
            is invalid, then the default is taken.
            </summary>
            <remarks>
            For the GaussianInputWriter the properties file might look like:
            <pre>
            Basis=6-31g
            Method=b3lyp
            Command=geometry optimization
            </pre>
            </remarks>
        </member>
        <member name="P:NCDK.IO.Listener.PropertiesListener.OutputWriter">
            <summary>
            Overwrites the default writer to which the output is directed.
            </summary>
        </member>
        <member name="M:NCDK.IO.Listener.PropertiesListener.ProcessIOSettingQuestion(NCDK.IO.Setting.IOSetting)">
            <summary>
            Processes the IOSettings by listing the question, giving the options
            and asking the user to provide their choice.
            </summary>
            <remarks>
            Note: if the input reader is <see langword="null"/>, then the method
            does not wait for an answer, and takes the default.</remarks>
        </member>
        <member name="T:NCDK.IO.Listener.TextGUIListener">
            <summary>
            Allows processing of IOSetting quesions which are passed to the user
            by using the System.out and System.in by default.
            </summary>
            <remarks>
            This listener can also be used to list all the questions a ChemObjectWriter
            has, by using a dummy StringWriter, and a <see langword="null"/> Reader.
            </remarks>
        </member>
        <member name="M:NCDK.IO.Listener.TextGUIListener.SetOutputWriter(System.IO.TextWriter)">
            <summary>
            Overwrites the default writer to which the output is directed.
            </summary>
        </member>
        <member name="M:NCDK.IO.Listener.TextGUIListener.SetInputReader(System.IO.TextReader)">
            <summary>
            Overwrites the default reader from which the input is taken.
            </summary>
        </member>
        <member name="M:NCDK.IO.Listener.TextGUIListener.ProcessIOSettingQuestion(NCDK.IO.Setting.IOSetting)">
            <summary>
            Processes the IOSettings by listing the question, giving the options
            and asking the user to provide their choice.
            </summary>
            <remarks>
            Note: if the input reader is <see langword="null"/>, then the method
            does not wait for an answer, and takes the default.</remarks>
        </member>
        <member name="T:NCDK.IO.MDLReader">
            <summary>
            Reads a molecule from the original MDL MOL or SDF file <token>cdk-cite-DAL92</token>. An SD files
            is read into a <see cref="T:NCDK.IChemSequence"/> of <see cref="T:NCDK.IChemModel"/>'s. Each ChemModel will contain one
            Molecule. If the MDL molfile contains a property block, the <see cref="T:NCDK.IO.MDLV2000Reader"/> should be
            used.
            <para>
            If all z coordinates are 0.0, then the xy coordinates are taken as
            2D, otherwise the coordinates are read as 3D.
            </para>
            <para>
            The title of the MOL file is read and can be retrieved with:
            <code>
              molecule.GetProperty&lt;string&gt;(CDKPropertyName.Title);
            </code>
            </para>
            </summary>
            <seealso cref="T:NCDK.IO.MDLV2000Reader"/>
        </member>
        <member name="M:NCDK.IO.MDLReader.#ctor(System.IO.Stream)">
            <summary>
             Constructs a new MDLReader that can read Molecule from a given Stream.
            </summary>
            <param name="input">The Stream to read from</param>
        </member>
        <member name="M:NCDK.IO.MDLReader.#ctor(System.IO.TextReader)">
            <summary>
            Constructs a new MDLReader that can read Molecule from a given Reader.
            </summary>
            <param name="input">The Reader to read from</param>
        </member>
        <member name="M:NCDK.IO.MDLReader.Read``1(``0)">
            <summary>
             Takes an object which subclasses <see cref="T:NCDK.IChemObject"/>, e.g. Molecule, and will read
             this (from file, database, internet etc). If the specific implementation
             does not support a specific <see cref="T:NCDK.IChemObject"/> it will throw an Exception.
            </summary>
            <param name="obj">The object that subclasses <see cref="T:NCDK.IChemObject"/></param>
            <returns>The IChemObject read</returns>
            <exception cref="T:NCDK.CDKException"></exception>
        </member>
        <member name="M:NCDK.IO.MDLReader.ReadChemFile(NCDK.IChemFile)">
            <summary>
            Read a ChemFile from a file in MDL SDF format.
            </summary>
            <returns>The ChemFile that was read from the MDL file.</returns>
        </member>
        <member name="M:NCDK.IO.MDLReader.ReadMolecule(NCDK.IAtomContainer)">
            <summary>
             Read a Molecule from a file in MDL sd format
            </summary>
            <returns>The Molecule that was read from the MDL file.</returns>
        </member>
        <member name="T:NCDK.IO.MDLRXNReader">
            <summary>
            Reads a molecule from an MDL RXN file <token>cdk-cite-DAL92</token>.
            </summary>
        </member>
        <member name="M:NCDK.IO.MDLRXNReader.#ctor(System.IO.TextReader)">
            <summary>
            Constructs a new MDLReader that can read Molecule from a given Reader.
            </summary>
            <param name="ins">The Reader to read from</param>
        </member>
        <member name="M:NCDK.IO.MDLRXNReader.Read``1(``0)">
            <summary>
            Takes an object which subclasses IChemObject, e.g.Molecule, and will read
            this (from file, database, internet etc). If the specific implementation
            does not support a specific <see cref="T:NCDK.IChemObject"/> it will throw an Exception.
            </summary>
            <param name="obj">The object that subclasses <see cref="T:NCDK.IChemObject"/></param>
            <returns>The IChemObject read</returns>
            <exception cref="T:NCDK.CDKException"></exception>
        </member>
        <member name="M:NCDK.IO.MDLRXNReader.ReadChemFile(NCDK.IChemFile)">
            <summary>
            Read a ChemFile from a file in MDL RDF format.
            </summary>
            <param name="chemFile">The IChemFile</param>
            <returns>The IChemFile that was read from the RDF file.</returns>
        </member>
        <member name="M:NCDK.IO.MDLRXNReader.ReadChemModel(NCDK.IChemModel)">
            <summary>
            Read a IChemModel from a file in MDL RDF format.
            </summary>
            <param name="chemModel">The IChemModel</param>
            <returns>The IChemModel that was read from the RDF file</returns>
        </member>
        <member name="M:NCDK.IO.MDLRXNReader.ReadReactionSet(NCDK.IReactionSet)">
             <summary>
             Read a IReactionSet from a file in MDL RDF format.
            
             <param name="setOfReactions">The IReactionSet</param>
             <returns>The IReactionSet that was read from the RDF file</returns>
             </summary>
        </member>
        <member name="M:NCDK.IO.MDLRXNReader.ReadReaction(NCDK.IChemObjectBuilder)">
             <summary>
             Read a Reaction from a file in MDL RXN format
            
             <returns>The Reaction that was read from the MDL file.</returns>
             </summary>
        </member>
        <member name="T:NCDK.IO.MDLRXNV2000Reader">
            <summary>
            Reads a molecule from an MDL RXN file <token>cdk-cite-DAL92</token>.
            This MDL RXN reader uses the MDLV2000 reader to read each mol file
            </summary>
        </member>
        <member name="M:NCDK.IO.MDLRXNV2000Reader.#ctor(System.IO.TextReader)">
            <summary>
            Constructs a new MDLReader that can read Molecule from a given Reader.
            </summary>
            <param name="input">The Reader to read from</param>
        </member>
        <member name="M:NCDK.IO.MDLRXNV2000Reader.Read``1(``0)">
            <summary>
            Takes an object which subclasses IChemObject, e.g.Molecule, and will read
            this (from file, database, Internet etc). If the specific implementation
            does not support a specific IChemObject it will throw an Exception.
            </summary>
            <param name="obj">The object that subclasses <see cref="T:NCDK.IChemObject"/></param>
            <returns>The <see cref="T:NCDK.IChemObject"/> read</returns>
            <exception cref="T:NCDK.CDKException"></exception>
        </member>
        <member name="M:NCDK.IO.MDLRXNV2000Reader.ReadReaction(NCDK.IChemObjectBuilder)">
            <summary>
            Read a Reaction from a file in MDL RXN format
            </summary>
            <returns>The Reaction that was read from the MDL file.</returns>
        </member>
        <member name="T:NCDK.IO.MDLRXNV3000Reader">
            <summary>
            Class that implements the new MDL mol format introduced in August 2002.
            The overall syntax is compatible with the old format, but I consider
            the format completely different, and thus implemented a separate Reader
            for it.
            </summary>
        </member>
        <member name="M:NCDK.IO.MDLRXNV3000Reader.ReadCommand">
            <summary>
            Reads the command on this line. If the line is continued on the next, that
            part is added.
            </summary>
            <returns>the command on this line.</returns>
        </member>
        <member name="T:NCDK.IO.MDLRXNWriter">
            <summary>
            Writes a reaction to a MDL rxn or SDF file. Attention: Stoichiometric
            coefficients have to be natural numbers.
            </summary>
            <example>
            <code>                using (var srm = new FileStream("output.mol", FileMode.Create))
                using (MDLRXNWriter writer = new MDLRXNWriter(srm))
                {
                    writer.Write(molecule);
                }
</code>
            </example>
            <remarks>
            See <token>cdk-cite-DAL92</token>.
            </remarks>
        </member>
        <member name="M:NCDK.IO.MDLRXNWriter.#ctor(System.IO.TextWriter)">
            <summary>
            Constructs a new MDLWriter that can write an array of
            Molecules to a Writer.
            </summary>
            <param name="output">The Writer to write to</param>
        </member>
        <member name="M:NCDK.IO.MDLRXNWriter.#ctor(System.IO.Stream)">
            <summary>
            Constructs a new MDLWriter that can write an array of
            Molecules to a given Stream.
            </summary>
            <param name="output">The Stream to write to</param>
        </member>
        <member name="M:NCDK.IO.MDLRXNWriter.SetRdFields(System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Here you can set a map which will be used to build rd fields in the file.
            The entries will be translated to rd fields like this:
            <pre>
            &gt; &lt;key&gt;
            &gt; value
            empty line
            </pre>
            </summary>
            <param name="map">The map to be used, map of string-string pairs</param>
        </member>
        <member name="M:NCDK.IO.MDLRXNWriter.Write(NCDK.IChemObject)">
            <summary>
            Writes a IChemObject to the MDL RXN file formated output.
            It can only output ChemObjects of type Reaction
            </summary>
            <param name="obj">class must be of type Molecule or MoleculeSet.</param>
            <seealso cref="T:NCDK.IChemFile"/> 
        </member>
        <member name="M:NCDK.IO.MDLRXNWriter.WriteReactionSet(NCDK.IReactionSet)">
            <summary>
             Writes an array of Reaction to an Stream in MDL rdf format.
            </summary>
            <param name="reactions">Array of Reactions that is written to an Stream</param>
        </member>
        <member name="M:NCDK.IO.MDLRXNWriter.WriteReaction(NCDK.IReaction)">
            <summary>
            Writes a Reaction to an Stream in MDL sdf format.
            </summary>
            <param name="reaction">A Reaction that is written to an Stream</param>
        </member>
        <member name="M:NCDK.IO.MDLRXNWriter.WriteAtomContainerSet(NCDK.IChemObjectSet{NCDK.IAtomContainer})">
            <summary>
            Writes a MoleculeSet to an Stream for the reaction.
            </summary>
            <param name="som">The MoleculeSet that is written to an Stream</param>
        </member>
        <member name="M:NCDK.IO.MDLRXNWriter.FormatMDLInt(System.Int32,System.Int32)">
            <summary>
            Formats an int to fit into the connectiontable and changes it
            to a string.
            </summary>
            <param name="i">The int to be formated</param>
            <param name="l">Length of the string</param>
            <returns>The string to be written into the connectiontable</returns>
        </member>
        <member name="T:NCDK.IO.MDLV2000Reader">
            <summary>
            Reads content from MDL molfiles and SD files. It can read a <see cref="T:NCDK.IAtomContainer"/>
            or <see cref="T:NCDK.IChemModel"/> from an MDL molfile, and a <see cref="T:NCDK.IChemFile"/>
             from a SD file, with a <see cref="T:NCDK.IChemSequence"/> of <see cref="T:NCDK.IChemModel"/>'s, 
             where each IChemModel will contain one <see cref="T:NCDK.IAtomContainer"/>.
            <para>
            From the Atom block it reads atomic coordinates, element types and formal
            charges. From the Bond block it reads the bonds and the orders. Additionally,
            it reads 'M  CHG', 'G  ', 'M  RAD' and 'M  ISO' lines from the property
            block.
            </para>
            <para>
            If all z coordinates are 0.0, then the xy coordinates are taken as 2D,
            otherwise the coordinates are read as 3D.
            </para>
            <para>The title of the MOL file is read and can be retrieved with:
            <code>
              molecule.GetProperty&lt;string&gt;(CDKPropertyName.Title);
            </code>
            </para>
            <para>RGroups which are saved in the MDL molfile as R#, are renamed according to
            their appearance, e.g. the first R# is named R1. With PseudAtom.Label
            "R1" is returned (instead of R#). This is introduced due to the SAR table
            generation procedure of Scitegics PipelinePilot.
            </para>
            </summary>
        </member>
        <member name="F:NCDK.IO.MDLV2000Reader.RECORD_DELIMITER">
            <summary>Delimits Structure-Data (SD) Files.</summary>
        </member>
        <member name="F:NCDK.IO.MDLV2000Reader.PseudoLabels">
            <summary>Valid pseudo labels.</summary>
        </member>
        <member name="M:NCDK.IO.MDLV2000Reader.#ctor(System.IO.Stream)">
            <summary>
            Constructs a new <see cref="T:NCDK.IO.MDLReader"/> that can read Molecule from a given <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="input">The Stream to read from</param>
        </member>
        <member name="M:NCDK.IO.MDLV2000Reader.#ctor(System.IO.TextReader)">
            <summary>
            Constructs a new <see cref="T:NCDK.IO.MDLReader"/> that can read Molecule from a given <see cref="T:System.IO.TextReader"/>.
            </summary>
            <param name="input">The Reader to read from</param>
        </member>
        <member name="M:NCDK.IO.MDLV2000Reader.Read``1(``0)">
            <summary>
            Takes an object which subclasses IChemObject, e.g. Molecule, and will
            read this (from file, database, internet etc). If the specific
            implementation does not support a specific IChemObject it will throw an
            Exception.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="obj">The object that subclasses IChemObject</param>
            <returns>The IChemObject read</returns>
        </member>
        <member name="M:NCDK.IO.MDLV2000Reader.ReadChemFile(NCDK.IChemFile)">
            <summary>
            Read a ChemFile from a file in MDL SDF format.
            </summary>
            <param name="chemFile"></param>
            <returns>The <see cref="T:NCDK.IChemFile"/> that was read from the MDL file.</returns>
        </member>
        <member name="M:NCDK.IO.MDLV2000Reader.NewModel(NCDK.IAtomContainer)">
            <summary>
            Create a new chem model for a single <see cref="T:NCDK.IAtomContainer"/>.
            </summary>
            <param name="container">the container to create the model for</param>
            <returns>a new <see cref="T:NCDK.IChemModel"/></returns>
        </member>
        <member name="M:NCDK.IO.MDLV2000Reader.ReadAtomContainer(NCDK.IAtomContainer)">
            <summary>
            Read an IAtomContainer from a file in MDL sd format
            </summary>
            <param name="molecule"></param>
            <returns>The Molecule that was read from the MDL file.</returns>
        </member>
        <member name="M:NCDK.IO.MDLV2000Reader.ApplyMDLValenceModel(NCDK.IAtom,System.Int32,System.Int32)">
            <summary>
            Applies the MDL valence model to atoms using the explicit valence (bond
            order sum) and charge to determine the correct number of implicit
            hydrogens. The model is not applied if the explicit valence is less than
            0 - this is the case when a query bond was read for an atom.
            </summary>
            <param name="atom">the atom to apply the model to</param>
            <param name="explicitValence">the explicit valence (bond order sum)</param>
        </member>
        <member name="M:NCDK.IO.MDLV2000Reader.ReadAtomFast(System.String,NCDK.IChemObjectBuilder,System.Collections.Generic.IDictionary{NCDK.IAtom,System.Int32},System.Int32)">
            <summary>
            Parse an atom line from the atom block using the format: 
            <pre>xxxxx.xxxxyyyyy.yyyyzzzzz.zzzz aaaddcccssshhhbbbvvvHHHrrriiimmmnnneee</pre>
            where: <list type="bullet"> <item>x: x coordinate</item> <item>y: y coordinate</item> <item>z: z
            coordinate</item> <item>a: atom symbol</item> <item>d: mass difference</item>
            <item>c: charge</item> <item>s: stereo parity</item> <item>h: hydrogen count + 1
            (not read - query)</item> <item>b: stereo care (not read - query)</item> <item>v:
            valence</item> <item>H: H0 designator (not read - query)</item> <item>r: not
            used</item> <item>i: not used</item> <item>m: atom reaction mapping</item> <item>n:
            inversion/retention flag</item> <item>e: exact change flag</item> </list>
            
            The parsing is strict and does not allow extra columns (i.e. NMR shifts)
            malformed input.
            </summary>
            <param name="line">input line</param>
            <param name="builder">chem object builder to create the atom</param>
            <param name="parities">map of atom parities for creation 0D stereochemistry</param>
            <param name="lineNum">the line number - for printing error messages</param>
            <returns>a new atom instance</returns>
        </member>
        <member name="M:NCDK.IO.MDLV2000Reader.ReadBondFast(System.String,NCDK.IChemObjectBuilder,NCDK.IAtom[],System.Int32[],System.Int32)">
            <summary>
            Read a bond from a line in the MDL bond block. The bond block is
            formatted as follows, <pre>111222tttsssxxxrrrccc</pre>, where:
            <list type="bullet">
                <item>111: first atom number</item>
                <item>222: second atom number</item>
                <item>ttt: bond type</item>
                <item>xxx: bond stereo</item>
                <item>rrr: bond topology</item>
                <item>ccc: reaction center</item>
            </list>
            </summary>
            <param name="line">the input line</param>
            <param name="builder">builder to create objects with</param>
            <param name="atoms">atoms read from the atom block</param>
            <param name="explicitValence">array to fill with explicit valence</param>
            <param name="lineNum">the input line number</param>
            <returns>a new bond</returns>
            <exception cref="T:NCDK.CDKException">if the input was malformed or didn't make sense</exception>
        </member>
        <member name="M:NCDK.IO.MDLV2000Reader.ReadPropertiesFast(System.IO.TextReader,NCDK.IAtomContainer,System.Int32)">
            <summary>
            Reads the property block from the <paramref name="input"/> setting the values in the
            container.
            </summary>
            <param name="input">input resource</param>
            <param name="container">the structure with atoms / bonds present</param>
            <param name="nAtoms">the number of atoms in the atoms block</param>
            <exception cref="T:System.IO.IOException">low-level IO error</exception>
        </member>
        <member name="M:NCDK.IO.MDLV2000Reader.ToStereo(System.Int32,System.Int32)">
            <summary>
            Convert an MDL V2000 stereo value to the CDK <see cref="T:NCDK.BondStereo"/>. The
            method should only be invoked for single/double bonds. If strict mode is
            enabled irrational bond stereo/types cause errors (e.g. up double bond).
            </summary>
            <param name="stereo">stereo value</param>
            <param name="type">bond type</param>
            <returns>bond stereo</returns>
            <exception cref="T:NCDK.CDKException">the stereo value was invalid (strict mode).</exception>
        </member>
        <member name="M:NCDK.IO.MDLV2000Reader.GetLength(System.String)">
            <summary>
            Determine the length of the line excluding trailing whitespace.
            </summary>
            <param name="str">a string</param>
            <returns> the length when trailing white space is removed</returns>
        </member>
        <member name="M:NCDK.IO.MDLV2000Reader.CreateAtom(System.String,NCDK.IChemObjectBuilder,System.Int32)">
            <summary>
            Create an atom for the provided symbol. If the atom symbol is a periodic
            element a new 'Atom' is created otherwise if the symbol is an allowed
            query atom ('R', 'Q', 'A', '*', 'L', 'LP') a new 'PseudoAtom' is created.
            If the symbol is invalid an exception is thrown.
            </summary>
            <param name="symbol">input symbol</param>
            <param name="builder">chem object builder</param>
            <param name="lineNum"></param>
            <returns>a new atom</returns>
            <exception cref="T:NCDK.CDKException">the symbol is not allowed</exception>
        </member>
        <member name="M:NCDK.IO.MDLV2000Reader.IsPseudoElement(System.String)">
            <summary>
            Is the atom symbol a non-periodic element (i.e. pseudo). Valid pseudo
            atoms are 'R#', 'A', 'Q', '*', 'L' and 'LP'. We also accept 'R' but this
            is not listed in the specification.
            </summary>
            <param name="symbol">a symbol from the input</param>
            <returns>the symbol is a valid pseudo element</returns>
        </member>
        <member name="M:NCDK.IO.MDLV2000Reader.ReadMDLCoordinate(System.String,System.Int32)">
            <summary>
            Read a coordinate from an MDL input. The MDL V2000 input coordinate has
            10 characters, 4 significant figures and is prefixed with whitespace for
            padding: 'xxxxx.xxxx'. Knowing the format allows us to use an optimised
            parser which does not consider exponents etc.
            </summary>
            <param name="line">input line</param>
            <param name="offset">first character of the coordinate</param>
            <returns>the specified value</returns>
            <exception cref="T:NCDK.CDKException">the coordinates specification was not valid</exception>
        </member>
        <member name="M:NCDK.IO.MDLV2000Reader.ToCharge(System.Char)">
            <summary>
            Convert the a character (from an MDL V2000 input) to a charge value:
            1 = +1, 2 = +2, 3 = +3, 4 = doublet radical, 5 = -1, 6 = -2, 7 = -3.
            </summary>
            <param name="c">a character</param>
            <returns>formal charge</returns>
        </member>
        <member name="M:NCDK.IO.MDLV2000Reader.Sign(System.Char)">
            <summary>
            Obtain the sign of the character, -1 if the character is '-', +1
            otherwise.
            </summary>
            <param name="c">a character</param>
            <returns>the sign</returns>
        </member>
        <member name="M:NCDK.IO.MDLV2000Reader.ToInt(System.Char)">
            <summary>
            Convert a character (ASCII code points) to an integer. If the character
            was not a digit (i.e. space) the value defaults to 0.
            </summary>
            <param name="c">a character</param>
            <returns>the numerical value</returns>
        </member>
        <member name="M:NCDK.IO.MDLV2000Reader.ReadUInt(System.String,System.Int32,System.Int32)">
            <summary>
            Read an unsigned int value from the given index with the expected number
            of digits.
            </summary>
            <param name="line">input line</param>
            <param name="index">start index</param>
            <param name="digits">number of digits (max)</param>
            <returns>an unsigned int</returns>
        </member>
        <member name="M:NCDK.IO.MDLV2000Reader.ReadMolfileInt(System.String,System.Int32)">
            <summary>
            Optimised method for reading a integer from 3 characters in a string at a
            specified index. MDL V2000 Molfile make heavy use of the 3 character ints
            in the atom/bond and property blocks. The integer may be signed and
            pre/post padded with white space.
            </summary>
            <param name="line">input</param>
            <param name="index">start index</param>
            <returns>the value specified in the string</returns>
        </member>
        <member name="M:NCDK.IO.MDLV2000Reader.Label(NCDK.IAtomContainer,System.Int32,System.String)">
            <summary>
            Labels the atom at the specified index with the provide label. If the
            atom was not already a pseudo atom then the original atom is replaced.
            </summary>
            <param name="container">structure</param>
            <param name="index">atom index to replace</param>
            <param name="label">the label for the atom</param>
            <seealso cref="P:NCDK.IPseudoAtom.Label"/>
        </member>
        <member name="M:NCDK.IO.MDLV2000Reader.ReadAtomSlow(System.String,NCDK.IChemObjectBuilder,System.Int32)">
            <summary>
            Reads an atom from the input allowing for non-standard formatting (i.e
            truncated lines) and chemical shifts.
            </summary>
            <param name="line">input line</param>
            <param name="builder">chem object builder</param>
            <param name="linecount">the current line count</param>
            <returns>an atom to add to a container</returns>
            <exception cref="T:NCDK.CDKException">a CDK error occurred</exception>
            <exception cref="T:System.IO.IOException">the isotopes file could not be read</exception>
        </member>
        <member name="M:NCDK.IO.MDLV2000Reader.ReadBondSlow(System.String,NCDK.IChemObjectBuilder,NCDK.IAtom[],System.Int32[],System.Int32)">
            <summary>
            Read a bond line from an MDL V2000 molfile bond block (slow). The
            explicit valence is also modified.
            </summary>
            <param name="line">the input from the bond block</param>
            <param name="builder">chem object builder</param>
            <param name="atoms">array of atoms</param>
            <param name="explicitValence">stores the explicit valence of each atom (bond order sum)</param>
            <param name="linecount">the current line count</param>
            <returns>a new bond</returns>
            <exception cref="T:NCDK.CDKException">the bond line could not be parsed</exception>
        </member>
        <member name="M:NCDK.IO.MDLV2000Reader.ReadPropertiesSlow(System.IO.TextReader,NCDK.IAtomContainer,System.Int32,System.Int32)">
            <summary>
            Read the properties from the V2000 block (slow).
            </summary>
            <param name="input">input source</param>
            <param name="container">the container with the atoms / bonds loaded</param>
            <param name="nAtoms">the number of atoms in the atom block</param>
            <param name="linecount">the line count</param>
            <exception cref="T:System.IO.IOException">internal low-level error</exception>
            <exception cref="T:NCDK.CDKException">the properties block could not be parsed</exception>
        </member>
        <member name="M:NCDK.IO.MDLV2000Reader.ReadNonStructuralData(System.IO.TextReader,NCDK.IAtomContainer)">
            <summary>
            Read non-structural data from input and store as properties the provided
            'container'. Non-structural data appears in a structure data file (SDF)
            after an Molfile and before the record deliminator ('$$$$'). The data
            consists of one or more Data Header and Data blocks, an example is seen
            below.
            <![CDATA[
            > 29 <DENSITY>
            0.9132 - 20.0
            
            > 29 <BOILING.POINT>
            63.0 (737 MM)
            79.0 (42 MM)
            
            > 29 <ALTERNATE.NAMES>
            SYLVAN
            
            > 29 <DATE>
            09-23-1980
            
            > 29 <CRC.NUMBER>
            F-0213
            
            ]]>
            </summary>
            <param name="input">input source</param>
            <param name="container">the container</param>
            <exception cref="T:System.IO.IOException">an error occur whilst reading the input</exception>
        </member>
        <member name="M:NCDK.IO.MDLV2000Reader.DataHeader(System.String)">
            <summary>
            Obtain the field name from a potential SD data header. If the header
            does not contain a field name, then null is returned. The method does
            not currently return field numbers (e.g. DT&lt;n&gt;).
            </summary>
            <param name="line">an input line</param>
            <returns>the field name</returns>
        </member>
        <member name="M:NCDK.IO.MDLV2000Reader.EndOfRecord(System.String)">
            <summary>
            Is the line the end of a record. A line is the end of a record if it
            is 'null' or is the SDF deliminator, '$$$$'.
            </summary>
            <param name="line">a line from the input</param>
            <returns>the line indicates the end of a record was reached</returns>
        </member>
        <member name="T:NCDK.IO.MDLV2000Reader.PropertyKey">
            <summary>
            Enumeration of property keys that can be specified in the V2000 property block.
            </summary>
        </member>
        <member name="F:NCDK.IO.MDLV2000Reader.PropertyKey.ATOM_ALIAS">
            <summary>Atom Alias.</summary>
        </member>
        <member name="F:NCDK.IO.MDLV2000Reader.PropertyKey.ATOM_VALUE">
            <summary>Atom Value.</summary>
        </member>
        <member name="F:NCDK.IO.MDLV2000Reader.PropertyKey.GROUP_ABBREVIATION">
            <summary>Group Abbreviation.</summary>
        </member>
        <member name="F:NCDK.IO.MDLV2000Reader.PropertyKey.SKIP">
            <summary>Skip lines.</summary>
        </member>
        <member name="F:NCDK.IO.MDLV2000Reader.PropertyKey.M_CHG">
            <summary>Charge [Generic].</summary>
        </member>
        <member name="F:NCDK.IO.MDLV2000Reader.PropertyKey.M_RAD">
            <summary>Radical [Generic].</summary>
        </member>
        <member name="F:NCDK.IO.MDLV2000Reader.PropertyKey.M_ISO">
            <summary>Isotope [Generic].</summary>
        </member>
        <member name="F:NCDK.IO.MDLV2000Reader.PropertyKey.M_RBC">
            <summary>Ring Bond Count [Query].</summary>
        </member>
        <member name="F:NCDK.IO.MDLV2000Reader.PropertyKey.M_SUB">
            <summary>Substitution Count [Query].</summary>
        </member>
        <member name="F:NCDK.IO.MDLV2000Reader.PropertyKey.M_UNS">
            <summary>Unsaturated Atom [Query].</summary>
        </member>
        <member name="F:NCDK.IO.MDLV2000Reader.PropertyKey.M_LIN">
            <summary>Link Atom [Query].</summary>
        </member>
        <member name="F:NCDK.IO.MDLV2000Reader.PropertyKey.M_ALS">
            <summary>Atom List [Query].</summary>
        </member>
        <member name="F:NCDK.IO.MDLV2000Reader.PropertyKey.M_APO">
            <summary>Attachment Point [Rgroup].</summary>
        </member>
        <member name="F:NCDK.IO.MDLV2000Reader.PropertyKey.M_AAL">
            <summary>Atom Attachment Order [Rgroup].</summary>
        </member>
        <member name="F:NCDK.IO.MDLV2000Reader.PropertyKey.M_RGP">
            <summary>Rgroup Label Location [Rgroup].</summary>
        </member>
        <member name="F:NCDK.IO.MDLV2000Reader.PropertyKey.M_LOG">
            <summary>Rgroup Logic, Unsatisfied Sites, Range of Occurrence [Rgroup].</summary>
        </member>
        <member name="F:NCDK.IO.MDLV2000Reader.PropertyKey.M_STY">
            <summary>Sgroup Type [Sgroup].</summary>
        </member>
        <member name="F:NCDK.IO.MDLV2000Reader.PropertyKey.M_SST">
            <summary>Sgroup Subtype [Sgroup].</summary>
        </member>
        <member name="F:NCDK.IO.MDLV2000Reader.PropertyKey.M_SLB">
            <summary>Sgroup Labels [Sgroup].</summary>
        </member>
        <member name="F:NCDK.IO.MDLV2000Reader.PropertyKey.M_SCN">
            <summary>Sgroup Connectivity [Sgroup].</summary>
        </member>
        <member name="F:NCDK.IO.MDLV2000Reader.PropertyKey.M_SDS">
            <summary>Sgroup Expansion [Sgroup].</summary>
        </member>
        <member name="F:NCDK.IO.MDLV2000Reader.PropertyKey.M_SAL">
            <summary>Sgroup Atom List [Sgroup].</summary>
        </member>
        <member name="F:NCDK.IO.MDLV2000Reader.PropertyKey.M_SBL">
            <summary>Sgroup Bond List [Sgroup].</summary>
        </member>
        <member name="F:NCDK.IO.MDLV2000Reader.PropertyKey.M_SPA">
            <summary>Multiple Group Parent Atom List [Sgroup].</summary>
        </member>
        <member name="F:NCDK.IO.MDLV2000Reader.PropertyKey.M_SMT">
            <summary>Sgroup Subscript [Sgroup].</summary>
        </member>
        <member name="F:NCDK.IO.MDLV2000Reader.PropertyKey.M_CRS">
            <summary>Sgroup Correspondence [Sgroup].</summary>
        </member>
        <member name="F:NCDK.IO.MDLV2000Reader.PropertyKey.M_SDI">
            <summary>Sgroup Display Information [Sgroup].</summary>
        </member>
        <member name="F:NCDK.IO.MDLV2000Reader.PropertyKey.M_SBV">
            <summary>Superatom Bond and Vector Information [Sgroup].</summary>
        </member>
        <member name="F:NCDK.IO.MDLV2000Reader.PropertyKey.M_SDT">
            <summary>Data Sgroup Field Description [Sgroup].</summary>
        </member>
        <member name="F:NCDK.IO.MDLV2000Reader.PropertyKey.M_SDD">
            <summary>Data Sgroup Display Information [Sgroup].</summary>
        </member>
        <member name="F:NCDK.IO.MDLV2000Reader.PropertyKey.M_SCD">
            <summary>Data Sgroup Data.</summary>
        </member>
        <member name="F:NCDK.IO.MDLV2000Reader.PropertyKey.M_SED">
            <summary>Data Sgroup Data.</summary>
        </member>
        <member name="F:NCDK.IO.MDLV2000Reader.PropertyKey.M_SPL">
            <summary>Sgroup Hierarchy Information.</summary>
        </member>
        <member name="F:NCDK.IO.MDLV2000Reader.PropertyKey.M_SNC">
            <summary>Sgroup Component Numbers.</summary>
        </member>
        <member name="F:NCDK.IO.MDLV2000Reader.PropertyKey.M_SBT">
            <summary>Sgroup Bracket Style.</summary>
        </member>
        <member name="F:NCDK.IO.MDLV2000Reader.PropertyKey.M_S3D">
            <summary>3D Feature Properties.</summary>
        </member>
        <member name="F:NCDK.IO.MDLV2000Reader.PropertyKey.M_ZZC">
            <summary>ACDLabs Atom Label</summary>
        </member>
        <member name="F:NCDK.IO.MDLV2000Reader.PropertyKey.M_END">
            <summary>End of Block.</summary>
        </member>
        <member name="F:NCDK.IO.MDLV2000Reader.PropertyKey.Unknown">
            <summary>Non-property header.</summary>
        </member>
        <member name="F:NCDK.IO.MDLV2000Reader.PropertyKey.mSuffix">
            <summary>Index of 'M XXX' properties for quick lookup.</summary>
        </member>
        <member name="M:NCDK.IO.MDLV2000Reader.PropertyKey.Of(System.String)">
            <summary>
            Determine the property key of the provided line.
            </summary>
            <param name="line">an property line</param>
            <returns>the key (defaults to <see cref="F:NCDK.IO.MDLV2000Reader.PropertyKey.Unknown"/>)</returns>
        </member>
        <member name="T:NCDK.IO.MDLV2000Reader.CTabVersion">
            <summary>
            Defines the version of the CTab.
            </summary>
        </member>
        <member name="M:NCDK.IO.MDLV2000Reader.CTabVersion.OfHeader(System.String)">
            <summary>
            Given a CTab header, what version was specified. The version
            is identifier in the by the presence of 'V[2|3]000'. If not
            version tag is present the version is unspecified.
            <![CDATA[
              5  5  0  0  0  0            999 V2000
              0  0  0  0  0  0            999 V3000
            ]]>
            </summary>
            <param name="header">input line (non-null)</param>
            <returns>the CTab version</returns>
        </member>
        <member name="T:NCDK.IO.MDLV2000Writer">
            <summary>
            Writes MDL molfiles, which contains a single molecule (see <token>cdk-cite-DAL92</token>).
            </summary>
            <example>
            For writing a MDL molfile you can this code:
            <code>                using (var srm = new FileStream("output.mol", FileMode.Create))
                using (MDLV2000Writer writer = new MDLV2000Writer(srm))
                {
                    writer.Write((IAtomContainer)molecule);
                }
</code>
            The writer has two IO settings: one for writing 2D coordinates, even if
            3D coordinates are given for the written data; the second writes aromatic
            bonds as bond type 4, which is, strictly speaking, a query bond type, but
            my many tools used to reflect aromaticity. The full IO setting API is
            explained in CDK News <token>cdk-cite-WILLIGHAGEN2004</token>. One programmatic option
            to set the option for writing 2D coordinates looks like:
            <code>                var customSettings = new NameValueCollection();
                customSettings["ForceWriteAs2DCoordinates"] = "true";
                PropertiesListener listener = new PropertiesListener(customSettings);
                writer.Listeners.Add(listener);
</code>
            </example>
        </member>
        <member name="T:NCDK.IO.MDLV2000Writer.SpinMultiplicity">
            <summary>
            Enumeration of all valid radical values.
            </summary>
        </member>
        <member name="P:NCDK.IO.MDLV2000Writer.SpinMultiplicity.Value">
            <summary>
            Radical value for the spin multiplicity in the properties block.
            </summary>
        </member>
        <member name="P:NCDK.IO.MDLV2000Writer.SpinMultiplicity.SingleElectrons">
            <summary>
            The number of single electrons that correspond to the spin multiplicity.
            </summary>
        </member>
        <member name="M:NCDK.IO.MDLV2000Writer.SpinMultiplicity.OfValue(System.Int32)">
            <summary>
            Create a SpinMultiplicity instance for the specified value.
            </summary>
            <param name="value">input value (in the property block)</param>
            <returns>instance</returns>
        </member>
        <member name="F:NCDK.IO.MDLV2000Writer.WriteAromaticBondTypes">
            <summary>
            Should aromatic bonds be written as bond type 4? If true, this makes the
            output a query file.
            </summary>
        </member>
        <member name="M:NCDK.IO.MDLV2000Writer.#ctor">
            <summary>
            Used only for InitIOSettings
            </summary>
        </member>
        <member name="M:NCDK.IO.MDLV2000Writer.#ctor(System.IO.TextWriter)">
            <summary>
            Constructs a new MDLWriter that can write an <see cref="T:NCDK.IAtomContainer"/>
            to the MDL molfile format.
            </summary>
            <param name="writer">The Writer to write to</param>
        </member>
        <member name="M:NCDK.IO.MDLV2000Writer.#ctor(System.IO.Stream)">
            <summary>
            Constructs a new MDLWriter that can write an <see cref="T:NCDK.IAtomContainer"/>
            to a given Stream.
            </summary>
            <param name="output">The Stream to write to</param>
        </member>
        <member name="M:NCDK.IO.MDLV2000Writer.Write(NCDK.IChemObject)">
            <summary>
            Writes a <see cref="T:NCDK.IChemObject"/> to the MDL molfile formated output.
            It can only output ChemObjects of type <see cref="T:NCDK.IChemFile"/>,
            <see cref="T:NCDK.IChemObject"/> and <see cref="T:NCDK.IAtomContainer"/>.
            </summary>
            <param name="obj"><see cref="T:NCDK.IChemObject"/> to write</param>
            <see cref="M:NCDK.IO.MDLV2000Writer.Accepts(System.Type)"/>
        </member>
        <member name="M:NCDK.IO.MDLV2000Writer.WriteMolecule(NCDK.IAtomContainer)">
            <summary>
            Writes a Molecule to an Stream in MDL sdf format.
            </summary>
            <param name="container">Molecule that is written to an Stream</param>
        </member>
        <member name="M:NCDK.IO.MDLV2000Writer.FormatMDLInt(System.Int32,System.Int32)">
            <summary>
            Formats an integer to fit into the connection table and changes it
            to a string.
            </summary>
            <param name="i">The int to be formated</param>
            <param name="l">Length of the string</param>
            <returns>The string to be written into the connectiontable</returns>
        </member>
        <member name="M:NCDK.IO.MDLV2000Writer.FormatMDLFloat(System.Double)">
            <summary>
            Formats a float to fit into the connectiontable and changes it
            to a string.
            </summary>
            <param name="fl">The float to be formated</param>
            <returns>The string to be written into the connectiontable</returns>
        </member>
        <member name="M:NCDK.IO.MDLV2000Writer.FormatMDLString(System.String,System.Int32)">
            <summary>
            Formats a string to fit into the connectiontable.
            </summary>
            <param name="s">The string to be formated</param>
            <param name="le">The length of the string</param>
            <returns>The string to be written in the connectiontable</returns>
        </member>
        <member name="M:NCDK.IO.MDLV2000Writer.InitIOSettings">
            <summary>
            Initializes IO settings.
            <para>
            Please note with regards to "WriteAromaticBondTypes": bond type values 4 through 8 are for SSS queries only,
            so a 'query file' is created if the container has aromatic bonds and this settings is true.
            </para>
            </summary>
        </member>
        <member name="M:NCDK.IO.MDLV2000Writer.SetWriteAromaticBondTypes(System.Boolean)">
            <summary>
            Convenience method to set the option for writing aromatic bond types.
            </summary>
            <param name="val">the value.</param>
        </member>
        <member name="T:NCDK.IO.MDLV3000Reader">
            <summary>
            Class that implements the MDL mol V3000 format. This reader reads the
            element symbol and 2D or 3D coordinates from the ATOM block.
            </summary>
        </member>
        <member name="M:NCDK.IO.MDLV3000Reader.ReadHeader(NCDK.IAtomContainer)">
            <summary>
            </summary>
            <returns>Last line read</returns>
            <exception cref="T:NCDK.CDKException">when no file content is detected</exception>
        </member>
        <member name="M:NCDK.IO.MDLV3000Reader.ReadAtomBlock(NCDK.IAtomContainer)">
            <summary>
            Reads the atoms, coordinates and charges.
            <para>IMPORTANT: it does not support the atom list and its negation!</para>
            </summary>
        </member>
        <member name="M:NCDK.IO.MDLV3000Reader.ReadBondBlock(NCDK.IAtomContainer)">
            <summary>
            Reads the bond atoms, order and stereo configuration.
            </summary>
        </member>
        <member name="M:NCDK.IO.MDLV3000Reader.ReadSGroup(NCDK.IAtomContainer)">
            <summary>
            Reads labels.
            </summary>
        </member>
        <member name="M:NCDK.IO.MDLV3000Reader.ReadCommand(System.String)">
            <summary>
            Reads the command on this line. If the line is continued on the next, that
            part is added.
            </summary>
            <returns>Returns the command on this line.</returns>
        </member>
        <member name="M:NCDK.IO.MDLV3000Reader.ApplyMDLValenceModel(NCDK.IAtom,System.Int32,System.Int32)">
            <summary>
            Applies the MDL valence model to atoms using the explicit valence (bond
            order sum) and charge to determine the correct number of implicit
            hydrogens. The model is not applied if the explicit valence is less than
            0 - this is the case when a query bond was read for an atom.
            </summary>
            <param name="atom">the atom to apply the model to</param>
            <param name="explicitValence">the explicit valence (bond order sum)</param>
        </member>
        <member name="T:NCDK.IO.MDLV3000Writer">
            <summary>
            Ctab V3000 format output. 
            </summary>
            <remarks>
            This writer provides output to the more modern (but less widely
            supported) V3000 format. Unlikely the V2000 format that is limited to 999 atoms or bonds
            V3000 can write arbitrarily large molecules. Beyond this the format removes some (but not all)
            ambiguities and simplifies output values with tagging (e.g 'CHG=-1' instead of '5').
            Supported Features:
            <list type="bullet">
                <item>Atom Block, non-query features</item>
                <item>Bond Block, non-query features</item>
                <item>Sgroup Block, partial support for all chemical Sgroups, complete support for: Abbreviations,
                MultipleGroup, SRUs, (Un)ordered Mixtures</item>
            </list>
            The 3D block and enhanced stereochemistry is not currently supported.
            </remarks>
        </member>
        <member name="M:NCDK.IO.MDLV3000Writer.#ctor">
            <summary>
            Used only for InitIOSettings
            </summary>
        </member>
        <member name="M:NCDK.IO.MDLV3000Writer.#ctor(System.IO.TextWriter)">
            <summary>
            Create a new V3000 writer, output to the provided JDK writer.
            </summary>
            <param name="writer">output location</param>
        </member>
        <member name="M:NCDK.IO.MDLV3000Writer.#ctor(System.IO.Stream)">
            <summary>
            Create a new V3000 writer, output to the provided output stream.
            </summary>
            <param name="output">output location</param>
        </member>
        <member name="M:NCDK.IO.MDLV3000Writer.NullAsZero(System.Nullable{System.Int32})">
            <summary>
            Safely access nullable int fields by defaulting to zero.
            </summary>
            <param name="x">value</param>
            <returns>value, or zero if null</returns>
        </member>
        <member name="M:NCDK.IO.MDLV3000Writer.FindIdx``1(System.Collections.Generic.IDictionary{``0,System.Int32},``0)">
            <summary>
            Access the index of Obj->Int map, if the entry isn't found we return -1.
            </summary>
            <typeparam name="T">the object type</typeparam>
            <param name="idxs">index map</param>
            <param name="obj">the object</param>
            <returns>index or -1 if not found</returns>
        </member>
        <member name="M:NCDK.IO.MDLV3000Writer.WriteHeader(NCDK.IAtomContainer)">
            <summary>
            Write the three line header of the MDL format: title, version/timestamp, remark.
            </summary>
            <param name="mol">molecule being output</param>
            <exception cref="T:System.IO.IOException">low-level IO error</exception>
        </member>
        <member name="M:NCDK.IO.MDLV3000Writer.GetLocalParity(System.Collections.Generic.IDictionary{NCDK.IChemObject,System.Int32},NCDK.ITetrahedralChirality)">
            <summary>
            Utility function for computing CTfile windings. The return value is adjusted
            to the MDL's model (look to lowest rank/highest number) from CDK's model (look from
            first).
            </summary>
            <param name="idxs">atom/bond index lookup</param>
            <param name="stereo">the tetrahedral configuration</param>
            <returns>winding to write to molfile</returns>
        </member>
        <member name="M:NCDK.IO.MDLV3000Writer.WriteAtomBlock(NCDK.IAtomContainer,NCDK.IAtom[],System.Collections.Generic.IDictionary{NCDK.IChemObject,System.Int32},System.Collections.Generic.IDictionary{NCDK.IAtom,NCDK.ITetrahedralChirality})">
            <summary>
            Write the atoms of a molecule. We pass in the order of atoms since for compatibility we
            have shifted all hydrogens to the back.
            </summary>
            <param name="mol">molecule</param>
            <param name="atoms">the atoms of a molecule in desired output order</param>
            <param name="idxs">index lookup</param>
            <param name="atomToStereo">tetrahedral stereo lookup</param>
            <exception cref="T:System.IO.IOException">low-level IO error</exception>
            <exception cref="T:NCDK.CDKException">inconsistent state etc</exception>
        </member>
        <member name="M:NCDK.IO.MDLV3000Writer.GetSymbol(NCDK.IAtom,System.Int32)">
            <summary>
            Access the atom symbol to write.
            </summary>
            <param name="atom">atom</param>
            <param name="elem">atomic number</param>
            <returns>atom symbol</returns>
        </member>
        <member name="M:NCDK.IO.MDLV3000Writer.WriteBondBlock(NCDK.IAtomContainer,System.Collections.Generic.IDictionary{NCDK.IChemObject,System.Int32})">
            <summary>
            Write the bonds of a molecule.
            </summary>
            <param name="mol">molecule</param>
            <param name="idxs">index lookup</param>
            <exception cref="T:System.IO.IOException">low-level IO error</exception>
            <exception cref="T:NCDK.CDKException">inconsistent state etc</exception>
        </member>
        <member name="M:NCDK.IO.MDLV3000Writer.PushHydrogensToBack(NCDK.IAtomContainer,System.Collections.Generic.IDictionary{NCDK.IChemObject,System.Int32})">
            <summary>
            CTfile specification is ambiguous as to how parity values should be written
            for implicit hydrogens. Old applications (Symyx Draw) seem to push any
            hydrogen to (implied) the last position but newer applications
            (Accelrys/BioVia Draw) only do so for implicit hydrogens (makes more sense).
            </summary>
            <remarks>
            To avoid the ambiguity for those who read 0D stereo (bad anyways) we
            actually do push all hydrogens atoms to the back of the atom list giving
            them highest value (4) when writing parity values.
            </remarks>
            <param name="mol">molecule</param>
            <param name="atomToIdx">mapping that will be filled with the output index</param>
            <returns>the output order of atoms</returns>
        </member>
        <member name="M:NCDK.IO.MDLV3000Writer.GetSgroups(NCDK.IAtomContainer)">
            <summary>
            Safely access the Sgroups of a molecule retuning an empty list
            if none are defined..
            </summary>
            <param name="mol">molecule</param>
            <returns>the sgroups</returns>
        </member>
        <member name="M:NCDK.IO.MDLV3000Writer.WriteSgroupBlock(System.Collections.Generic.IEnumerable{NCDK.SGroups.Sgroup},System.Collections.Generic.IDictionary{NCDK.IChemObject,System.Int32})">
            <summary>
            Write the Sgroup block to the output.
            </summary>
            <param name="sgroups">the sgroups, non-null</param>
            <param name="idxs">index map for looking up atom and bond indexes</param>
            <exception cref="T:System.IO.IOException">low-level IO error</exception>
            <exception cref="T:NCDK.CDKException">unsupported format feature or invalid state</exception>
        </member>
        <member name="M:NCDK.IO.MDLV3000Writer.WriteMol(NCDK.IAtomContainer)">
            <summary>
            Writes a molecule to the V3000 format.
            </summary>
            <param name="mol">molecule</param>
            <exception cref="T:System.IO.IOException">low-level IO error</exception>
            <exception cref="T:NCDK.CDKException">state exception (e.g undef bonds), unsupported format feature etc</exception>
        </member>
        <member name="M:NCDK.IO.MDLV3000Writer.Write(NCDK.IChemObject)">
            <summary>
            Writes a molecule to the V3000 format. 
            </summary>
            <param name="obj"></param>
            <exception cref="T:NCDK.CDKException">state exception (e.g undef bonds), unsupported format feature, object not supported etc</exception>
        </member>
        <member name="T:NCDK.IO.MDLV3000Writer.V30LineWriter">
            <summary>
            A convenience function for writing V3000 lines that auto
            wrap when >80 characters. We actually wrap at 78 since
            the '-\n' takes the final two. We normally only need to wrap
            for Sgroups but all lines are handled.
            </summary>
        </member>
        <member name="M:NCDK.IO.MDLV3000Writer.V30LineWriter.WriteDirect(System.String)">
            <summary>
            Write the string to the output directly without any prefix or wrapping.
            </summary>
            <param name="str">the string</param>
            <returns>self-reference for chaining</returns>
            <exception cref="T:System.IO.IOException">low-level IO error</exception>
        </member>
        <member name="M:NCDK.IO.MDLV3000Writer.V30LineWriter.WriteDirect(System.Char)">
            <summary>
            Write the char to the output directly without any prefix or wrapping.
            </summary>
            <param name="c">the character</param>
            <returns>self-reference for chaining</returns>
            <exception cref="T:System.IO.IOException">low-level IO error</exception>
        </member>
        <member name="M:NCDK.IO.MDLV3000Writer.V30LineWriter.Write(System.Double)">
            <summary>
            Write a floating point number to the output, wrapping
            if needed.
            </summary>
            <param name="num">value</param>
            <returns>self-reference for chaining.</returns>
            <exception cref="T:System.IO.IOException">low-level IO error</exception>
        </member>
        <member name="M:NCDK.IO.MDLV3000Writer.V30LineWriter.Write(System.Int32)">
            <summary>
            Write a int number to the output, wrapping if needed.
            </summary>
            <param name="num">value</param>
            <returns>self-reference for chaining.</returns>
            <exception cref="T:System.IO.IOException">low-level IO error</exception>
        </member>
        <member name="M:NCDK.IO.MDLV3000Writer.V30LineWriter.Write(System.String)">
            <summary>
            Write a string to the output, wrapping if needed.
            </summary>
            <param name="str">value</param>
            <returns>self-reference for chaining.</returns>
            <exception cref="T:System.IO.IOException">low-level IO error</exception>
        </member>
        <member name="M:NCDK.IO.MDLV3000Writer.V30LineWriter.Write(System.Char)">
            <summary>
            Write a char number to the output, wrapping if needed.
            </summary>
            <param name="c">char</param>
            <returns>self-reference for chaining.</returns>
            <exception cref="T:System.IO.IOException">low-level IO error</exception>
        </member>
        <member name="M:NCDK.IO.MDLV3000Writer.V30LineWriter.Write(System.Collections.Generic.IEnumerable{NCDK.IChemObject},System.Collections.Generic.IDictionary{NCDK.IChemObject,System.Int32})">
            <summary>
            Write chemobject index list, mainly useful for Sgroup output.
            </summary>
            <param name="chemObjects">collection of chemobjects</param>
            <param name="idxs">index map</param>
            <returns>self-reference for chaining.</returns>
            <exception cref="T:System.IO.IOException">low-level IO error</exception>
        </member>
        <member name="T:NCDK.IO.MDLValence">
            <summary>
            Adds implicit hydrogens and specifies valency using the MDL valence model.
            </summary>
            <seealso href="http://nextmovesoftware.com/blog/2013/02/27/explicit-and-implicit-hydrogens-taking-liberties-with-valence/">Explicit and Implicit Hydrogens: taking liberties with valence</seealso>
        </member>
        <member name="M:NCDK.IO.MDLValence.Apply(NCDK.IAtomContainer)">
            <summary>
            Apply the MDL valence model to the provided atom container.
            </summary>
            <param name="container">an atom container loaded from an MDL format</param>
            <returns>the container (for convenience)</returns>
        </member>
        <member name="M:NCDK.IO.MDLValence.ImplicitValence(System.Int32,System.Int32,System.Int32)">
             <summary>
             Given an element (atomic number) its charge and the explicit valence
             (bond order sum) return the implicit valence for that atom. This valence
             is from the MDL valence model which was decoded by NextMove Software and
             licenced as below.
             </summary>
             <remarks>
             $Id: MDLValence.h 2288 2012-11-26 03:39:27Z glandrum $
            
             Copyright (C) 2012 NextMove Software
            
             @@ All Rights Reserved @@ This file is part of the RDKit. The contents
             are covered by the terms of the BSD license which is included in the file
             license.txt, found at the root of the RDKit source tree.
             </remarks>
             <seealso href="http://nextmovesoftware.com/blog/2013/02/27/explicit-and-implicit-hydrogens-taking-liberties-with-valence/">Explicit and Implicit Hydrogens taking liberties with valence</seealso>
        </member>
        <member name="T:NCDK.IO.Mol2Reader">
            <summary>
            Reads a molecule from an Mol2 file, such as written by Sybyl.
            See the specs <see href="http://www.tripos.com/data/support/mol2.pdf">here</see>.
            </summary>
        </member>
        <member name="F:NCDK.IO.Mol2Reader.ATOM_TYPE_ALIASES">
            <summary>
            Dictionary of known atom type aliases. If the key is seen on input, it
            is repleaced with the specified value. Bugs /openbabel/bug/214 and /cdk/bug/1346
            </summary>
        </member>
        <member name="M:NCDK.IO.Mol2Reader.#ctor(System.IO.TextReader)">
            <summary>
            Constructs a new MDLReader that can read Molecule from a given Reader.
            </summary>
            <param name="input">The Reader to read from</param>
        </member>
        <member name="M:NCDK.IO.Mol2Reader.ReadMolecule(NCDK.IAtomContainer)">
            <summary>
            Read a Reaction from a file in MDL RXN format
            </summary>
            <returns>The Reaction that was read from the MDL file.</returns>
        </member>
        <member name="T:NCDK.IO.Mol2Writer">
            <summary>
            An output Writer that writes molecular data into the
            <see href="http://www.tripos.com/data/support/mol2.pdf">Tripos Mol2 format</see>.
            Writes the atoms and the bonds only at this moment.
            </summary>
        </member>
        <member name="M:NCDK.IO.Mol2Writer.#ctor(System.IO.TextWriter)">
            <summary>
            Constructs a new Mol2 writer.
            <param name="output">the stream to write the Mol2 file to.</param>
            </summary>
        </member>
        <member name="M:NCDK.IO.Mol2Writer.WriteMolecule(NCDK.IAtomContainer)">
            <summary>
            Writes a single frame in XYZ format to the Writer.
            </summary>
            <param name="mol">the Molecule to write</param>
            <exception cref="T:System.IO.IOException">if there is an error during writing</exception>
        </member>
        <member name="T:NCDK.IO.Mopac7Reader">
            <summary>
            Reads MOPAC output, extracts several electronic parameters and assigns them as a molecule
            properties.
            </summary>
            <remarks>
            Parameters: "NO. OF FILLED LEVELS",    "TOTAL ENERGY","FINAL HEAT OF FORMATION",
            "IONIZATION POTENTIAL", "ELECTRONIC ENERGY","CORE-CORE REPULSION","MOLECULAR WEIGHT".
            Doesn't update structure coordinates ! (TODO fix)
            </remarks>
        </member>
        <member name="M:NCDK.IO.Mopac7Reader.#ctor(System.IO.TextReader)">
            <summary>
            Constructs a new Mopac7reader that can read a molecule from a given <see cref="T:System.IO.TextReader"/>.
            </summary>
            <param name="input">The <see cref="T:System.IO.TextReader"/> to read from</param>
        </member>
        <member name="M:NCDK.IO.Mopac7Reader.#ctor(System.IO.Stream)">
            <summary>
            Constructs a new Mopac7reader that can read a molecule from a given <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="input">The <see cref="T:System.IO.Stream"/> to read from</param>
        </member>
        <member name="T:NCDK.IO.MoSSOutputReader">
            <summary>
            Reader for MoSS output files <token>cdk-cite-BOR2002</token> which present the results
            of a substructure mining study. These files look like:
            <pre>
            id,description,nodes,edges,s_abs,s_rel,c_abs,c_rel
            1,S-c:c:c:c:c:c,7,6,491,5.055081,5,1.7421603
            2,S-c:c:c:c:c,6,5,493,5.0756717,5,1.7421603
            </pre>
            <note type="caution">
            The output contains substructures, not full molecules,
            even though they are read as such right now.
            </note>
            </summary>
        </member>
        <member name="M:NCDK.IO.MoSSOutputReader.#ctor(System.IO.TextReader)">
            <summary>
            Create a reader for MoSS output files from a <see cref="T:System.IO.TextReader"/>.
            </summary>
            <param name="input">source of CIF data</param>
        </member>
        <member name="M:NCDK.IO.MoSSOutputReader.#ctor(System.IO.Stream)">
            <summary>
            Create a reader for MoSS output files from an <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="input">source of CIF data</param>
        </member>
        <member name="P:NCDK.IO.MoSSOutputReader.Format">
            <inheritdoc/>    
        </member>
        <member name="M:NCDK.IO.MoSSOutputReader.Accepts(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.IO.MoSSOutputReader.Read``1(``0)">
            <summary>
            Read a <see cref="T:NCDK.IChemObjectSet`1"/> from the input source.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="obj">object an <see cref="T:NCDK.IChemObjectSet`1"/> into which the data is stored.</param>
            <returns>the content in a <see cref="T:NCDK.IChemObjectSet`1"/> object</returns>
        </member>
        <member name="M:NCDK.IO.MoSSOutputReader.ReadAtomContainerSet(NCDK.IChemObjectSet{NCDK.IAtomContainer})">
            <summary>
            Read the file content into a <see cref="T:NCDK.IAtomContainerSet"/>.
            </summary>
            <param name="molSet">an <see cref="T:NCDK.IAtomContainerSet"/> to store the structures</param>
            <returns>the <see cref="T:NCDK.IAtomContainerSet"/> containing the molecules read in</returns>
            <exception cref="T:System.IO.IOException">if there is an error during reading</exception>
        </member>
        <member name="T:NCDK.IO.PCCompoundASNReader">
            <summary>
            Reads an object from ASN formated input for PubChem Compound entries. The following
            bits are supported: atoms.aid, atoms.element, bonds.aid1, bonds.aid2. Additionally,
            it extracts the InChI and canonical SMILES properties.
            </summary>
        </member>
        <member name="M:NCDK.IO.PCCompoundASNReader.#ctor(System.IO.TextReader)">
            <summary>
            Construct a new reader from a Reader type object.
            </summary>
            <param name="input">reader from which input is read</param>
        </member>
        <member name="T:NCDK.IO.PCCompoundXMLReader">
            <summary>
            Reads an object from ASN.1 XML formated input for PubChem Compound entries.
            The following bits are supported: atoms.aid, atoms.element, atoms.2d,
            atoms.3d, bonds.aid1, bonds.aid2.
            </summary>
        </member>
        <member name="M:NCDK.IO.PCCompoundXMLReader.#ctor(System.IO.TextReader)">
            <summary>
            Construct a new reader from a Reader type object.
            </summary>
            <param name="input">reader from which input is read</param>
        </member>
        <member name="T:NCDK.IO.PCSubstanceXMLReader">
            <summary>
            Reads an object from ASN formated input for PubChem Compound entries. The following
            bits are supported: atoms.aid, atoms.element, bonds.aid1, bonds.aid2. Additionally,
            it extracts the InChI and canonical SMILES properties.
            </summary>
        </member>
        <member name="M:NCDK.IO.PCSubstanceXMLReader.#ctor(System.IO.TextReader)">
            <summary>
            Construct a new reader from a Reader type object.
            </summary>
            <param name="input">reader from which input is read</param>
        </member>
        <member name="T:NCDK.IO.PDBReader">
            <summary>
            Reads the contents of a PDBFile.
            <para>A description can be found at <see href="http://www.rcsb.org/pdb/static.do?p=file_formats/pdb/index.html">http://www.rcsb.org/pdb/static.do?p=file_formats/pdb/index.html</see>.</para>
            </summary>
        </member>
        <member name="F:NCDK.IO.PDBReader.bondsFromConnectRecords">
            <summary>
            This is a temporary store for bonds from CONNECT records. As CONNECT is
            deliberately fully redundant (a->b and b->a) we need to use this to weed
            out the duplicates.
            </summary>
        </member>
        <member name="F:NCDK.IO.PDBReader.hetDictionary">
            <summary>
            A mapping between HETATM 3-letter codes + atomNames to CDK atom type
            names; for example "RFB.N13" maps to "N.planar3".
            </summary>
        </member>
        <member name="M:NCDK.IO.PDBReader.#ctor(System.IO.Stream)">
            <summary>
            Constructs a new PDBReader that can read Molecules from a given Stream.
            </summary>
            <param name="oIn">The Stream to read from</param>
        </member>
        <member name="M:NCDK.IO.PDBReader.#ctor(System.IO.TextReader)">
            <summary>
            Constructs a new PDBReader that can read Molecules from a given Reader.
            </summary>
            <param name="oIn">The Reader to read from</param>
        </member>
        <member name="M:NCDK.IO.PDBReader.Read``1(``0)">
            <summary>
            Takes an object which subclasses IChemObject, e.g. Molecule, and will
            read this (from file, database, internet etc). If the specific
            implementation does not support a specific IChemObject it will throw
            an Exception.
            </summary>
            <param name="oObj">The object that subclasses IChemObject</param>
            <returns>The IChemObject read</returns>
            <exception cref="T:NCDK.CDKException"></exception>
        </member>
        <member name="M:NCDK.IO.PDBReader.ReadChemFile(NCDK.IChemFile)">
            <summary>
            Read a <see cref="T:NCDK.IChemFile"/> from a file in PDB format. The molecules
            in the file are stored as <see cref="T:NCDK.IBioPolymer"/>s in the
            <see cref="T:NCDK.IChemFile"/>. The residues are the monomers of the
            <see cref="T:NCDK.IBioPolymer"/>, and their names are the concatenation of the
            residue, chain id, and the sequence number. Separate chains (denoted by
            TER records) are stored as separate <see cref="T:NCDK.IBioPolymer"/> molecules.
            </summary>
            <remarks>
            Connectivity information is not currently read.
            </remarks>
            <returns>The ChemFile that was read from the PDB file.</returns>
        </member>
        <member name="M:NCDK.IO.PDBReader.ReadAtom(System.String,System.Int32)">
            <summary>
            Creates an <see cref="T:NCDK.Default.PDBAtom"/> and sets properties to their values from
            the ATOM or HETATM record. If the line is shorter than 80 characters, the
            information past 59 characters is treated as optional. If the line is
            shorter than 59 characters, a <see cref="T:System.ApplicationException"/> is thrown.
            </summary>
            <param name="cLine">the PDB ATOM or HEATATM record.</param>
            <param name="lineLength"></param>
            <returns>the <see cref="T:NCDK.Default.PDBAtom"/>created from the record.</returns>
            <exception cref="T:System.IO.InvalidDataException">if the line is too short (less than 59 characters).</exception>
        </member>
        <member name="T:NCDK.IO.PDBWriter">
            <summary>
            Saves small molecules in a rudimentary PDB format. It does not allow
            writing of PDBProtein data structures.
            </summary>
        </member>
        <member name="M:NCDK.IO.PDBWriter.#ctor(System.IO.TextWriter)">
            <summary>
            Creates a PDB writer.
            </summary>
            <param name="output">the stream to write the PDB file to.</param>
        </member>
        <member name="M:NCDK.IO.PDBWriter.WriteMolecule(NCDK.IAtomContainer)">
            <summary>
            Writes a single frame in PDB format to the Writer.
            </summary>
            <param name="molecule">the Molecule to write</param>
        </member>
        <member name="T:NCDK.IO.PMPReader">
            <summary>
            Reads an frames from a PMP formated input.
            Both compilation and use of this class requires Java 1.4.
            </summary>
        </member>
        <member name="M:NCDK.IO.PMPReader.#ctor(System.IO.TextReader)">
            <summary>
            construct a new reader from a Reader type object
            <param name="input">reader from which input is read</param>
            </summary>
        </member>
        <member name="M:NCDK.IO.PMPReader.Read``1(``0)">
            <summary>
            reads the content from a PMP input. It can only return a
            IChemObject of type ChemFile
            </summary>
            <param name="obj">class must be of type ChemFile</param>
            <seealso cref="T:NCDK.IChemFile"/>
        </member>
        <member name="M:NCDK.IO.PMPReader.ReadChemFile(NCDK.IChemFile)">
             <summary>
              Private method that actually parses the input to read a ChemFile
              object.
            
              Each PMP frame is stored as a Crystal in a ChemModel. The PMP
              file is stored as a ChemSequence of ChemModels.
             </summary>
             <returns>A ChemFile containing the data parsed from input.</returns>
        </member>
        <member name="T:NCDK.IO.GaussianInputWriter">
            <summary>
            File writer thats generates input files for Gaussian calculation jobs. It was tested with Gaussian98.
            </summary>
        </member>
        <member name="M:NCDK.IO.GaussianInputWriter.#ctor(System.IO.TextWriter)">
            <summary>
            Constructs a new writer that produces input files to run a Gaussian QM job.
            </summary>
            <param name="output"></param>
        </member>
        <member name="M:NCDK.IO.GaussianInputWriter.WriteMolecule(NCDK.IAtomContainer)">
            <summary>
            Writes a molecule for input for Gaussian.
            </summary>
            <param name="mol"></param>
        </member>
        <member name="T:NCDK.IO.Mopac7Writer">
            <summary>
            Prepares input file for running MOPAC.
            Optimization is switched on if there are no coordinates.
            </summary>
        </member>
        <member name="M:NCDK.IO.Mopac7Writer.#ctor(System.IO.Stream)">
            <summary>
            Creates a writer to serialize a molecule as Mopac7 input. Output is written to the
            given <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="output"><see cref="T:System.IO.Stream"/> to which the output is written</param>
        </member>
        <member name="M:NCDK.IO.Mopac7Writer.#ctor(System.IO.TextWriter)">
            <summary>
            Creates a writer to serialize a molecule as Mopac7 input. Output is written to the
            given <see cref="T:System.IO.TextWriter"/>.
            </summary>
            <param name="output"><see cref="T:System.IO.TextWriter"/> to which the output is written</param>
        </member>
        <member name="T:NCDK.IO.PubChemXml.PubChemXMLHelper">
            <summary>
            Helper class to parse PubChem XML documents.
            </summary>
        </member>
        <member name="M:NCDK.IO.PubChemXml.PubChemXMLHelper.#ctor(NCDK.IChemObjectBuilder)">
            <summary>
            
            </summary>
            <param name="builder"></param>
            <exception cref="T:System.IO.IOException">if there is error in getting the <see cref="T:NCDK.Config.IsotopeFactory"/></exception>
        </member>
        <member name="F:NCDK.IO.PubChemXml.PubChemXMLHelper.PubChem_Namespace">
            <summary>"http://www.ncbi.nlm.nih.gov"</summary>
        </member>
        <member name="F:NCDK.IO.PubChemXml.PubChemXMLHelper.Name_EL_PCCOMPOUND">
            <summary>PC-Compound</summary>
        </member>
        <member name="F:NCDK.IO.PubChemXml.PubChemXMLHelper.Name_EL_PCCOMPOUNDS">
            <summary>PC-Compounds</summary>
        </member>
        <member name="F:NCDK.IO.PubChemXml.PubChemXMLHelper.Name_EL_PCSUBSTANCE">
            <summary>PC-Substance</summary>
        </member>
        <member name="F:NCDK.IO.PubChemXml.PubChemXMLHelper.Name_EL_PCSUBSTANCE_SID">
            <summary>PC-Substance_sid</summary>
        </member>
        <member name="F:NCDK.IO.PubChemXml.PubChemXMLHelper.Name_EL_PCCOMPOUND_ID">
            <summary>PC-Compound_id</summary>
        </member>
        <member name="F:NCDK.IO.PubChemXml.PubChemXMLHelper.Name_EL_PCCOMPOUND_CID">
            <summary>PC-CompoundType_id_cid</summary>
        </member>
        <member name="F:NCDK.IO.PubChemXml.PubChemXMLHelper.Name_EL_PCID_ID">
            <summary>PC-ID_id</summary>
        </member>
        <member name="T:NCDK.IO.RandomAccess.DefaultRandomAccessChemObjectReader">
            <summary>
            Abstract class for random readings.
            </summary>
        </member>
        <member name="F:NCDK.IO.RandomAccess.DefaultRandomAccessChemObjectReader.listenerList">
            <summary>
            Holder of reader event listeners.
            </summary>
        </member>
        <member name="T:NCDK.IO.RandomAccess.RandomAccessReader">
            <summary>
            Random access to text files of compounds.
            Reads the file as a text and builds an index file, if the index file doesn't already exist.
            The index stores offset, length and a third field reserved for future use.
            Subsequent access for a record N uses this index to seek the record and return the molecule.
            Useful for very big files.
            </summary>
        </member>
        <member name="M:NCDK.IO.RandomAccess.RandomAccessReader.#ctor(System.String,NCDK.IChemObjectBuilder)">
            <summary>
            Reads the file and builds an index file, if the index file doesn't already exist.
            </summary>
            <param name="file">the file object containing the molecules to be indexed</param>
            <param name="builder">a chem object builder</param>
            <exception cref="T:System.IO.IOException">if there is an error during reading</exception>
        </member>
        <member name="M:NCDK.IO.RandomAccess.RandomAccessReader.#ctor(System.String,NCDK.IChemObjectBuilder,NCDK.IO.Listener.IReaderListener)">
            <summary>
            Reads the file and builds an index file, if the index file doesn't already exist.
            </summary>
            <param name="file">file the file object containing the molecules to be indexed</param>
            <param name="builder">builder a chem object builder</param>
            <param name="listener">listen for read event</param>
            <exception cref="T:System.IO.IOException">if there is an error during reading</exception>
        </member>
        <member name="M:NCDK.IO.RandomAccess.RandomAccessReader.ReadRecord(System.Int32)">
            <summary>
            Returns the object at given record No.
            </summary>
            <param name="record">Zero-based record number</param>
            <returns></returns>
        </member>
        <member name="M:NCDK.IO.RandomAccess.RandomAccessReader.ReadContent(System.Int32)">
             <summary>
             Reads the record text content into a string.
            
             <param name="record">The record number</param>
             <returns>A string representation of the record</returns>
             <exception cref="T:System.IO.IOException">if error occurs during reading</exception>
             <exception cref="T:NCDK.CDKException">if the record number is invalid</exception>
             </summary>
        </member>
        <member name="M:NCDK.IO.RandomAccess.RandomAccessReader.ProcessContent">
            <summary>
            The reader is already set to read the record buffer.
            </summary>
            <returns>the read IChemObject</returns>
            <exception cref="T:System.IO.IOException">an error occurred whilst reading the file</exception>
        </member>
        <member name="M:NCDK.IO.RandomAccess.RandomAccessReader.MakeIndex">
            <summary>
            The index file <see cref="M:NCDK.IO.RandomAccess.RandomAccessReader.GetIndexFile(System.String)"/> is loaded, if already exists, or created a new.
            </summary>
        </member>
        <member name="M:NCDK.IO.RandomAccess.RandomAccessReader.GetIndexFile(System.String)">
            <summary>
            Opens the file index <pre>_cdk.index</pre> in a temporary folder, as specified by <see cref="M:System.IO.Path.GetTempPath"/> property.
            </summary>
            <param name="filename">the name of the file for which the index was generated</param>
            <returns>a file object representing the index file</returns>
        </member>
        <member name="T:NCDK.IO.RandomAccess.RandomAccessSDFReader">
            <summary>
            Random access of SDF file. Doesn't load molecules in memory, uses prebuilt
            index and seeks to find the correct record offset.
            </summary>
        </member>
        <member name="P:NCDK.IO.RandomAccess.RandomAccessSDFReader.Format">
            <seealso cref="P:NCDK.IO.IChemObjectIO.Format"/>
        </member>
        <member name="T:NCDK.IO.ReaderEvent">
            <summary>
            Signals that something has happened in a file reader. This class is
            primarily in place for future development when additional information
            may be passed to <see cref="T:NCDK.IO.Listener.IReaderListener"/>s.
            </summary>
        </member>
        <member name="M:NCDK.IO.ReaderEvent.#ctor(System.Object)">
            <summary>
            Creates a reader event.
            </summary>
            <param name="source">the object on which the event initially occurred.</param>
        </member>
        <member name="T:NCDK.IO.ReaderFactory">
            <summary>
            A factory for creating ChemObjectReaders. The type of reader
            created is determined from the content of the input. Formats
            of GZiped files can be detected too.
            </summary>
            <example>    
            <code>            using (StringReader stringReader = new StringReader("&lt;molecule/&gt;"))
            using (var reader = new ReaderFactory().CreateReader(stringReader))
            {
                //
            }
</code>
            </example>
        </member>
        <member name="M:NCDK.IO.ReaderFactory.#ctor">
            <summary>
            Constructs a ReaderFactory which tries to detect the format in the
            first 65536 chars.
            </summary>
        </member>
        <member name="M:NCDK.IO.ReaderFactory.#ctor(System.Int32)">
            <summary>
            Constructs a ReaderFactory which tries to detect the format in the
            first given number of chars.
            </summary>
            <param name="headerLength">length of the header in number of chars</param>
        </member>
        <member name="M:NCDK.IO.ReaderFactory.RegisterFormat(NCDK.IO.Formats.IChemFormatMatcher)">
            <summary>
            Registers a format for detection.
            </summary>
        </member>
        <member name="M:NCDK.IO.ReaderFactory.CreateReader(System.IO.Stream)">
            <summary>
            Detects the format of the Reader input, and if known, it will return
            a CDK Reader to read the format, or null when the reader is not
            implemented.
            </summary>
            <param name="input"></param>
            <returns><see langword="null"/> if CDK does not contain a reader for the detected format.</returns>
            <seealso cref="M:NCDK.IO.ReaderFactory.CreateReader(System.IO.TextReader)"/>
        </member>
        <member name="M:NCDK.IO.ReaderFactory.GetReaderType(NCDK.IO.Formats.IChemFormat)">
            <summary>
            Creates a new IChemObjectReader based on the given <see cref="T:NCDK.IO.Formats.IChemFormat"/>.
            </summary>
            <seealso cref="M:NCDK.IO.ReaderFactory.CreateReader(System.IO.Stream)"/>
        </member>
        <member name="M:NCDK.IO.ReaderFactory.CreateReader(System.IO.TextReader)">
            <summary>
            Detects the format of the Reader input, and if known, it will return
            a CDK Reader to read the format. This method is not able to detect the
            format of gziped files. Use CreateReader(Stream) instead for such
            files.
            </summary>
            <seealso cref="M:NCDK.IO.ReaderFactory.CreateReader(System.IO.Stream)"/>
        </member>
        <member name="T:NCDK.IO.RGroupQueryReader">
             <summary>
             A reader for Symyx' Rgroup files (RGFiles).
             An RGfile describes a single molecular query with Rgroups.
             Each RGfile is a combination of Ctabs defining the root molecule and each
             member of each Rgroup in the query.
            
             <para>The RGFile format is described in the manual
             <see href="http://www.symyx.com/downloads/public/ctfile/ctfile.pdf">"CTFile Formats"</see> , Chapter 5.
             </para>
             </summary>
        </member>
        <member name="T:NCDK.IO.RGroupQueryReader.RGroupLogic">
            <summary>
            Private bean style class to capture LOG (logic) lines.
            </summary>
        </member>
        <member name="M:NCDK.IO.RGroupQueryReader.#ctor(System.IO.Stream)">
            <summary>
            Constructs a new RgroupQueryReader that can read RgroupAtomContainerSet
            from a given Stream.
            <param name="ins">The Stream to read from.</param>
            </summary>
        </member>
        <member name="M:NCDK.IO.RGroupQueryReader.#ctor(System.IO.TextReader)">
            <summary>
            Constructs a new RgroupQueryReader that can read RgroupAtomContainerSet
            from a given Reader.
            </summary>
            <param name="ins">The Reader to read from.</param>
        </member>
        <member name="M:NCDK.IO.RGroupQueryReader.Read``1(``0)">
            <summary>
            Check input <see cref="T:NCDK.IChemObject"/> and proceed to parse.
            Accepts/returns <see cref="T:NCDK.IChemObject"/> of type <see cref="T:NCDK.Isomorphisms.Matchers.RGroupQuery"/> only.
            </summary>
            <returns><see cref="T:NCDK.IChemObject"/> read from file</returns>
            <param name="obj">class must be of type <see cref="T:NCDK.Isomorphisms.Matchers.RGroupQuery"/></param>
        </member>
        <member name="M:NCDK.IO.RGroupQueryReader.ParseRGFile(NCDK.Isomorphisms.Matchers.RGroupQuery)">
            <summary>
            Parse the RGFile. Uses of <see cref="T:NCDK.IO.MDLV2000Reader"/>
            to parse individual $CTAB blocks.
            </summary>
            <param name="rGroupQuery">empty</param>
            <returns>populated query</returns>
        </member>
        <member name="M:NCDK.IO.RGroupQueryReader.CheckLineBeginsWith(System.String,System.String,System.Int32)">
            <summary>
            Checks that a given line starts as expected, according to RGFile format.
            </summary>
            <param name="line"></param>
            <param name="expect"></param>
            <param name="lineCount"></param>
        </member>
        <member name="T:NCDK.IO.RGroupQueryWriter">
            <summary>
            A writer for Symyx' Rgroup files (RGFiles).
            </summary>
            <remarks>
            An RGfile describes a single molecular query with Rgroups.
            Each RGfile is a combination of Ctabs defining the root molecule and each
            member of each Rgroup in the query.
            
            This class relies on the <see cref="T:NCDK.IO.MDLV2000Writer"/> to
            create CTAB data blocks.
            </remarks>
        </member>
        <member name="M:NCDK.IO.RGroupQueryWriter.#ctor(System.IO.TextWriter)">
            <summary>
            Constructs a new writer that can write an <see cref="T:NCDK.Isomorphisms.Matchers.IRGroupQuery"/>
            to the Symx RGFile format.
            </summary>
            <param name="output">The Writer to write to</param>
        </member>
        <member name="M:NCDK.IO.RGroupQueryWriter.Accepts(System.Type)">
            <summary>
            Returns true for accepted input types.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NCDK.IO.RGroupQueryWriter.GetCTAB(NCDK.IAtomContainer)">
            <summary>
            Produces a CTAB block for an atomContainer, without the header lines.
            </summary>
            <param name="atomContainer"></param>
            <returns>CTAB block</returns>
        </member>
        <member name="P:NCDK.IO.RGroupQueryWriter.Format">
            <summary>
            Returns output format.
            </summary>
        </member>
        <member name="M:NCDK.IO.RGroupQueryWriter.Write(NCDK.IChemObject)">
            <summary>
            The actual writing of the output.
            </summary>
            <param name="obj"></param>
            <exception cref="T:NCDK.CDKException">could not write RGroup query</exception>
        </member>
        <member name="T:NCDK.IO.RssWriter">
            <summary>
            Generates an RSS feed. It the object is a <see cref="T:NCDK.IChemObjectSet`1"/>, the molecules
            are put in separately. All other objects are made CML and put in.
            </summary>
        </member>
        <member name="P:NCDK.IO.RssWriter.LinkMap">
            <summary>
            the link map. If you put a string in this map with one of the objects you want to write as key, it will be added as a link to this object (no validity check is done)
            </summary>
        </member>
        <member name="P:NCDK.IO.RssWriter.DateMap">
            <summary>
            the date map. If you put a <see cref="T:System.DateTime"/> in this map with one of the objects you want to write as key, it will be added as a date to this object (no validity check is done)
            </summary>
        </member>
        <member name="P:NCDK.IO.RssWriter.TitleMap">
            <summary>
            the title map. If you put a string in this map with one of the objects you want to write as key, it will be added as a title to this object (no validity check is done)
            </summary>
        </member>
        <member name="P:NCDK.IO.RssWriter.CreatorMap">
            <summary>
            the creator map. If you put a string in this map with one of the objects you want to write as key, it will be added as a creator to this object (no validity check is done)
            </summary>
        </member>
        <member name="P:NCDK.IO.RssWriter.InChIMap">
            <summary>
            InChI map If you put any number of strings in this map with one of the objects you want to write as key, it will be added as a child to the same node as the cml code of the object
            </summary>
        </member>
        <member name="F:NCDK.IO.RssWriter.Title">
            <summary>
            This will be the title for the rss feed
            </summary>
        </member>
        <member name="F:NCDK.IO.RssWriter.Link">
            <summary>
            This will be the link for the rss feed
            </summary>
        </member>
        <member name="F:NCDK.IO.RssWriter.Description">
            <summary>
            This will be the description for the rss feed
            </summary>
        </member>
        <member name="P:NCDK.IO.RssWriter.Publisher">
            <summary>
            This will be the Publisher for the rss feed
            </summary>
        </member>
        <member name="F:NCDK.IO.RssWriter.ImageLink">
            <summary>
            This will be the ImageLink for the rss feed
            </summary>
        </member>
        <member name="F:NCDK.IO.RssWriter.About">
            <summary>
            This will be the About for the rss feed
            </summary>
        </member>
        <member name="F:NCDK.IO.RssWriter.TimeZone">
            <summary>
            This will be added to the data as TimeZone. format according to 23c. Examples "+01:00" "-05:00"
            </summary>
        </member>
        <member name="P:NCDK.IO.RssWriter.multiMap">
            <summary>
            the multi map. If you put any number of nu.xom.Elements in this map with one of the objects you want to write as key, it will be added as a child to the same node as the cml code of the object
            </summary>
        </member>
        <member name="M:NCDK.IO.RssWriter.Write(NCDK.IChemObject)">
            <summary>
            Writes a <see cref="T:NCDK.IChemObject"/> to the MDL molfile formated output.
            </summary>
            <param name="obj">Best choice is a set of molecules</param>
            <see cref="M:NCDK.IO.IChemObjectWriter.Write(NCDK.IChemObject)"/>
        </member>
        <member name="T:NCDK.IO.SDFWriter">
            <summary>
            Writes MDL SD files (<token>cdk-cite-DAL92</token>). A MDL SD file contains one or more molecules,
            complemented by properties.
            </summary>
        </member>
        <member name="M:NCDK.IO.SDFWriter.#ctor(System.IO.TextWriter)">
            <summary>
            Create an SDfile writer.
            </summary>
            <param name="wtr">writer</param>
        </member>
        <member name="M:NCDK.IO.SDFWriter.#ctor(System.IO.Stream)">
            <summary>
            Create an SDfile writer, the provided output stream is wrapped
            in a UTF-8 buffered writer.
            </summary>
            <param name="output">out stream</param>
        </member>
        <member name="M:NCDK.IO.SDFWriter.#ctor(System.IO.TextWriter,System.Collections.Generic.ICollection{System.String})">
            <summary>
            Constructs a new SDFWriter that writes to the given <see cref="T:System.IO.TextWriter"/>.
            </summary>
            <param name="output">The <see cref="T:System.IO.TextWriter"/> to write to</param>
            <param name="propertiesToWrite"></param>
        </member>
        <member name="M:NCDK.IO.SDFWriter.#ctor(System.IO.Stream,System.Collections.Generic.ICollection{System.String})">
            <summary>
            Constructs a new <see cref="T:NCDK.IO.SDFWriter"/> that can write to a given
            <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="output">The <see cref="T:System.IO.Stream"/> to write to</param>
            <param name="propertiesToWrite"></param>
        </member>
        <member name="M:NCDK.IO.SDFWriter.#ctor(System.Collections.Generic.ICollection{System.String})">
            <summary>
            Writes SD-File to a string including the given properties
            </summary>
        </member>
        <member name="M:NCDK.IO.SDFWriter.Write(NCDK.IChemObject)">
            <summary>
            Writes a <see cref="T:NCDK.IChemObject"/> to the MDL SD file formated output. It can only
            output <see cref="T:NCDK.IChemObject"/> of type <see cref="T:NCDK.IChemFile"/>, <see cref="T:NCDK.IAtomContainerSet"/>
            and <see cref="T:NCDK.IAtomContainerSet"/>.
            </summary>
            <param name="obj">an acceptable <see cref="T:NCDK.IChemObject"/></param>
            <seealso cref="M:NCDK.IO.SDFWriter.Accepts(System.Type)"/>
        </member>
        <member name="M:NCDK.IO.SDFWriter.WriteMoleculeSet(System.Collections.Generic.IEnumerable{NCDK.IAtomContainer})">
            <summary>
            Writes an <see cref="T:NCDK.IAtomContainerSet"/>.
            </summary>
            <param name="som">the <see cref="T:NCDK.IAtomContainerSet"/> to serialize</param>
        </member>
        <member name="F:NCDK.IO.SDFWriter.cdkInternalProperties">
            <summary>
            A list of properties used by CDK algorithms which must never be
            serialized into the SD file format.
            </summary>
        </member>
        <member name="T:NCDK.IO.ShelXReader">
            <summary>
            A reader for ShelX output (RES) files. It does not read all information.
            The list of fields that is read: REM, END, CELL, SPGR.
            In additions atoms are read.
            <para>A reader for ShelX files. It currently supports ShelXL.</para>
            </summary>
            <remarks>
            The ShelXL format is described on the net:
            <see href="http://www.msg.ucsf.edu/local/programs/shelxl/ch_07.html">http://www.msg.ucsf.edu/local/programs/shelxl/ch_07.html</see>.
            </remarks>
        </member>
        <member name="M:NCDK.IO.ShelXReader.#ctor(System.IO.TextReader)">
            <summary>
            Create an ShelX file reader.
            </summary>
            <param name="input">source of ShelX data</param>
        </member>
        <member name="M:NCDK.IO.ShelXReader.Read``1(``0)">
            <summary>
            Read a <see cref="T:NCDK.IChemFile"/> from input.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="obj"></param>
            <returns> the content in a <see cref="T:NCDK.IChemFile"/> object</returns>
        </member>
        <member name="M:NCDK.IO.ShelXReader.ReadChemFile(NCDK.IChemFile)">
            <summary>
            Read the ShelX from input. Each ShelX document is expected to contain one crystal structure.
            </summary>
            <param name="file"></param>
            <returns>a ChemFile with the coordinates, charges, vectors, etc.</returns>
        </member>
        <member name="T:NCDK.IO.ShelXWriter">
            <summary>
            Serializes a MoleculeSet or a Molecule object to ShelX code.
            The output can be read with Platon.
            </summary>
        </member>
        <member name="M:NCDK.IO.ShelXWriter.#ctor(System.IO.TextWriter)">
            <summary>
            Constructs a new ShelXWriter class. Output will be stored in the Writer class given as parameter.
            </summary>
            <param name="output">Writer to redirect the output to.</param>
        </member>
        <member name="M:NCDK.IO.ShelXWriter.Write(NCDK.IChemObject)">
            <summary>
            Serializes the IChemObject to ShelX and redirects it to the output Writer.
            </summary>
            <param name="obj">A Molecule of MoleculeSet object</param>
        </member>
        <member name="T:NCDK.IO.SMILESReader">
             <summary>
             This Reader reads files which has one SMILES string on each
             line, where the format is given as below:
             <para>
             COC ethoxy ethane
             </para>
             Thus first the SMILES, and then after the first space (or tab) on the line a title
             that is stored as <see cref="F:NCDK.CDKPropertyName.Title"/>. For legacy comparability the
             title is also placed in a "SMIdbNAME" property. If a line is invalid an empty
             molecule is inserted into the container set. The molecule with have the prop
             <see cref="F:NCDK.IO.Iterator.EnumerableSMILESReader.BadSmilesInput"/> set to the input line that
             could not be read. 
            
             <para>For each line a molecule is generated, and multiple Molecules are
             read as MoleculeSet.</para>
             </summary>
             <seealso cref="T:NCDK.IO.Iterator.EnumerableSMILESReader"/>
        </member>
        <member name="M:NCDK.IO.SMILESReader.#ctor(System.IO.TextReader)">
             <summary>
             Construct a new reader from a Reader and a specified builder object.
            
             <param name="input">The Reader object from which to read structures</param>
             </summary>
        </member>
        <member name="M:NCDK.IO.SMILESReader.Read``1(``0)">
            <summary>
            Reads the content from a XYZ input. It can only return a
            <see cref="T:NCDK.IChemObject"/> of type <see cref="T:NCDK.IChemFile"/>.
            </summary>
            <param name="obj">class must be of type ChemFile</param>
            <seealso cref="T:NCDK.IChemFile"/>
        </member>
        <member name="M:NCDK.IO.SMILESReader.ReadAtomContainerSet(NCDK.IChemObjectSet{NCDK.IAtomContainer})">
            <summary>
             Private method that actually parses the input to read a ChemFile
             object.
            </summary>
            <param name="som">The set of molecules that came from the file</param>
            <returns>A ChemFile containing the data parsed from input.</returns>
        </member>
        <member name="M:NCDK.IO.SMILESReader.Suffix(System.String)">
            <summary>
            Obtain the suffix after a line containing SMILES. The suffix follows
            any ' ' or '\t' termination characters.
            </summary>
            <param name="line">input line</param>
            <returns>the suffix - or an empty line</returns>
        </member>
        <member name="T:NCDK.IO.SMILESWriter">
            <summary>
            Writes the SMILES strings to a plain text file.
            </summary>
        </member>
        <member name="M:NCDK.IO.SMILESWriter.#ctor(System.IO.TextWriter)">
            <summary>
            Constructs a new SMILESWriter that can write a list of SMILES to a Writer
            </summary>
            <param name="output">The Writer to write to</param>
        </member>
        <member name="M:NCDK.IO.SMILESWriter.Write(NCDK.IChemObject)">
            <summary>
            Writes the content from object to output.
            </summary>
            <param name="obj">IChemObject of which the data is given as output.</param>
        </member>
        <member name="M:NCDK.IO.SMILESWriter.WriteAtomContainerSet(System.Collections.Generic.IEnumerable{NCDK.IAtomContainer})">
            <summary>
            Writes a list of molecules to an Stream.
            </summary>
            <param name="som">MoleculeSet that is written to an Stream</param>
        </member>
        <member name="M:NCDK.IO.SMILESWriter.WriteAtomContainer(NCDK.IAtomContainer)">
            <summary>
            Writes the content from molecule to output.
            </summary>
            <param name="molecule">Molecule of which the data is given as output.</param>
        </member>
        <member name="T:NCDK.IO.VASPReader">
            <summary>
            Read output files generated with the VASP software.
            </summary>
        </member>
        <member name="F:NCDK.IO.VASPReader.anames">
            <summary>size is ntype. Contains the names of the atoms</summary>
        </member>
        <member name="F:NCDK.IO.VASPReader.representation">
            <summary>"Direct" only so far</summary>
        </member>
        <member name="M:NCDK.IO.VASPReader.#ctor(System.IO.TextReader)">
            <summary>
            Creates a new <see cref="T:NCDK.IO.VASPReader"/> instance.
            </summary>
            <param name="input">a <see cref="T:System.IO.TextReader"/> value</param>
        </member>
        <member name="M:NCDK.IO.VASPReader.NextVASPToken(System.Boolean)">
             <summary>
             Find the next token of an VASP file.
             ABINIT tokens are words separated by space(s). Characters
             following a "#" are ignored till the end of the line.
            
             <returns>a <see cref="T:System.String"/> value</returns>
             <exception cref="T:System.IO.IOException">if an error occurs</exception>
             </summary>
        </member>
        <member name="M:NCDK.IO.VASPReader.NextVASPTokenFollowing(System.String)">
            <summary>
            Find the next token of a VASP file beginning
            with the *next* line.
            </summary>
        </member>
        <member name="T:NCDK.IO.WriterFactory">
            <summary>
            Helper tool to create IChemObjectWriters.
            </summary>
        </member>
        <member name="M:NCDK.IO.WriterFactory.#ctor">
            <summary>
            Constructs a ChemObjectIOInstantionTests.
            </summary>
        </member>
        <member name="M:NCDK.IO.WriterFactory.FindChemFormats(System.Int32)">
            <summary>
            Finds IChemFormats that provide a container for serialization for the
            given features. The syntax of the integer is explained in the DataFeatures class.
            </summary>
            <param name="features">the data features for which a IChemFormat is searched</param>
            <returns>an array of IChemFormat's that can contain the given features</returns>
            <seealso cref="T:NCDK.Tools.DataFeatures"/>
        </member>
        <member name="M:NCDK.IO.WriterFactory.CreateWriter(NCDK.IO.Formats.IChemFormat,System.IO.Stream)">
            <summary>
            Creates a new IChemObjectWriter based on the given IChemFormat.
            </summary>
        </member>
        <member name="M:NCDK.IO.WriterFactory.CreateWriter(NCDK.IO.Formats.IChemFormat,System.IO.TextWriter)">
            <summary>
            Creates a new IChemObjectWriter based on the given IChemFormat.
            </summary>
        </member>
        <member name="T:NCDK.IO.XYZReader">
            <summary>
            Reads an object from XYZ formated input.
            
            <para>This class is based on Dan Gezelter's XYZReader from Jmol</para>
            </summary>
        </member>
        <member name="M:NCDK.IO.XYZReader.#ctor(System.IO.TextReader)">
            <summary>
            Construct a new reader from a Reader type object.
            </summary>
            <param name="input">reader from which input is read</param>
        </member>
        <member name="M:NCDK.IO.XYZReader.Read``1(``0)">
            <summary>
            reads the content from a XYZ input. It can only return a
            <see cref="T:NCDK.IChemObject"/>  of type <see cref="T:NCDK.IChemFile"/> 
            </summary>
            <param name="obj">class must be of type ChemFile</param>
            <seealso cref="T:NCDK.IChemFile"/>
        </member>
        <member name="M:NCDK.IO.XYZReader.ReadChemFile(NCDK.IChemFile)">
            <summary>
             Private method that actually parses the input to read a <see cref="T:NCDK.IChemFile"/>  object.
            </summary>
            <returns>A ChemFile containing the data parsed from input.</returns>
        </member>
        <member name="T:NCDK.IO.XYZWriter">
            <summary>
            </summary>
        </member>
        <member name="M:NCDK.IO.XYZWriter.#ctor(System.IO.TextWriter)">
            <summary>
            Constructor.
            </summary>
            <param name="output">the stream to write the XYZ file to.</param>
        </member>
        <member name="M:NCDK.IO.XYZWriter.WriteMolecule(NCDK.IAtomContainer)">
            <summary>
            writes a single frame in XYZ format to the Writer.
            <param name="mol">the Molecule to write</param>
            </summary>
        </member>
        <member name="T:NCDK.IO.ZMatrixReader">
            <summary>
            It reads Z matrices like in Gaussian input files. It seems that it cannot
            handle Z matrices where values are given via a stringID for which the value
            is given later.
            </summary>
        </member>
        <member name="M:NCDK.IO.ZMatrixReader.#ctor(System.IO.TextReader)">
            <summary>
            Constructs a <see cref="T:NCDK.IO.ZMatrixReader"/> from a Reader that contains the
            data to be parsed.
            </summary>
            <param name="input">Reader containing the data to read</param>
        </member>
        <member name="M:NCDK.IO.ZMatrixReader.Read``1(``0)">
             <summary>
              Returns a <see cref="T:NCDK.IChemObject"/> of type object bye reading from
              the input.
            
              The function supports only reading of <see cref="T:NCDK.IChemFile"/>'s.
             </summary>
             <param name="obj">IChemObject that types the class to return.</param>
             <exception cref="T:NCDK.CDKException">when a <see cref="T:NCDK.IChemObject"/> is requested that cannot be read.</exception>
        </member>
        <member name="M:NCDK.IO.ZMatrixReader.ReadChemFile(NCDK.IChemFile)">
            <summary>
             Private method that actually parses the input to read a <see cref="T:NCDK.IChemFile"/> object.
            </summary>
            <param name="file">the file to read from</param>
            <returns>A ChemFile containing the data parsed from input.</returns>
        </member>
        <member name="M:NCDK.Fingerprints.AbstractFingerprinter.GetParameters">
            <summary>
            Base classes should override this method to report the parameters they
            are configured with.
            </summary>
            <returns>The key=value pairs of configured parameters</returns>
        </member>
        <member name="M:NCDK.Fingerprints.AbstractFingerprinter.GetFingerprint(NCDK.IAtomContainer)">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Fingerprints.IBitFingerprint">
            <summary>
            Interface for bit fingerprint representations.
            </summary>
        </member>
        <member name="P:NCDK.Fingerprints.IBitFingerprint.Cardinality">
            <summary>
            The number of bits set to true in the fingerprint.
            </summary>
        </member>
        <member name="P:NCDK.Fingerprints.IBitFingerprint.Count">
            <summary>
            The size of the fingerprint, i.e., the number of hash bins.
            </summary>
        </member>
        <member name="M:NCDK.Fingerprints.IBitFingerprint.And(NCDK.Fingerprints.IBitFingerprint)">
            <summary>
            Performs a logical <b>AND</b> of the bits in this target bit set with
            the bits in the argument fingerprint. This fingerprint is modified so
            that each bit in it has the value <see langword="true"/> if and only if 
            it both initially had the value <see langword="true"/> and the
            corresponding bit in the fingerprint argument also had the value
            <see langword="true"/>.
            </summary>
            <param name="fingerprint">the fingerprint with which to perform the AND operation</param>
            <exception cref="T:System.ArgumentException">if the two fingerprints are not of same size</exception>
        </member>
        <member name="M:NCDK.Fingerprints.IBitFingerprint.Or(NCDK.Fingerprints.IBitFingerprint)">
            <summary>
            Performs a logical <b>OR</b> of the bits in this target bit set with
            the bits in the argument fingerprint. This operation can also be seen
            as merging two fingerprints. This fingerprint is modified so
            that each bit in it has the value <see langword="true"/> if and only if
            it either already had the value <see langword="true"/> or the corresponding
            bit in the bit set argument has the value <see langword="true"/>.
            </summary>        
            <param name="fingerprint">the fingerprint with which to perform the OR operation</param>
            <exception cref="T:System.ArgumentException">if the two fingerprints are not of same size</exception>
        </member>
        <member name="P:NCDK.Fingerprints.IBitFingerprint.Item(System.Int32)">
            <summary>
            The value of the bit with the specified index. The value
            is <see langword="true"/> if the bit with the index <paramref name="index"/>
            is currently set in this fingerprint; otherwise, the result
            is <see langword="false"/>.
            </summary>
            <param name="index">the index of the bit to return the value for</param>
        </member>
        <member name="M:NCDK.Fingerprints.IBitFingerprint.AsBitSet">
            <summary>
            Returns a <see cref="T:System.Collections.BitArray"/> representation of the fingerprint.
            This might take significantly more memory!
            </summary>
            <returns>the fingerprint as a <see cref="T:System.Collections.BitArray"/></returns>
        </member>
        <member name="M:NCDK.Fingerprints.IBitFingerprint.Set(System.Int32)">
            <summary>
            Sets the bit at the specified index to true.
            <param name="i">index</param>
            </summary>
        </member>
        <member name="M:NCDK.Fingerprints.IBitFingerprint.GetSetBits">
            <summary>
            Returns a listing of the bits in the fingerprint that are set to true.
            </summary>
            <returns>listing of all bits that are set</returns>
        </member>
        <member name="T:NCDK.Fingerprints.ICountFingerprint">
            <summary>
            Interface for count fingerprint representations. The fingerprint is
            regarded as a list of hashes and a list of counts where the the list of
            counts keeps track of how many times the corresponding hash is found in
            the fingerprint. So index refers to position in the list. The list must
            be sorted in natural order (ascending).
            </summary>
        </member>
        <member name="P:NCDK.Fingerprints.ICountFingerprint.Count">
            <summary>
            The number of bits of this fingerprint.
            </summary>
        </member>
        <member name="M:NCDK.Fingerprints.ICountFingerprint.GetNumberOfPopulatedBins">
            <summary>
            Returns the number of bins that are populated. This number is typically smaller
            then the total number of bins.
            </summary>
            <returns>the number of populated bins</returns>
            <see cref="P:NCDK.Fingerprints.ICountFingerprint.Count"/>
        </member>
        <member name="M:NCDK.Fingerprints.ICountFingerprint.GetCount(System.Int32)">
            <summary>
            Returns the count value for the bin with the given index.
            </summary>
            <param name="index">the index of the bin to return the number of hits for.</param>
            <returns>the count for the bin with given index.</returns>
        </member>
        <member name="M:NCDK.Fingerprints.ICountFingerprint.GetHash(System.Int32)">
            <summary>
            Returns the hash corresponding to the given index in the fingerprint.
            </summary>
            <param name="index">the index of the bin to return the hash for.</param>
            <returns>the hash for the bin with the given index.</returns>
        </member>
        <member name="M:NCDK.Fingerprints.ICountFingerprint.Merge(NCDK.Fingerprints.ICountFingerprint)">
            <summary>
            Merge all from <paramref name="fp"/> into the current fingerprint.
            </summary>
            <param name="fp">to be merged</param>
        </member>
        <member name="M:NCDK.Fingerprints.ICountFingerprint.SetBehaveAsBitFingerprint(System.Boolean)">
            <summary>
            Changes behaviour, if true is given the count fingerprint will
            behave as a bit fingerprint and return 0 or 1 for counts.
            </summary>
            <param name="behaveAsBitFingerprint"></param>
        </member>
        <member name="M:NCDK.Fingerprints.ICountFingerprint.HasHash(System.Int32)">
            <summary>
            Whether the fingerprint contains the given hash.
            </summary>
            <param name="hash"></param>
            <returns>true if the fingerprint contains the given hash, otherwise false.</returns>
        </member>
        <member name="M:NCDK.Fingerprints.ICountFingerprint.GetCountForHash(System.Int32)">
            <summary>
            Get the number of times a certain hash exists in the fingerprint.
            </summary>
            <param name="hash"></param>
            <returns>the number associated with the given hash</returns>
        </member>
        <member name="T:NCDK.Fingerprints.IFingerprinter">
            <summary>
            Interface for fingerprint calculators.
            </summary>
        </member>
        <member name="M:NCDK.Fingerprints.IFingerprinter.GetVersionDescription">
            <summary>
            Generate a fingerprint type version description in chemfp's FPS format. We
            report the library version rather than an individual version per fingerprint,
            although this is awkward as many fingerprint's don't/won't change between releases
            and we can not keep comptability we guarantee we document how the fingerprint was
            encoded.
            </summary>
            <remarks>
            Examples:
            <pre>
            #type=CDK-Fingerprinter/2.0 searchDepth=7 pathLimit=2000 hashPseudoAtoms=true
            #type=CDK-CircularFingerprint/2.0 classType=ECFP4
            </pre>
            </remarks>
            <returns>version description.</returns>
        </member>
        <member name="M:NCDK.Fingerprints.IFingerprinter.GetFingerprint(NCDK.IAtomContainer)">
            <summary>
            Generate a binary fingerprint as a bit. This method will usually delegate to
            <see cref="M:NCDK.Fingerprints.IFingerprinter.GetBitFingerprint(NCDK.IAtomContainer)"/> and invoke
            <see cref="M:NCDK.Fingerprints.IBitFingerprint.AsBitSet"/>, it is included for backwards compatibility.
            </summary>
            <param name="mol">molecule</param>
            <returns>BitSet</returns>
            <exception cref="T:NCDK.CDKException">problem generating fingerprint</exception>
        </member>
        <member name="M:NCDK.Fingerprints.IFingerprinter.GetBitFingerprint(NCDK.IAtomContainer)">
            <summary>
            Returns the bit fingerprint for the given <see cref="T:NCDK.IAtomContainer"/>.
            </summary>
            <param name="container"><see cref="T:NCDK.IAtomContainer"/> for which the fingerprint should be calculated.</param>
            <returns>the bit fingerprint</returns>
            <exception cref="T:NCDK.CDKException">may be thrown if there is an error during aromaticity detection or (for key based fingerprints) if there is a SMARTS parsing error</exception>   
            <exception cref="T:System.NotSupportedException">if the Fingerprinter can not produce bit fingerprints</exception>
        </member>
        <member name="M:NCDK.Fingerprints.IFingerprinter.GetCountFingerprint(NCDK.IAtomContainer)">
            <summary>
            Returns the count fingerprint for the given <see cref="T:NCDK.IAtomContainer"/>.
            </summary>
            <param name="container"><see cref="T:NCDK.IAtomContainer"/> for which the fingerprint should be calculated.</param>
            <returns>the count fingerprint</returns>
            <exception cref="T:NCDK.CDKException">if there is an error during aromaticity detection or (for key based fingerprints) if there is a SMARTS parsing error.</exception>
            <exception cref="T:System.NotSupportedException">if the Fingerprinter can not produce count fingerprints</exception>
        </member>
        <member name="M:NCDK.Fingerprints.IFingerprinter.GetRawFingerprint(NCDK.IAtomContainer)">
            <summary>
            Returns the raw representation of the fingerprint for the given IAtomContainer. The raw representation contains
            counts as well as the key strings.
            </summary>
            <param name="container">IAtomContainer for which the fingerprint should be calculated.</param>
            <returns>the raw fingerprint</returns>
            <exception cref="T:NCDK.CDKException"></exception>
        </member>
        <member name="P:NCDK.Fingerprints.IFingerprinter.Count">
            <summary>
            The size (or length) of the fingerprint.
            </summary>
        </member>
        <member name="T:NCDK.Fingerprints.CircularFingerprinter">
             <summary>
              <para>Circular fingerprints: for generating fingerprints that are functionally equivalent to ECFP-2/4/6 and FCFP-2/4/6
              fingerprints, which are partially described by Rogers et al. <token>cdk-cite-Rogers2010</token>.</para>
             </summary>
             <remarks>
              <para>While the literature describes the method in detail, it does not disclose either the hashing technique for converting
              lists of integers into 32-bit codes, nor does it describe the scheme used to classify the atom types for creating
              the FCFP-class of descriptors. For this reason, the fingerprints that are created are not binary compatible with
              the reference implementation. They do, however, achieve effectively equal performance for modelling purposes.</para>
            
              <para>The resulting fingerprint bits are presented as a list of unique bits, each with a 32-bit hashcode; typically there
              are no more than a hundred or so unique bit hashcodes per molecule. These identifiers can be folded into a smaller
              array of bits, such that they can be represented as a single long binary number, which is often more convenient.</para>
            
                <para>The  integer hashing is done using the CRC32 algorithm, using the Java CRC32 class, which is the same
                formula/parameters as used by PNG files, and described in:</para>
            
                    <see href="http://www.w3.org/TR/PNG/#D-CRCAppendix">http://www.w3.org/TR/PNG/#D-CRCAppendix</see>
            
                <para>Implicit vs. explicit hydrogens are handled, i.e. it doesn't matter whether the incoming molecule is hydrogen
                suppressed or not.</para>
            
              <para>Implementation note: many of the algorithms involved in the generation of fingerprints (e.g. aromaticity, atom
              typing) have been coded up explicitly for use by this class, rather than making use of comparable functionality
              elsewhere in the CDK. This is to ensure that the CDK implementation of the algorithm is strictly equal to other
              implementations: dependencies on CDK functionality that could be modified or improved in the future would break
              binary compatibility with formerly identical implementations on other platforms.</para>
            
              <para>For the FCFP class of fingerprints, atom typing is done using a scheme similar to that described by
              Green et al <token>cdk-cite-Green1994</token>.</para>
              
              <para>The fingerprints and their uses have been described in the literature: A.M. Clark, M. Sarker, E. Ekins,
              "New target prediction and visualization tools incorporating open source molecular fingerprints for TB Mobile 2.0",
              Journal of Cheminformatics, 6:38 (2014).</para>
              
                  <see href="http://www.jcheminf.com/content/6/1/38">http://www.jcheminf.com/content/6/1/38</see>
             </remarks>
        </member>
        <member name="F:NCDK.Fingerprints.CircularFingerprinter.CLASS_ECFP0">
            ------------ constants ------------
            identity by literal atom environment
        </member>
        <member name="F:NCDK.Fingerprints.CircularFingerprinter.CLASS_FCFP0">
            identity by functional character of the atom
        </member>
        <member name="F:NCDK.Fingerprints.CircularFingerprinter.ATOMCLASS_ECFP">
            ------------ private members ------------
        </member>
        <member name="F:NCDK.Fingerprints.CircularFingerprinter.amask">
            summary information about the molecule, for quick access
        </member>
        <member name="F:NCDK.Fingerprints.CircularFingerprinter.maskDon">
            stored information for bio-typing; only defined for FCFP-class fingerprints
        </member>
        <member name="F:NCDK.Fingerprints.CircularFingerprinter.maskAcc">
            stored information for bio-typing; only defined for FCFP-class fingerprints
        </member>
        <member name="F:NCDK.Fingerprints.CircularFingerprinter.maskPos">
            stored information for bio-typing; only defined for FCFP-class fingerprints
        </member>
        <member name="F:NCDK.Fingerprints.CircularFingerprinter.maskNeg">
            stored information for bio-typing; only defined for FCFP-class fingerprints
        </member>
        <member name="F:NCDK.Fingerprints.CircularFingerprinter.maskAro">
            stored information for bio-typing; only defined for FCFP-class fingerprints
        </member>
        <member name="F:NCDK.Fingerprints.CircularFingerprinter.maskHal">
            stored information for bio-typing; only defined for FCFP-class fingerprints
        </member>
        <member name="M:NCDK.Fingerprints.CircularFingerprinter.#ctor">
            ------------ methods ------------
            <summary>
            Default constructor: uses the ECFP6 type.
            </summary>
        </member>
        <member name="M:NCDK.Fingerprints.CircularFingerprinter.#ctor(System.Int32)">
            <summary>
            Specific constructor: initializes with descriptor class type, one of ECFP_{p} or FCFP_{p}, where ECFP is
            for the extended-connectivity fingerprints, FCFP is for the functional class version, and {p} is the
            path diameter, and may be 0, 2, 4 or 6.
            </summary>
            <param name="classType">one of CLASS_ECFP{n} or CLASS_FCFP{n}</param>
        </member>
        <member name="M:NCDK.Fingerprints.CircularFingerprinter.#ctor(System.Int32,System.Int32)">
            <summary>
            Specific constructor: initializes with descriptor class type, one of ECFP_{p} or FCFP_{p}, where ECFP is
            for the extended-connectivity fingerprints, FCFP is for the functional class version, and {p} is the
            path diameter, and may be 0, 2, 4 or 6.
            </summary>
            <param name="classType">one of CLASS_ECFP{n} or CLASS_FCFP{n}</param>
            <param name="len">size of folded (binary) fingerprint</param>
        </member>
        <member name="M:NCDK.Fingerprints.CircularFingerprinter.Calculate(NCDK.IAtomContainer)">
            <summary>
            Calculates the fingerprints for the given <see cref="T:NCDK.IAtomContainer"/>, and stores them for subsequent retrieval.
            </summary>
            <param name="mol">chemical structure; all nodes should be known legitimate elements</param>
        </member>
        <member name="P:NCDK.Fingerprints.CircularFingerprinter.FPCount">
            <summary>
            Returns the number of fingerprints generated.
            </summary>
            <returns>total number of unique fingerprint hashes generated</returns>
        </member>
        <member name="M:NCDK.Fingerprints.CircularFingerprinter.GetFP(System.Int32)">
            <summary>
            Returns the requested fingerprint.
            </summary>
            <param name="N">index of fingerprint (0-based)</param>
            <returns>instance of a fingerprint hash</returns>
        </member>
        <member name="M:NCDK.Fingerprints.CircularFingerprinter.GetBitFingerprint(NCDK.IAtomContainer)">
            <summary>
            Calculates the circular fingerprint for the given <see cref="T:NCDK.IAtomContainer"/>, and <b>folds</b> the result into a single bitset
            (see GetSize()).
            </summary>
            <param name="mol">IAtomContainer for which the fingerprint should be calculated.</param>
            <returns>the fingerprint</returns>
        </member>
        <member name="M:NCDK.Fingerprints.CircularFingerprinter.GetCountFingerprint(NCDK.IAtomContainer)">
            <summary>
            Calculates the circular fingerprint for the given <see cref="T:NCDK.IAtomContainer"/>, and returns a datastructure that enumerates all
            of the fingerprints, and their counts (i.e. does <b>not</b> fold them into a bitmask).
            </summary>
            <param name="mol">IAtomContainer for which the fingerprint should be calculated.</param>
            <returns>the count fingerprint</returns>
        </member>
        <member name="M:NCDK.Fingerprints.CircularFingerprinter.GetRawFingerprint(NCDK.IAtomContainer)">
            <summary>
            Invalid: it is not appropriate to convert the integer hash codes into strings.
            </summary>
        </member>
        <member name="P:NCDK.Fingerprints.CircularFingerprinter.Count">
            <summary>
            Returns the extent of the folded fingerprints.
            </summary>
            <returns>the size of the fingerprint</returns>
        </member>
        <member name="M:NCDK.Fingerprints.CircularFingerprinter.InitialIdentityECFP(System.Int32)">
            ------------ private methods ------------
            calculates an integer number that stores the bit-packed identity of the given atom
        </member>
        <member name="M:NCDK.Fingerprints.CircularFingerprinter.CircularIterate(System.Int32,System.Int32)">
            takes the current identity values
        </member>
        <member name="M:NCDK.Fingerprints.CircularFingerprinter.GrowAtoms(System.Int32[])">
            takes a set of atom indices and adds all atoms that are adjacent to at least one of them; the resulting list of
            atom indices is sorted
        </member>
        <member name="M:NCDK.Fingerprints.CircularFingerprinter.ConsiderNewFP(NCDK.Fingerprints.CircularFingerprinter.FP)">
            consider adding a new fingerprint: if it's a duplicate with regard to the atom list, either replace the match or
            discard it
        </member>
        <member name="M:NCDK.Fingerprints.CircularFingerprinter.ExcavateMolecule">
            ------------ molecule analysis: cached cheminformatics ------------
            summarize preliminary information about the molecular structure, to make sure the rest all goes quickly
        </member>
        <member name="M:NCDK.Fingerprints.CircularFingerprinter.MarkRingBlocks">
            assign a ring block ID to each atom (0=not in ring)
        </member>
        <member name="M:NCDK.Fingerprints.CircularFingerprinter.RecursiveRingFind(System.Int32[],System.Int32,System.Int32,System.Int32,System.Collections.Generic.List{System.Int32[]})">
            hunt for ring recursively: start with a partially defined path, and go exploring
        </member>
        <member name="M:NCDK.Fingerprints.CircularFingerprinter.DetectStrictAromaticity">
            aromaticity detection: uses a very narrowly defined algorithm, which detects 6-membered rings with alternating double bonds;
            rings that are chained together (e.g. anthracene) will also be detected by the extended followup; note that this will NOT mark
            rings such as thiophene, imidazolium, porphyrins, etc.: these systems will be left in their original single/double bond form
        </member>
        <member name="M:NCDK.Fingerprints.CircularFingerprinter.RubricTetrahedral(System.Int32)">
            tetrahedral 'rubric': for any sp3 atom that has enough neighbours and appropriate wedge bond/3D geometry information,
            build up a list of neighbours in a certain permutation order; the resulting array of size 4 can have a total of
            24 permutations; there are two groups of 12 that can be mapped onto each other by tetrahedral rotations, hence this
            is a partioning technique for chirality; it can be thought of as all but the last step of determination of chiral
            parity, except that the raw information is required for the circular fingerprint chirality resolution; note that this
            does not consider the possibility of lone-pair chirality (e.g. sp3 phosphorus)
        </member>
        <member name="M:NCDK.Fingerprints.CircularFingerprinter.CalculateBioTypes">
            biotypes: when generating FCFP-type descriptors, atoms are initially labelled according to their functional
            capabilities, that being defined by centers of biological interactions, such as hydrogen bonding and electrostatics
        </member>
        <member name="M:NCDK.Fingerprints.CircularFingerprinter.ConsiderBioTypeAromaticity(System.Int32[])">
            if the given ring is aromatic, mark the atoms accordingly: note that this "biotype" definition of aromaticity is
            different to the one used in the rest of this class: any ring of size 5 to 7 that has a lone pair or pi bond on every
            atom is labelled as aromatic, because the concept required is physical behaviour, i.e. ring current and effect on
            neighbouring functional groups, rather than disambiguating conjugational equivalence
        </member>
        <member name="M:NCDK.Fingerprints.CircularFingerprinter.ConsiderBioTypeTetrazole(System.Int32[])">
            if the given ring is a tetrazole, mark the aroms accordingly; must be ring size length 5; it's possible to fool the
            tetrazole test with a non-sane/invalid molecule
        </member>
        <member name="M:NCDK.Fingerprints.CircularFingerprinter.DetermineDonor(System.Int32)">
            hydrogen bond donor
        </member>
        <member name="M:NCDK.Fingerprints.CircularFingerprinter.DetermineAcceptor(System.Int32)">
            hydrogen bond acceptor
        </member>
        <member name="M:NCDK.Fingerprints.CircularFingerprinter.DeterminePositive(System.Int32)">
            positive charge centre
        </member>
        <member name="M:NCDK.Fingerprints.CircularFingerprinter.DetermineNegative(System.Int32)">
            negative charge centre
        </member>
        <member name="M:NCDK.Fingerprints.CircularFingerprinter.DetermineHalide(System.Int32)">
            halide
        </member>
        <member name="M:NCDK.Fingerprints.CircularFingerprinter.BondOrderBioType(System.Int32)">
            returns either the bond order in the molecule, or -1 if the atoms are both labelled as aromatic
        </member>
        <member name="M:NCDK.Fingerprints.CircularFingerprinter.AppendInteger(System.Int32[],System.Int32)">
            convenience: appending to an int array
        </member>
        <member name="M:NCDK.Fingerprints.CircularFingerprinter.FindBond(System.Int32,System.Int32)">
            convenience: scans the atom adjacency to grab the bond index
        </member>
        <member name="T:NCDK.Fingerprints.EStateFingerprinter">
            <summary>
            This fingerprinter generates 79 bit fingerprints using the E-State fragments.
            </summary>
            <remarks>
            <para>The E-State fragments are those described in <token>cdk-cite-HALL1995</token> and
            the SMARTS patterns were taken from
            <see href="http://www.rdkit.org">RDKit</see>. Note that this fingerprint simply
            indicates the presence or occurrence of the fragments. If you need counts
            of the fragments take a look at <see cref="!:QSAR.Descriptors.Moleculars.KierHallSmartsDescriptor"/>,
            which also lists the substructures corresponding to each bit position.
            </para>
            <para>This class assumes that aromaticity perception and atom typing have
            been performed prior to generating the fingerprint.
            </para>
            <note type="warning">
            ESTATE substructure keys cannot be used for substructure
            filtering. It is possible for some keys to match substructures and not match
            the superstructures. Some keys check for hydrogen counts which may not be
            preserved in a superstructure.
            </note>
            </remarks>
        </member>
        <member name="M:NCDK.Fingerprints.EStateFingerprinter.GetBitFingerprint(NCDK.IAtomContainer)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Fingerprints.EStateFingerprinter.GetRawFingerprint(NCDK.IAtomContainer)">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.Fingerprints.EStateFingerprinter.Count">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Fingerprints.EStateFingerprinter.GetCountFingerprint(NCDK.IAtomContainer)">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Fingerprints.ExtendedFingerprinter">
            <summary>
            Generates an extended fingerprint for a given <see cref="T:NCDK.IAtomContainer"/>, that
            the <see cref="T:NCDK.Fingerprints.Fingerprinter"/> with additional bits describing ring
            features.
            </summary>
            <seealso cref="T:NCDK.Fingerprints.Fingerprinter"/>
        </member>
        <member name="M:NCDK.Fingerprints.ExtendedFingerprinter.#ctor">
            <summary>
            Creates a fingerprint generator of length <see cref="F:NCDK.Fingerprints.Fingerprinter.DefaultSize"/> 
            and with a search depth of <see cref="F:NCDK.Fingerprints.Fingerprinter.DefaultSearchDepth"/>.
            </summary>
        </member>
        <member name="M:NCDK.Fingerprints.ExtendedFingerprinter.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructs a fingerprint generator that creates fingerprints of
            the given size, using a generation algorithm with the given search
            depth.
            </summary>
            <param name="size">The desired size of the fingerprint</param>
            <param name="searchDepth">The desired depth of search</param>
        </member>
        <member name="M:NCDK.Fingerprints.ExtendedFingerprinter.GetBitFingerprint(NCDK.IAtomContainer)">
            <summary>
            Generates a fingerprint of the default size for the given
            AtomContainer, using path and ring metrics. It contains the
            informations from GetBitFingerprint() and bits which tell if the structure
            has 0 rings, 1 or less rings, 2 or less rings ... 10 or less rings
            (referring to smallest set of smallest rings) and bits which tell if
            there is a fused ring system with 1,2...8 or more rings in it
            </summary>
            <param name="container">The AtomContainer for which a Fingerprint is generated</param>
            <returns>a bit fingerprint for the given <see cref="T:NCDK.IAtomContainer"/>.</returns>
        </member>
        <member name="M:NCDK.Fingerprints.ExtendedFingerprinter.GetRawFingerprint(NCDK.IAtomContainer)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Fingerprints.ExtendedFingerprinter.GetBitFingerprint(NCDK.IAtomContainer,NCDK.IRingSet,System.Collections.Generic.IList{NCDK.IRingSet})">
            <summary>
            Generates a fingerprint of the default size for the given
            AtomContainer, using path and ring metrics. It contains the
            informations from <see cref="M:NCDK.Fingerprints.Fingerprinter.GetBitFingerprint(NCDK.IAtomContainer)"/> and bits which tell if the structure
            has 0 rings, 1 or less rings, 2 or less rings ... 10 or less rings and
            bits which tell if there is a fused ring system with 1,2...8 or more
            rings in it. The RingSet used is passed via rs parameter. This must be
            a smallesSetOfSmallestRings. The List must be a list of all ring
            systems in the molecule.
            </summary>
            <param name="atomContainer">The AtomContainer for which a Fingerprint is generated</param>
            <param name="ringSet">An SSSR RingSet of ac (if not available, use <see cref="M:NCDK.Fingerprints.ExtendedFingerprinter.GetBitFingerprint(NCDK.IAtomContainer)"/>, which does the calculation)</param>
            <param name="rslist">A list of all ring systems in ac</param>
            <exception cref="T:NCDK.CDKException">for example if input can not be cloned.</exception>
            <returns>a BitArray representing the fingerprint</returns>
        </member>
        <member name="P:NCDK.Fingerprints.ExtendedFingerprinter.Count">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Fingerprints.ExtendedFingerprinter.GetCountFingerprint(NCDK.IAtomContainer)">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Fingerprints.Fingerprinter">
            <summary>
            Generates a fingerprint for a given <see cref="T:NCDK.IAtomContainer" />. Fingerprints are
            one-dimensional bit arrays, where bits are set according to a the
            occurrence of a particular structural feature (See for example the
            Daylight inc. theory manual for more information). Fingerprints allow for
            a fast screening step to exclude candidates for a substructure search in a
            database. They are also a means for determining the similarity of chemical
            structures. 
            <para>
            The FingerPrinter assumes that hydrogens are explicitly given! 
            Furthermore, if pseudo atoms or atoms with malformed symbols are present,
            their atomic number is taken as one more than the last element currently 
            supported in <see cref="T:NCDK.Tools.PeriodicTable" />.</para>
            </summary>
            <example>
            A fingerprint is generated for an <see cref="T:NCDK.IAtomContainer" /> with this code: 
            <code>                var molecule = new AtomContainer();
                var fingerprinter = new Fingerprinter();
                var fingerprint = fingerprinter.GetBitFingerprint(molecule);
                Console.WriteLine(fingerprint.Count); // returns 1024 by default
</code>
            </example>
            <remarks>
            <note type="warning">
            The aromaticity detection for this
            FingerPrinter relies on AllRingsFinder, which is known to take very long
            for some molecules with many cycles or special cyclic topologies. Thus,
            the AllRingsFinder has a built-in timeout of 5 seconds after which it
            aborts and  Exception. If you want your SMILES generated at any
            expense, you need to create your own AllRingsFinder, set the timeout to a
            higher value, and assign it to this FingerPrinter. In the vast majority of
            cases, however, the defaults will be fine. </note>
            <note type="warning">The daylight manual says:
            "Fingerprints are not so definite: if a fingerprint indicates a pattern is
            missing then it certainly is, but it can only indicate a pattern's presence
            with some probability." In the case of very small molecules, the
            probability that you get the same fingerprint for different molecules is
            high.</note>
            </remarks>
        </member>
        <member name="F:NCDK.Fingerprints.Fingerprinter.DefaultPathLimit">
            <summary>Throw an exception if too many paths (per atom) are generated.</summary>
        </member>
        <member name="F:NCDK.Fingerprints.Fingerprinter.DefaultSize">
            <summary>The default length of created fingerprints.</summary>
        </member>
        <member name="F:NCDK.Fingerprints.Fingerprinter.DefaultSearchDepth">
            <summary>The default search depth used to create the fingerprints.</summary>
        </member>
        <member name="M:NCDK.Fingerprints.Fingerprinter.#ctor">
            <summary>
            Creates a fingerprint generator of length <see cref="F:NCDK.Fingerprints.Fingerprinter.DefaultSize"/> 
            and with a search depth of <see cref="F:NCDK.Fingerprints.Fingerprinter.DefaultSearchDepth"/>.
            </summary>
        </member>
        <member name="M:NCDK.Fingerprints.Fingerprinter.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructs a fingerprint generator that creates fingerprints of
            the given size, using a generation algorithm with the given search
            depth.
            </summary>
            <param name="size">The desired size of the fingerprint</param>
            <param name="searchDepth">The desired depth of search (number of bonds)</param>
        </member>
        <member name="M:NCDK.Fingerprints.Fingerprinter.GetBitFingerprint(NCDK.IAtomContainer,NCDK.RingSearches.AllRingsFinder)">
            <summary>
            Generates a fingerprint of the default size for the given AtomContainer.
            </summary>
            <param name="container">The AtomContainer for which a Fingerprint is generated</param>
            <param name="ringFinder">An instance of <see cref="T:NCDK.RingSearches.AllRingsFinder"/></param>
            <exception cref="T:NCDK.CDKException">if there is a timeout in ring or aromaticity perception</exception>
            <returns>A <see cref="T:System.Collections.BitArray"/> representing the fingerprint</returns>
        </member>
        <member name="M:NCDK.Fingerprints.Fingerprinter.GetBitFingerprint(NCDK.IAtomContainer)">
            <summary>
            Generates a fingerprint of the default size for the given AtomContainer.
            </summary>
            <param name="container">The AtomContainer for which a Fingerprint is generated</param>
        </member>
        <member name="M:NCDK.Fingerprints.Fingerprinter.GetRawFingerprint(NCDK.IAtomContainer)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Fingerprints.Fingerprinter.FindPathes(NCDK.IAtomContainer,System.Int32)">
            <summary>
            Get all paths of lengths 0 to the specified length.
            </summary>
            <remarks>
            This method will find all paths up to length N starting from each
            atom in the molecule and return the unique set of such paths.
            </remarks>
            <param name="container">The molecule to search</param>
            <param name="searchDepth">The maximum path length desired</param>
            <returns>A IDictionary of path strings, keyed on themselves</returns>
        </member>
        <member name="M:NCDK.Fingerprints.Fingerprinter.Compare(NCDK.IAtom,NCDK.IAtom)">
            <summary>
            Compares atom symbols lexicographical
            </summary>
            <param name="a">atom a</param>
            <param name="b">atom b</param>
            <returns>comparison &lt;0 a is less than b, &gt;0 a is more than b</returns>
        </member>
        <member name="M:NCDK.Fingerprints.Fingerprinter.Compare(NCDK.IBond,NCDK.IBond)">
            <summary>
            Compares bonds symbols lexicographical
            </summary>
            <param name="a">bond a</param>
            <param name="b">bond b</param>
            <returns>comparison &lt;0 a is less than b, &gt;0 a is more than b</returns>
        </member>
        <member name="M:NCDK.Fingerprints.Fingerprinter.Compare(System.Collections.Generic.List{NCDK.IAtom},System.Collections.Generic.List{NCDK.IBond})">
            <summary>
            Compares a path of atoms with it's self to give the
            lexicographically lowest traversal (forwards or backwards).
            </summary>
            <param name="apath">path of atoms</param>
            <param name="bpath">path of bonds</param>
            <returns>&lt;0 forward is lower &gt;0 reverse is lower</returns>
        </member>
        <member name="M:NCDK.Fingerprints.Fingerprinter.GetBondSymbol(NCDK.IBond)">
            <summary>
            Gets the bondSymbol attribute of the Fingerprinter class
            </summary>
            <param name="bond">Description of the Parameter</param>
            <returns>The bondSymbol value</returns>
        </member>
        <member name="T:NCDK.Fingerprints.FingerprinterTool">
            <summary>
            Tool with helper methods for IFingerprint.
            </summary>
        </member>
        <member name="M:NCDK.Fingerprints.FingerprinterTool.IsSubset(System.Collections.BitArray,System.Collections.BitArray)">
            <summary>
            Checks whether all the positive bits in BitArray bs2 occur in BitArray bs1. If
            so, the molecular structure from which bs2 was generated is a possible
            substructure of bs1. 
            </summary>
            <example>
            <code>                var mol = TestMoleculeFactory.MakeIndole();
                var fingerprinter = new Fingerprinter();
                var bs = fingerprinter.GetBitFingerprint(mol);
                var frag1 = TestMoleculeFactory.MakePyrrole();
                var bs1 = fingerprinter.GetBitFingerprint(frag1);
                if (FingerprinterTool.IsSubset(bs.AsBitSet(), bs1.AsBitSet()))
                {
                    Console.Out.WriteLine("Pyrrole is subset of Indole.");
                }
</code>
            </example>
            <param name="bs1">The reference <see cref="T:System.Collections.BitArray" /></param>
            <param name="bs2">The <see cref="T:System.Collections.BitArray" /> which is compared with bs1</param>
            <returns>True, if bs2 is a subset of bs1</returns>
        </member>
        <member name="M:NCDK.Fingerprints.FingerprinterTool.ListDifferences(System.Collections.BitArray,System.Collections.BitArray)">
            <summary>
            This lists all bits set in bs2 and not in bs2 (other way round not considered) in a list and to logger.
            See. <see cref="M:NCDK.Fingerprints.FingerprinterTool.Differences(System.Collections.BitArray,System.Collections.BitArray)"/> for a method to list all differences,
            including those missing present in bs2 but not bs1.
            </summary>
            <param name="bs1">First bitset</param>
            <param name="bs2">Second bitset</param>
            <returns>An arrayList of Integers</returns>
            <seealso cref="M:NCDK.Fingerprints.FingerprinterTool.Differences(System.Collections.BitArray,System.Collections.BitArray)"/>
        </member>
        <member name="M:NCDK.Fingerprints.FingerprinterTool.Differences(System.Collections.BitArray,System.Collections.BitArray)">
            <summary>
            List all differences between the two bit vectors. Unlike 
            <see cref="M:NCDK.Fingerprints.FingerprinterTool.ListDifferences(System.Collections.BitArray,System.Collections.BitArray)"/> which only list
            those which are set in <paramref name="s"/> but not in <paramref name="t"/>.
            </summary>
            <param name="s">a bit vector</param>
            <param name="t">another bit vector</param>
            <returns>all differences between <paramref name="s"/> and <paramref name="t"/></returns>
        </member>
        <member name="M:NCDK.Fingerprints.FingerprinterTool.MakeBitFingerprint(System.Collections.Generic.IDictionary{System.String,System.Int32})">
            <summary>
            Convert a mapping of features and their counts to a 1024-bit binary fingerprint. A single 
            bit is set for each pattern.
            </summary>
            <param name="features">features to include</param>
            <returns>the continuous fingerprint</returns>
            <seealso cref="M:NCDK.Fingerprints.FingerprinterTool.MakeBitFingerprint(System.Collections.Generic.IDictionary{System.String,System.Int32},System.Int32,System.Int32)"/>
        </member>
        <member name="M:NCDK.Fingerprints.FingerprinterTool.MakeBitFingerprint(System.Collections.Generic.IDictionary{System.String,System.Int32},System.Int32)">
            <summary>
            Convert a mapping of features and their counts to a binary fingerprint. A single bit is
            set for each pattern.
            </summary>
            <param name="features">features to include</param>
            <param name="len">fingerprint length</param>
            <returns>the continuous fingerprint</returns>
            <seealso cref="M:NCDK.Fingerprints.FingerprinterTool.MakeBitFingerprint(System.Collections.Generic.IDictionary{System.String,System.Int32},System.Int32,System.Int32)"/>
        </member>
        <member name="M:NCDK.Fingerprints.FingerprinterTool.MakeBitFingerprint(System.Collections.Generic.IDictionary{System.String,System.Int32},System.Int32,System.Int32)">
            <summary>
            Convert a mapping of features and their counts to a binary fingerprint. Each feature
            can set 1-n hashes, the amount is modified by the <paramref name="bits"/> operand.
            </summary>
            <param name="features">features to include</param>
            <param name="len">fingerprint length</param>
            <param name="bits">number of bits to set for each pattern</param>
            <returns>the continuous fingerprint</returns>
        </member>
        <member name="M:NCDK.Fingerprints.FingerprinterTool.MakeCountFingerprint(System.Collections.Generic.IDictionary{System.String,System.Int32})">
            <summary>
            Wrap a mapping of features and their counts to a continuous (count based) fingerprint.
            </summary>
            <param name="features">features to include</param>
            <returns>the continuous fingerprint</returns>
        </member>
        <member name="T:NCDK.Fingerprints.GraphOnlyFingerprinter">
            <summary>
            Specialized version of the <see cref="T:NCDK.Fingerprints.Fingerprinter"/> which does not take bond orders
            into account.
            </summary>
            <seealso cref="T:NCDK.Fingerprints.Fingerprinter"/>
        </member>
        <member name="M:NCDK.Fingerprints.GraphOnlyFingerprinter.#ctor">
            <summary>
            Creates a fingerprint generator of length <see cref="F:NCDK.Fingerprints.Fingerprinter.DefaultSize"/>
            and with a search depth of <see cref="F:NCDK.Fingerprints.Fingerprinter.DefaultSearchDepth"/>.
            </summary>
        </member>
        <member name="M:NCDK.Fingerprints.GraphOnlyFingerprinter.GetBondSymbol(NCDK.IBond)">
            <summary>
            Gets the bondSymbol attribute of the Fingerprinter class. Because we do
            not consider bond orders to be important, we just return "";
            </summary>
            <param name="bond">Description of the Parameter</param>
            <returns>The bondSymbol value</returns>
        </member>
        <member name="T:NCDK.Fingerprints.HybridizationFingerprinter">
            <summary>
            Generates a fingerprint for a given <see cref="T:NCDK.IAtomContainer" />. Fingerprints are
            one-dimensional bit arrays, where bits are set according to a the occurrence
            of a particular structural feature (See for example the Daylight inc. theory
            manual for more information). Fingerprints allow for a fast screening step to
            exclude candidates for a substructure search in a database. They are also a
            means for determining the similarity of chemical structures.
            </summary>
            <example>
            A fingerprint is generated for an AtomContainer with this code:
            <code>                var molecule = new AtomContainer();
                var fingerprinter = new HybridizationFingerprinter();
                var fingerprint = fingerprinter.GetBitFingerprint(molecule);
                Console.WriteLine(fingerprint.Count); // returns 1024 by default
</code>
            </example>
            <remarks>
            The FingerPrinter assumes that hydrogens are explicitly given!
            Furthermore, if pseudo atoms or atoms with malformed symbols are present,
            their atomic number is taken as one more than the last element currently
            supported in <see cref="T:NCDK.Tools.PeriodicTable" />.
            <para>Unlike the <see cref="T:NCDK.Fingerprints.Fingerprinter" />, this fingerprinter does not take into
            account aromaticity. Instead, it takes into account SP2 <see cref="T:NCDK.Hybridization" />.
            </para>
            </remarks>
        </member>
        <member name="M:NCDK.Fingerprints.HybridizationFingerprinter.#ctor">
            <summary>
            Creates a fingerprint generator of length <see cref="F:NCDK.Fingerprints.Fingerprinter.DefaultSize"/>
            and with a search depth of <see cref="F:NCDK.Fingerprints.Fingerprinter.DefaultSearchDepth"/>.
            </summary>
        </member>
        <member name="M:NCDK.Fingerprints.HybridizationFingerprinter.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructs a fingerprint generator that creates fingerprints of
            the given size, using a generation algorithm with the given search
            depth.
            </summary>
            <param name="size">The desired size of the fingerprint</param>
            <param name="searchDepth">The desired depth of search</param>
        </member>
        <member name="M:NCDK.Fingerprints.HybridizationFingerprinter.GetBondSymbol(NCDK.IBond)">
            <summary>
            Gets the bond Symbol attribute of the Fingerprinter class.
            </summary>
            <returns>The bondSymbol value</returns>
        </member>
        <member name="M:NCDK.Fingerprints.HybridizationFingerprinter.IsSP2Bond(NCDK.IBond)">
            <summary>
            Returns true if the bond binds two atoms, and both atoms are SP2.
            </summary>
        </member>
        <member name="M:NCDK.Fingerprints.IntArrayCountFingerprint.#ctor(System.Collections.Generic.IDictionary{System.String,System.Int32},System.Boolean)">
            <summary>
            Create an <see cref="T:NCDK.Fingerprints.IntArrayCountFingerprint"/> from a rawFingerprint
            and if <paramref name="behaveAsBitFingerprint"/> make it only return 0 or 1
            as count thus behaving like a bit finger print.
            </summary>
            <param name="rawFingerprint"></param>
            <param name="behaveAsBitFingerprint"></param>
        </member>
        <member name="T:NCDK.Fingerprints.KlekotaRothFingerprinter">
             <summary>
             SMARTS based substructure fingerprint based on <b>Chemical substructures
             that enrich for biological activity</b> <token>cdk-cite-Klekota01112008</token>.
            
             Presence of 4860 substructures
             </summary>
        </member>
        <member name="T:NCDK.Fingerprints.LingoFingerprinter">
            <summary>
            An implementation of the LINGO fingerprint <token>cdk-cite-Vidal2005</token>.
            </summary>
            <remarks>
            While the current
            implementation converts ring closure symbols to 0's it does not convert 2-letter element symbols
            to single letters (ala OpenEye).
            </remarks>
        </member>
        <member name="M:NCDK.Fingerprints.LingoFingerprinter.#ctor">
            <summary>
            Initialize the fingerprinter with a default substring length of 4.
            </summary>
        </member>
        <member name="M:NCDK.Fingerprints.LingoFingerprinter.#ctor(System.Int32)">
            <summary>
            Initialize the fingerprinter.
            </summary>
            <param name="n">The length of substrings to consider</param>
        </member>
        <member name="T:NCDK.Fingerprints.MACCSFingerprinter">
            <summary>
            This fingerprinter generates 166 bit MACCS keys.
            </summary>
            <remarks>
            <para>
            The SMARTS patterns for each of the features was taken from
            <see href="http://www.rdkit.org"> RDKit</see>. However given that there is no
            official and explicit listing of the original key definitions, the results
            of this implementation may differ from others.
            </para>
            <para>
            This class assumes that aromaticity perception, atom typing and adding of
            implicit hydrogens have been performed prior to generating the fingerprint.
            </para>
            <note type="note">
            Currently bits 1 and 44 are completely ignored since the RDKit
            defs do not provide a definition and I can't find an official description
            of them.
            </note>
            <note type="warning">
            MACCS substructure keys cannot be used for substructure
            filtering. It is possible for some keys to match substructures and not match
            the superstructures. Some keys check for hydrogen counts which may not be
            preserved in a superstructure.
            </note>
            </remarks>
        </member>
        <member name="M:NCDK.Fingerprints.MACCSFingerprinter.GetBitFingerprint(NCDK.IAtomContainer)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Fingerprints.MACCSFingerprinter.GetRawFingerprint(NCDK.IAtomContainer)">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.Fingerprints.MACCSFingerprinter.Count">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Fingerprints.MACCSFingerprinter.GetCountFingerprint(NCDK.IAtomContainer)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Fingerprints.MACCSFingerprinter.GetKeys(NCDK.IChemObjectBuilder)">
            <summary>
            Access MACCS keys definitions.
            </summary>
            <returns>array of MACCS keys.</returns>
            <exception cref="T:NCDK.CDKException">maccs keys could not be loaded</exception>
        </member>
        <member name="M:NCDK.Fingerprints.MACCSFingerprinter.CreatePattern(System.String,NCDK.IChemObjectBuilder)">
            <summary>
            Create a pattern for the provided SMARTS - if the SMARTS is '?' a pattern
            is not created.
            </summary>
            <param name="smarts">a smarts pattern</param>
            <param name="builder">chem object builder</param>
            <returns>the pattern to match</returns>
        </member>
        <member name="T:NCDK.Fingerprints.Model.Bayesian">
            <summary>
            Bayesian models using fingerprints: provides model creation, analysis, prediction and serialisation.
            </summary>
            <remarks>
            <para>Uses a variation of the classic Bayesian model, using a Laplacian correction, which sums log
            values of ratios rather than multiplying them together. This is an effective way to work with large
            numbers of fingerprints without running into extreme numerical precision issues, but it also means
            that the outgoing predictor is an arbitrary value rather than a probability, which introduces
            the need for an additional calibration step prior to interpretation.</para>
            
            <para>For more information about the method, see:
                    J. Chem. Inf. Model, v.46, pp.1124-1133 (2006)
                    J. Biomol. Screen., v.10, pp.682-686 (2005)
                    Molec. Divers., v.10, pp.283-299 (2006)</para>
            
            <para>Currently only the CircularFingerprinter fingerprints are supported (i.e. ECFP_n and FCFP_n).</para>
            
            <para>Model building is done by selecting the fingerprinting method and folding size, then providing
            a series of molecules &amp; responses. Individual model contributions are kept around in order to
            produce the analysis data (e.g. the ROC curve), but is discarded during serialise/deserialise
            cycles.</para>
            
            <para>Fingerprint "folding" is optional, but recommended, because it places an upper limit on the model
            size. If folding is not used (folding=0) then the entire 32-bits are used, which means that in the
            diabolical case, the number of Bayesian contributions that needs to be stored is 4 billion. In practice
            the improvement in predictivity tends to plateaux out at around 1024 bits, so values of 2048 or 4096
            are generally safe. Folding values must be integer powers of 2.</para>
            </remarks>
        </member>
        <member name="F:NCDK.Fingerprints.Model.Bayesian.numActive">
            incoming hash codes: actual values, and subsumed values are {#active,#total}
        </member>
        <member name="F:NCDK.Fingerprints.Model.Bayesian.contribs">
            built model: contributions for each hash code
        </member>
        <member name="F:NCDK.Fingerprints.Model.Bayesian.estimates">
            self-validation metrics: can optionally be calculated after a build
        </member>
        <member name="F:NCDK.Fingerprints.Model.Bayesian.noteTitle">
            optional text attributes (serialisable)
        </member>
        <member name="F:NCDK.Fingerprints.Model.Bayesian.noteOrigin">
            optional text attributes (serialisable)
        </member>
        <member name="M:NCDK.Fingerprints.Model.Bayesian.#ctor(System.Int32)">
            ----------------- public methods -----------------
            <summary>
            Instantiate a Bayesian model with no data.
            </summary>
            <param name="classType">one of the CircularFingerprinter.CLASS_* constants</param>
        </member>
        <member name="M:NCDK.Fingerprints.Model.Bayesian.#ctor(System.Int32,System.Int32)">
            <summary>
            Instantiate a Bayesian model with no data.
            </summary>
            <param name="classType">one of the CircularFingerprinter.CLASS_* constants</param>
            <param name="folding">the maximum number of fingerprint bits, which must be a power of 2 (e.g. 1024, 2048) or 0 for no folding</param>
        </member>
        <member name="P:NCDK.Fingerprints.Model.Bayesian.ClassType">
            <summary>
            Access to the fingerprint type, one of <see cref="T:NCDK.Fingerprints.CircularFingerprinter"/>.CLASS_*.
            </summary>
        </member>
        <member name="P:NCDK.Fingerprints.Model.Bayesian.Folding">
            <summary>
            Access to the fingerprint folding extent, either 0 (for none) or a power of 2.
            </summary>
        </member>
        <member name="M:NCDK.Fingerprints.Model.Bayesian.AddMolecule(NCDK.IAtomContainer,System.Boolean)">
            <summary>
            Appends a new row to the model source data, which consists of a molecule and whether or not it
            is considered active.
            </summary>
            <param name="mol">molecular structure, which must be non-blank</param>
            <param name="active">whether active or not</param>
        </member>
        <member name="M:NCDK.Fingerprints.Model.Bayesian.Build">
            <summary>
            Performs that Bayesian model generation, using the {molecule:activity} pairs that have been submitted up to this
            point. Once this method has finished, the object can be used to generate predictions, validation data or to
            serialise for later use.
            </summary>
        </member>
        <member name="M:NCDK.Fingerprints.Model.Bayesian.Predict(NCDK.IAtomContainer)">
            <summary>
            For a given molecule, determines its fingerprints and uses them to calculate a Bayesian prediction. Note that this
            value is unscaled, and so it only has relative meaning within the confines of the model, i.e. higher is more likely to
            be active.
            </summary>
            <param name="mol">molecular structure which cannot be blank or null</param>
            <returns>predictor value</returns>
        </member>
        <member name="M:NCDK.Fingerprints.Model.Bayesian.ScalePredictor(System.Double)">
            <summary>
            Converts a raw Bayesian prediction and transforms it into a probability-like range, i.e. most values within the domain
            are between 0..1, and assigning a cutoff of activie = scaled_prediction &gt; 0.5 is reasonable. The transform (scale/translation)
            is determined by the ROC-analysis, if any. The resulting value can be used as a probability by capping the values so that
            0 ÔøΩÔøΩ p ÔøΩÔøΩ 1.
            </summary>
            <param name="pred">raw prediction, as provided by the Predict(..) method</param>
            <returns>scaled prediction</returns>
        </member>
        <member name="M:NCDK.Fingerprints.Model.Bayesian.ValidateLeaveOneOut">
            <summary>
            Produces an ROC validation set, using the inputs provided prior to the model building, using leave-one-out. Note that
            this should only be used for small datasets, since it is very thorough, and scales as O(N^2) relative to training set
            size.
            </summary>
        </member>
        <member name="M:NCDK.Fingerprints.Model.Bayesian.ValidateFiveFold">
            <summary>
            Produces a ROC validation set by partitioning the inputs into 5 groups, and performing five separate 80% in/20% out
            model simulations. This is quite efficient, and takes approximately 5 times as long as building the original
            model: it should be used for larger datasets.
            </summary>
        </member>
        <member name="M:NCDK.Fingerprints.Model.Bayesian.ValidateThreeFold">
            <summary>
            Produces a ROC validation set by partitioning the inputs into 3 groups, and performing three separate 66% in/33% out
            model simulations. This is quite efficient, and takes approximately 3 times as long as building the original
            model: it should be used for larger datasets.
            </summary>
        </member>
        <member name="M:NCDK.Fingerprints.Model.Bayesian.ClearTraining">
            <summary>
            Clears out the training set, to free up memory.
            </summary>
        </member>
        <member name="P:NCDK.Fingerprints.Model.Bayesian.TrainingSize">
            <summary>
            the size of the training set, i.e. the total number of molecules used to create the model.
            </summary>
        </member>
        <member name="P:NCDK.Fingerprints.Model.Bayesian.TrainingActives">
            <summary>
            the number of actives in the training set that was used to create the model.
            </summary>
        </member>
        <member name="P:NCDK.Fingerprints.Model.Bayesian.ROCAUC">
            <summary>
            the integral of the area-under-the-curve of the receiver-operator-characteristic. A value of 1
            means perfect recall, 0.5 is pretty much random.
            </summary>
        </member>
        <member name="P:NCDK.Fingerprints.Model.Bayesian.ROCType">
            <summary>
            a string description of the method used to create the ROC curve (e.g. "leave-one-out" or "five-fold").
            </summary>
        </member>
        <member name="P:NCDK.Fingerprints.Model.Bayesian.RocX">
            <summary>
            X-values that can be used to plot the ROC-curve.
            </summary>
        </member>
        <member name="P:NCDK.Fingerprints.Model.Bayesian.RocY">
            <summary>
            Y-values that can be used to plot the ROC-curve.
            </summary>
        </member>
        <member name="P:NCDK.Fingerprints.Model.Bayesian.NoteTitle">
            <summary>
            the optional title used to describe the model.
            </summary>
        </member>
        <member name="P:NCDK.Fingerprints.Model.Bayesian.NoteOrigin">
            <summary>
            the optional description of the source for the model.
            </summary>
        </member>
        <member name="P:NCDK.Fingerprints.Model.Bayesian.NoteComments">
            <summary>
            the optional comments, which is a list of arbitrary text strings.
            </summary>
        </member>
        <member name="M:NCDK.Fingerprints.Model.Bayesian.Serialise">
            <summary>
            Converts the current model into a serialised string representation. The serialised form omits the original data
            that was used to build the model, but otherwise contains all of the information necessary to recreate the model
            and use it to make predictions against new molecules. The format used is a concise text-based format that is
            easy to recognise by its prefix, and is reasonably efficient with regard to storage space.
            </summary>
            <returns>serialised model</returns>
        </member>
        <member name="M:NCDK.Fingerprints.Model.Bayesian.Deserialise(System.String)">
            <summary>
            Converts a given string into a Bayesian model instance, or throws an exception if it is not valid.
            </summary>
            <param name="str">string containing the serialised model</param>
            <returns>instantiated model that can be used for predictions</returns>
        </member>
        <member name="M:NCDK.Fingerprints.Model.Bayesian.Deserialise(System.IO.TextReader)">
            <summary>
            Reads the incoming stream and attempts to convert it into an instantiated model. The input most be compatible
            with the format used by the Serialise() method, otherwise an exception will be thrown.
            </summary>
            <param name="rdr">reader</param>
            <returns>instantiated model that can be used for predictions</returns>
        </member>
        <member name="M:NCDK.Fingerprints.Model.Bayesian.SingleLeaveOneOut(System.Int32)">
            ----------------- private methods -----------------
            estimate leave-one-out predictor for a given training entry
        </member>
        <member name="M:NCDK.Fingerprints.Model.Bayesian.ValidateNfold(System.Int32)">
            performs cross-validation, splitting into N different segments
        </member>
        <member name="M:NCDK.Fingerprints.Model.Bayesian.BuildPartial(System.Int32[],System.Int32,System.Int32)">
            generates a contribution model based on all the training set for which (n%div)!=seg; e.g. for 5-fold, it would use the 80% of the training set
            that is not implied by the current skein
        </member>
        <member name="M:NCDK.Fingerprints.Model.Bayesian.EstimatePartial(System.Int32[],System.Int32,System.Collections.Generic.IDictionary{System.Int32,System.Double})">
            using contributions build from some partial section of the training set, uses that to estimate for an untrained entry
        </member>
        <member name="M:NCDK.Fingerprints.Model.Bayesian.CalculateROC">
            assumes estimates already calculated, fills in the ROC data
        </member>
        <member name="M:NCDK.Fingerprints.Model.Bayesian.CalibrateThresholds(System.Double[],System.Double[],System.Double[])">
            rederives the low/high thresholds, using ROC curve data: once the analysis is complete, the midpoint will be the optimum balance 
        </member>
        <member name="M:NCDK.Fingerprints.Model.Bayesian.Resize(System.Double[],System.Int32)">
            convenience functions    
        </member>
        <member name="T:NCDK.Fingerprints.PubchemFingerprinter">
            <summary>
            Generates a Pubchem fingerprint for a molecule.
            These fingerprints are described
            <see href="ftp://ftp.ncbi.nlm.nih.gov/pubchem/specifications/pubchem_fingerprints.txt">here</see> and are of the structural key type, of length 881. 
            See <see cref="T:NCDK.Fingerprints.Fingerprinter" /> for a more detailed description of fingerprints in general. This implementation is
            based on the domain code made available by the NCGC
            <see href="http://www.ncgc.nih.gov/pub/openhts/code/NCGC_PubChemFP.java.txt">here</see>.
            </summary>
            <example>
            A fingerprint is generated for an <see cref="T:NCDK.IAtomContainer" /> with this code: 
            <code>                var molecule = new AtomContainer();
                IFingerprinter fingerprinter = new PubchemFingerprinter(Silent.ChemObjectBuilder.Instance);
                IBitFingerprint fingerprint = fingerprinter.GetBitFingerprint(molecule);
                Console.WriteLine(fingerprint.Count); // returns 881
</code>
            </example>
            <remarks>
            <note type="note">
            The fingerprinter assumes that you have detected aromaticity and
            atom types before evaluating the fingerprint. Also the fingerprinter
            expects that explicit H's are present
            </note>
            <note type="note">
            Note that this fingerprint is not particularly fast, as it will perform
            ring detection using <see cref="T:NCDK.RingSearches.AllRingsFinder" />
            as well as multiple SMARTS queries.
            </note>
            <para>
            Some SMARTS patterns have been modified from the original code, since they
            were based on explicit H matching. As a result, we replace the explicit H's
            with a query of the '#&lt;N&gt;&amp;!H0' where '&lt;N&gt;' is the atomic number. Thus bit 344 was
            with a query of the #N&amp;!H0 where N is the atomic number. Thus bit 344 was
            originally '[#6](~[#6])([H])' but is written here as
            '[#6&amp;!H0]~[#6]'. In some cases, where the H count can be reduced
            to single possibility we directly use that H count. An example is bit 35,
            which was <c>[#6](~[#6])(~[#6])(~[#6])([H])</c> and is rewritten as
            <pre>[#6H1](~[#6])(~[#6])(~[#6])</pre>.
            </para>
            <note type="warning">
            This class is not thread-safe and uses stores intermediate steps
            internally. Please use a separate instance of the class for each thread.
            </note>
            </remarks>
            <threadsafety static="true" instance="false" />
        </member>
        <member name="F:NCDK.Fingerprints.PubchemFingerprinter.FPSize">
            <summary>
            Number of bits in this fingerprint.
            </summary>
        </member>
        <member name="M:NCDK.Fingerprints.PubchemFingerprinter.GetBitFingerprint(NCDK.IAtomContainer)">
            <summary>
            Calculate 881 bit Pubchem fingerprint for a molecule.
            </summary>
            <remarks>
            See <see href="ftp://ftp.ncbi.nlm.nih.gov/pubchem/specifications/pubchem_fingerprints.txt">here</see>
            for a description of each bit position.</remarks>
            <param name="atomContainer">the molecule to consider</param>
            <returns>the fingerprint</returns>
            <exception cref="T:NCDK.CDKException">if there is an error during substructure searching or atom typing</exception>
            <see cref="M:NCDK.Fingerprints.PubchemFingerprinter.GetFingerprintAsBytes"/>
        </member>
        <member name="M:NCDK.Fingerprints.PubchemFingerprinter.GetRawFingerprint(NCDK.IAtomContainer)">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.Fingerprints.PubchemFingerprinter.Count">
            <summary>
            the size of the fingerprint.
            </summary>
        </member>
        <member name="M:NCDK.Fingerprints.PubchemFingerprinter.GetFingerprintAsBytes">
            <summary>
            Returns the fingerprint generated for a molecule as a byte[].
            </summary>
            <remarks>
            Note that this should be immediately called after calling <see cref="M:NCDK.Fingerprints.PubchemFingerprinter.GetRawFingerprint(NCDK.IAtomContainer)"/>.
            </remarks>
            <returns>The fingerprint as a byte array</returns>
            <seealso cref="M:NCDK.Fingerprints.PubchemFingerprinter.GetRawFingerprint(NCDK.IAtomContainer)"/>
        </member>
        <member name="M:NCDK.Fingerprints.PubchemFingerprinter.Decode(System.String)">
            <summary>
            Returns a fingerprint from a Base64 encoded Pubchem fingerprint.
            </summary>
            <param name="enc">The Base64 encoded fingerprint</param>
            <returns>A BitArray corresponding to the input fingerprint</returns>
        </member>
        <member name="M:NCDK.Fingerprints.PubchemFingerprinter.Encode">
            the first four bytes contains the length of the fingerprint
        </member>
        <member name="M:NCDK.Fingerprints.PubchemFingerprinter.Base64Encode(System.Byte[])">
            based on NCBI C implementation
        </member>
        <member name="T:NCDK.Fingerprints.RandomNumber">
            <summary>
            Generates pseudorandom numbers using the MersenneTwister method from commons-math.
            </summary>
        </member>
        <member name="M:NCDK.Fingerprints.RandomNumber.GenerateMersenneTwisterRandomNumber(System.Int32,System.Int64)">
            <summary>
            Mersenne Twister Random Number for a hashcode within a range between 0 to n.
            </summary>
            <param name="n">the maximum value the</param>
            <param name="seed">the seed for the next pseudorandom number</param>
            <returns>next pseudorandom number</returns>
        </member>
        <member name="T:NCDK.Fingerprints.ShortestPathFingerprinter">
             <summary>
             Generates a fingerprint for a given <see cref="T:NCDK.IAtomContainer" />. Fingerprints are one-dimensional bit arrays, where bits
             are set according to a the occurrence of a particular structural feature (See for example the Daylight inc. theory
             manual for more information). Fingerprints allow for a fast screening step to exclude candidates for a substructure
             search in a database. They are also a means for determining the similarity of chemical structures.
             </summary>
             <example>
             A fingerprint is generated for an AtomContainer with this code:
             It is recommended to use atomtyped container before generating the fingerprints. 
             <code>                var molecule = new AtomContainer();
                AtomContainerManipulator.PercieveAtomTypesAndConfigureAtoms(molecule);
                var fingerprinter = new ShortestPathFingerprinter();
                var fingerprint = fingerprinter.GetBitFingerprint(molecule);
                Console.WriteLine(fingerprint.Count); // returns 1024 by default
</code>
            </example>
            <remarks>
             <para>The FingerPrinter calculates fingerprint based on the Shortest Paths between two atoms. It also takes into account
             ring system, charges etc while generating a fingerprint. </para>
             <para>The FingerPrinter assumes that hydrogens are explicitly given! Furthermore, if pseudo atoms or atoms with
             malformed symbols are present, their atomic number is taken as one more than the last element currently supported in <see cref="T:NCDK.Tools.PeriodicTable" />.
             </para>
             </remarks>
        </member>
        <member name="F:NCDK.Fingerprints.ShortestPathFingerprinter.DefaultSize">
            <summary>
            The default length of created fingerprints.
            </summary>
        </member>
        <member name="F:NCDK.Fingerprints.ShortestPathFingerprinter.fingerprintLength">
            <summary>
            The default length of created fingerprints.
            </summary>
        </member>
        <member name="M:NCDK.Fingerprints.ShortestPathFingerprinter.#ctor">
            <summary>
            Creates a fingerprint generator of length <see cref="F:NCDK.Fingerprints.ShortestPathFingerprinter.DefaultSize"/>. 
            </summary>
        </member>
        <member name="M:NCDK.Fingerprints.ShortestPathFingerprinter.#ctor(System.Int32)">
            <summary>
            Constructs a fingerprint generator that creates fingerprints of the given fingerprintLength, using a generation
            algorithm with shortest paths.
            </summary>
            <param name="fingerprintLength">The desired fingerprintLength of the fingerprint</param>
        </member>
        <member name="M:NCDK.Fingerprints.ShortestPathFingerprinter.GetBitFingerprint(NCDK.IAtomContainer)">
            <summary>
            Generates a shortest path based BitArray fingerprint for the given AtomContainer.
            </summary>
            <param name="ac">The AtomContainer for which a fingerprint is generated</param>
            <exception cref="T:NCDK.CDKException">if there error in aromaticity perception or other CDK functions</exception>
            <returns>A <see cref="T:System.Collections.BitArray"/> representing the fingerprint</returns>
        </member>
        <member name="M:NCDK.Fingerprints.ShortestPathFingerprinter.GetRawFingerprint(NCDK.IAtomContainer)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="ac">The <see cref="T:NCDK.IAtomContainer"/> for which a fingerprint is generated</param>
            <returns><see cref="T:System.Collections.Generic.IDictionary`2"/> of raw fingerprint paths/features</returns>
            <exception cref="T:System.NotSupportedException">method is not supported</exception>
        </member>
        <member name="M:NCDK.Fingerprints.ShortestPathFingerprinter.FindPaths(NCDK.IAtomContainer)">
             <summary>
             Get all paths of lengths 0 to the specified length.
            
             This method will find all paths upto length N starting from each atom in the molecule and return the unique set
             of such paths.
             </summary>
             <param name="container">The molecule to search</param>
             <returns>A map of path strings, keyed on themselves</returns>
        </member>
        <member name="M:NCDK.Fingerprints.ShortestPathWalker.#ctor(NCDK.IAtomContainer)">
            <summary>
            Create a new shortest path walker for a given container.
            </summary>
            <param name="container">the molecule to encode the shortest paths</param>
        </member>
        <member name="M:NCDK.Fingerprints.ShortestPathWalker.GetPaths">
            <summary>
            Access a set of all shortest paths.
            </summary>
            <returns>the paths</returns>
        </member>
        <member name="M:NCDK.Fingerprints.ShortestPathWalker.Traverse">
            <summary>
            Traverse all-pairs of shortest-paths within a chemical graph.
            </summary>
        </member>
        <member name="M:NCDK.Fingerprints.ShortestPathWalker.Reverse(System.Int32[])">
            <summary>
            Reverse an array of integers.
            </summary>
            <param name="src">array to reverse</param>
            <returns>reversed copy of <paramref name="src"/></returns>
        </member>
        <member name="M:NCDK.Fingerprints.ShortestPathWalker.Encode(System.Int32[])">
            <summary>
            Encode the provided path of atoms to a string.
            </summary>
            <param name="path">inclusive array of vertex indices</param>
            <returns>encoded path</returns>
        </member>
        <member name="M:NCDK.Fingerprints.ShortestPathWalker.ToAtomPattern(NCDK.IAtom)">
            <summary>
            Convert an atom to a string representation. Currently this method just
            returns the symbol but in future may include other properties, such as, stereo
            descriptor and charge.
            </summary>
            <param name="atom">The atom to encode</param>
            <returns>encoded atom</returns>
        </member>
        <member name="M:NCDK.Fingerprints.ShortestPathWalker.GetBondSymbol(NCDK.IBond)">
            <summary>
            Gets the bondSymbol attribute of the HashedFingerprinter class
            </summary>
            <param name="bond">Description of the Parameter</param>
            <returns>The bondSymbol value</returns>
        </member>
        <member name="M:NCDK.Fingerprints.ShortestPathWalker.IsSP2Bond(NCDK.IBond)">
            <summary>
            Returns true if the bond binds two atoms, and both atoms are SP2 in a ring system.
            </summary>
        </member>
        <member name="M:NCDK.Fingerprints.ShortestPathWalker.ToString">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Fingerprints.SimpleAtomCanonicalizer">
            <summary>
            This code returns a sorted set of atoms for a container according to its
            symbol and hybridization states. This will aid in finding a deterministic
            path rather than Stochastic one.
            </summary>
        </member>
        <member name="M:NCDK.Fingerprints.SimpleAtomCanonicalizer.CanonicalizeAtoms(NCDK.IAtomContainer)">
            <summary>
            <param name="container">the container</param>
            <returns>canonicalized atoms</returns>
            </summary>
        </member>
        <member name="T:NCDK.Fingerprints.SimpleAtomComparator">
            <summary>
            This code returns a sorted set of atoms for a container according to its
            symbol and hybridization states. This will aid in finding a deterministic
            path rather than Stochastic one. 
            </summary>
        </member>
        <member name="T:NCDK.Fingerprints.StandardSubstructureSets">
            <summary>
            Default sets of atom containers aimed for use with the substructure.
            </summary>
        </member>
        <member name="M:NCDK.Fingerprints.StandardSubstructureSets.GetFunctionalGroupSMARTS">
            <summary>
            The functional groups.
            </summary>
            <returns>A set of the functional groups.</returns>
            <exception cref="T:System.Exception">if there is an error parsing SMILES for the functional groups</exception>
        </member>
        <member name="T:NCDK.Fingerprints.SubstructureFingerprinter">
            <summary>
            <see cref="T:NCDK.Fingerprints.IFingerprinter"/> that gives a bit set which has a size equal to the number
            of substructures it was constructed from. A set bit indicates that that
            substructure was found at least once in the molecule for which the
            fingerprint was calculated. The fingerprint currently supports 307
            substructures, listed below:
            </summary>
            <list type="table">
            <thead>
            <item>
            <term>Bit position</term><term>Description</term><term>Pattern</term>
            </item>
            </thead>
            <tbody>
            <item><term>0</term><term>Primary carbon</term><term>[CX4H3][#6]</term></item>
            <item><term>1</term><term>Secondary carbon</term><term>[CX4H2]([#6])[#6]</term></item>
            <item><term>2</term><term>Tertiary carbon</term><term>[CX4H1]([#6])([#6])[#6]</term></item>
            <item><term>3</term><term>Quaternary carbon</term><term>[CX4]([#6])([#6])([#6])[#6]</term></item>
            <item><term>4</term><term>Alkene</term><term>[CX3;$([H2]),$([H1][#6]),$(C([#6])[#6])]=[CX3;$([H2]),$([H1][#6]),$(C([#6])[#6])]</term></item>
            <item><term>5</term><term>Alkyne</term><term>[CX2]#[CX2]</term></item>
            <item><term>6</term><term>Allene</term><term>[CX3]=[CX2]=[CX3]</term></item>
            <item><term>7</term><term>Alkylchloride</term><term>[ClX1][CX4]</term></item>
            <item><term>8</term><term>Alkylfluoride</term><term>[FX1][CX4]</term></item>
            <item><term>9</term><term>Alkylbromide</term><term>[BrX1][CX4]</term></item>
            <item><term>10</term><term>Alkyliodide</term><term>[IX1][CX4]</term></item>
            <item><term>11</term><term>Alcohol</term><term>[OX2H][CX4;!$(C([OX2H])[O,S,#7,#15])]</term></item>
            <item><term>12</term><term>Primary alcohol</term><term>[OX2H][CX4H2;!$(C([OX2H])[O,S,#7,#15])]</term></item>
            <item><term>13</term><term>Secondary alcohol</term><term>[OX2H][CX4H;!$(C([OX2H])[O,S,#7,#15])]</term></item>
            <item><term>14</term><term>Tertiary alcohol</term><term>[OX2H][CX4D4;!$(C([OX2H])[O,S,#7,#15])]</term></item>
            <item><term>15</term><term>Dialkylether</term><term>[OX2]([CX4;!$(C([OX2])[O,S,#7,#15,F,Cl,Br,I])])[CX4;!$(C([OX2])[O,S,#7,#15])]</term></item>
            <item><term>16</term><term>Dialkylthioether</term><term>[SX2]([CX4;!$(C([OX2])[O,S,#7,#15,F,Cl,Br,I])])[CX4;!$(C([OX2])[O,S,#7,#15])]</term></item>
            <item><term>17</term><term>Alkylarylether</term><term>[OX2](c)[CX4;!$(C([OX2])[O,S,#7,#15,F,Cl,Br,I])]</term></item>
            <item><term>18</term><term>Diarylether</term><term>[c][OX2][c]</term></item>
            <item><term>19</term><term>Alkylarylthioether</term><term>[SX2](c)[CX4;!$(C([OX2])[O,S,#7,#15,F,Cl,Br,I])]</term></item>
            <item><term>20</term><term>Diarylthioether</term><term>[c][SX2][c]</term></item>
            <item><term>21</term><term>Oxonium</term><term>[O+;!$([O]~[!#6]);!$([S]*~[#7,#8,#15,#16])]</term></item>
            <item><term>22</term><term>Amine</term><term>[NX3+0,NX4+;!$([N]~[!#6]);!$([N]*~[#7,#8,#15,#16])]</term></item>
            <item><term>23</term><term>Primary aliph amine</term><term>[NX3H2+0,NX4H3+;!$([N][!C]);!$([N]*~[#7,#8,#15,#16])]</term></item>
            <item><term>24</term><term>Secondary aliph amine</term><term>[NX3H1+0,NX4H2+;!$([N][!C]);!$([N]*~[#7,#8,#15,#16])]</term></item>
            <item><term>25</term><term>Tertiary aliph amine</term><term>[NX3H0+0,NX4H1+;!$([N][!C]);!$([N]*~[#7,#8,#15,#16])]</term></item>
            <item><term>26</term><term>Quaternary aliph ammonium</term><term>[NX4H0+;!$([N][!C]);!$([N]*~[#7,#8,#15,#16])]</term></item>
            <item><term>27</term><term>Primary arom amine</term><term>[NX3H2+0,NX4H3+]c</term></item>
            <item><term>28</term><term>Secondary arom amine</term><term>[NX3H1+0,NX4H2+;!$([N][!c]);!$([N]*~[#7,#8,#15,#16])]</term></item>
            <item><term>29</term><term>Tertiary arom amine</term><term>[NX3H0+0,NX4H1+;!$([N][!c]);!$([N]*~[#7,#8,#15,#16])]</term></item>
            <item><term>30</term><term>Quaternary arom ammonium</term><term>[NX4H0+;!$([N][!c]);!$([N]*~[#7,#8,#15,#16])]</term></item>
            <item><term>31</term><term>Secondary mixed amine</term><term>[NX3H1+0,NX4H2+;$([N]([c])[C]);!$([N]*~[#7,#8,#15,#16])]</term></item>
            <item><term>32</term><term>Tertiary mixed amine</term><term>[NX3H0+0,NX4H1+;$([N]([c])([C])[#6]);!$([N]*~[#7,#8,#15,#16])]</term></item>
            <item><term>33</term><term>Quaternary mixed ammonium</term><term>[NX4H0+;$([N]([c])([C])[#6][#6]);!$([N]*~[#7,#8,#15,#16])]</term></item>
            <item><term>34</term><term>Ammonium</term><term>[N+;!$([N]~[!#6]);!$(N=*);!$([N]*~[#7,#8,#15,#16])]</term></item>
            <item><term>35</term><term>Alkylthiol</term><term>[SX2H][CX4;!$(C([SX2H])~[O,S,#7,#15])]</term></item>
            <item><term>36</term><term>Dialkylthioether</term><term>[SX2]([CX4;!$(C([SX2])[O,S,#7,#15,F,Cl,Br,I])])[CX4;!$(C([SX2])[O,S,#7,#15])]</term></item>
            <item><term>37</term><term>Alkylarylthioether</term><term>[SX2](c)[CX4;!$(C([SX2])[O,S,#7,#15])]</term></item>
            <item><term>38</term><term>Disulfide</term><term>[SX2D2][SX2D2]</term></item>
            <item><term>39</term><term>1,2-Aminoalcohol</term><term>[OX2H][CX4;!$(C([OX2H])[O,S,#7,#15,F,Cl,Br,I])][CX4;!$(C([N])[O,S,#7,#15])][NX3;!$(NC=[O,S,N])]</term></item>
            <item><term>40</term><term>1,2-Diol</term><term>[OX2H][CX4;!$(C([OX2H])[O,S,#7,#15])][CX4;!$(C([OX2H])[O,S,#7,#15])][OX2H]</term></item>
            <item><term>41</term><term>1,1-Diol</term><term>[OX2H][CX4;!$(C([OX2H])([OX2H])[O,S,#7,#15])][OX2H]</term></item>
            <item><term>42</term><term>Hydroperoxide</term><term>[OX2H][OX2]</term></item>
            <item><term>43</term><term>Peroxo</term><term>[OX2D2][OX2D2]</term></item>
            <item><term>44</term><term>Organolithium compounds</term><term>[LiX1][#6,#14]</term></item>
            <item><term>45</term><term>Organomagnesium compounds</term><term>[MgX2][#6,#14]</term></item>
            <item><term>46</term><term>Organometallic compounds</term><term>[!#1;!#5;!#6;!#7;!#8;!#9;!#14;!#15;!#16;!#17;!#33;!#34;!#35;!#52;!#53;!#85]~[#6;!-]</term></item>
            <item><term>47</term><term>Aldehyde</term><term>[$([CX3H][#6]),$([CX3H2])]=[OX1]</term></item>
            <item><term>48</term><term>Ketone</term><term>[#6][CX3](=[OX1])[#6]</term></item>
            <item><term>49</term><term>Thioaldehyde</term><term>[$([CX3H][#6]),$([CX3H2])]=[SX1]</term></item>
            <item><term>50</term><term>Thioketone</term><term>[#6][CX3](=[SX1])[#6]</term></item>
            <item><term>51</term><term>Imine</term><term>[NX2;$([N][#6]),$([NH]);!$([N][CX3]=[#7,#8,#15,#16])]=[CX3;$([CH2]),$([CH][#6]),$([C]([#6])[#6])]</term></item>
            <item><term>52</term><term>Immonium</term><term>[NX3+;!$([N][!#6]);!$([N][CX3]=[#7,#8,#15,#16])]</term></item>
            <item><term>53</term><term>Oxime</term><term>[NX2](=[CX3;$([CH2]),$([CH][#6]),$([C]([#6])[#6])])[OX2H]</term></item>
            <item><term>54</term><term>Oximether</term><term>[NX2](=[CX3;$([CH2]),$([CH][#6]),$([C]([#6])[#6])])[OX2][#6;!$(C=[#7,#8])]</term></item>
            <item><term>55</term><term>Acetal</term><term>[OX2]([#6;!$(C=[O,S,N])])[CX4;!$(C(O)(O)[!#6])][OX2][#6;!$(C=[O,S,N])]</term></item>
            <item><term>56</term><term>Hemiacetal</term><term>[OX2H][CX4;!$(C(O)(O)[!#6])][OX2][#6;!$(C=[O,S,N])]</term></item>
            <item><term>57</term><term>Aminal</term><term>[NX3v3;!$(NC=[#7,#8,#15,#16])]([#6])[CX4;!$(C(N)(N)[!#6])][NX3v3;!$(NC=[#7,#8,#15,#16])][#6]</term></item>
            <item><term>58</term><term>Hemiaminal</term><term>[NX3v3;!$(NC=[#7,#8,#15,#16])]([#6])[CX4;!$(C(N)(N)[!#6])][OX2H]</term></item>
            <item><term>59</term><term>Thioacetal</term><term>[SX2]([#6;!$(C=[O,S,N])])[CX4;!$(C(S)(S)[!#6])][SX2][#6;!$(C=[O,S,N])]</term></item>
            <item><term>60</term><term>Thiohemiacetal</term><term>[SX2]([#6;!$(C=[O,S,N])])[CX4;!$(C(S)(S)[!#6])][OX2H]</term></item>
            <item><term>61</term><term>Halogen acetal like</term><term>[NX3v3,SX2,OX2;!$(*C=[#7,#8,#15,#16])][CX4;!$(C([N,S,O])([N,S,O])[!#6])][FX1,ClX1,BrX1,IX1]</term></item>
            <item><term>62</term><term>Acetal like</term><term>[NX3v3,SX2,OX2;!$(*C=[#7,#8,#15,#16])][CX4;!$(C([N,S,O])([N,S,O])[!#6])][FX1,ClX1,BrX1,IX1,NX3v3,SX2,OX2;!$(*C=[#7,#8,#15,#16])]</term></item>
            <item><term>63</term><term>Halogenmethylen ester and similar</term><term>[NX3v3,SX2,OX2;$(**=[#7,#8,#15,#16])][CX4;!$(C([N,S,O])([N,S,O])[!#6])][FX1,ClX1,BrX1,IX1]</term></item>
            <item><term>64</term><term>NOS methylen ester and similar</term><term>[NX3v3,SX2,OX2;$(**=[#7,#8,#15,#16])][CX4;!$(C([N,S,O])([N,S,O])[!#6])][NX3v3,SX2,OX2;!$(*C=[#7,#8,#15,#16])]</term></item>
            <item><term>65</term><term>Hetero methylen ester and similar</term><term>[NX3v3,SX2,OX2;$(**=[#7,#8,#15,#16])][CX4;!$(C([N,S,O])([N,S,O])[!#6])][FX1,ClX1,BrX1,IX1,NX3v3,SX2,OX2;!$(*C=[#7,#8,#15,#16])]</term></item>
            <item><term>66</term><term>Cyanhydrine</term><term>[NX1]#[CX2][CX4;$([CH2]),$([CH]([CX2])[#6]),$(C([CX2])([#6])[#6])][OX2H]</term></item>
            <item><term>67</term><term>Chloroalkene</term><term>[ClX1][CX3]=[CX3]</term></item>
            <item><term>68</term><term>Fluoroalkene</term><term>[FX1][CX3]=[CX3]</term></item>
            <item><term>69</term><term>Bromoalkene</term><term>[BrX1][CX3]=[CX3]</term></item>
            <item><term>70</term><term>Iodoalkene</term><term>[IX1][CX3]=[CX3]</term></item>
            <item><term>71</term><term>Enol</term><term>[OX2H][CX3;$([H1]),$(C[#6])]=[CX3]</term></item>
            <item><term>72</term><term>Endiol</term><term>[OX2H][CX3;$([H1]),$(C[#6])]=[CX3;$([H1]),$(C[#6])][OX2H]</term></item>
            <item><term>73</term><term>Enolether</term><term>[OX2]([#6;!$(C=[N,O,S])])[CX3;$([H0][#6]),$([H1])]=[CX3]</term></item>
            <item><term>74</term><term>Enolester</term><term>[OX2]([CX3]=[OX1])[#6X3;$([#6][#6]),$([H1])]=[#6X3;!$(C[OX2H])]</term></item>
            <item><term>75</term><term>Enamine</term><term>[NX3;$([NH2][CX3]),$([NH1]([CX3])[#6]),$([N]([CX3])([#6])[#6]);!$([N]*=[#7,#8,#15,#16])][CX3;$([CH]),$([C][#6])]=[CX3]</term></item>
            <item><term>76</term><term>Thioenol</term><term>[SX2H][CX3;$([H1]),$(C[#6])]=[CX3]</term></item>
            <item><term>77</term><term>Thioenolether</term><term>[SX2]([#6;!$(C=[N,O,S])])[CX3;$(C[#6]),$([CH])]=[CX3]</term></item>
            <item><term>78</term><term>Acylchloride</term><term>[CX3;$([R0][#6]),$([H1R0])](=[OX1])[ClX1]</term></item>
            <item><term>79</term><term>Acylfluoride</term><term>[CX3;$([R0][#6]),$([H1R0])](=[OX1])[FX1]</term></item>
            <item><term>80</term><term>Acylbromide</term><term>[CX3;$([R0][#6]),$([H1R0])](=[OX1])[BrX1]</term></item>
            <item><term>81</term><term>Acyliodide</term><term>[CX3;$([R0][#6]),$([H1R0])](=[OX1])[IX1]</term></item>
            <item><term>82</term><term>Acylhalide</term><term>[CX3;$([R0][#6]),$([H1R0])](=[OX1])[FX1,ClX1,BrX1,IX1]</term></item>
            <item><term>83</term><term>Carboxylic acid</term><term>[CX3;$([R0][#6]),$([H1R0])](=[OX1])[$([OX2H]),$([OX1-])]</term></item>
            <item><term>84</term><term>Carboxylic ester</term><term>[CX3;$([R0][#6]),$([H1R0])](=[OX1])[OX2][#6;!$(C=[O,N,S])]</term></item>
            <item><term>85</term><term>Lactone</term><term>[#6][#6X3R](=[OX1])[#8X2][#6;!$(C=[O,N,S])]</term></item>
            <item><term>86</term><term>Carboxylic anhydride</term><term>[CX3;$([H0][#6]),$([H1])](=[OX1])[#8X2][CX3;$([H0][#6]),$([H1])](=[OX1])</term></item>
            <item><term>87</term><term>Carboxylic acid derivative</term><term>[$([#6X3H0][#6]),$([#6X3H])](=[!#6])[!#6]</term></item>
            <item><term>88</term><term>Carbothioic acid</term><term>[CX3;!R;$([C][#6]),$([CH]);$([C](=[OX1])[$([SX2H]),$([SX1-])]),$([C](=[SX1])[$([OX2H]),$([OX1-])])]</term></item>
            <item><term>89</term><term>Carbothioic S ester</term><term>[CX3;$([R0][#6]),$([H1R0])](=[OX1])[SX2][#6;!$(C=[O,N,S])]</term></item>
            <item><term>90</term><term>Carbothioic S lactone</term><term>[#6][#6X3R](=[OX1])[#16X2][#6;!$(C=[O,N,S])]</term></item>
            <item><term>91</term><term>Carbothioic O ester</term><term>[CX3;$([H0][#6]),$([H1])](=[SX1])[OX2][#6;!$(C=[O,N,S])]</term></item>
            <item><term>92</term><term>Carbothioic O lactone</term><term>[#6][#6X3R](=[SX1])[#8X2][#6;!$(C=[O,N,S])]</term></item>
            <item><term>93</term><term>Carbothioic halide</term><term>[CX3;$([H0][#6]),$([H1])](=[SX1])[FX1,ClX1,BrX1,IX1]</term></item>
            <item><term>94</term><term>Carbodithioic acid</term><term>[CX3;!R;$([C][#6]),$([CH]);$([C](=[SX1])[SX2H])]</term></item>
            <item><term>95</term><term>Carbodithioic ester</term><term>[CX3;!R;$([C][#6]),$([CH]);$([C](=[SX1])[SX2][#6;!$(C=[O,N,S])])]</term></item>
            <item><term>96</term><term>Carbodithiolactone</term><term>[#6][#6X3R](=[SX1])[#16X2][#6;!$(C=[O,N,S])]</term></item>
            <item><term>97</term><term>Amide</term><term>[CX3;$([R0][#6]),$([H1R0])](=[OX1])[#7X3;$([H2]),$([H1][#6;!$(C=[O,N,S])]),$([#7]([#6;!$(C=[O,N,S])])[#6;!$(C=[O,N,S])])]</term></item>
            <item><term>98</term><term>Primary amide</term><term>[CX3;$([R0][#6]),$([H1R0])](=[OX1])[NX3H2]</term></item>
            <item><term>99</term><term>Secondary amide</term><term>[CX3;$([R0][#6]),$([H1R0])](=[OX1])[#7X3H1][#6;!$(C=[O,N,S])]</term></item>
            <item><term>100</term><term>Tertiary amide</term><term>[CX3;$([R0][#6]),$([H1R0])](=[OX1])[#7X3H0]([#6;!$(C=[O,N,S])])[#6;!$(C=[O,N,S])]</term></item>
            <item><term>101</term><term>Lactam</term><term>[#6R][#6X3R](=[OX1])[#7X3;$([H1][#6;!$(C=[O,N,S])]),$([H0]([#6;!$(C=[O,N,S])])[#6;!$(C=[O,N,S])])]</term></item>
            <item><term>102</term><term>Alkyl imide</term><term>[#6X3;$([H0][#6]),$([H1])](=[OX1])[#7X3H0]([#6])[#6X3;$([H0][#6]),$([H1])](=[OX1])</term></item>
            <item><term>103</term><term>N hetero imide</term><term>[#6X3;$([H0][#6]),$([H1])](=[OX1])[#7X3H0]([!#6])[#6X3;$([H0][#6]),$([H1])](=[OX1])</term></item>
            <item><term>104</term><term>Imide acidic</term><term>[#6X3;$([H0][#6]),$([H1])](=[OX1])[#7X3H1][#6X3;$([H0][#6]),$([H1])](=[OX1])</term></item>
            <item><term>105</term><term>Thioamide</term><term>[$([CX3;!R][#6]),$([CX3H;!R])](=[SX1])[#7X3;$([H2]),$([H1][#6;!$(C=[O,N,S])]),$([#7]([#6;!$(C=[O,N,S])])[#6;!$(C=[O,N,S])])]</term></item>
            <item><term>106</term><term>Thiolactam</term><term>[#6R][#6X3R](=[SX1])[#7X3;$([H1][#6;!$(C=[O,N,S])]),$([H0]([#6;!$(C=[O,N,S])])[#6;!$(C=[O,N,S])])]</term></item>
            <item><term>107</term><term>Oximester</term><term>[#6X3;$([H0][#6]),$([H1])](=[OX1])[#8X2][#7X2]=,:[#6X3;$([H0]([#6])[#6]),$([H1][#6]),$([H2])]</term></item>
            <item><term>108</term><term>Amidine</term><term>[NX3;!$(NC=[O,S])][CX3;$([CH]),$([C][#6])]=[NX2;!$(NC=[O,S])]</term></item>
            <item><term>109</term><term>Hydroxamic acid</term><term>[CX3;$([H0][#6]),$([H1])](=[OX1])[#7X3;$([H1]),$([H0][#6;!$(C=[O,N,S])])][$([OX2H]),$([OX1-])]</term></item>
            <item><term>110</term><term>Hydroxamic acid ester</term><term>[CX3;$([H0][#6]),$([H1])](=[OX1])[#7X3;$([H1]),$([H0][#6;!$(C=[O,N,S])])][OX2][#6;!$(C=[O,N,S])]</term></item>
            <item><term>111</term><term>Imidoacid</term><term>[CX3R0;$([H0][#6]),$([H1])](=[NX2;$([H1]),$([H0][#6;!$(C=[O,N,S])])])[$([OX2H]),$([OX1-])]</term></item>
            <item><term>112</term><term>Imidoacid cyclic</term><term>[#6R][#6X3R](=,:[#7X2;$([H1]),$([H0][#6;!$(C=[O,N,S])])])[$([OX2H]),$([OX1-])]</term></item>
            <item><term>113</term><term>Imidoester</term><term>[CX3R0;$([H0][#6]),$([H1])](=[NX2;$([H1]),$([H0][#6;!$(C=[O,N,S])])])[OX2][#6;!$(C=[O,N,S])]</term></item>
            <item><term>114</term><term>Imidolactone</term><term>[#6R][#6X3R](=,:[#7X2;$([H1]),$([H0][#6;!$(C=[O,N,S])])])[OX2][#6;!$(C=[O,N,S])]</term></item>
            <item><term>115</term><term>Imidothioacid</term><term>[CX3R0;$([H0][#6]),$([H1])](=[NX2;$([H1]),$([H0][#6;!$(C=[O,N,S])])])[$([SX2H]),$([SX1-])]</term></item>
            <item><term>116</term><term>Imidothioacid cyclic</term><term>[#6R][#6X3R](=,:[#7X2;$([H1]),$([H0][#6;!$(C=[O,N,S])])])[$([SX2H]),$([SX1-])]</term></item>
            <item><term>117</term><term>Imidothioester</term><term>[CX3R0;$([H0][#6]),$([H1])](=[NX2;$([H1]),$([H0][#6;!$(C=[O,N,S])])])[SX2][#6;!$(C=[O,N,S])]</term></item>
            <item><term>118</term><term>Imidothiolactone</term><term>[#6R][#6X3R](=,:[#7X2;$([H1]),$([H0][#6;!$(C=[O,N,S])])])[SX2][#6;!$(C=[O,N,S])]</term></item>
            <item><term>119</term><term>Amidine</term><term>[#7X3v3;!$(N([#6X3]=[#7X2])C=[O,S])][CX3R0;$([H1]),$([H0][#6])]=[NX2v3;!$(N(=[#6X3][#7X3])C=[O,S])]</term></item>
            <item><term>120</term><term>Imidolactam</term><term>[#6][#6X3R;$([H0](=[NX2;!$(N(=[#6X3][#7X3])C=[O,S])])[#7X3;!$(N([#6X3]=[#7X2])C=[O,S])]),$([H0](-[NX3;!$(N([#6X3]=[#7X2])C=[O,S])])=,:[#7X2;!$(N(=[#6X3][#7X3])C=[O,S])])]</term></item>
            <item><term>121</term><term>Imidoylhalide</term><term>[CX3R0;$([H0][#6]),$([H1])](=[NX2;$([H1]),$([H0][#6;!$(C=[O,N,S])])])[FX1,ClX1,BrX1,IX1]</term></item>
            <item><term>122</term><term>Imidoylhalide cyclic</term><term>[#6R][#6X3R](=,:[#7X2;$([H1]),$([H0][#6;!$(C=[O,N,S])])])[FX1,ClX1,BrX1,IX1]</term></item>
            <item><term>123</term><term>Amidrazone</term><term>[$([$([#6X3][#6]),$([#6X3H])](=[#7X2v3])[#7X3v3][#7X3v3]),$([$([#6X3][#6]),$([#6X3H])]([#7X3v3])=[#7X2v3][#7X3v3])]</term></item>
            <item><term>124</term><term>Alpha aminoacid</term><term>[NX3,NX4+;!$([N]~[!#6]);!$([N]*~[#7,#8,#15,#16])][C][CX3](=[OX1])[OX2H,OX1-]</term></item>
            <item><term>125</term><term>Alpha hydroxyacid</term><term>[OX2H][C][CX3](=[OX1])[OX2H,OX1-]</term></item>
            <item><term>126</term><term>Peptide middle</term><term>[NX3;$([N][CX3](=[OX1])[C][NX3,NX4+])][C][CX3](=[OX1])[NX3;$([N][C][CX3](=[OX1])[NX3,OX2,OX1-])]</term></item>
            <item><term>127</term><term>Peptide C term</term><term>[NX3;$([N][CX3](=[OX1])[C][NX3,NX4+])][C][CX3](=[OX1])[OX2H,OX1-]</term></item>
            <item><term>128</term><term>Peptide N term</term><term>[NX3,NX4+;!$([N]~[!#6]);!$([N]*~[#7,#8,#15,#16])][C][CX3](=[OX1])[NX3;$([N][C][CX3](=[OX1])[NX3,OX2,OX1-])]</term></item>
            <item><term>129</term><term>Carboxylic orthoester</term><term>[#6][OX2][CX4;$(C[#6]),$([CH])]([OX2][#6])[OX2][#6]</term></item>
            <item><term>130</term><term>Ketene</term><term>[CX3]=[CX2]=[OX1]</term></item>
            <item><term>131</term><term>Ketenacetal</term><term>[#7X2,#8X3,#16X2;$(*[#6,#14])][#6X3]([#7X2,#8X3,#16X2;$(*[#6,#14])])=[#6X3]</term></item>
            <item><term>132</term><term>Nitrile</term><term>[NX1]#[CX2]</term></item>
            <item><term>133</term><term>Isonitrile</term><term>[CX1-]#[NX2+]</term></item>
            <item><term>134</term><term>Vinylogous carbonyl or carboxyl derivative</term><term>[#6X3](=[OX1])[#6X3]=,:[#6X3][#7,#8,#16,F,Cl,Br,I]</term></item>
            <item><term>135</term><term>Vinylogous acid</term><term>[#6X3](=[OX1])[#6X3]=,:[#6X3][$([OX2H]),$([OX1-])]</term></item>
            <item><term>136</term><term>Vinylogous ester</term><term>[#6X3](=[OX1])[#6X3]=,:[#6X3][#6;!$(C=[O,N,S])]</term></item>
            <item><term>137</term><term>Vinylogous amide</term><term>[#6X3](=[OX1])[#6X3]=,:[#6X3][#7X3;$([H2]),$([H1][#6;!$(C=[O,N,S])]),$([#7]([#6;!$(C=[O,N,S])])[#6;!$(C=[O,N,S])])]</term></item>
            <item><term>138</term><term>Vinylogous halide</term><term>[#6X3](=[OX1])[#6X3]=,:[#6X3][FX1,ClX1,BrX1,IX1]</term></item>
            <item><term>139</term><term>Carbonic acid dieester</term><term>[#6;!$(C=[O,N,S])][#8X2][#6X3](=[OX1])[#8X2][#6;!$(C=[O,N,S])]</term></item>
            <item><term>140</term><term>Carbonic acid esterhalide</term><term>[#6;!$(C=[O,N,S])][OX2;!R][CX3](=[OX1])[OX2][FX1,ClX1,BrX1,IX1]</term></item>
            <item><term>141</term><term>Carbonic acid monoester</term><term>[#6;!$(C=[O,N,S])][OX2;!R][CX3](=[OX1])[$([OX2H]),$([OX1-])]</term></item>
            <item><term>142</term><term>Carbonic acid derivatives</term><term>[!#6][#6X3](=[!#6])[!#6]</term></item>
            <item><term>143</term><term>Thiocarbonic acid dieester</term><term>[#6;!$(C=[O,N,S])][#8X2][#6X3](=[SX1])[#8X2][#6;!$(C=[O,N,S])]</term></item>
            <item><term>144</term><term>Thiocarbonic acid esterhalide</term><term>[#6;!$(C=[O,N,S])][OX2;!R][CX3](=[SX1])[OX2][FX1,ClX1,BrX1,IX1]</term></item>
            <item><term>145</term><term>Thiocarbonic acid monoester</term><term>[#6;!$(C=[O,N,S])][OX2;!R][CX3](=[SX1])[$([OX2H]),$([OX1-])]</term></item>
            <item><term>146</term><term>Urea</term><term>[#7X3;!$([#7][!#6])][#6X3](=[OX1])[#7X3;!$([#7][!#6])]</term></item>
            <item><term>147</term><term>Thiourea</term><term>[#7X3;!$([#7][!#6])][#6X3](=[SX1])[#7X3;!$([#7][!#6])]</term></item>
            <item><term>148</term><term>Isourea</term><term>[#7X2;!$([#7][!#6])]=,:[#6X3]([#8X2&amp;!$([#8][!#6]),OX1-])[#7X3;!$([#7][!#6])]</term></item>
            <item><term>149</term><term>Isothiourea</term><term>[#7X2;!$([#7][!#6])]=,:[#6X3]([#16X2&amp;!$([#16][!#6]),SX1-])[#7X3;!$([#7][!#6])]</term></item>
            <item><term>150</term><term>Guanidine</term><term>[N;v3X3,v4X4+][CX3](=[N;v3X2,v4X3+])[N;v3X3,v4X4+]</term></item>
            <item><term>151</term><term>Carbaminic acid</term><term>[NX3]C(=[OX1])[O;X2H,X1-]</term></item>
            <item><term>152</term><term>Urethan</term><term>[#7X3][#6](=[OX1])[#8X2][#6]</term></item>
            <item><term>153</term><term>Biuret</term><term>[#7X3][#6](=[OX1])[#7X3][#6](=[OX1])[#7X3]</term></item>
            <item><term>154</term><term>Semicarbazide</term><term>[#7X3][#7X3][#6X3]([#7X3;!$([#7][#7])])=[OX1]</term></item>
            <item><term>155</term><term>Carbazide</term><term>[#7X3][#7X3][#6X3]([#7X3][#7X3])=[OX1]</term></item>
            <item><term>156</term><term>Semicarbazone</term><term>[#7X2](=[#6])[#7X3][#6X3]([#7X3;!$([#7][#7])])=[OX1]</term></item>
            <item><term>157</term><term>Carbazone</term><term>[#7X2](=[#6])[#7X3][#6X3]([#7X3][#7X3])=[OX1]</term></item>
            <item><term>158</term><term>Thiosemicarbazide</term><term>[#7X3][#7X3][#6X3]([#7X3;!$([#7][#7])])=[SX1]</term></item>
            <item><term>159</term><term>Thiocarbazide</term><term>[#7X3][#7X3][#6X3]([#7X3][#7X3])=[SX1]</term></item>
            <item><term>160</term><term>Thiosemicarbazone</term><term>[#7X2](=[#6])[#7X3][#6X3]([#7X3;!$([#7][#7])])=[SX1]</term></item>
            <item><term>161</term><term>Thiocarbazone</term><term>[#7X2](=[#6])[#7X3][#6X3]([#7X3][#7X3])=[SX1]</term></item>
            <item><term>162</term><term>Isocyanate</term><term>[NX2]=[CX2]=[OX1]</term></item>
            <item><term>163</term><term>Cyanate</term><term>[OX2][CX2]#[NX1]</term></item>
            <item><term>164</term><term>Isothiocyanate</term><term>[NX2]=[CX2]=[SX1]</term></item>
            <item><term>165</term><term>Thiocyanate</term><term>[SX2][CX2]#[NX1]</term></item>
            <item><term>166</term><term>Carbodiimide</term><term>[NX2]=[CX2]=[NX2]</term></item>
            <item><term>167</term><term>Orthocarbonic derivatives</term><term>[CX4H0]([O,S,#7])([O,S,#7])([O,S,#7])[O,S,#7,F,Cl,Br,I]</term></item>
            <item><term>168</term><term>Phenol</term><term>[OX2H][c]</term></item>
            <item><term>169</term><term>1,2-Diphenol</term><term>[OX2H][c][c][OX2H]</term></item>
            <item><term>170</term><term>Arylchloride</term><term>[Cl][c]</term></item>
            <item><term>171</term><term>Arylfluoride</term><term>[F][c]</term></item>
            <item><term>172</term><term>Arylbromide</term><term>[Br][c]</term></item>
            <item><term>173</term><term>Aryliodide</term><term>[I][c]</term></item>
            <item><term>174</term><term>Arylthiol</term><term>[SX2H][c]</term></item>
            <item><term>175</term><term>Iminoarene</term><term>[c]=[NX2;$([H1]),$([H0][#6;!$([C]=[N,S,O])])]</term></item>
            <item><term>176</term><term>Oxoarene</term><term>[c]=[OX1]</term></item>
            <item><term>177</term><term>Thioarene</term><term>[c]=[SX1]</term></item>
            <item><term>178</term><term>Hetero N basic H</term><term>[nX3H1+0]</term></item>
            <item><term>179</term><term>Hetero N basic no H</term><term>[nX3H0+0]</term></item>
            <item><term>180</term><term>Hetero N nonbasic</term><term>[nX2,nX3+]</term></item>
            <item><term>181</term><term>Hetero O</term><term>[o]</term></item>
            <item><term>182</term><term>Hetero S</term><term>[sX2]</term></item>
            <item><term>183</term><term>Heteroaromatic</term><term>[a;!c]</term></item>
            <item><term>184</term><term>Nitrite</term><term>[NX2](=[OX1])[O;$([X2]),$([X1-])]</term></item>
            <item><term>185</term><term>Thionitrite</term><term>[SX2][NX2]=[OX1]</term></item>
            <item><term>186</term><term>Nitrate</term><term>[$([NX3](=[OX1])(=[OX1])[O;$([X2]),$([X1-])]),$([NX3+]([OX1-])(=[OX1])[O;$([X2]),$([X1-])])]</term></item>
            <item><term>187</term><term>Nitro</term><term>[$([NX3](=O)=O),$([NX3+](=O)[O-])][!#8]</term></item>
            <item><term>188</term><term>Nitroso</term><term>[NX2](=[OX1])[!#7;!#8]</term></item>
            <item><term>189</term><term>Azide</term><term>[NX1]~[NX2]~[NX2,NX1]</term></item>
            <item><term>190</term><term>Acylazide</term><term>[CX3](=[OX1])[NX2]~[NX2]~[NX1]</term></item>
            <item><term>191</term><term>Diazo</term><term>[$([#6]=[NX2+]=[NX1-]),$([#6-]-[NX2+]#[NX1])]</term></item>
            <item><term>192</term><term>Diazonium</term><term>[#6][NX2+]#[NX1]</term></item>
            <item><term>193</term><term>Nitrosamine</term><term>[#7;!$(N*=O)][NX2]=[OX1]</term></item>
            <item><term>194</term><term>Nitrosamide</term><term>[NX2](=[OX1])N-*=O</term></item>
            <item><term>195</term><term>N-Oxide</term><term>[$([#7+][OX1-]),$([#7v5]=[OX1]);!$([#7](~[O])~[O]);!$([#7]=[#7])]</term></item>
            <item><term>196</term><term>Hydrazine</term><term>[NX3;$([H2]),$([H1][#6]),$([H0]([#6])[#6]);!$(NC=[O,N,S])][NX3;$([H2]),$([H1][#6]),$([H0]([#6])[#6]);!$(NC=[O,N,S])]</term></item>
            <item><term>197</term><term>Hydrazone</term><term>[NX3;$([H2]),$([H1][#6]),$([H0]([#6])[#6]);!$(NC=[O,N,S])][NX2]=[#6]</term></item>
            <item><term>198</term><term>Hydroxylamine</term><term>[NX3;$([H2]),$([H1][#6]),$([H0]([#6])[#6]);!$(NC=[O,N,S])][OX2;$([H1]),$(O[#6;!$(C=[N,O,S])])]</term></item>
            <item><term>199</term><term>Sulfon</term><term>[$([SX4](=[OX1])(=[OX1])([#6])[#6]),$([SX4+2]([OX1-])([OX1-])([#6])[#6])]</term></item>
            <item><term>200</term><term>Sulfoxide</term><term>[$([SX3](=[OX1])([#6])[#6]),$([SX3+]([OX1-])([#6])[#6])]</term></item>
            <item><term>201</term><term>Sulfonium</term><term>[S+;!$([S]~[!#6]);!$([S]*~[#7,#8,#15,#16])]</term></item>
            <item><term>202</term><term>Sulfuric acid</term><term>[SX4](=[OX1])(=[OX1])([$([OX2H]),$([OX1-])])[$([OX2H]),$([OX1-])]</term></item>
            <item><term>203</term><term>Sulfuric monoester</term><term>[SX4](=[OX1])(=[OX1])([$([OX2H]),$([OX1-])])[OX2][#6;!$(C=[O,N,S])]</term></item>
            <item><term>204</term><term>Sulfuric diester</term><term>[SX4](=[OX1])(=[OX1])([OX2][#6;!$(C=[O,N,S])])[OX2][#6;!$(C=[O,N,S])]</term></item>
            <item><term>205</term><term>Sulfuric monoamide</term><term>[SX4](=[OX1])(=[OX1])([#7X3;$([H2]),$([H1][#6;!$(C=[O,N,S])]),$([#7]([#6;!$(C=[O,N,S])])[#6;!$(C=[O,N,S])])])[$([OX2H]),$([OX1-])]</term></item>
            <item><term>206</term><term>Sulfuric diamide</term><term>[SX4](=[OX1])(=[OX1])([#7X3;$([H2]),$([H1][#6;!$(C=[O,N,S])]),$([#7]([#6;!$(C=[O,N,S])])[#6;!$(C=[O,N,S])])])[#7X3;$([H2]),$([H1][#6;!$(C=[O,N,S])]),$([#7]([#6;!$(C=[O,N,S])])[#6;!$(C=[O,N,S])])]</term></item>
            <item><term>207</term><term>Sulfuric esteramide</term><term>[SX4](=[OX1])(=[OX1])([#7X3][#6;!$(C=[O,N,S])])[OX2][#6;!$(C=[O,N,S])]</term></item>
            <item><term>208</term><term>Sulfuric derivative</term><term>[SX4D4](=[!#6])(=[!#6])([!#6])[!#6]</term></item>
            <item><term>209</term><term>Sulfonic acid</term><term>[SX4;$([H1]),$([H0][#6])](=[OX1])(=[OX1])[$([OX2H]),$([OX1-])]</term></item>
            <item><term>210</term><term>Sulfonamide</term><term>[SX4;$([H1]),$([H0][#6])](=[OX1])(=[OX1])[#7X3;$([H2]),$([H1][#6;!$(C=[O,N,S])]),$([#7]([#6;!$(C=[O,N,S])])[#6;!$(C=[O,N,S])])]</term></item>
            <item><term>211</term><term>Sulfonic ester</term><term>[SX4;$([H1]),$([H0][#6])](=[OX1])(=[OX1])[OX2][#6;!$(C=[O,N,S])]</term></item>
            <item><term>212</term><term>Sulfonic halide</term><term>[SX4;$([H1]),$([H0][#6])](=[OX1])(=[OX1])[FX1,ClX1,BrX1,IX1]</term></item>
            <item><term>213</term><term>Sulfonic derivative</term><term>[SX4;$([H1]),$([H0][#6])](=[!#6])(=[!#6])[!#6]</term></item>
            <item><term>214</term><term>Sulfinic acid</term><term>[SX3;$([H1]),$([H0][#6])](=[OX1])[$([OX2H]),$([OX1-])]</term></item>
            <item><term>215</term><term>Sulfinic amide</term><term>[SX3;$([H1]),$([H0][#6])](=[OX1])[#7X3;$([H2]),$([H1][#6;!$(C=[O,N,S])]),$([#7]([#6;!$(C=[O,N,S])])[#6;!$(C=[O,N,S])])]</term></item>
            <item><term>216</term><term>Sulfinic ester</term><term>[SX3;$([H1]),$([H0][#6])](=[OX1])[OX2][#6;!$(C=[O,N,S])]</term></item>
            <item><term>217</term><term>Sulfinic halide</term><term>[SX3;$([H1]),$([H0][#6])](=[OX1])[FX1,ClX1,BrX1,IX1]</term></item>
            <item><term>218</term><term>Sulfinic derivative</term><term>[SX3;$([H1]),$([H0][#6])](=[!#6])[!#6]</term></item>
            <item><term>219</term><term>Sulfenic acid</term><term>[SX2;$([H1]),$([H0][#6])][$([OX2H]),$([OX1-])]</term></item>
            <item><term>220</term><term>Sulfenic amide</term><term>[SX2;$([H1]),$([H0][#6])][#7X3;$([H2]),$([H1][#6;!$(C=[O,N,S])]),$([#7]([#6;!$(C=[O,N,S])])[#6;!$(C=[O,N,S])])]</term></item>
            <item><term>221</term><term>Sulfenic ester</term><term>[SX2;$([H1]),$([H0][#6])][OX2][#6;!$(C=[O,N,S])]</term></item>
            <item><term>222</term><term>Sulfenic halide</term><term>[SX2;$([H1]),$([H0][#6])][FX1,ClX1,BrX1,IX1]</term></item>
            <item><term>223</term><term>Sulfenic derivative</term><term>[SX2;$([H1]),$([H0][#6])][!#6]</term></item>
            <item><term>224</term><term>Phosphine</term><term>[PX3;$([H3]),$([H2][#6]),$([H1]([#6])[#6]),$([H0]([#6])([#6])[#6])]</term></item>
            <item><term>225</term><term>Phosphine oxide</term><term>[PX4;$([H3]=[OX1]),$([H2](=[OX1])[#6]),$([H1](=[OX1])([#6])[#6]),$([H0](=[OX1])([#6])([#6])[#6])]</term></item>
            <item><term>226</term><term>Phosphonium</term><term>[P+;!$([P]~[!#6]);!$([P]*~[#7,#8,#15,#16])]</term></item>
            <item><term>227</term><term>Phosphorylen</term><term>[PX4;$([H3]=[CX3]),$([H2](=[CX3])[#6]),$([H1](=[CX3])([#6])[#6]),$([H0](=[CX3])([#6])([#6])[#6])]</term></item>
            <item><term>228</term><term>Phosphonic acid</term><term>[PX4;$([H1]),$([H0][#6])](=[OX1])([$([OX2H]),$([OX1-])])[$([OX2H]),$([OX1-])]</term></item>
            <item><term>229</term><term>Phosphonic monoester</term><term>[PX4;$([H1]),$([H0][#6])](=[OX1])([$([OX2H]),$([OX1-])])[OX2][#6;!$(C=[O,N,S])]</term></item>
            <item><term>230</term><term>Phosphonic diester</term><term>[PX4;$([H1]),$([H0][#6])](=[OX1])([OX2][#6;!$(C=[O,N,S])])[OX2][#6;!$(C=[O,N,S])]</term></item>
            <item><term>231</term><term>Phosphonic monoamide</term><term>[PX4;$([H1]),$([H0][#6])](=[OX1])([$([OX2H]),$([OX1-])])[#7X3;$([H2]),$([H1][#6;!$(C=[O,N,S])]),$([#7]([#6;!$(C=[O,N,S])])[#6;!$(C=[O,N,S])])]</term></item>
            <item><term>232</term><term>Phosphonic diamide</term><term>[PX4;$([H1]),$([H0][#6])](=[OX1])([#7X3;$([H2]),$([H1][#6;!$(C=[O,N,S])]),$([#7]([#6;!$(C=[O,N,S])])[#6;!$(C=[O,N,S])])])[#7X3;$([H2]),$([H1][#6;!$(C=[O,N,S])]),$([#7]([#6;!$(C=[O,N,S])])[#6;!$(C=[O,N,S])])]</term></item>
            <item><term>233</term><term>Phosphonic esteramide</term><term>[PX4;$([H1]),$([H0][#6])](=[OX1])([OX2][#6;!$(C=[O,N,S])])[#7X3;$([H2]),$([H1][#6;!$(C=[O,N,S])]),$([#7]([#6;!$(C=[O,N,S])])[#6;!$(C=[O,N,S])])]</term></item>
            <item><term>234</term><term>Phosphonic acid derivative</term><term>[PX4;$([H1]),$([H0][#6])](=[!#6])([!#6])[!#6]</term></item>
            <item><term>235</term><term>Phosphoric acid</term><term>[PX4D4](=[OX1])([$([OX2H]),$([OX1-])])([$([OX2H]),$([OX1-])])[$([OX2H]),$([OX1-])]</term></item>
            <item><term>236</term><term>Phosphoric monoester</term><term>[PX4D4](=[OX1])([$([OX2H]),$([OX1-])])([$([OX2H]),$([OX1-])])[OX2][#6;!$(C=[O,N,S])]</term></item>
            <item><term>237</term><term>Phosphoric diester</term><term>[PX4D4](=[OX1])([$([OX2H]),$([OX1-])])([OX2][#6;!$(C=[O,N,S])])[OX2][#6;!$(C=[O,N,S])]</term></item>
            <item><term>238</term><term>Phosphoric triester</term><term>[PX4D4](=[OX1])([OX2][#6;!$(C=[O,N,S])])([OX2][#6;!$(C=[O,N,S])])[OX2][#6;!$(C=[O,N,S])]</term></item>
            <item><term>239</term><term>Phosphoric monoamide</term><term>[PX4D4](=[OX1])([$([OX2H]),$([OX1-])])([$([OX2H]),$([OX1-])])[#7X3;$([H2]),$([H1][#6;!$(C=[O,N,S])]),$([#7]([#6;!$(C=[O,N,S])])[#6;!$(C=[O,N,S])])]</term></item>
            <item><term>240</term><term>Phosphoric diamide</term><term>[PX4D4](=[OX1])([$([OX2H]),$([OX1-])])([#7X3;$([H2]),$([H1][#6;!$(C=[O,N,S])]),$([#7]([#6;!$(C=[O,N,S])])[#6;!$(C=[O,N,S])])])[#7X3;$([H2]),$([H1][#6;!$(C=[O,N,S])]),$([#7]([#6;!$(C=[O,N,S])])[#6;!$(C=[O,N,S])])]</term></item>
            <item><term>241</term><term>Phosphoric triamide</term><term>[PX4D4](=[OX1])([#7X3;$([H2]),$([H1][#6;!$(C=[O,N,S])]),$([#7]([#6;!$(C=[O,N,S])])[#6;!$(C=[O,N,S])])])([#7X3;$([H2]),$([H1][#6;!$(C=[O,N,S])]),$([#7]([#6;!$(C=[O,N,S])])[#6;!$(C=[O,N,S])])])[#7X3;$([H2]),$([H1][#6;!$(C=[O,N,S])]),$([#7]([#6;!$(C=[O,N,S])])[#6;!$(C=[O,N,S])])]</term></item>
            <item><term>242</term><term>Phosphoric monoestermonoamide</term><term>[PX4D4](=[OX1])([$([OX2H]),$([OX1-])])([OX2][#6;!$(C=[O,N,S])])[#7X3;$([H2]),$([H1][#6;!$(C=[O,N,S])]),$([#7]([#6;!$(C=[O,N,S])])[#6;!$(C=[O,N,S])])]</term></item>
            <item><term>243</term><term>Phosphoric diestermonoamide</term><term>[PX4D4](=[OX1])([OX2][#6;!$(C=[O,N,S])])([OX2][#6;!$(C=[O,N,S])])[#7X3;$([H2]),$([H1][#6;!$(C=[O,N,S])]),$([#7]([#6;!$(C=[O,N,S])])[#6;!$(C=[O,N,S])])]</term></item>
            <item><term>244</term><term>Phosphoric monoesterdiamide</term><term>[PX4D4](=[OX1])([OX2][#6;!$(C=[O,N,S])])([#7X3;$([H2]),$([H1][#6;!$(C=[O,N,S])]),$([#7]([#6;!$(C=[O,N,S])])[#6;!$(C=[O,N,S])])])[#7X3;$([H2]),$([H1][#6;!$(C=[O,N,S])]),$([#7]([#6;!$(C=[O,N,S])])[#6;!$(C=[O,N,S])])]</term></item>
            <item><term>245</term><term>Phosphoric acid derivative</term><term>[PX4D4](=[!#6])([!#6])([!#6])[!#6]</term></item>
            <item><term>246</term><term>Phosphinic acid</term><term>[PX4;$([H2]),$([H1][#6]),$([H0]([#6])[#6])](=[OX1])[$([OX2H]),$([OX1-])]</term></item>
            <item><term>247</term><term>Phosphinic ester</term><term>[PX4;$([H2]),$([H1][#6]),$([H0]([#6])[#6])](=[OX1])[OX2][#6;!$(C=[O,N,S])]</term></item>
            <item><term>248</term><term>Phosphinic amide</term><term>[PX4;$([H2]),$([H1][#6]),$([H0]([#6])[#6])](=[OX1])[#7X3;$([H2]),$([H1][#6;!$(C=[O,N,S])]),$([#7]([#6;!$(C=[O,N,S])])[#6;!$(C=[O,N,S])])]</term></item>
            <item><term>249</term><term>Phosphinic acid derivative</term><term>[PX4;$([H2]),$([H1][#6]),$([H0]([#6])[#6])](=[!#6])[!#6]</term></item>
            <item><term>250</term><term>Phosphonous acid</term><term>[PX3;$([H1]),$([H0][#6])]([$([OX2H]),$([OX1-])])[$([OX2H]),$([OX1-])]</term></item>
            <item><term>251</term><term>Phosphonous monoester</term><term>[PX3;$([H1]),$([H0][#6])]([$([OX2H]),$([OX1-])])[OX2][#6;!$(C=[O,N,S])]</term></item>
            <item><term>252</term><term>Phosphonous diester</term><term>[PX3;$([H1]),$([H0][#6])]([OX2][#6;!$(C=[O,N,S])])[OX2][#6;!$(C=[O,N,S])]</term></item>
            <item><term>253</term><term>Phosphonous monoamide</term><term>[PX3;$([H1]),$([H0][#6])]([$([OX2H]),$([OX1-])])[#7X3;$([H2]),$([H1][#6;!$(C=[O,N,S])]),$([#7]([#6;!$(C=[O,N,S])])[#6;!$(C=[O,N,S])])]</term></item>
            <item><term>254</term><term>Phosphonous diamide</term><term>[PX3;$([H1]),$([H0][#6])]([#7X3;$([H2]),$([H1][#6;!$(C=[O,N,S])]),$([#7]([#6;!$(C=[O,N,S])])[#6;!$(C=[O,N,S])])])[#7X3;$([H2]),$([H1][#6;!$(C=[O,N,S])]),$([#7]([#6;!$(C=[O,N,S])])[#6;!$(C=[O,N,S])])]</term></item>
            <item><term>255</term><term>Phosphonous esteramide</term><term>[PX3;$([H1]),$([H0][#6])]([OX2][#6;!$(C=[O,N,S])])[#7X3;$([H2]),$([H1][#6;!$(C=[O,N,S])]),$([#7]([#6;!$(C=[O,N,S])])[#6;!$(C=[O,N,S])])]</term></item>
            <item><term>256</term><term>Phosphonous derivatives</term><term>[PX3;$([D2]),$([D3][#6])]([!#6])[!#6]</term></item>
            <item><term>257</term><term>Phosphinous acid</term><term>[PX3;$([H2]),$([H1][#6]),$([H0]([#6])[#6])][$([OX2H]),$([OX1-])]</term></item>
            <item><term>258</term><term>Phosphinous ester</term><term>[PX3;$([H2]),$([H1][#6]),$([H0]([#6])[#6])][OX2][#6;!$(C=[O,N,S])]</term></item>
            <item><term>259</term><term>Phosphinous amide</term><term>[PX3;$([H2]),$([H1][#6]),$([H0]([#6])[#6])][#7X3;$([H2]),$([H1][#6;!$(C=[O,N,S])]),$([#7]([#6;!$(C=[O,N,S])])[#6;!$(C=[O,N,S])])]</term></item>
            <item><term>260</term><term>Phosphinous derivatives</term><term>[PX3;$([H2]),$([H1][#6]),$([H0]([#6])[#6])][!#6]</term></item>
            <item><term>261</term><term>Quart silane</term><term>[SiX4]([#6])([#6])([#6])[#6]</term></item>
            <item><term>262</term><term>Non-quart silane</term><term>[SiX4;$([H1]([#6])([#6])[#6]),$([H2]([#6])[#6]),$([H3][#6]),$([H4])]</term></item>
            <item><term>263</term><term>Silylmonohalide</term><term>[SiX4]([FX1,ClX1,BrX1,IX1])([#6])([#6])[#6]</term></item>
            <item><term>264</term><term>Het trialkylsilane</term><term>[SiX4]([!#6])([#6])([#6])[#6]</term></item>
            <item><term>265</term><term>Dihet dialkylsilane</term><term>[SiX4]([!#6])([!#6])([#6])[#6]</term></item>
            <item><term>266</term><term>Trihet alkylsilane</term><term>[SiX4]([!#6])([!#6])([!#6])[#6]</term></item>
            <item><term>267</term><term>Silicic acid derivative</term><term>[SiX4]([!#6])([!#6])([!#6])[!#6]</term></item>
            <item><term>268</term><term>Trialkylborane</term><term>[BX3]([#6])([#6])[#6]</term></item>
            <item><term>269</term><term>Boric acid derivatives</term><term>[BX3]([!#6])([!#6])[!#6]</term></item>
            <item><term>270</term><term>Boronic acid derivative</term><term>[BX3]([!#6])([!#6])[!#6]</term></item>
            <item><term>271</term><term>Borohydride</term><term>[BH1,BH2,BH3,BH4]</term></item>
            <item><term>272</term><term>Quaternary boron</term><term>[BX4]</term></item>
            <item><term>273</term><term>Aromatic</term><term>a</term></item>
            <item><term>274</term><term>Heterocyclic</term><term>[!#6;!R0]</term></item>
            <item><term>275</term><term>Epoxide</term><term>[OX2r3]1[#6r3][#6r3]1</term></item>
            <item><term>276</term><term>NH aziridine</term><term>[NX3H1r3]1[#6r3][#6r3]1</term></item>
            <item><term>277</term><term>Spiro</term><term>[D4R;$(*(@*)(@*)(@*)@*)]</term></item>
            <item><term>278</term><term>Annelated rings</term><term>[R;$(*(@*)(@*)@*);!$([R2;$(*(@*)(@*)(@*)@*)])]@[R;$(*(@*)(@*)@*);!$([R2;$(*(@*)(@*)(@*)@*)])]</term></item>
            <item><term>279</term><term>Bridged rings</term><term>[R;$(*(@*)(@*)@*);!$([D4R;$(*(@*)(@*)(@*)@*)]);!$([R;$(*(@*)(@*)@*);!$([R2;$(*(@*)(@*)(@*)@*)])]@[R;$(*(@*)(@*)@*);!$([R2;$(*(@*)(@*)(@*)@*)])])]</term></item>
            <item><term>280</term><term>Sugar pattern 1</term><term>[OX2;$([r5]1@C@C@C(O)@C1),$([r6]1@C@C@C(O)@C(O)@C1)]</term></item>
            <item><term>281</term><term>Sugar pattern 2</term><term>[OX2;$([r5]1@C(!@[OX2,NX3,SX2,FX1,ClX1,BrX1,IX1])@C@C@C1),$([r6]1@C(!@[OX2,NX3,SX2,FX1,ClX1,BrX1,IX1])@C@C@C@C1)]</term></item>
            <item><term>282</term><term>Sugar pattern combi</term><term>[OX2;$([r5]1@C(!@[OX2,NX3,SX2,FX1,ClX1,BrX1,IX1])@C@C(O)@C1),$([r6]1@C(!@[OX2,NX3,SX2,FX1,ClX1,BrX1,IX1])@C@C(O)@C(O)@C1)]</term></item>
            <item><term>283</term><term>Sugar pattern 2 reducing</term><term>[OX2;$([r5]1@C(!@[OX2H1])@C@C@C1),$([r6]1@C(!@[OX2H1])@C@C@C@C1)]</term></item>
            <item><term>284</term><term>Sugar pattern 2 alpha</term><term>[OX2;$([r5]1@[C@@](!@[OX2,NX3,SX2,FX1,ClX1,BrX1,IX1])@C@C@C1),$([r6]1@[C@@](!@[OX2,NX3,SX2,FX1,ClX1,BrX1,IX1])@C@C@C@C1)]</term></item>
            <item><term>285</term><term>Sugar pattern 2 beta</term><term>[OX2;$([r5]1@[C@](!@[OX2,NX3,SX2,FX1,ClX1,BrX1,IX1])@C@C@C1),$([r6]1@[C@](!@[OX2,NX3,SX2,FX1,ClX1,BrX1,IX1])@C@C@C@C1)]</term></item>
            <item><term>286</term><term>Conjugated double bond</term><term>*=*[*]=,#,:[*]</term></item>
            <item><term>287</term><term>Conjugated tripple bond</term><term>*#*[*]=,#,:[*]</term></item>
            <item><term>288</term><term>Cis double bond</term><term>*&amp;#47[D2]=[D2]/*</term></item>
            <item><term>289</term><term>Trans double bond</term><term>*&amp;#47[D2]=[D2]/*</term></item>
            <item><term>290</term><term>Mixed anhydrides</term><term>[$(*=O),$([#16,#14,#5]),$([#7]([#6]=[OX1]))][#8X2][$(*=O),$([#16,#14,#5]),$([#7]([#6]=[OX1]))]</term></item>
            <item><term>291</term><term>Halogen on hetero</term><term>[FX1,ClX1,BrX1,IX1][!#6]</term></item>
            <item><term>292</term><term>Halogen multi subst</term><term>[F,Cl,Br,I;!$([X1]);!$([X0-])]</term></item>
            <item><term>293</term><term>Trifluoromethyl</term><term>[FX1][CX4;!$([H0][Cl,Br,I]);!$([F][C]([F])([F])[F])]([FX1])([FX1])</term></item>
            <item><term>294</term><term>C ONS bond</term><term>[#6]~[#7,#8,#16]</term></item>
            <item><term>295</term><term>Charged</term><term>[!+0]</term></item>
            <item><term>296</term><term>Anion</term><term>[-1,-2,-3,-4,-5,-6,-7]</term></item>
            <item><term>297</term><term>Kation</term><term>[+1,+2,+3,+4,+5,+6,+7]</term></item>
            <item><term>298</term><term>Salt</term><term>([-1,-2,-3,-4,-5,-6,-7]).([+1,+2,+3,+4,+5,+6,+7])</term></item>
            <item><term>299</term><term>1,3-Tautomerizable</term><term>[$([#7X2,OX1,SX1]=*[!H0;!$([a;!n])]),$([#7X3,OX2,SX2;!H0]*=*),$([#7X3,OX2,SX2;!H0]*:n)]</term></item>
            <item><term>300</term><term>1,5-Tautomerizable</term><term>[$([#7X2,OX1,SX1]=,:**=,:*[!H0;!$([a;!n])]),$([#7X3,OX2,SX2;!H0]*=**=*),$([#7X3,OX2,SX2;!H0]*=,:**:n)]</term></item>
            <item><term>301</term><term>Rotatable bond</term><term>[!$(*#*)&amp;!D1]-!@[!$(*#*)&amp;!D1]</term></item>
            <item><term>302</term><term>Michael acceptor</term><term>[CX3]=[CX3][$([CX3]=[O,N,S]),$(C#[N]),$([S,P]=[OX1]),$([NX3]=O),$([NX3+](=O)[O-])]</term></item>
            <item><term>303</term><term>Dicarbodiazene</term><term>[CX3](=[OX1])[NX2]=[NX2][CX3](=[OX1])</term></item>
            <item><term>304</term><term>CH-acidic</term><term>[$([CX4;!$([H0]);!$(C[!#6;!$([P,S]=O);!$(N(~O)~O)])][$([CX3]=[O,N,S]),$(C#[N]),$([S,P]=[OX1]),$([NX3]=O),$([NX3+](=O)[O-]);!$(*[S,O,N;H1,H2]);!$([*+0][S,O;X1-])]),$([CX4;!$([H0])]1[CX3]=[CX3][CX3]=[CX3]1)]</term></item>
            <item><term>305</term><term>CH-acidic strong</term><term>[CX4;!$([H0]);!$(C[!#6;!$([P,S]=O);!$(N(~O)~O)])]([$([CX3]=[O,N,S]),$(C#[N]),$([S,P]=[OX1]),$([NX3]=O),$([NX3+](=O)[O-]);!$(*[S,O,N;H1,H2]);!$([*+0][S,O;X1-])])[$([CX3]=[O,N,S]),$(C#[N]),$([S,P]=[OX1]),$([NX3]=O),$([NX3+](=O)[O-]);!$(*[S,O,N;H1,H2]);!$([*+0][S,O;X1-])]</term></item>
            <item><term>306</term><term>Chiral center specified</term><term>[$([*@](~*)(~*)(*)*),$([*@H](*)(*)*),$([*@](~*)(*)*),$([*@H](~*)~*)]</term></item>
            </tbody></list>
        </member>
        <member name="M:NCDK.Fingerprints.SubstructureFingerprinter.#ctor">
            <summary>
            Set up the fingerprinter to use the fragments from <see cref="T:NCDK.Fingerprints.StandardSubstructureSets"/>.
            </summary>
        </member>
        <member name="M:NCDK.Fingerprints.SubstructureFingerprinter.#ctor(System.String[])">
            <summary>
            Set up the fingerprinter to use a user-defined set of fragments.
            </summary>
            <param name="smarts">The collection of fragments to look for</param>
        </member>
        <member name="M:NCDK.Fingerprints.SubstructureFingerprinter.GetBitFingerprint(NCDK.IAtomContainer)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Fingerprints.SubstructureFingerprinter.GetRawFingerprint(NCDK.IAtomContainer)">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.Fingerprints.SubstructureFingerprinter.Count">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Fingerprints.SubstructureFingerprinter.GetSubstructure(System.Int32)">
            <summary>
            Retrieves the SMARTS representation of a substructure for a given
            bit in the fingerprint.
            </summary>
            <param name="bitIndex"></param>
            <returns>SMARTS representation of substructure at index <paramref name="bitIndex"/>.</returns>
        </member>
        <member name="M:NCDK.Fingerprints.SubstructureFingerprinter.GetCountFingerprint(NCDK.IAtomContainer)">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Fingerprints.SignatureFingerprinter">
            <summary>
            An implementation of a <see cref="T:NCDK.Signatures.AtomSignature"/>-based fingerprint.
            </summary>
        </member>
        <member name="M:NCDK.Fingerprints.SignatureFingerprinter.#ctor">
            <summary>
            Initialize the fingerprinter with a default signature depth of 1.
            </summary>
        </member>
        <member name="M:NCDK.Fingerprints.SignatureFingerprinter.#ctor(System.Int32)">
            <summary>
            Initialize the fingerprinter with a certain signature depth.
            </summary>
            <param name="depth">The depth of the signatures to calculate.</param>
        </member>
        <member name="T:NCDK.Formula.FullEnumerationFormulaGenerator">
            <summary>
            This class generates molecular formulas within given mass range and elemental
            composition. There is no guaranteed order in which the formulas are
            generated.
            
            Usage:
            
            <pre>
            IsotopeFactory ifac = Isotopes.getInstance();
            IIsotope c = ifac.getMajorIsotope(&quot;C&quot;);
            IIsotope h = ifac.getMajorIsotope(&quot;H&quot;);
            IIsotope n = ifac.getMajorIsotope(&quot;N&quot;);
            IIsotope o = ifac.getMajorIsotope(&quot;O&quot;);
            IIsotope p = ifac.getMajorIsotope(&quot;P&quot;);
            IIsotope s = ifac.getMajorIsotope(&quot;S&quot;);
            
            MolecularFormulaRange mfRange = new MolecularFormulaRange();
            mfRange.addIsotope(c, 0, 50);
            mfRange.addIsotope(h, 0, 100);
            mfRange.addIsotope(o, 0, 50);
            mfRange.addIsotope(n, 0, 50);
            mfRange.addIsotope(p, 0, 10);
            mfRange.addIsotope(s, 0, 10);
            
            MolecularFormulaGenerator mfg = new MolecularFormulaGenerator(builder, minMass,
                    maxMass, mfRange);
            double minMass = 133.003;
            double maxMass = 133.005;
            IMolecularFormulaSet mfSet = mfg.getAllFormulas();
            </pre>
            
            The code was originally developed for a MZmine 2 framework module, published
            in Pluskal et al. <token>cdk-cite-Pluskal2012</token>.
            </summary>
        </member>
        <member name="F:NCDK.Formula.FullEnumerationFormulaGenerator.minMass">
            <summary>
            Mass range to search by this instance of MolecularFormulaGenerator
            </summary>
        </member>
        <member name="F:NCDK.Formula.FullEnumerationFormulaGenerator.maxMass">
            <summary>
            Mass range to search by this instance of MolecularFormulaGenerator
            </summary>
        </member>
        <member name="F:NCDK.Formula.FullEnumerationFormulaGenerator.isotopes">
            <summary>
            Internal arrays of isotopes (elements) used for the formula generation,
            their minimal and maximal counts, and the current counts, which
            correspond to the latest formula candidate.
            
            For example, let's assume we set isotopes=[C,H,N], minCounts=[0,0,0], and
            maxCounts=[3,3,3]. Then, currentCounts will be iterated in the following
            order: [0,0,0], [1,0,0], [2,0,0], [3,0,0], [0,1,0], [1,1,0], [2,1,0],
            [3,1,0], [0,2,0], [1,2,0], [2,2,0], etc.
            
            The lastIncreasedPosition index indicates the last position in
            currentCounts that was increased by calling increaseCounter(position)
            </summary>
        </member>
        <member name="F:NCDK.Formula.FullEnumerationFormulaGenerator.searchRunning">
            <summary>
            A flag indicating that the formula generation is running. If the search
            is finished (the whole search space has been examined) or the search is
            canceled by calling the cancel() method, this flag is set to false.
            </summary>
            <seealso cref="M:NCDK.Formula.FullEnumerationFormulaGenerator.Cancel"/>
        </member>
        <member name="M:NCDK.Formula.FullEnumerationFormulaGenerator.#ctor(NCDK.IChemObjectBuilder,System.Double,System.Double,NCDK.Formula.MolecularFormulaRange)">
            <summary>
            Initiate the MolecularFormulaGenerator.
            </summary>
            <param name="minMass">Lower boundary of the target mass range</param>
            <param name="maxMass">Upper boundary of the target mass range</param>
            <param name="mfRange">A range of elemental compositions defining the search space</param>
            <exception cref="T:System.ArgumentOutOfRangeException">In case some of the isotopes in mfRange has undefined exact mass or in case illegal parameters are provided (e.g.,             negative mass values or empty MolecularFormulaRange)</exception>
            <seealso cref="T:NCDK.Formula.MolecularFormulaRange"/>
        </member>
        <member name="M:NCDK.Formula.FullEnumerationFormulaGenerator.GetNextFormula">
            <summary>
            Returns next generated formula or null in case no new formula was found
            (search is finished). There is no guaranteed order in which the formulas
            are generated.
            </summary>
        </member>
        <member name="M:NCDK.Formula.FullEnumerationFormulaGenerator.GetAllFormulas">
            <summary>
            Generates a <see cref="T:NCDK.IMolecularFormulaSet"/> by repeatedly calling <see cref="M:NCDK.Formula.FullEnumerationFormulaGenerator.GetNextFormula"/> until all possible formulas are generated. There is no
            guaranteed order to the formulas in the resulting
            <see cref="T:NCDK.IMolecularFormulaSet"/>.
            </summary>
            <remarks>
            <note type="note">
            If some formulas were already generated by calling <see cref="M:NCDK.Formula.FullEnumerationFormulaGenerator.GetNextFormula"/> on this MolecularFormulaGenerator instance, those
            formulas will not be included in the returned
            </note>
            </remarks> 
            <see cref="T:NCDK.IMolecularFormulaSet"/>.
            <seealso cref="M:NCDK.Formula.FullEnumerationFormulaGenerator.GetNextFormula"/>
        </member>
        <member name="M:NCDK.Formula.FullEnumerationFormulaGenerator.IncreaseCounter(System.Int32)">
            <summary>
            Increases the internal counter array currentCounts[] at given position.
            If the position has reached its maximum value, its value is reset to the
            minimum value and the next position is increased.
            </summary>
            <param name="position">Index to the currentCounts[] array that should be increased</param>
        </member>
        <member name="M:NCDK.Formula.FullEnumerationFormulaGenerator.CalculateCurrentMass">
            <summary>
            Calculates the exact mass of the currently evaluated formula. Basically,
            it multiplies the currentCounts[] array by the masses of the isotopes in
            the isotopes[] array.
            </summary>
        </member>
        <member name="M:NCDK.Formula.FullEnumerationFormulaGenerator.GenerateFormulaObject">
            <summary>
            Generates a MolecularFormula object that contains the isotopes in the
            isotopes[] array with counts in the currentCounts[] array. In other
            words, generates a proper CDK representation of the currently examined
            formula.
            </summary>
        </member>
        <member name="M:NCDK.Formula.FullEnumerationFormulaGenerator.GetFinishedPercentage">
            <summary>
            Returns a value between 0.0 and 1.0 indicating what portion of the search
            space has been examined so far by this MolecularFormulaGenerator. Before
            the first call to <see cref="M:NCDK.Formula.FullEnumerationFormulaGenerator.GetNextFormula"/>, this method returns 0. After
            all possible formulas are generated, this method returns 1.0 (the exact
            returned value might be slightly off due to rounding errors). This method
            can be called from any thread.
            </summary>
        </member>
        <member name="M:NCDK.Formula.FullEnumerationFormulaGenerator.Cancel">
            <summary>
            Cancel the current search. This method can be called from any thread. If
            another thread is executing the <see cref="M:NCDK.Formula.FullEnumerationFormulaGenerator.GetNextFormula"/> method, that
            method call will return immediately with null return value. If another
            thread is executing the <see cref="M:NCDK.Formula.FullEnumerationFormulaGenerator.GetAllFormulas"/> method, that method call
            will return immediately, returning all formulas generated until this
            moment. The search cannot be restarted once canceled - any subsequent
            calls to <see cref="M:NCDK.Formula.FullEnumerationFormulaGenerator.GetNextFormula"/> will return null.
            </summary>
        </member>
        <member name="T:NCDK.Formula.FullEnumerationFormulaGenerator.IIsotopeSorterByMass">
            <summary>
            A simple <see cref="T:System.Collections.Generic.IComparer`1"/> implementation for sorting IIsotopes by their
            mass
            </summary>
        </member>
        <member name="T:NCDK.Formula.MolecularFormula">
            <summary>
            Class defining a molecular formula object. It maintains a list of list <see cref="T:NCDK.IIsotope"/>.
            </summary>
            <remarks>
            Examples:
            <list type="bullet">
            <item>[C<sub>5</sub>H<sub>5</sub>]-</item>
            <item>C<sub>6</sub>H<sub>6</sub></item>
            <item><sup>12</sup>C<sub>5</sub><sup>13</sup>CH<sub>6</sub></item>
            </list>
            </remarks>
        </member>
        <member name="F:NCDK.Formula.MolecularFormula.properties">
            <summary>
            A dictionary for the storage of any kind of properties of this object.
            </summary>
        </member>
        <member name="M:NCDK.Formula.MolecularFormula.SetProperty(System.Object,System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Formula.MolecularFormula.RemoveProperty(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Formula.MolecularFormula.GetProperty``1(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Formula.MolecularFormula.GetProperty``1(System.Object,``0)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Formula.MolecularFormula.GetProperties">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Formula.MolecularFormula.SetProperties(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.Object,System.Object}})">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Formula.MolecularFormula.AddProperties(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.Object,System.Object}})">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.Formula.MolecularFormula.Charge">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Formula.MolecularFormula.#ctor">
            <summary>
            Constructs an empty MolecularFormula.
            </summary>
        </member>
        <member name="M:NCDK.Formula.MolecularFormula.Add(NCDK.IMolecularFormula)">
            <summary>
            Adds an molecularFormula to this MolecularFormula.
            </summary>
            <param name="formula">The molecularFormula to be added to this chemObject</param>
            <returns>The IMolecularFormula</returns>
        </member>
        <member name="M:NCDK.Formula.MolecularFormula.Add(NCDK.IIsotope)">
            <summary>
            Adds an Isotope to this MolecularFormula one time.
            </summary>
            <param name="isotope">The isotope to be added to this MolecularFormula</param>
        </member>
        <member name="M:NCDK.Formula.MolecularFormula.Add(NCDK.IIsotope,System.Int32)">
            <summary>
            Adds an Isotope to this MolecularFormula in a number of occurrences.
            </summary>
            <param name="isotope">The isotope to be added to this MolecularFormula</param>
            <param name="count">The number of occurrences to add</param>
        </member>
        <member name="M:NCDK.Formula.MolecularFormula.Contains(NCDK.IIsotope)">
            <summary>
            True, if the MolecularFormula contains the given IIsotope object and not
            the instance. The method looks for other isotopes which has the same
            symbol, natural abundance and exact mass.
            </summary>
            <param name="isotope">The IIsotope this MolecularFormula is searched for</param>
            <returns>True, if the MolecularFormula contains the given isotope object</returns>
        </member>
        <member name="M:NCDK.Formula.MolecularFormula.GetCount(NCDK.IIsotope)">
            <summary>
            Checks a set of Nodes for the occurrence of the isotope in the
            IMolecularFormula from a particular isotope. It returns 0 if the does not exist.
            </summary>
            <param name="isotope">The IIsotope to look for</param>
            <returns>The occurrence of this isotope in this IMolecularFormula</returns>
        </member>
        <member name="P:NCDK.Formula.MolecularFormula.Count">
            <summary>
            The the number of different isotopes in this IMolecularFormula.
            </summary>
        </member>
        <member name="P:NCDK.Formula.MolecularFormula.Isotopes">
            <summary>
            An IEnumerator with the isotopes in this IMolecularFormula.
            </summary>
        </member>
        <member name="M:NCDK.Formula.MolecularFormula.Clear">
            <summary>
            Removes all isotopes of this molecular formula.
            </summary>
        </member>
        <member name="M:NCDK.Formula.MolecularFormula.Remove(NCDK.IIsotope)">
            <summary>
            Removes the given isotope from the MolecularFormula.
            </summary>
            <param name="isotope">The IIsotope to be removed</param>
        </member>
        <member name="M:NCDK.Formula.MolecularFormula.Clone">
            <summary>
            Clones this <see cref="T:NCDK.Formula.MolecularFormula"/> object and its content. I should integrate into ChemObject.
            </summary>
            <returns>The cloned object</returns>
        </member>
        <member name="M:NCDK.Formula.MolecularFormula.IsTheSame(NCDK.IIsotope,NCDK.IIsotope)">
            <summary>
            Compare to IIsotope. The method doesn't compare instance but if they
            have the same symbol, natural abundance and exact mass.
            </summary>
            <param name="isotopeOne">The first Isotope to compare</param>
            <param name="isotopeTwo">The second Isotope to compare</param>
            <returns>True, if both isotope are the same</returns>
        </member>
        <member name="T:NCDK.Formula.RoundRobinFormulaGenerator">
            <summary>
            This class generates molecular formulas within given mass range and elemental
            composition. It should not be used directly but via the <see cref="T:NCDK.Formula.MolecularFormulaGenerator"/> as it cannot deal with
            all kind of inputs.
            </summary>
            <remarks>
            <para>
            This class is using the Round Robin algorithm <token>cdk-cite-Boecker2008</token> on mass ranges
            <token>cdk-cite-Duehrkop2013</token>. It uses dynamic programming to compute an extended residue table which allows a constant
            time lookup if some integer mass is decomposable over a certain alphabet. For each alphabet this table has to be
            computed only once and is then cached in memory. Using this table the algorithm can decide directly which masses
            are decomposable and, therefore, is only enumerating formulas which masses are in the given integer mass range. The
            mass range decomposer is using a logarithmic number of tables, one for each alphabet and an allowed mass deviation.
            It, therefore, allows to decompose a whole range of integer numbers instead of a single one.
            </para>
            <para>
            As masses are real values, the decomposer has to translate values from real space to integer space and vice versa.
            This translation is done via multiplying with a blow-up factor (which is by default 5963.337687) and rounding the
            results. The blow-up factor is optimized for organic molecules. For other alphabets (e.g. amino acids or molecules
            without hydrogens) another blow-up factor have to be chosen. Therefore, it is recommended to use this decomposer
            only for organic molecular formulas.
            </para>
            </remarks>
        </member>
        <member name="F:NCDK.Formula.RoundRobinFormulaGenerator.builder">
            <summary>
            generates the IMolecularFormula and IMolecularFormulaSet instances
            </summary>
        </member>
        <member name="F:NCDK.Formula.RoundRobinFormulaGenerator.decomposer">
            <summary>
            the decomposer algorithm with the cached extended residue table
            </summary>
        </member>
        <member name="F:NCDK.Formula.RoundRobinFormulaGenerator.mfRange">
            <summary>
            defines the alphabet as well as the lower- and upperbounds of the chemical alphabet
            </summary>
        </member>
        <member name="F:NCDK.Formula.RoundRobinFormulaGenerator.lastDecomposition">
            <summary>
            is used to estimate which part of the search space is already traversed
            </summary>
        </member>
        <member name="F:NCDK.Formula.RoundRobinFormulaGenerator.done">
            <summary>
            a flag indicating if the algorithm is done or should be canceled.
            This flag have to be volatile to allow other threads to cancel the enumeration procedure.
            </summary>
        </member>
        <member name="M:NCDK.Formula.RoundRobinFormulaGenerator.#ctor(NCDK.IChemObjectBuilder,System.Double,System.Double,NCDK.Formula.MolecularFormulaRange)">
            <summary>
            Initiate the MolecularFormulaGenerator.
            </summary>
            <param name="minMass">Lower boundary of the target mass range</param>
            <param name="maxMass">Upper boundary of the target mass range</param>
            <param name="mfRange">A range of elemental compositions defining the search space</param>
            <exception cref="T:System.ArgumentOutOfRangeException">In case some of the isotopes in mfRange has undefined exact mass or in case illegal parameters are provided (e.g., negative mass values or empty MolecularFormulaRange)</exception>
            <seealso cref="T:NCDK.Formula.MolecularFormulaRange"/>
        </member>
        <member name="M:NCDK.Formula.RoundRobinFormulaGenerator.GetNextFormula">
            <seealso cref="M:NCDK.Formula.MolecularFormulaGenerator.GetNextFormula"/>
        </member>
        <member name="M:NCDK.Formula.RoundRobinFormulaGenerator.GetAllFormulas">
            <seealso cref="M:NCDK.Formula.MolecularFormulaGenerator.GetAllFormulas"/>
        </member>
        <member name="M:NCDK.Formula.RoundRobinFormulaGenerator.GetFinishedPercentage">
            <summary>
            This method does not work for Round Robin as the algorithm only enumerates formulas which really have the
            searched mass range (except for false positives due to rounding errors). As the exact number of molecular formulas
            with a given mass is unknown (calculating it is as expensive as enumerating them) there is no way to give a
            progress number. Therefore, the method returns just 0 if it's enumerating and 1 if it's done.
            </summary>
        </member>
        <member name="M:NCDK.Formula.RoundRobinFormulaGenerator.Cancel">
            <summary>
            Cancel the computation
            </summary>
        </member>
        <member name="T:NCDK.Formula.RoundRobinFormulaGenerator.DecomposerFactory">
            <summary>
            As every decomposer has to be initialized (i.e. an extended residue table has to be computed) it is important
            to cache decomposer instances when decomposing a large set of numbers (initialization time is only dependent on
            alphabet size. For decomposing large masses the decomposition time might exceed the initialization time. For very
            small masses it is the other way around). This simple cache stores the last 10 used decomposers. It is very likely
            that for a given mass spectrum only one alphabet is chosen to decompose all peaks. In this case this cache should
            be sufficient.
            </summary>
        </member>
        <member name="T:NCDK.Formula.RoundRobinFormulaGenerator.RangeMassDecomposer">
            <summary>
            Decomposes a given mass over an alphabet, returning all decompositions which masses equals the given mass
            considering a given deviation.
            MassDecomposerFast calculates the decompositions with the help of an ERT containing deviation information, not requiring to iterate over all different integer mass values <token>cdk-cite-Duehrkop2013</token>.
            </summary>
        </member>
        <member name="F:NCDK.Formula.RoundRobinFormulaGenerator.RangeMassDecomposer.ERTs">
            <summary>
            Avoid locks by making ERTs volatile. This leads to the situation that several threads might accidentally compute
            the same ERT tables. However, as soon as an ERT table is written it is synchronized around all threads. After
            writing an ERT table it is never changed, so additional locking is not necessary.
            </summary>
        </member>
        <member name="M:NCDK.Formula.RoundRobinFormulaGenerator.RangeMassDecomposer.#ctor(NCDK.IIsotope[])">
            <param name="allowedIsotopes">array of the elements of the alphabet</param>
        </member>
        <member name="M:NCDK.Formula.RoundRobinFormulaGenerator.RangeMassDecomposer.IsCompatible(NCDK.IIsotope[])">
            <summary>
            checks if this decomposer can be used for the given alphabet. This is the case when the decomposer
            contains the same elements as the given alphabet.
            </summary>
            <remarks>
            It would be also the case when the given alphabet is a subset of this decomposers alphabet. However,
            if the alphabet size of the decomposer is much larger, the decomposer might be slower anyways due to
            larger memory footprint. As we expect that the alphabet does not change that often, it might be
            sufficient to just compare the arrays.
            </remarks>
        </member>
        <member name="M:NCDK.Formula.RoundRobinFormulaGenerator.RangeMassDecomposer.Init">
            <summary>
            Initializes the decomposer. Computes the extended residue table. This have to be done only one time for
            a given alphabet, independently from the masses you want to decompose. This method is called automatically
            if you compute the decompositions, so call it only if you want to control the time of the initialisation.
            </summary>
        </member>
        <member name="M:NCDK.Formula.RoundRobinFormulaGenerator.RangeMassDecomposer.MaybeDecomposable(System.Double,System.Double)">
            <summary>
            Check if a mass is decomposable. This is done in constant time (especially: it is very very very fast!).
            But it doesn't check if there is a valid decomposition. Therefore, even if the method returns true,
            all decompositions may be invalid for the given validator or given bounds.
            #decompose(mass) uses this function before starting the decomposition, therefore this method should only
            be used if you don't want to start the decomposition algorithm.
            </summary>
            <returns>true if the mass is decomposable, ignoring bounds or any additional filtering rule</returns>
        </member>
        <member name="M:NCDK.Formula.RoundRobinFormulaGenerator.RangeMassDecomposer.DecomposeIterator(System.Double,System.Double,NCDK.Formula.MolecularFormulaRange)">
            <summary>
            Returns an iterator over all decompositons of this mass range
            </summary>
            <param name="from">lowest mass to decompose</param>
            <param name="to">(inclusive) largest mass to decompose</param>
            <param name="boundaries">defines lowerbounds and upperbounds for the number of elements</param>
        </member>
        <member name="M:NCDK.Formula.RoundRobinFormulaGenerator.RangeMassDecomposer.CalcERT(System.Int32)">
            <summary>
            calculates ERTs to look up whether a mass or lower masses within a certain deviation are decomposable.
            only ERTs for deviation 2^x are calculated
            </summary>
        </member>
        <member name="T:NCDK.Formula.RoundRobinFormulaGenerator.RangeMassDecomposer.DecompIterator">
            <summary>
            Iterator implementation of the loop
            We do not use static classes. This gives us the possibility to make some of the variables behave thread safe
            and resistant against changes from the user.
            </summary>
        </member>
        <member name="T:NCDK.Formula.RoundRobinFormulaGenerator.ChemicalElement">
            <summary>
            A POJO storing the weight information about a character in the alphabet
            </summary>
        </member>
        <member name="F:NCDK.Formula.RoundRobinFormulaGenerator.ChemicalElement.owner">
            <summary>
            corresponding character in the alphabet
            </summary>
        </member>
        <member name="F:NCDK.Formula.RoundRobinFormulaGenerator.ChemicalElement.mass">
            <summary>
            the exact mass of the character
            </summary>
        </member>
        <member name="F:NCDK.Formula.RoundRobinFormulaGenerator.ChemicalElement.integerMass">
            <summary>
            the transformation of the mass in the integer space
            </summary>
        </member>
        <member name="T:NCDK.Formula.MolecularFormulaSet">
            <summary>
            Class defining an set object of MolecularFormulas. It maintains
            a list of list IMolecularFormula.
            </summary>
        </member>
        <member name="F:NCDK.Formula.MolecularFormulaSet.components">
            <summary> Internal List of IMolecularFormula.</summary>
        </member>
        <member name="M:NCDK.Formula.MolecularFormulaSet.#ctor">
            <summary>
            Constructs an empty MolecularFormulaSet.
            </summary>
            <seealso cref="M:NCDK.Formula.MolecularFormulaSet.#ctor(NCDK.IMolecularFormula)"/>
        </member>
        <member name="M:NCDK.Formula.MolecularFormulaSet.#ctor(NCDK.IMolecularFormula)">
            <summary>
            Constructs a MolecularFormulaSet with a copy MolecularFormulaSet of another
            MolecularFormulaSet (A shallow copy, i.e., with the same objects as in
            the original MolecularFormulaSet).
            </summary>
            <param name="formula">An MolecularFormula to copy from</param>
            <seealso cref="T:NCDK.Formula.MolecularFormulaSet"/>
        </member>
        <member name="M:NCDK.Formula.MolecularFormulaSet.AddRange(System.Collections.Generic.IEnumerable{NCDK.IMolecularFormula})">
            <summary>
            Adds all molecularFormulas in the MolecularFormulaSet to this chemObject.
            </summary>
            <param name="formulaSet">The MolecularFormulaSet</param>
        </member>
        <member name="M:NCDK.Formula.MolecularFormulaSet.Add(NCDK.IMolecularFormula)">
            <summary>
            Adds an molecularFormula to this chemObject.
            </summary>
            <param name="formula">The molecularFormula to be added to this chemObject</param>
        </member>
        <member name="M:NCDK.Formula.MolecularFormulaSet.GetEnumerator">
            <summary>
            Returns an Enumerator for looping over all IMolecularFormula
            in this MolecularFormulaSet.
            </summary>
            <returns>An Iterable with the IMolecularFormula in this MolecularFormulaSet</returns>
        </member>
        <member name="P:NCDK.Formula.MolecularFormulaSet.Count">
            <summary>
            Returns the number of MolecularFormulas in this MolecularFormulaSet.
            </summary>
            <returns>The number of MolecularFormulas in this MolecularFormulaSet</returns>
        </member>
        <member name="M:NCDK.Formula.MolecularFormulaSet.Contains(NCDK.IMolecularFormula)">
            <summary>
            True, if the MolecularFormulaSet contains the given IMolecularFormula object.
            </summary>
            <param name="formula">The IMolecularFormula this MolecularFormulaSet is searched for</param>
            <returns>True, if the MolecularFormulaSet contains the given IMolecularFormula object</returns>
        </member>
        <member name="P:NCDK.Formula.MolecularFormulaSet.Item(System.Int32)">
            <summary>
            The MolecularFormula at position <paramref name="position"/> in the
            chemObject.
            </summary>
            <param name="position">The position of the IMolecularFormula to be returned.</param>
        </member>
        <member name="M:NCDK.Formula.MolecularFormulaSet.Clear">
            <summary>
            Removes all IMolecularFormula from this chemObject.
            </summary>
        </member>
        <member name="M:NCDK.Formula.MolecularFormulaSet.Remove(NCDK.IMolecularFormula)">
            <summary>
            Removes an IMolecularFormula from this chemObject.
            </summary>
            <param name="formula">The IMolecularFormula to be removed from this chemObject</param>
        </member>
        <member name="M:NCDK.Formula.MolecularFormulaSet.RemoveAt(System.Int32)">
            <summary>
            Removes an MolecularFormula from this chemObject.
            </summary>
            <param name="position">The position of the MolecularFormula to be removed from this chemObject</param>
        </member>
        <member name="M:NCDK.Formula.MolecularFormulaSet.Clone">
            <summary>
            Clones this MolecularFormulaSet object and its content.
            </summary>
            <returns>The cloned object</returns>
        </member>
        <member name="T:NCDK.Formula.IsotopeContainer">
            <summary>
            This class defines a isotope container. It contains in principle a
            IMolecularFormula, a mass and intensity/abundance value.
            </summary>
        </member>
        <member name="M:NCDK.Formula.IsotopeContainer.#ctor(NCDK.IMolecularFormula,System.Double)">
            <summary>
            Constructor of the <see cref="T:NCDK.Formula.IsotopeContainer"/> object setting a <see cref="T:NCDK.IMolecularFormula"/> object and intensity value.
            </summary>
            <param name="formula">The formula of this container</param>
            <param name="intensity">The intensity of this container</param>
        </member>
        <member name="M:NCDK.Formula.IsotopeContainer.#ctor(System.Double,System.Double)">
            <summary>
            Constructor of the IsotopeContainer object setting a mass and intensity value.
            </summary>
            <param name="mass">The mass of this container</param>
            <param name="intensity">The intensity of this container</param>
        </member>
        <member name="P:NCDK.Formula.IsotopeContainer.Formula">
            <summary>
            the IMolecularFormula object of this container.
            </summary>
        </member>
        <member name="P:NCDK.Formula.IsotopeContainer.Mass">
            <summary>
            the mass value of this container.
            </summary>
        </member>
        <member name="P:NCDK.Formula.IsotopeContainer.Intensity">
            <summary>
            the intensity value of this container.
            </summary>
        </member>
        <member name="M:NCDK.Formula.IsotopeContainer.Clone">
            <summary>
            Clones this IsotopeContainer object and its content.
            </summary>
            <returns>The cloned object</returns>
        </member>
        <member name="T:NCDK.Formula.IsotopePattern">
            <summary>
            This class defines the properties of a deisotoped
            pattern distribution. A isotope pattern is a set of
            compounds with different set of isotopes.
            </summary>
        </member>
        <member name="M:NCDK.Formula.IsotopePattern.#ctor">
            <summary>
            Constructor of the IsotopePattern object.
            </summary>
        </member>
        <member name="M:NCDK.Formula.IsotopePattern.SetMonoIsotope(NCDK.Formula.IsotopeContainer)">
            <summary>
            Set the mono isotope object. Adds the isoContainer to the isotope 
                            pattern, if it is not already added. 
            </summary>
            <param name="isoContainer">The IsotopeContainer object</param>
        </member>
        <member name="M:NCDK.Formula.IsotopePattern.GetMonoIsotope">
            <summary>
            Returns the mono-isotope peak that form this isotope pattern.
            </summary>
            <returns>The IsotopeContainer acting as mono-isotope</returns>
        </member>
        <member name="P:NCDK.Formula.IsotopePattern.Charge">
            <summary>
            the charge in this pattern.
            </summary>
        </member>
        <member name="M:NCDK.Formula.IsotopePattern.Clone">
            <summary>
            Clones this IsotopePattern object and its content.
            </summary>
            <returns>The cloned object</returns>
        </member>
        <member name="T:NCDK.Formula.IsotopePatternGenerator">
            <summary>
            Generates all Combinatorial chemical isotopes given a structure.
            </summary>
        </member>
        <member name="F:NCDK.Formula.IsotopePatternGenerator.minAbundance">
            <summary> Minimal abundance of the isotopes to be added in the combinatorial search.</summary>
        </member>
        <member name="M:NCDK.Formula.IsotopePatternGenerator.#ctor">
            <summary>
            Constructor for the IsotopeGenerator. The minimum abundance is set to 
                                    0.1 (10% abundance) by default. 
            </summary>
        </member>
        <member name="M:NCDK.Formula.IsotopePatternGenerator.#ctor(System.Double)">
            <summary>
            Constructor for the IsotopeGenerator.
            </summary>
            <param name="minAb">Minimal abundance of the isotopes to be added in the combinatorial search (scale 0.0 to 1.0)</param>
        </member>
        <member name="M:NCDK.Formula.IsotopePatternGenerator.GetIsotopes(NCDK.IMolecularFormula)">
            <summary>
            Get all combinatorial chemical isotopes given a structure.
            </summary>
            <param name="molFor">The IMolecularFormula to start</param>
            <returns>A IsotopePattern object containing the different combinations</returns>
        </member>
        <member name="M:NCDK.Formula.IsotopePatternGenerator.CalculateAbundanceAndMass(NCDK.Formula.IsotopePattern,System.String)">
            <summary>
            Calculates the mass and abundance of all isotopes generated by adding one
            atom. Receives the periodic table element and calculate the isotopes, if
            there exist a previous calculation, add these new isotopes. In the
            process of adding the new isotopes, remove those that has an abundance
            less than setup parameter minAbundance, and remove duplicated masses.
            </summary>
            <param name="elementSymbol">The chemical element symbol</param>
            <returns>the calculation was successful</returns>
        </member>
        <member name="M:NCDK.Formula.IsotopePatternGenerator.SearchMass(System.Collections.Generic.ICollection{System.Double},System.Double)">
            <summary>
            Search the key mass in this Set.
            </summary>
            <param name="keySet">The Set object</param>
            <param name="mass">The mass to look for</param>
            <returns>The key value</returns>
        </member>
        <member name="M:NCDK.Formula.IsotopePatternGenerator.CleanAbundance(NCDK.Formula.IsotopePattern,System.Double)">
            <summary>
            Normalize the intensity (relative abundance) of all isotopes in relation
            of the most abundant isotope.
            </summary>
            <param name="isopattern">The IsotopePattern object</param>
            <param name="minAbundance">The minimum abundance</param>
            <returns>The IsotopePattern cleaned</returns>
        </member>
        <member name="T:NCDK.Formula.IsotopePatternManipulator">
            <summary>
            Class to manipulate IsotopePattern objects.
            </summary>
        </member>
        <member name="M:NCDK.Formula.IsotopePatternManipulator.Normalize(NCDK.Formula.IsotopePattern)">
            <summary>
            Return the isotope pattern normalized to the highest abundance.
            </summary>
            <param name="isotopeP">The IsotopePattern object to normalize</param>
            <returns>The IsotopePattern normalized</returns>
        </member>
        <member name="M:NCDK.Formula.IsotopePatternManipulator.SortAndNormalizedByIntensity(NCDK.Formula.IsotopePattern)">
            <summary>
            Return the isotope pattern sorted and normalized by intensity
            to the highest abundance.
            </summary>
            <param name="isotopeP">The IsotopePattern object to sort</param>
            <returns>The IsotopePattern sorted</returns>
        </member>
        <member name="M:NCDK.Formula.IsotopePatternManipulator.SortByIntensity(NCDK.Formula.IsotopePattern)">
            <summary>
            Return the isotope pattern sorted by intensity to the highest abundance.
            </summary>
            <param name="isotopeP">The IsotopePattern object to sort</param>
            <returns>The IsotopePattern sorted</returns>
        </member>
        <member name="M:NCDK.Formula.IsotopePatternManipulator.SortByMass(NCDK.Formula.IsotopePattern)">
            <summary>
            Return the isotope pattern sorted by mass to the highest abundance.
            </summary>
            <param name="isotopeP">The IsotopePattern object to sort</param>
            <returns>The IsotopePattern sorted</returns>
        </member>
        <member name="T:NCDK.Formula.IsotopePatternSimilarity">
            <summary>
            This class gives a score hit of similarity between two different isotope abundance pattern.
            </summary>
        </member>
        <member name="P:NCDK.Formula.IsotopePatternSimilarity.Tolerance">
            <summary>
            the tolerance of the mass accuracy in ppm.
            </summary>
        </member>
        <member name="M:NCDK.Formula.IsotopePatternSimilarity.Compare(NCDK.Formula.IsotopePattern,NCDK.Formula.IsotopePattern)">
            <summary>
            Compare the IMolecularFormula with a isotope
            abundance pattern.
            </summary>
            <param name="isoto1">The Isotope pattern reference (predicted)</param>
            <param name="isoto2">The Isotope pattern reference (detected)</param>
            <returns>The hit score of similarity</returns>
        </member>
        <member name="M:NCDK.Formula.IsotopePatternSimilarity.GetClosestDataDiff(NCDK.Formula.IsotopeContainer,NCDK.Formula.IsotopePattern)">
            <summary>
            Search and find the closest difference in an array in terms of mass and
            intensity. Always return the position in this List.
            </summary>
            <param name="isoContainer"></param>
            <param name="pattern"></param>
            <returns></returns>
        </member>
        <member name="T:NCDK.Formula.MolecularFormulaChecker">
            <summary>
            Validate a molecular formula given in IMolecularformula object. The
            validation is based according different rules that you have to introduce before
            see IRule.
            </summary>
            <seealso cref="T:NCDK.Formula.Rules.IRule"/>
        </member>
        <member name="F:NCDK.Formula.MolecularFormulaChecker.rules">
            <summary>List of IRules to be applied in the validation.</summary>
        </member>
        <member name="M:NCDK.Formula.MolecularFormulaChecker.#ctor(System.Collections.Generic.IList{NCDK.Formula.Rules.IRule})">
            <summary>
            Construct an instance of MolecularFormulaChecker. It must be initialized with the rules to applied.
            </summary>
            <param name="rules">A List with IRule to be applied</param>
        </member>
        <member name="P:NCDK.Formula.MolecularFormulaChecker.Rules">
            <summary>
            The IRules to be applied to validate the IMolecularFormula.
            </summary>
        </member>
        <member name="M:NCDK.Formula.MolecularFormulaChecker.IsValidSum(NCDK.IMolecularFormula)">
            <summary>
            Validate if a IMolecularFormula is valid. The result more close to 1 means
            maximal probability to be valid. Opposite more close to 0 means minimal
            probability to be valid. To know the result in each IRule use
            <see cref="M:NCDK.Formula.MolecularFormulaChecker.IsValid(NCDK.IMolecularFormula)"/>.
            </summary>
            <param name="formula">The IMolecularFormula value</param>
            <returns>The percent of the validity</returns>
            <seealso cref="M:NCDK.Formula.MolecularFormulaChecker.IsValid(NCDK.IMolecularFormula)"/>
        </member>
        <member name="M:NCDK.Formula.MolecularFormulaChecker.IsValid(NCDK.IMolecularFormula)">
            <summary>
            Validate if a IMolecularFormula is valid. The results of each IRule which
            has to be applied is put into IMolecularFormula as properties. To extract
            the result final as the product of rule's result use
            <see cref="M:NCDK.Formula.MolecularFormulaChecker.IsValidSum(NCDK.IMolecularFormula)"/>.
            </summary>
            <param name="formula">The IMolecularFormula value</param>
            <returns>formulaWith  The IMolecularFormula with the results for each IRule into properties</returns>
            <seealso cref="M:NCDK.Formula.MolecularFormulaChecker.IsValidSum(NCDK.IMolecularFormula)"/>
        </member>
        <member name="T:NCDK.Formula.MolecularFormulaGenerator">
            <summary>
            This class generates molecular formulas within given mass range and elemental
            composition.
            </summary>
            <example>
            <code>            IsotopeFactory ifac = Isotopes.Instance;
             IIsotope c = ifac.GetMajorIsotope("C");
             IIsotope h = ifac.GetMajorIsotope("H");
             IIsotope n = ifac.GetMajorIsotope("N");
             IIsotope o = ifac.GetMajorIsotope("O");
             IIsotope p = ifac.GetMajorIsotope("P");
             IIsotope s = ifac.GetMajorIsotope("S");
             
             MolecularFormulaRange mfRange = new MolecularFormulaRange();
             mfRange.AddIsotope(c, 0, 50);
             mfRange.AddIsotope(h, 0, 100);
             mfRange.AddIsotope(o, 0, 50);
             mfRange.AddIsotope(n, 0, 50);
             mfRange.AddIsotope(p, 0, 10);
             mfRange.AddIsotope(s, 0, 10);

            var builder = Silent.ChemObjectBuilder.Instance;
            double minMass = 133.003;
            double maxMass = 133.005;
            MolecularFormulaGenerator mfg = new MolecularFormulaGenerator(builder, minMass, maxMass, mfRange);
            IMolecularFormulaSet mfSet = mfg.GetAllFormulas();
</code>
            </example>    
            <remarks>
            This class offers two implementations: The Round Robin algorithm <token>cdk-cite-Boecker2008</token> on mass ranges
            <token>cdk-cite-Duehrkop2013</token> is used on most inputs. For special cases (e.g. single elements, extremely large mass ranges)
            a full enumeration algorithm <token>cdk-cite-Pluskal2012</token> is used.
            
            The Round Robin algorithm was originally developed for the SIRIUS 3 software. The full enumeration algorithm was
            originally developed for a MZmine 2 framework module, published in Pluskal et al. <token>cdk-cite-Pluskal2012</token>.
            </remarks>
        </member>
        <member name="F:NCDK.Formula.MolecularFormulaGenerator.formulaGenerator">
            <summary>
            The chosen implementation
            </summary>
        </member>
        <member name="M:NCDK.Formula.MolecularFormulaGenerator.#ctor(NCDK.IChemObjectBuilder,System.Double,System.Double,NCDK.Formula.MolecularFormulaRange)">
            <summary>
            Initiate the MolecularFormulaGenerator.
            </summary>
            <param name="minMass">Lower boundary of the target mass range</param>
            <param name="maxMass">Upper boundary of the target mass range</param>
            <param name="mfRange">A range of elemental compositions defining the search space</param>
            <exception cref="T:System.ArgumentOutOfRangeException">In case some of the isotopes in mfRange has undefined exact             mass or in case illegal parameters are provided (e.g.,             negative mass values or empty MolecularFormulaRange)</exception>
            <seealso cref="T:NCDK.Formula.MolecularFormulaRange"/>
        </member>
        <member name="M:NCDK.Formula.MolecularFormulaGenerator.IsIllPosed(System.Double,System.Double,NCDK.Formula.MolecularFormulaRange)">
            <summary>
            Decides wheter to use the round robin algorithm or full enumeration algorithm.
            The round robin implementation here is optimized for chemical elements in organic compounds. It gets slow
            if
            - the mass of the smallest element is very large (i.e. hydrogen is not allowed)
            - the maximal mass to decompose is too large (round robin always decomposes integers. Therefore, the mass have
              to be small enough to be represented as 32 bit integer)
            - the number of elements in the set is extremely small (in this case, however, the problem becomes trivial anyways)
            
            In theory we could handle these problems by optimizing the way DECOMP discretizes the masses. However, it's easier
            to just fall back to the full enumeration method if a problem occurs (especially, because most of the problems
            lead to trivial cases that are fast to compute).
            </summary>
            <returns>true if the problem is ill-posed (i.e. should be calculated by full enumeration method)</returns>
        </member>
        <member name="M:NCDK.Formula.MolecularFormulaGenerator.GetNextFormula">
            <summary>
            Returns next generated formula or null in case no new formula was found
            (search is finished). There is no guaranteed order in which the formulas
            are generated.
            </summary>
        </member>
        <member name="M:NCDK.Formula.MolecularFormulaGenerator.GetAllFormulas">
            <summary>
            Generates a <see cref="T:NCDK.IMolecularFormulaSet"/> by repeatedly calling <see cref="M:NCDK.Formula.MolecularFormulaGenerator.GetNextFormula"/> until all possible formulas are generated. There is no
            guaranteed order to the formulas in the resulting
            <see cref="T:NCDK.IMolecularFormulaSet"/>.
            </summary>
            <remarks>
            <note type="note">
            If some formulas were already generated by calling <see cref="M:NCDK.Formula.MolecularFormulaGenerator.GetNextFormula"/> on this MolecularFormulaGenerator instance, those
            formulas will not be included in the returned
            <see cref="T:NCDK.IMolecularFormulaSet"/>.
            </note>
            </remarks> 
            <seealso cref="M:NCDK.Formula.MolecularFormulaGenerator.GetNextFormula"/>
        </member>
        <member name="M:NCDK.Formula.MolecularFormulaGenerator.GetFinishedPercentage">
            <summary>
            Returns a value between 0.0 and 1.0 indicating what portion of the search
            space has been examined so far by this MolecularFormulaGenerator. Before
            the first call to <see cref="M:NCDK.Formula.MolecularFormulaGenerator.GetNextFormula"/>, this method returns 0. After
            all possible formulas are generated, this method returns 1.0 (the exact
            returned value might be slightly off due to rounding errors). This method
            can be called from any thread.
            </summary>
        </member>
        <member name="M:NCDK.Formula.MolecularFormulaGenerator.Cancel">
            <summary>
            Cancel the current search. This method can be called from any thread. If
            another thread is executing the <see cref="M:NCDK.Formula.MolecularFormulaGenerator.GetNextFormula"/> method, that
            method call will return immediately with null return value. If another
            thread is executing the <see cref="M:NCDK.Formula.MolecularFormulaGenerator.GetAllFormulas"/> method, that method call
            will return immediately, returning all formulas generated until this
            moment. The search cannot be restarted once canceled - any subsequent
            calls to <see cref="M:NCDK.Formula.MolecularFormulaGenerator.GetNextFormula"/> will return null.
            </summary>
        </member>
        <member name="M:NCDK.Formula.MolecularFormulaGenerator.CheckInputParameters(NCDK.IChemObjectBuilder,System.Double,System.Double,NCDK.Formula.MolecularFormulaRange)">
            <summary>
            Checks if input parameters are valid and throws an <see cref="T:System.ArgumentOutOfRangeException"/> otherwise.
            </summary>
        </member>
        <member name="T:NCDK.Formula.MolecularFormulaRange">
            <summary>
            Class defining a expanded molecular formula object. The Isotopes don't have
            a fix occurrence in the MolecularFormula but they have a range.
            <para>
            With this class man can define a MolecularFormula which contains certain IIsotope
            with a maximum and minimum occurrence.
            </para>
            </summary>
            <remarks>
            Examples:
            <list type="bullet">
            <item><c>[C(1-5)H(4-10)]-</c></item>
            </list>
            </remarks>
        </member>
        <member name="M:NCDK.Formula.MolecularFormulaRange.#ctor">
            <summary>
            Constructs an empty MolecularFormulaExpand.
            </summary>
        </member>
        <member name="M:NCDK.Formula.MolecularFormulaRange.AddIsotope(NCDK.IIsotope,System.Int32,System.Int32)">
            <summary>
            Adds an Isotope to this MolecularFormulaExpand in a number of
            maximum and minimum occurrences allowed.
            </summary>
            <param name="isotope">The isotope to be added to this MolecularFormulaExpand</param>
            <param name="countMax">The maximal number of occurrences to add</param>
            <param name="countMin">The minimal number of occurrences to add</param>
        </member>
        <member name="M:NCDK.Formula.MolecularFormulaRange.Contains(NCDK.IIsotope)">
            <summary>
            True, if the MolecularFormulaExpand contains the given IIsotope.
            The method looks for other isotopes which has the same
            symbol, natural abundance and exact mass.
            </summary>
            <param name="isotope">The IIsotope this MolecularFormula is searched for</param>
            <returns>True, if the MolecularFormula contains the given isotope object</returns>
        </member>
        <member name="M:NCDK.Formula.MolecularFormulaRange.GetIsotopeCountMax(NCDK.IIsotope)">
            <summary>
            Checks a set of Nodes for the maximal occurrence of the isotope in the
            MolecularFormulaExpand from a particular isotope. It returns -1 if the Isotope
            does not exist.
            </summary>
            <param name="isotope">The IIsotope to look for</param>
            <returns>The occurrence of this isotope in this IMolecularFormula</returns>
        </member>
        <member name="M:NCDK.Formula.MolecularFormulaRange.GetIsotopeCountMin(NCDK.IIsotope)">
            <summary>
            Checks a set of Nodes for the minimal occurrence of the isotope in the
            MolecularFormulaExpand from a particular isotope. It returns -1 if the Isotope
            does not exist.
            </summary>
            <param name="isotope">The IIsotope to look for</param>
            <returns>The occurrence of this isotope in this IMolecularFormula</returns>
        </member>
        <member name="P:NCDK.Formula.MolecularFormulaRange.Count">
            <summary>
            Checks a set of Nodes for the number of different isotopes in the
            MolecularFormulaExpand.
            </summary>
            <returns>The the number of different isotopes in this MolecularFormulaExpand</returns>
        </member>
        <member name="M:NCDK.Formula.MolecularFormulaRange.GetIsotope(NCDK.IIsotope)">
            <summary>
            Get the isotope instance given an IIsotope. The instance is those
            that has the isotope with the same symbol, natural abundance and
            exact mass.
            </summary>
            <param name="isotope">The IIsotope for looking for</param>
            <returns>The IIsotope instance</returns>
            <seealso cref="M:NCDK.Formula.MolecularFormulaRange.GetIsotopes"/>
        </member>
        <member name="M:NCDK.Formula.MolecularFormulaRange.GetIsotopes">
            <summary>
            Get all isotopes in this MolecularFormulaExpand.
            </summary>
            <returns>The isotopes in this MolecularFormulaExpand</returns>
        </member>
        <member name="M:NCDK.Formula.MolecularFormulaRange.Clear">
            <summary>
            Removes all isotopes of this molecular formula.
            </summary>
        </member>
        <member name="M:NCDK.Formula.MolecularFormulaRange.Remove(NCDK.IIsotope)">
            <summary>
            Removes the given isotope from the MolecularFormulaExpand.
            </summary>
            <param name="isotope">The IIsotope to be removed</param>
        </member>
        <member name="M:NCDK.Formula.MolecularFormulaRange.Clone">
            <summary>
            Clones this MolecularFormulaExpand object and its content. I should
            integrate into ChemObject.
            </summary>
            <returns>The cloned object</returns>
        </member>
        <member name="M:NCDK.Formula.MolecularFormulaRange.IsTheSame(NCDK.IIsotope,NCDK.IIsotope)">
            <summary>
            Compare to IIsotope. The method doesn't compare instance but if they
            have the same symbol, natural abundance and exact mass.
            </summary>
            <param name="isotopeOne">The first Isotope to compare</param>
            <param name="isotopeTwo">The second Isotope to compare</param>
            <returns>True, if both isotope are the same</returns>
        </member>
        <member name="T:NCDK.Formula.Rules.ChargeRule">
            <summary>
            This class validate if the charge in the IMolecularFormula correspond with
            a specific value. As default it is defined as neutral == 0.0.
            </summary>
            <remarks>
            Table 1: Parameters set by this rule.
            <list type="table">
            <listheader>
              <term>Name</term>
              <term>Default</term>
              <term>Description</term>
            </listheader>
            <item>
              <term>charge</term>
              <term>0.0</term>
              <term>The Charge of MolecularFormula</term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:NCDK.Formula.Rules.ChargeRule.#ctor">
            <summary>
             Constructor for the ChargeRule object.
            </summary>
        </member>
        <member name="P:NCDK.Formula.Rules.ChargeRule.Parameters">
            <summary>
            The parameters attribute of the <see cref="T:NCDK.Formula.Rules.ChargeRule"/> object.
            </summary>
        </member>
        <member name="M:NCDK.Formula.Rules.ChargeRule.Validate(NCDK.IMolecularFormula)">
            <summary>
            Validate the charge of this IMolecularFormula.
            </summary>
            <param name="formula">Parameter is the IMolecularFormula</param>
            <returns>A double value meaning 1.0 True, 0.0 False</returns>
        </member>
        <member name="T:NCDK.Formula.Rules.ElementRule">
            <summary>
            This class validate if the occurrence of the IElements in the IMolecularFormula
            are into a limits. As default defines all elements of the periodic table with
            a occurrence of zero to 100.
            </summary>
            <remarks>
            Table 1: Parameters set by this rule.
            <list type="table">
            <listheader>
            <term>Name</term>
            <term>Default</term>
            <term>Default</term>
            </listheader>
            <item>
            <term>elements</term>
            <term>C,H,N,O</term>
            <term>The <see cref="T:NCDK.IElement"/> to be analyzed</term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:NCDK.Formula.Rules.ElementRule.#ctor">
            <summary>
            Constructor for the ElementRule object.
            </summary>
        </member>
        <member name="P:NCDK.Formula.Rules.ElementRule.Parameters">
            <summary>
            The parameters attribute of the ElementRule object.
            </summary>
        </member>
        <member name="M:NCDK.Formula.Rules.ElementRule.Validate(NCDK.IMolecularFormula)">
            <summary>
            Validate the occurrence of this <see cref="T:NCDK.IMolecularFormula"/>.
            </summary>
            <param name="formula">Parameter is the <see cref="T:NCDK.IMolecularFormula"/></param>
            <returns>An ArrayList containing 9 elements in the order described above</returns>
        </member>
        <member name="M:NCDK.Formula.Rules.ElementRule.EnsureDefaultOccurElements(NCDK.IChemObjectBuilder)">
            <summary>
            Initiate the MolecularFormulaExpand with the maximum and minimum occurrence of the Elements.
            In this case all elements of the periodic table are loaded.
            </summary>
            <param name="builder"></param>
        </member>
        <member name="T:NCDK.Formula.Rules.IRule">
            <summary>
            Interface which groups all method that validate a IMolecularFormula.
            </summary>
        </member>
        <member name="M:NCDK.Formula.Rules.IRule.Validate(NCDK.IMolecularFormula)">
            <summary>
            Analyze the validity for the given IMolecularFormula.
            </summary>
            <param name="formula">An <see cref="T:NCDK.IMolecularFormula"/> for which this rule should be analyzed</param>
            <returns>A double value between 0 and 1. 1 meaning 100% valid and 0 not valid</returns>
            <exception cref="T:NCDK.CDKException">if an error occurs during the validation. See documentation for individual rules</exception>
        </member>
        <member name="T:NCDK.Formula.Rules.IsotopePatternRule">
            <summary>
            This class validate if the Isotope Pattern from a given <see cref="T:NCDK.IMolecularFormula"/> correspond with other to compare.
            </summary>
            <remarks>
            Table 1: Parameters set by this rule.
            <list type="table">
            <listheader>
              <term>Name</term>
              <term>Default</term>
              <term>Description</term>
            </listheader>
            <item>
              <term>isotopePattern</term>
              <term>List &lt;Double[]&gt;</term>
              <term>The Isotope Pattern to compare</term>
            </item>
            </list>
            </remarks> 
        </member>
        <member name="F:NCDK.Formula.Rules.IsotopePatternRule.toleranceMass">
            <summary>Accuracy on the mass measuring isotope pattern</summary>
        </member>
        <member name="M:NCDK.Formula.Rules.IsotopePatternRule.#ctor">
            <summary>
            Constructor for the <see cref="T:NCDK.Formula.Rules.IsotopePatternRule"/> object.
            </summary>
        </member>
        <member name="P:NCDK.Formula.Rules.IsotopePatternRule.Parameters">
            <summary>
            The parameters attribute of the <see cref="T:NCDK.Formula.Rules.IsotopePatternRule"/> object.
            </summary>
        </member>
        <member name="M:NCDK.Formula.Rules.IsotopePatternRule.Validate(NCDK.IMolecularFormula)">
            <summary>
            Validate the isotope pattern of this <see cref="T:NCDK.IMolecularFormula"/>. Important, first
            you have to add with the <see cref="P:NCDK.Formula.Rules.IsotopePatternRule.Parameters"/> a <see cref="T:NCDK.IMolecularFormulaSet"/>
            which represents the isotope pattern to compare.
            </summary>
            <param name="formula">arameter is the <see cref="T:NCDK.IMolecularFormula"/></param>
            <returns>A double value meaning 1.0 True, 0.0 False</returns>
        </member>
        <member name="T:NCDK.Formula.Rules.MMElementRule">
            <summary>
            This class validate if the occurrence of the IElements in the IMolecularFormula, for
            metabolites, are into a maximal limit according paper: The study is from 2 different mass spectral
            databases and according different mass of the metabolites. The analysis don't
            take account if the IElement is not contained in the matrix. It will be jumped. 
            </summary>
            <remarks>
            <para>
            The rules is based from Tobias Kind paper with the title "Seven Golden Rules for heuristic
            filtering of molecular formula" <token>cdk-cite-kind2007</token>.
            </para>
            Table 1: Parameters set by this rule.
            <list type="table">
            <listheader>
              <term>Name</term>
              <term>Default</term>
              <term>Description</term>
            </listheader>
            <item>
              <term>database</term>
              <term>willey</term>
              <term>Mass spectral databases extraction</term>
            </item>
            <item>
              <term>massRange</term>
              <term>&lt; 500</term>
              <term>Mass to take account</term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="F:NCDK.Formula.Rules.MMElementRule.databaseUsed">
            <summary> Database used. As default Willey.</summary>
        </member>
        <member name="F:NCDK.Formula.Rules.MMElementRule.rangeMassUsed">
            <summary> Mass range used. As default lower than 500.</summary>
        </member>
        <member name="T:NCDK.Formula.Rules.MMElementRule.RangeMass">
            <summary> A enumeration of the possible mass range according the rules. </summary>
        </member>
        <member name="F:NCDK.Formula.Rules.MMElementRule.RangeMass.Minus500">
            <summary>IMolecularFormula from a metabolite with a mass lower than 500 Da.</summary>
        </member>
        <member name="F:NCDK.Formula.Rules.MMElementRule.RangeMass.Minus1000">
            <summary>IMolecularFormula from a metabolite with a mass lower than 1000 Da.</summary>
        </member>
        <member name="F:NCDK.Formula.Rules.MMElementRule.RangeMass.Minus2000">
            <summary>IMolecularFormula from a metabolite with a mass lower than 2000 Da.</summary>
        </member>
        <member name="F:NCDK.Formula.Rules.MMElementRule.RangeMass.Minus3000">
            <summary>IMolecularFormula from a metabolite with a mass lower than 3000 Da.</summary>
        </member>
        <member name="T:NCDK.Formula.Rules.MMElementRule.Database">
            <summary> A enumeration of the possible databases according the rules.</summary>
        </member>
        <member name="F:NCDK.Formula.Rules.MMElementRule.Database.WILEY">
            <summary>Wiley mass spectral database.</summary>
        </member>
        <member name="F:NCDK.Formula.Rules.MMElementRule.Database.DNP">
            <summary>Dictionary of Natural Products Online mass spectral database.</summary>
        </member>
        <member name="M:NCDK.Formula.Rules.MMElementRule.#ctor">
            <summary>
            Constructor for the MMElementRule object.
            </summary>
        </member>
        <member name="P:NCDK.Formula.Rules.MMElementRule.Parameters">
            <summary>
            The parameters attribute of the MMElementRule object.
            </summary>
        </member>
        <member name="M:NCDK.Formula.Rules.MMElementRule.Validate(NCDK.IMolecularFormula)">
            <summary>
            Validate the occurrence of this IMolecularFormula.
            </summary>
            <param name="formula">Parameter is the IMolecularFormula</param>
            <returns>An ArrayList containing 9 elements in the order described above</returns>
        </member>
        <member name="M:NCDK.Formula.Rules.MMElementRule.GetDNP_500">
            <summary>
            Get the map linking the symbol of the element and number maximum of occurrence.
            For the analysis with the DNP database and mass lower than 500 Da.
            </summary>
            <returns>The HashMap of the symbol linked with the maximum occurrence</returns>
        </member>
        <member name="M:NCDK.Formula.Rules.MMElementRule.GetDNP_1000">
            <summary>
            Get the map linking the symbol of the element and number maximum of occurrence.
            For the analysis with the DNP database and mass lower than 1000 Da.
            </summary>
            <returns>The HashMap of the symbol linked with the maximum occurrence</returns>
        </member>
        <member name="M:NCDK.Formula.Rules.MMElementRule.GetDNP_2000">
            <summary>
            Get the map linking the symbol of the element and number maximum of occurrence.
            For the analysis with the DNP database and mass lower than 2000 Da.
            </summary>
            <returns>The HashMap of the symbol linked with the maximum occurrence</returns>
        </member>
        <member name="M:NCDK.Formula.Rules.MMElementRule.GetDNP_3000">
            <summary>
            Get the map linking the symbol of the element and number maximum of occurrence.
            For the analysis with the DNP database and mass lower than 3000 Da.
            </summary>
            <returns>The HashMap of the symbol linked with the maximum occurrence</returns>
        </member>
        <member name="M:NCDK.Formula.Rules.MMElementRule.GetWisley_500">
            <summary>
            Get the map linking the symbol of the element and number maximum of occurrence.
            For the analysis with the Wisley database and mass lower than 500 Da.
            </summary>
            <returns>The HashMap of the symbol linked with the maximum occurrence</returns>
        </member>
        <member name="M:NCDK.Formula.Rules.MMElementRule.GetWisley_1000">
            <summary>
            Get the map linking the symbol of the element and number maximum of occurrence.
            For the analysis with the Wisley database and mass lower than 1000 Da.
            </summary>
            <returns>The HashMap of the symbol linked with the maximum occurrence</returns>
        </member>
        <member name="M:NCDK.Formula.Rules.MMElementRule.GetWisley_2000">
            <summary>
            Get the map linking the symbol of the element and number maximum of occurrence.
            For the analysis with the Wisley database and mass lower than 2000 Da.
            </summary>
            <returns>The HashMap of the symbol linked with the maximum occurrence</returns>
        </member>
        <member name="T:NCDK.Formula.Rules.NitrogenRule">
            <summary>
            This class validate if the rule of nitrogen is kept.
            <para>If a compound has an odd number of nitrogen atoms,
            then the molecular ion (the [M]<sup>+</sup>) will have an odd mass and the value for m/e will be odd.</para>
            <para>If a compound has no nitrogen atom or an even number of nitrogen atoms, then the m/e value of [M]<sup>+</sup> will be even.</para>
            </summary>
            <remarks>
            Table 1: Parameters set by this rule.
            <list type="table">
            <item>
              <term>Name</term>
              <term>Default</term>
              <term>Description</term>
            </item>
            <item>
              <term>charge</term>
              <term>0.0</term>
              <term>The Nitrogen rule of MolecularFormula</term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:NCDK.Formula.Rules.NitrogenRule.#ctor">
            <summary>
            Constructor for the NitrogenRule object.
            </summary>
        </member>
        <member name="P:NCDK.Formula.Rules.NitrogenRule.Parameters">
            <summary>
            The parameters attribute of the NitrogenRule object.
            </summary>
        </member>
        <member name="M:NCDK.Formula.Rules.NitrogenRule.Validate(NCDK.IMolecularFormula)">
            <summary>
            Validate the nitrogen rule of this IMolecularFormula.
            </summary>
            <param name="formula">Parameter is the IMolecularFormula</param>
            <returns>A double value meaning 1.0 True, 0.0 False</returns>
        </member>
        <member name="M:NCDK.Formula.Rules.NitrogenRule.GetOthers(NCDK.IMolecularFormula)">
            <summary>
            Get the number of other elements which affect to the calculation of the nominal mass.
            For example Fe, Co, Hg, Pt, As.
            </summary>
            <param name="formula">The IMolecularFormula to analyze</param>
            <returns>Number of elements</returns>
        </member>
        <member name="M:NCDK.Formula.Rules.NitrogenRule.IsOdd(System.Double)">
            <summary>
            Determine if a integer is odd.
            </summary>
            <param name="value">The value to analyze</param>
            <returns>True, if the integer is odd</returns>
        </member>
        <member name="T:NCDK.Formula.Rules.RDBERule">
            <summary>
            <para>Ring Double Bond Equivalents (RDBE) or
            Double Bond Equivalents (DBE) are calculated from valence values of
            elements contained in a formula and should tell the number of bonds - or rings.
            Since this formula will fail for MFs with higher valence states such as
            N(V), P(V), S(IV) or S(VI), this method will focus on the lowest valence state for these elements.</para>
            <para>The equation used is: D = 1 + [0.5 SUM_i(N_i(V_I-2))]</para>
            <para>where D is the unsaturation, i is the total number of different elements in the composition, N_i the number
            of atoms of element i, and Vi is the common valence of the atom i.</para>
            </summary>
            <remarks>
            Table 1: Parameters set by this rule.
            <list type="table">
            <item>
              <term>Name</term>
              <term>Default</term>
              <term>Description</term>
            </item>
            <item>
              <term>charge</term>
              <term>0.0</term>
              <term>The RDBE rule of MolecularFormula</term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:NCDK.Formula.Rules.RDBERule.#ctor">
            <summary>
            Constructor for the RDBE object.
            </summary>
        </member>
        <member name="P:NCDK.Formula.Rules.RDBERule.Parameters">
            <summary>
            The parameters attribute of the <see cref="T:NCDK.Formula.Rules.RDBERule"/> object.
            </summary>
        </member>
        <member name="M:NCDK.Formula.Rules.RDBERule.Validate(NCDK.IMolecularFormula)">
            <summary>
            Validate the RDBRule of this IMolecularFormula.
            </summary>
            <param name="formula">Parameter is the IMolecularFormula</param>
            <returns>A double value meaning 1.0 True, 0.0 False</returns>
        </member>
        <member name="M:NCDK.Formula.Rules.RDBERule.Validate(NCDK.IMolecularFormula,System.Double)">
            <summary>
            Validate the ion state. It takes into account that neutral, nonradical compounds
            always have an even-numbered pair-wiser arrangement of binding electrons signilizaded
            by an integer DBE value. Charged compounds due to soft ionzation techniques
            will give an odd number of binding electrons and a fractional DBE (X.05).
            </summary>
            <param name="formula">Parameter is the IMolecularFormula</param>
            <param name="value">The RDBE value</param>
            <returns>True, if corresponds with</returns>
        </member>
        <member name="M:NCDK.Formula.Rules.RDBERule.GetRDBEValue(NCDK.IMolecularFormula)">
            <summary>
            Method to extract the Ring Double Bond Equivalents (RDB) value. It test all possible
            oxidation states.
            </summary>
            <param name="formula">The IMolecularFormula object</param>
            <returns>The RDBE value</returns>
            <seealso cref="M:NCDK.Formula.Rules.RDBERule.CreateTable"/>
        </member>
        <member name="M:NCDK.Formula.Rules.RDBERule.GetOxidationState(NCDK.IAtom)">
            <summary>
            Get the common oxidation state given a atom.
            </summary>
            <param name="newAtom">The IAtom</param>
            <returns>The oxidation state value</returns>
        </member>
        <member name="M:NCDK.Formula.Rules.RDBERule.CreateTable">
            <summary>
            Create the table with the common oxidation states
            </summary>
        </member>
        <member name="M:NCDK.Formula.Rules.RDBERule.Combinations.#ctor(System.Object[],System.Int32)">
            <summary>
            Create a Combination to enumerate through all subsets of the
            supplied Object array, selecting m at a time.
            </summary>
            <param name="inArray">the group to choose from</param>
            <param name="m">int the number to select in each choice</param>
        </member>
        <member name="M:NCDK.Formula.Rules.RDBERule.Combinations.HasMoreElements">
            <summary>
            </summary>
            <returns>true, unless we have already returned the last combination.</returns>
        </member>
        <member name="M:NCDK.Formula.Rules.RDBERule.Combinations.MoveIndex">
            <summary>
            Move the index forward a notch. The algorithm finds the rightmost
            index element that can be incremented, increments it, and then
            changes the elements to the right to each be 1 plus the element on their left.
            <para>
            For example, if an index of 5 things taken 3 at a time is at {0 3 4}, only the 0 can
            be incremented without running out of room. The next index is {1, 1+1, 1+2) or
            {1, 2, 3}. This will be followed by {1, 2, 4}, {1, 3, 4}, and {2, 3, 4}.
            </para>
            <para>
            The algorithm is from Applied Combinatorics, by Alan Tucker.
            </para>
            </summary>
        </member>
        <member name="M:NCDK.Formula.Rules.RDBERule.Combinations.NextElement">
            <summary>
            Actually, an array of Objects is returned. The declaration must say just Object,
            because the Combinations class implements Enumeration, which declares that the
            NextElement() returns a plain Object. Users must cast the returned object to (Object[]).
            </summary>
            <returns><see cref="T:System.Object"/>, the next combination from the supplied Object array.</returns>
        </member>
        <member name="M:NCDK.Formula.Rules.RDBERule.Combinations.RightmostIndexBelowMax">
            <summary>
            </summary>
            <returns>int, the index which can be bumped up.</returns>
        </member>
        <member name="T:NCDK.Formula.Rules.ToleranceRangeRule">
            <summary>
            This class validate if the mass from an IMolecularFormula is
            between the tolerance range give a experimental mass. As default
            the mass to range is 0.0.
            </summary>
            <remarks>
            Table 1: Parameters set by this rule.
            <list type="table">
            <item>
              <term>Name</term>
              <term>Default</term>
              <term>Description</term>
            </item>
            <item>
              <term>mass</term>
              <term>0.0</term>
              <term>The Mass which the MolecularFormula has to be compared</term>
            </item>
            <item>
              <term>tolerance</term>
              <term>0.05</term>
              <term>The range tolerance</term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:NCDK.Formula.Rules.ToleranceRangeRule.#ctor">
            <summary>
            Constructor for the ToleranceRangeRule object.
            </summary>
        </member>
        <member name="P:NCDK.Formula.Rules.ToleranceRangeRule.Parameters">
            <summary>
            The parameters attribute of the ToleranceRangeRule object.
            </summary>
        </member>
        <member name="M:NCDK.Formula.Rules.ToleranceRangeRule.Validate(NCDK.IMolecularFormula)">
            <summary>
            Validate the Tolerance Range of this IMolecularFormula.
            </summary>
            <param name="formula">Parameter is the IMolecularFormula</param>
            <returns>A double value meaning 1.0 True, 0.0 False</returns>
        </member>
        <member name="F:NCDK.Graphs.InChI.JniInChIInputAdapter.IS_WINDOWS">
            <summary>
            Flag indicating windows or linux.
            </summary>
        </member>
        <member name="F:NCDK.Graphs.InChI.JniInChIInputAdapter.FLAG_CHAR">
            <summary>
            Switch character for passing options. / in windows, - on other systems.
            </summary>
        </member>
        <member name="T:NCDK.Graphs.InChI.InChIGenerator">
            <summary>
            This class generates the IUPAC International Chemical Identifier (InChI) for
            a CDK IAtomContainer. It places calls to a JNI wrapper for the InChI C++ library.
            </summary>
            <remarks><para>If the atom container has 3D coordinates for all of its atoms then they
            will be used, otherwise 2D coordinates will be used if available.</para>
            <para>Spin multiplicities and some aspects of stereochemistry are not
            currently handled completely.</para>
            </remarks>
            <example>
            <code>            // Generate factory -  if native code does not load
            InChIGeneratorFactory factory = new InChIGeneratorFactory();
            // Get InChIGenerator
            InChIGenerator gen = factory.GetInChIGenerator(container);

            INCHI_RET ret = gen.ReturnStatus;
            if (ret == INCHI_RET.WARNING)
            {
                // InChI generated, but with warning message
                Console.WriteLine($"InChI warning: {gen.Message}");
            }
            else if (ret != INCHI_RET.OKAY)
            {
                // InChI generation failed
                throw new CDKException($"InChI failed: {ret.ToString()} [{gen.Message}]");
            }

            string inchi = gen.InChI;
            string auxinfo = gen.AuxInfo;
</code>
            </example>
            TODO: distinguish between singlet and undefined spin multiplicity<br />
            TODO: double bond and allene parities<br />
            TODO: problem recognising bond stereochemistry<br />
        </member>
        <member name="F:NCDK.Graphs.InChI.InChIGenerator.ReferringAtomContainer">
            <summary>
            AtomContainer instance refers to.
            </summary>
        </member>
        <member name="M:NCDK.Graphs.InChI.InChIGenerator.#ctor(NCDK.IAtomContainer,System.Boolean)">
            <summary>
            Constructor. Generates InChI from CDK AtomContainer.
            <para>Reads atoms, bonds etc from atom container and converts to format
            InChI library requires, then calls the library.</para>
            </summary>
            <param name="atomContainer">AtomContainer to generate InChI for.</param>
            <param name="ignoreAromaticBonds">if aromatic bonds should be treated as bonds of type single and double</param>
            <exception cref="T:NCDK.CDKException">if there is an error during InChI generation</exception>
        </member>
        <member name="M:NCDK.Graphs.InChI.InChIGenerator.#ctor(NCDK.IAtomContainer,System.String,System.Boolean)">
            <summary>
            Constructor. Generates InChI from CDK AtomContainer.
            <para>Reads atoms, bonds etc from atom container and converts to format
            InChI library requires, then calls the library.</para>
            </summary>
            <param name="atomContainer">AtomContainer to generate InChI for.</param>
            <param name="options">Space delimited string of options to pass to InChI library.
                Each option may optionally be preceded by a command line switch (/ or -).</param>
            <param name="ignoreAromaticBonds">if aromatic bonds should be treated as bonds of type single and double</param>
        </member>
        <member name="M:NCDK.Graphs.InChI.InChIGenerator.#ctor(NCDK.IAtomContainer,System.Collections.Generic.IEnumerable{NCDK.NInChI.INCHI_OPTION},System.Boolean)">
            <summary>
            Constructor. Generates InChI from CDK AtomContainer.
            <para>Reads atoms, bonds etc from atom container and converts to format
            InChI library requires, then calls the library.</para>
            </summary>
            <param name="atomContainer">AtomContainer to generate InChI for.</param>
            <param name="options">List of INCHI_OPTION.</param>
            <param name="ignoreAromaticBonds">if aromatic bonds should be treated as bonds of type single and double</param>
        </member>
        <member name="M:NCDK.Graphs.InChI.InChIGenerator.GenerateInChIFromCDKAtomContainer(NCDK.IAtomContainer,System.Boolean)">
            <summary>
            Reads atoms, bonds etc from atom container and converts to format
            InChI library requires, then places call for the library to generate
            the InChI.
            </summary>
            <param name="atomContainer">AtomContainer to generate InChI for.</param>
            <param name="ignore"></param>
        </member>
        <member name="P:NCDK.Graphs.InChI.InChIGenerator.ReturnStatus">
            <summary>
            Gets return status from InChI process. <see cref="F:NCDK.NInChI.INCHI_RET.OKAY"/> and <see cref="F:NCDK.NInChI.INCHI_RET.WARNING"/> indicate
            InChI has been generated, in all other cases InChI generation
            has failed.
            </summary>
        </member>
        <member name="P:NCDK.Graphs.InChI.InChIGenerator.InChI">
            <summary>
            Gets generated InChI string.
            </summary>
        </member>
        <member name="M:NCDK.Graphs.InChI.InChIGenerator.GetInChIKey">
            <summary>
            Gets generated InChIKey string.
            </summary>
        </member>
        <member name="P:NCDK.Graphs.InChI.InChIGenerator.AuxInfo">
            <summary>
            Gets auxillary information.
            </summary>
        </member>
        <member name="P:NCDK.Graphs.InChI.InChIGenerator.Message">
            <summary>
            Gets generated (error/warning) messages.
            </summary>
        </member>
        <member name="P:NCDK.Graphs.InChI.InChIGenerator.Log">
            <summary>
            Gets generated log.
            </summary>
        </member>
        <member name="T:NCDK.Graphs.InChI.InChIGeneratorFactory">
            <summary>
            Factory providing access to <see cref="T:NCDK.Graphs.InChI.InChIGenerator"/> and <see cref="T:NCDK.Graphs.InChI.InChIToStructure"/>.
            See those classes for examples of use. These methods make use of the
            JNI-InChI library.
            </summary>
            <example>
            The <see cref="T:NCDK.Graphs.InChI.InChIGeneratorFactory"/> is a singleton class, which means that there
            exists only one instance of the class. An instance of this class is obtained
            with:
            <code>
            InChIGeneratorFactory factory = InChIGeneratorFactory.Instance;
            </code>
            </example>
            <remarks>
            InChI/Structure interconversion is implemented in this way so that we can
            check whether or not the native code required is available. If the native
            code cannot be loaded during the first call to <see cref="P:NCDK.Graphs.InChI.InChIGeneratorFactory.Instance"/>
            method (when the instance is created) a <see cref="T:NCDK.CDKException"/> will be thrown. The
            most common problem is that the native code is not in the * the correct
            location. Java searches the locations in the PATH environmental
            variable, under Windows, and LD_LIBRARY_PATH under Linux, so the JNI-InChI
            native libraries must be in one of these locations. If the JNI-InChI jar file
            is being used and either the current working directory, or '.' are contained
            in PATH of LD_LIBRARY_PATH then the native code should be placed
            automatically. If the native files are in the correct location but fail to
            load, then they may need to be recompiled for your system. See:
            <list type="bullet">
            <item>http://sourceforge.net/projects/jni-inchi</item>
            <item>http://www.iupac.org/inchi/</item>
            </list>
            </remarks>
        </member>
        <member name="P:NCDK.Graphs.InChI.InChIGeneratorFactory.Instance">
            <summary>
            Gives the one <see cref="T:NCDK.Graphs.InChI.InChIGeneratorFactory"/> instance, 
            if needed also creates it.
            </summary>
        </member>
        <member name="P:NCDK.Graphs.InChI.InChIGeneratorFactory.IgnoreAromaticBonds">
            <summary>
            If the CDK aromaticity flag should be ignored and the bonds treated solely as single and double bonds.
            </summary>
            <remarks>
            Sets whether aromatic bonds should be treated as single and double bonds for the InChI generation.The bond type
            INCHI_BOND_TYPE.Altern is considered special in contrast to single, double, and triple bonds,
            and is not bulletproof. If the molecule has clearly defined single and double bonds,
            the option can be used to force the class not to use the alternating bond type.
            http://www.inchi-trust.org/fileadmin/user_upload/html/inchifaq/inchi-faq.html#16.3
            </remarks>
        </member>
        <member name="M:NCDK.Graphs.InChI.InChIGeneratorFactory.GetInChIGenerator(NCDK.IAtomContainer)">
            <summary>
            Gets an Standard InChI generator for a <see cref="T:NCDK.IAtomContainer"/>. AuxInfo is not
            generated by this method, please use <see cref="M:NCDK.Graphs.InChI.InChIGeneratorFactory.GetInChIGenerator(NCDK.IAtomContainer,System.Collections.Generic.IList{NCDK.NInChI.INCHI_OPTION})"/>
            with no options specified if you would like to generate AuxInfo.
            </summary>
            <param name="container">AtomContainer to generate InChI for.</param>
            <returns>the InChI generator object</returns>
            <exception cref="T:NCDK.CDKException">if the generator cannot be instantiated</exception>
        </member>
        <member name="M:NCDK.Graphs.InChI.InChIGeneratorFactory.GetInChIGenerator(NCDK.IAtomContainer,System.String)">
            <summary>
            Gets InChI generator for CDK IAtomContainer.
            </summary>
            <param name="container">AtomContainer to generate InChI for.</param>
            <param name="options">string of options for InChI generation.</param>
            <returns>the InChI generator object</returns>
            <exception cref="T:NCDK.CDKException">if the generator cannot be instantiated</exception>
        </member>
        <member name="M:NCDK.Graphs.InChI.InChIGeneratorFactory.GetInChIGenerator(NCDK.IAtomContainer,System.Collections.Generic.IList{NCDK.NInChI.INCHI_OPTION})">
            <summary>
            Gets InChI generator for CDK IAtomContainer.
            </summary>
            <param name="container">AtomContainer to generate InChI for.</param>
            <param name="options">List of options (net.sf.jniinchi.INCHI_OPTION) for InChI generation.</param>
            <returns>the InChI generator object</returns>
            <exception cref="T:NCDK.CDKException">if the generator cannot be instantiated</exception>
        </member>
        <member name="M:NCDK.Graphs.InChI.InChIGeneratorFactory.GetInChIToStructure(System.String,NCDK.IChemObjectBuilder)">
            <summary>
            Gets structure generator for an InChI string.
            </summary>
            <param name="inchi">InChI to generate structure from.</param>
            <param name="builder">the builder to use</param>
            <returns>the InChI structure generator object</returns>
            <exception cref="T:NCDK.CDKException">if the generator cannot be instantiated</exception>
        </member>
        <member name="M:NCDK.Graphs.InChI.InChIGeneratorFactory.GetInChIToStructure(System.String,NCDK.IChemObjectBuilder,System.String)">
            <summary>
            Gets structure generator for an InChI string.
            </summary>
            <param name="inchi">InChI to generate structure from.</param>
            <param name="builder">the builder to employ</param>
            <param name="options">string of options for structure generation.</param>
            <returns>the InChI structure generator object</returns>
            <exception cref="T:NCDK.CDKException">if the generator cannot be instantiated</exception>
        </member>
        <member name="M:NCDK.Graphs.InChI.InChIGeneratorFactory.GetInChIToStructure(System.String,NCDK.IChemObjectBuilder,System.Collections.Generic.IList{System.String})">
            <summary>
            Gets structure generator for an InChI string.
            </summary>
            <param name="inchi">InChI to generate structure from.</param>
            <param name="options">List of options (net.sf.jniinchi.INCHI_OPTION) for structure generation.</param>
            <param name="builder">the builder to employ</param>
            <returns>the InChI structure generator object</returns>
            <exception cref="T:NCDK.CDKException">if the generator cannot be instantiated</exception>
        </member>
        <member name="T:NCDK.Graphs.InChI.InChIToStructure">
            <summary>
            This class generates a CDK IAtomContainer from an InChI string.  It places
            calls to a JNI wrapper for the InChI C++ library.
            <para>
            The generated IAtomContainer will have all 2D and 3D coordinates set to 0.0,
            but may have atom parities set.  Double bond and allene stereochemistry are
            not currently recorded.
            </para>
            </summary>
            <example>
            <code>            // Generate factory -  if native code does not load
             InChIGeneratorFactory factory = new InChIGeneratorFactory();
             // Get InChIToStructure
             InChIToStructure intostruct = factory.GetInChIToStructure(inchi, Default.ChemObjectBuilder.Instance);
             
             INCHI_RET ret = intostruct.ReturnStatus;
            if (ret == INCHI_RET.WARNING)
            {
                // Structure generated, but with warning message
                Console.WriteLine($"InChI warning: {intostruct.Message}");
            }
            else if (ret != INCHI_RET.OKAY)
            {
                // Structure generation failed
                throw new CDKException($"Structure generation failed failed: {ret.ToString()} [{intostruct.Message}]");
            }             
             IAtomContainer container = intostruct.AtomContainer;
</code>
            </example>
        </member>
        <member name="M:NCDK.Graphs.InChI.InChIToStructure.#ctor(System.String,NCDK.IChemObjectBuilder)">
            <summary>
            Constructor. Generates CDK AtomContainer from InChI.
            </summary>
            <param name="inchi"></param>
            <param name="builder"></param>
        </member>
        <member name="M:NCDK.Graphs.InChI.InChIToStructure.#ctor(System.String,NCDK.IChemObjectBuilder,System.String)">
            <summary>
            Constructor. Generates CMLMolecule from InChI.
            </summary>
            <param name="inchi"></param>
            <param name="builder"></param>
            <param name="options"></param>
        </member>
        <member name="M:NCDK.Graphs.InChI.InChIToStructure.#ctor(System.String,NCDK.IChemObjectBuilder,System.Collections.Generic.IList{System.String})">
            <summary>
            Constructor. Generates CMLMolecule from InChI.
            </summary>
            <param name="inchi"></param>
            <param name="builder"></param>
            <param name="options"></param>
        </member>
        <member name="M:NCDK.Graphs.InChI.InChIToStructure.GenerateAtomContainerFromInChI(NCDK.IChemObjectBuilder)">
            <summary>
            Gets structure from InChI, and converts InChI library data structure into an IAtomContainer.
            </summary>
            <param name="builder"></param>
        </member>
        <member name="M:NCDK.Graphs.InChI.InChIToStructure.FindOtherSinglyBonded(NCDK.IAtomContainer,NCDK.IAtom,NCDK.IAtom)">
            <summary>
            Finds a neighbor attached to 'atom' that is singley bonded and isn't 'exclude'. If no such atom exists, the 'atom' is returned.
            </summary>
            <param name="container">a molecule container</param>
            <param name="atom">the atom to find the neighbor or</param>
            <param name="exclude">don't find this atom</param>
            <returns>the other atom (or 'atom')</returns>
        </member>
        <member name="P:NCDK.Graphs.InChI.InChIToStructure.AtomContainer">
            <summary>
            Generated molecule.
            </summary>
        </member>
        <member name="P:NCDK.Graphs.InChI.InChIToStructure.ReturnStatus">
            <summary>
            Return status from InChI process.  OKAY and WARNING indicate
            InChI has been generated, in all other cases InChI generation has failed.
            </summary>
        </member>
        <member name="P:NCDK.Graphs.InChI.InChIToStructure.Message">
            <summary>
            Generated (error/warning) messages.
            </summary>
        </member>
        <member name="P:NCDK.Graphs.InChI.InChIToStructure.Log">
            <summary>
            Generated log.
            </summary>
        </member>
        <member name="P:NCDK.Graphs.InChI.InChIToStructure.WarningFlags">
            <summary>
            Returns warning flags, see INCHIDIFF in inchicmp.h.
            
            [x][y]:
            <list type="bullet">
            <item>x=0 =&gt; Reconnected if present in InChI otherwise Disconnected/Normal</item>
            <item>x=1 =&gt; Disconnected layer if Reconnected layer is present</item>
            <item>y=1 =&gt; Main layer or Mobile-H</item>
            <item>y=0 =&gt; Fixed-H layer</item>
            </list>
            </summary>
        </member>
        <member name="T:NCDK.Graphs.Invariant.EquivalentClassPartitioner">
            <summary>
            An algorithm for topological symmetry. This algorithm derived from the
            algorithm <token>cdk-cite-Hu94</token>.
            </summary>
        </member>
        <member name="M:NCDK.Graphs.Invariant.EquivalentClassPartitioner.#ctor">
            <summary>
            Constructor for the TopologicalEquivalentClass object.
            </summary>
        </member>
        <member name="M:NCDK.Graphs.Invariant.EquivalentClassPartitioner.#ctor(NCDK.IAtomContainer)">
            <summary>
            Constructor for the TopologicalEquivalentClass object.
            </summary>
        </member>
        <member name="M:NCDK.Graphs.Invariant.EquivalentClassPartitioner.GetTopoEquivClassbyHuXu(NCDK.IAtomContainer)">
            <summary>
            Get the topological equivalent class of the molecule.
            </summary>
            <param name="atomContainer">atoms and bonds of the molecule</param>
            <returns>an array contains the automorphism partition of the molecule</returns>
        </member>
        <member name="M:NCDK.Graphs.Invariant.EquivalentClassPartitioner.PrepareNode(NCDK.IAtomContainer)">
            <summary>
            Prepare the node identifier. The purpose of this is to increase the
            differentiation of the nodes. Detailed information please see the
            corresponding literature.
            </summary>
            <param name="atomContainer">atoms and bonds of the molecule</param>
            <returns>an array of node identifier</returns>
        </member>
        <member name="M:NCDK.Graphs.Invariant.EquivalentClassPartitioner.BuildNodeMatrix(System.Double[])">
            <summary>
            Build node Matrix.
            </summary>
            <param name="nodeSequence">an array contains node number for each atom</param>
            <returns>node Matrix</returns>
        </member>
        <member name="M:NCDK.Graphs.Invariant.EquivalentClassPartitioner.BuildTrialNodeMatrix(System.Double[])">
            <summary>
            Build trial node Matrix.
            </summary>
            <param name="weight">an array contains the weight of atom</param>
            <returns>trial node matrix.</returns>
        </member>
        <member name="M:NCDK.Graphs.Invariant.EquivalentClassPartitioner.BuildBondMatrix">
            <summary>
            Build bond matrix.
            </summary>
            <returns>bond matrix.</returns>
        </member>
        <member name="M:NCDK.Graphs.Invariant.EquivalentClassPartitioner.BuildWeightMatrix(System.Double[][],System.Double[][])">
            <summary>
            Build weight array for the given node matrix and bond matrix.
            </summary>
            <param name="nodeMatrix">array contains node information</param>
            <param name="bondMatrix">array contains bond information</param>
            <returns>weight array for the node</returns>
        </member>
        <member name="M:NCDK.Graphs.Invariant.EquivalentClassPartitioner.CheckDiffNumber(System.Double[])">
            <summary>
            Get different number of the given number.
            </summary>
            <param name="weight">array contains weight of the nodes</param>
            <returns>number of different weight</returns>
        </member>
        <member name="M:NCDK.Graphs.Invariant.EquivalentClassPartitioner.GetEquivalentClass(System.Double[])">
            <summary>
            Get the final equivalent class.
            </summary>
            <param name="weight">array contains weight of the nodes</param>
            <returns>an array contains the automorphism partition</returns>
        </member>
        <member name="M:NCDK.Graphs.Invariant.EquivalentClassPartitioner.FindTopoEquivClass(System.Double[])">
            <summary>
            Find the topological equivalent class for the given weight.
            </summary>
            <param name="weight">array contains weight of the nodes</param>
            <returns>an array contains the automorphism partition</returns>
        </member>
        <member name="T:NCDK.Graphs.Invariant.GIMatrix">
            <summary>
            This class is intended to provide the user an efficient way of implementing matrix of double number and
            using normal operations (linear operations, addition, subtraction, multiplication, inversion, concatenation)
            on them. The internal representation of a matrix is an array of array of double objects. For the moment,
            double class is the best way I have developed to perform exact operation on numbers; however, for
            irdoubles, normal operations on float and doubles have to be performed, with the well-known risks of error
            this implies. This class also provides a way of representing matrix as arrays of string for output use.
            <para>
            Please note that although in most books matrix elements' indexes take values between [1..n] I chose not
            to disturb Java language way of calling indexes; so the indexes used here take values between [0..n-1] instead.
            </para>
            </summary>
        </member>
        <member name="M:NCDK.Graphs.Invariant.GIMatrix.#ctor(System.Int32[][])">
            <summary>
            Class constructor. Uses an array of integers to create a new Matrix object. Note that integers
            will be converted to double objects so mathematical operations may be properly performed and
            provide exact solutions. The given array should be properly instantiated as a matrix i.e. it
            must contain a fixed number of lines and columns, otherwise an exception will be thrown.
            Array must be at leat 1x1.
            </summary>
            <param name="array">an array of integer (first index is the line, second is the column)</param>
        </member>
        <member name="M:NCDK.Graphs.Invariant.GIMatrix.#ctor(System.Double[][])">
            <summary>
            Class constructor. Uses an array of doubles to create a new Matrix object. The given array should
            be properly instantiated as a matrix i.e. it must contain a fixed number of lines and columns,
            otherwise an exception will be thrown. Array must be at leat 1x1.
            </summary>
            <param name="array">an array of double objects (first index is the line, second is the column)</param>
            <exception cref="T:NCDK.Graphs.Invariant.BadMatrixFormatException">in case the given array is unproper to construct a matrix</exception>
        </member>
        <member name="M:NCDK.Graphs.Invariant.GIMatrix.#ctor(System.Int32,System.Int32)">
            <summary>
            Class constructor. Creates a new Matrix object with fixed dimensions. The matrix is
            initialised to the "zero" matrix.
            </summary>
            <param name="line">number of lines</param>
            <param name="col">number of columns</param>
        </member>
        <member name="M:NCDK.Graphs.Invariant.GIMatrix.#ctor(NCDK.Graphs.Invariant.GIMatrix)">
            <summary>
            Class constructor. Copies an already existing Matrix object in a new Matrix object.
            </summary>
            <param name="matrix">a Matrix object</param>
        </member>
        <member name="M:NCDK.Graphs.Invariant.GIMatrix.#ctor(NCDK.Graphs.Invariant.GIMatrix[][])">
            <summary>
            Class constructor. Creates a new Matrix object using a table of matrices (an array of Matrix objects).
            The given array should be properly instantiated i.e. it must contain a fixed number of lines and columns,
            otherwise an exception will be thrown.
            </summary>
            <param name="table">an array of matrices</param>
            <exception cref="T:NCDK.Graphs.Invariant.BadMatrixFormatException">if the table is not properly instantiated</exception>
        </member>
        <member name="P:NCDK.Graphs.Invariant.GIMatrix.Height">
            <summary>
            The number of lines of the matrix.
            </summary>
        </member>
        <member name="P:NCDK.Graphs.Invariant.GIMatrix.Width">
            <summary>
            The number of columns of the matrix.
            </summary>
        </member>
        <member name="P:NCDK.Graphs.Invariant.GIMatrix.ArrayValue">
            <summary>
            The internal representation of the matrix, that is an array of double objects.
             (first index is the line, second is the column)
            </summary>
            <exception cref="T:NCDK.Graphs.Invariant.BadMatrixFormatException">in case the given array is unproper to construct a matrix</exception>
        </member>
        <member name="M:NCDK.Graphs.Invariant.GIMatrix.GetValueAt(System.Int32,System.Int32)">
            <summary>
            Returns the value of the given element.
            </summary>
            <param name="i">the line number</param>
            <param name="j">the column number</param>
            <returns>the double at the given index in the Matrix</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">if the given index is out of the matrix's range</exception>
        </member>
        <member name="M:NCDK.Graphs.Invariant.GIMatrix.SetValueAt(System.Int32,System.Int32,System.Double)">
            <summary>
            Sets the value of the element at the given index.
            </summary>
            <param name="i">the line number</param>
            <param name="j">the column number</param>
            <param name="element">the double to place at the given index in the Matrix</param>
            <exception cref="T:System.ArgumentOutOfRangeException">if the given index is out of the matrix's range</exception>
        </member>
        <member name="M:NCDK.Graphs.Invariant.GIMatrix.GetLine(System.Int32)">
            <summary>
            Returns the line-matrix at the given line index.
            </summary>
            <param name="i">the line number</param>
            <returns>the specified line as a Matrix object</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">if the given index is out of the matrix's range</exception>
        </member>
        <member name="M:NCDK.Graphs.Invariant.GIMatrix.GetColumn(System.Int32)">
            <summary>
            Returns the column-matrix at the given line index.
            </summary>
            <param name="j">the column number</param>
            <returns>the specified column as a Matrix object</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">if the given index is out of the matrix's range</exception>
        </member>
        <member name="M:NCDK.Graphs.Invariant.GIMatrix.SetLine(System.Int32,NCDK.Graphs.Invariant.GIMatrix)">
            <summary>
            Sets the line of the matrix at the specified index to a new value.
            </summary>
            <param name="i">the line number</param>
            <param name="line">the line to be placed at the specified index</param>
            <exception cref="T:System.ArgumentOutOfRangeException">if the given index is out of the matrix's range</exception>
            <exception cref="T:NCDK.Graphs.Invariant.BadMatrixFormatException">in case the given Matrix is unproper to replace a line of this Matrix</exception>
        </member>
        <member name="M:NCDK.Graphs.Invariant.GIMatrix.SetColumn(System.Int32,NCDK.Graphs.Invariant.GIMatrix)">
            <summary>
            Sets the column of the matrix at the specified index to a new value.
            </summary>
            <param name="j">the column number</param>
            <param name="column">the column to be placed at the specified index</param>
            <exception cref="T:System.ArgumentOutOfRangeException">if the given index is out of the matrix's range</exception>
            <exception cref="T:NCDK.Graphs.Invariant.BadMatrixFormatException">in case the given Matrix is unproper to replace a column of this Matrix</exception>
        </member>
        <member name="M:NCDK.Graphs.Invariant.GIMatrix.CreateIdentity(System.Int32)">
            <summary>
            Returns the identity matrix.
            </summary>
            <param name="n">the matrix's dimension (identity matrix is a square matrix)</param>
            <returns>the identity matrix of format nxn</returns>
        </member>
        <member name="M:NCDK.Graphs.Invariant.GIMatrix.CreateZero(System.Int32,System.Int32)">
            <summary>
            Returns a null matrix (with zeros everywhere) of given dimensions.
            </summary>
            <param name="m">number of lines</param>
            <param name="n">number of columns</param>
            <returns>the zero (null) matrix of format mxn</returns>
        </member>
        <member name="M:NCDK.Graphs.Invariant.GIMatrix.Equals(NCDK.Graphs.Invariant.GIMatrix)">
            <summary>
            Verifies if two given matrix are equal or not. The matrix must be of the same size and dimensions,
            otherwise an exception will be thrown.
            </summary>
            <param name="matrix">the Matrix object to be compared to</param>
            <returns>true if both matrix are equal element to element</returns>
            <exception cref="T:NCDK.Graphs.Invariant.BadMatrixFormatException">if the given matrix doesn't have the same dimensions as this one</exception>
        </member>
        <member name="M:NCDK.Graphs.Invariant.GIMatrix.IsSquare">
            <summary>
            Verifies if the matrix is square, that is if it has an equal number of lines and columns.
            </summary>
            <returns>true if this matrix is square</returns>
        </member>
        <member name="M:NCDK.Graphs.Invariant.GIMatrix.IsSymmetric">
            <summary>
            Verifies if the matrix is symmetric, that is if the matrix is equal to it's transpose.
            </summary>
            <returns>true if the matrix is symmetric</returns>
            <exception cref="T:NCDK.Graphs.Invariant.BadMatrixFormatException">if the matrix is not square</exception>
        </member>
        <member name="M:NCDK.Graphs.Invariant.GIMatrix.IsAntisymmetric">
            <summary>
            Verifies if the matrix is antisymmetric, that is if the matrix is equal to the opposite of
            it's transpose.
            </summary>
            <returns>true if the matrix is antisymmetric</returns>
            <exception cref="T:NCDK.Graphs.Invariant.BadMatrixFormatException">if the matrix is not square</exception>
        </member>
        <member name="M:NCDK.Graphs.Invariant.GIMatrix.IsTriangularSuperior">
            <summary>
            Verifies if the matrix is triangular superior or not. A triangular superior matrix has
            zero (0) values everywhere under it's diagonal.
            </summary>
            <returns>true if the matrix is triangular superior</returns>
            <exception cref="T:NCDK.Graphs.Invariant.BadMatrixFormatException">if the matrix is not square</exception>
        </member>
        <member name="M:NCDK.Graphs.Invariant.GIMatrix.IsTriangularInferior">
            <summary>
            Verifies if the matrix is triangular inferior or not. A triangular inferior matrix has
            zero (0) values everywhere upper it's diagonal.
            </summary>
            <returns>true if the matrix is triangular inferior</returns>
            <exception cref="T:NCDK.Graphs.Invariant.BadMatrixFormatException">if the matrix is not square</exception>
        </member>
        <member name="M:NCDK.Graphs.Invariant.GIMatrix.IsDiagonal">
            <summary>
            Verifies whether or not the matrix is diagonal. A diagonal matrix only has elements on its diagonal
            and zeros (0) at every other index. The matrix must be square.
            </summary>
            <returns>true if the matrix is diagonal</returns>
            <exception cref="T:NCDK.Graphs.Invariant.BadMatrixFormatException">if the matrix is not square</exception>
        </member>
        <member name="M:NCDK.Graphs.Invariant.GIMatrix.IsInvertible">
            <summary>
            Verifies if the matrix is invertible or not by asking for its determinant.
            </summary>
            <returns>true if the matrix is invertible</returns>
            <exception cref="T:NCDK.Graphs.Invariant.BadMatrixFormatException">if the matrix is not square</exception>
        </member>
        <member name="M:NCDK.Graphs.Invariant.GIMatrix.Inverse">
            <summary>
            Returns the transpose of this matrix. The transpose of a matrix A = {a(i,j)} is the matrix B = {b(i,j)}
            such that b(i,j) = a(j,i) for every i,j i.e. it is the symmetrical reflection of the matrix along its
            diagonal. The matrix must be square to use this method, otherwise an exception will be thrown.
            </summary>
            <returns>the matrix's transpose as a Matrix object</returns>
        </member>
        <member name="M:NCDK.Graphs.Invariant.GIMatrix.GaussJordan">
            <summary>
            Gauss-Jordan algorithm. Returns the reduced-echeloned matrix of this matrix. The
            algorithm has not yet been optimised but since it is quite simple, it should not be
            a serious problem.
            </summary>
            <returns>the reduced matrix</returns>
        </member>
        <member name="M:NCDK.Graphs.Invariant.GIMatrix.Transpose">
            <summary>
            Returns the transpose of this matrix. The transpose of a matrix A = {a(i,j)} is the matrix B = {b(i,j)}
            such that b(i,j) = a(j,i) for every i,j i.e. it is the symmetrical reflection of the matrix along its
            diagonal. The matrix must be square to use this method, otherwise an exception will be thrown.
            </summary>
            <returns>the matrix's transpose as a Matrix object</returns>
            <exception cref="T:NCDK.Graphs.Invariant.BadMatrixFormatException">if the matrix is not square</exception>
        </member>
        <member name="M:NCDK.Graphs.Invariant.GIMatrix.Diagonal">
            <summary>
            Returns a matrix containing all of the diagonal elements of this matrix and zero (0) everywhere
            else. This matrix is called the diagonal of the matrix.
            </summary>
            <returns>the diagonal of the matrix</returns>
            <exception cref="T:NCDK.Graphs.Invariant.BadMatrixFormatException">if the matrix is not square</exception>
        </member>
        <member name="M:NCDK.Graphs.Invariant.GIMatrix.MultiplyLine(System.Int32,System.Double)">
            <summary>
            Returns the resulting matrix of an elementary linear operation that consists of multiplying a
            single line of the matrix by a constant.
            </summary>
            <param name="i">the line number</param>
            <param name="c">the double constant that multiplies the line</param>
            <returns>the resulting Matrix object of the linear operation</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">if the given index is out of the matrix's range</exception>
        </member>
        <member name="M:NCDK.Graphs.Invariant.GIMatrix.InvertLine(System.Int32,System.Int32)">
            <summary>
            Returns the resulting matrix of an elementary linear operation that consists of inverting two lines.
            </summary>
            <param name="i">the first line number</param>
            <param name="j">the second line number</param>
            <returns>the resulting Matrix object of the linear operation</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">if the given index is out of the matrix's range</exception>
        </member>
        <member name="M:NCDK.Graphs.Invariant.GIMatrix.AddLine(System.Int32,System.Int32,System.Double)">
            <summary>
            Returns the resulting matrix of an elementary linear operation that consists of adding one line,
            multiplied by some constant factor, to another line.
            </summary>
            <param name="i">the first line number</param>
            <param name="j">the second line number (to be added to the first)</param>
            <param name="c">the double constant that multiplies the first line</param>
            <returns>the resulting Matrix object of the linear operation</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">if the given index is out of the matrix's range</exception>
        </member>
        <member name="M:NCDK.Graphs.Invariant.GIMatrix.Add(NCDK.Graphs.Invariant.GIMatrix)">
            <summary>
             Addition from two matrices.
            </summary>
        </member>
        <member name="M:NCDK.Graphs.Invariant.GIMatrix.Multiply(System.Double)">
            <summary>
            Returns the result of the scalar multiplication of the matrix, that is the multiplication of every
            of its elements by a given number.
            </summary>
            <param name="c">the constant by which the matrix is multiplied</param>
            <returns>the resulting matrix of the scalar multiplication</returns>
        </member>
        <member name="M:NCDK.Graphs.Invariant.GIMatrix.Multiply(NCDK.Graphs.Invariant.GIMatrix)">
            <summary>
            Returns the result of the matrix multiplication of this matrix by another one. The matrix passed
            as parameter <i>follows</i> this matrix in the multiplication, so for an example if the dimension of
            the actual matrix is mxn, the dimension of the second one should be nxp in order for the multiplication
            to be performed (otherwise an exception will be thrown) and the resulting matrix will have dimension mxp.
            </summary>
            <param name="matrix">the matrix following this one in the matrix multiplication</param>
            <returns>the resulting matrix of the matrix multiplication</returns>
            <exception cref="T:NCDK.Graphs.Invariant.BadMatrixFormatException">if the matrix passed in arguments has wrong dimensions</exception>
        </member>
        <member name="M:NCDK.Graphs.Invariant.GIMatrix.Determinant">
            <summary>
            Returns the determinant of this matrix. The matrix must be
            square in order to use this method, otherwise an exception will be thrown.
            <i>Warning: this algorithm is very inefficient and takes too much time to compute
            with large matrices.</i>
            </summary>
            <returns>the determinant of the matrix</returns>
            <exception cref="T:NCDK.Graphs.Invariant.BadMatrixFormatException">if the matrix is not square</exception>
        </member>
        <member name="M:NCDK.Graphs.Invariant.GIMatrix.Trace">
            <summary>
            Returns the trace of this matrix, that is the sum of the elements of its diagonal. The matrix must be
            square in order to use this method, otherwise an exception will be thrown.
            </summary>
            <returns>the trace of the matrix</returns>
            <exception cref="T:NCDK.Graphs.Invariant.BadMatrixFormatException">if the matrix is not square</exception>
        </member>
        <member name="T:NCDK.Graphs.Invariant.HuLuIndexTool">
            <summary>
            Collection of methods for the calculation of topological indices of a
            molecular graph.
            </summary>
        </member>
        <member name="M:NCDK.Graphs.Invariant.HuLuIndexTool.GetEAIDNumber(NCDK.IAtomContainer)">
            <summary>
            Calculates the extended adjacency matrix index.
            An implementation of the algorithm published in <token>cdk-cite-HU96</token>.
            </summary>
        </member>
        <member name="M:NCDK.Graphs.Invariant.HuLuIndexTool.DisplayMatrix(System.Double[][])">
            <summary> Lists a 2D double matrix to the System console. </summary>
        </member>
        <member name="M:NCDK.Graphs.Invariant.HuLuIndexTool.DisplayMatrix(System.Int32[][])">
            <summary> Lists a 2D int matrix to the System console. </summary>
        </member>
        <member name="M:NCDK.Graphs.Invariant.HuLuIndexTool.DisplayArray(System.Int32[])">
            <summary> Lists a 1D array to the System console. </summary>
        </member>
        <member name="M:NCDK.Graphs.Invariant.HuLuIndexTool.DisplayArray(System.Double[])">
            <summary> Lists a 1D array to the System console. </summary>
        </member>
        <member name="T:NCDK.Graphs.Invariant.Canon">
            <summary>
            An implementation based on the canon algorithm <token>cdk-cite-WEI89</token>. The
            algorithm uses an initial set of of invariants which are assigned a rank.
            Equivalent ranks are then shattered using an unambiguous function (in this
            case, the product of primes of adjacent ranks). Once no more equivalent ranks
            can be shattered ties are artificially broken and rank shattering continues.
            Unlike the original description rank stability is not maintained reducing
            the number of values to rank at each stage to only those which are equivalent.
            </summary>
            <remarks>
            The initial set of invariants is basic and are - <i>
            "sufficient for the purpose of obtaining unique notation for simple SMILES,
             but it is not necessarily a ‚Äúcomplete‚Äù set. No ‚Äúperfect‚Äù set of invariants
             is known that will distinguish all possible graph asymmetries. However,
             for any given set of structures, a set of invariants can be devised to
             provide the necessary discrimination"</i> <token>cdk-cite-WEI89</token>. As such this
             producer should not be considered a complete canonical labelled but in
             practice performs well. For a more accurate and computationally expensive
             labelling, please using the <see cref="T:NCDK.Graphs.Invariant.InChINumbersTools" />.
            </remarks>
            <example>
            <code>            IAtomContainer m = TestMoleculeFactory.MakeAlphaPinene();
            int[][] g = GraphUtil.ToAdjList(m);

            // obtain canon labelling
            long[] canon_labels = Canon.Label(m, g);

            // obtain symmetry classes
            long[] symmetry_labels = Canon.Symmetry(m, g);
</code>
            </example>
        </member>
        <member name="F:NCDK.Graphs.Invariant.Canon.g">
            <summary>
            Graph, adjacency list representation.
            </summary>
        </member>
        <member name="F:NCDK.Graphs.Invariant.Canon.labelling">
            <summary>
            Storage of canon labelling and symmetry classes.
            </summary>
        </member>
        <member name="F:NCDK.Graphs.Invariant.Canon.symmetry">
            <summary>
            Storage of canon labelling and symmetry classes.
            </summary>
        </member>
        <member name="F:NCDK.Graphs.Invariant.Canon.symOnly">
            <summary>Only compute the symmetry classes.</summary>
        </member>
        <member name="M:NCDK.Graphs.Invariant.Canon.#ctor(System.Int32[][],System.Int64[],System.Boolean[],System.Boolean)">
            <summary>
            Create a canon labelling for the graph (<paramref name="g"/>) with the specified invariants.
            </summary>
            <param name="g">a graph (adjacency list representation)</param>
            <param name="hydrogens">binary vector of terminal hydrogens</param>
            <param name="partition">an initial partition of the vertices</param>
            <param name="symOnly"></param>
        </member>
        <member name="M:NCDK.Graphs.Invariant.Canon.Label(NCDK.IAtomContainer,System.Int32[][])">
            <summary>
            Compute the canonical labels for the provided structure. The labelling
            does not consider isomer information or stereochemistry. The current
            implementation does not fully distinguish all structure topologies
            but in practise performs well in the majority of cases. A complete
            canonical labelling can be obtained using the <see cref="T:NCDK.Graphs.Invariant.InChINumbersTools"/>
            but is computationally much more expensive.
            </summary>
            <param name="container">structure</param>
            <param name="g">adjacency list graph representation</param>
            <returns>the canonical labelling</returns>
            <seealso cref="T:NCDK.Graphs.Invariant.EquivalentClassPartitioner"/>
            <seealso cref="T:NCDK.Graphs.Invariant.InChINumbersTools"/>
        </member>
        <member name="M:NCDK.Graphs.Invariant.Canon.Label(NCDK.IAtomContainer,System.Int32[][],System.Int64[])">
            <summary>
            Compute the canonical labels for the provided structure. The labelling
            does not consider isomer information or stereochemistry. This method
            allows provision of a custom array of initial invariants.
            </summary>
            <remarks>
            The current
            implementation does not fully distinguish all structure topologies
            but in practise performs well in the majority of cases. A complete
            canonical labelling can be obtained using the <see cref="T:NCDK.Graphs.Invariant.InChINumbersTools"/>
            but is computationally much more expensive.
            </remarks>
            <param name="container">structure</param>
            <param name="g">adjacency list graph representation</param>
            <param name="invariants">initial invariants</param>
            <returns>the canonical labelling</returns>
            <seealso cref="T:NCDK.Graphs.Invariant.EquivalentClassPartitioner"/>
            <seealso cref="T:NCDK.Graphs.Invariant.InChINumbersTools"/>
        </member>
        <member name="M:NCDK.Graphs.Invariant.Canon.Symmetry(NCDK.IAtomContainer,System.Int32[][])">
            <summary>
            Compute the symmetry classes for the provided structure. There are known
            examples where symmetry is incorrectly found. The <see cref="T:NCDK.Graphs.Invariant.EquivalentClassPartitioner"/> 
            gives more accurate symmetry perception but
            this method is very quick and in practise successfully portions the
            majority of chemical structures.
            </summary>
            <param name="container">structure</param>
            <param name="g">adjacency list graph representation</param>
            <returns>symmetry classes</returns>
            <seealso cref="T:NCDK.Graphs.Invariant.EquivalentClassPartitioner"/>
        </member>
        <member name="M:NCDK.Graphs.Invariant.Canon.Refine(System.Int64[],System.Boolean[])">
            <summary>
            Internal - refine invariants to a canonical labelling and symmetry classes.
            </summary>
            <param name="invariants">the invariants to refine (canonical labelling gets written here)</param>
            <param name="hydrogens">binary vector of terminal hydrogens</param>
            <returns>the symmetry classes</returns>
        </member>
        <member name="M:NCDK.Graphs.Invariant.Canon.PrimeProduct(System.Int32[],System.Int64[],System.Boolean[])">
            <summary>
            Compute the prime product of the values (ranks) for the given
            adjacent neighbors (ws).
            </summary>
            <param name="ws">indices (adjacent neighbors)</param>
            <param name="ranks">invariant ranks</param>
            <param name="hydrogens"></param>
            <returns>the prime product</returns>
        </member>
        <member name="M:NCDK.Graphs.Invariant.Canon.BasicInvariants(NCDK.IAtomContainer,System.Int32[][])">
            <summary>
            Generate the initial invariants for each atom in the <paramref name="container"/>.
            The labels use the invariants described in <token>cdk-cite-WEI89</token>. 
            </summary>
            <remarks>
            The bits in the low 32-bits are: <pre>0000000000xxxxXXXXeeeeeeescchhhh</pre>
            where:
            <list type="bullet">
                <item>0: padding</item>
                <item>x: number of connections</item>
                <item>X: number of non-hydrogens bonds</item>
                <item>e: atomic number</item>
                <item>s: sign of charge</item>
                <item>c: absolute charge</item>
                <item>h: number of attached hydrogens</item>
            </list>
            <b>Important: These invariants are <i>basic</i> and there are known
            examples they don't distinguish. One trivial example to consider is
            "[O]C=O" where both oxygens have no hydrogens and a single
            connection but the atoms are not equivalent. Including a better
            initial partition is more expensive</b>
            </remarks>
            <param name="container">an atom container to generate labels for</param>
            <param name="graph">graph representation (adjacency list)</param>
            <returns>initial invariants</returns>
            <exception cref="T:System.NullReferenceException">an atom had unset atomic number, hydrogen count or formal charge</exception>
        </member>
        <member name="M:NCDK.Graphs.Invariant.Canon.GetAtomicNumber(NCDK.IAtom)">
            <summary>
            Access atomic number of atom defaulting to 0 for pseudo atoms.
            </summary>
            <param name="atom">an atom</param>
            <returns>the atomic number</returns>
            <exception cref="T:System.NullReferenceException">the atom was non-pseudo at did not have an atomic number</exception>
        </member>
        <member name="M:NCDK.Graphs.Invariant.Canon.GetImplH(NCDK.IAtom)">
            <summary>
            Access implicit hydrogen count of the atom defaulting to 0 for pseudo atoms.
            </summary>
            <param name="atom">an atom</param>
            <returns>the implicit hydrogen count</returns>
            <exception cref="T:System.NullReferenceException">the atom was non-pseudo at did not have an implicit hydrogen count</exception>
        </member>
        <member name="M:NCDK.Graphs.Invariant.Canon.Charge(NCDK.IAtom)">
            <summary>
            Access formal charge of an atom defaulting to 0 if undefined.
            </summary>
            <param name="atom">an atom</param>
            <returns>the formal charge</returns>
        </member>
        <member name="M:NCDK.Graphs.Invariant.Canon.TerminalHydrogens(NCDK.IAtomContainer,System.Int32[][])">
            <summary>
            Locate explicit hydrogens that are attached to exactly one other atom.
            </summary>
            <param name="ac">a structure</param>
            <param name="g"></param>
            <returns>binary set of terminal hydrogens</returns>
        </member>
        <member name="F:NCDK.Graphs.Invariant.Canon.PRIMES">
            <summary>
            The first 10,000 primes.
            </summary>
        </member>
        <member name="T:NCDK.Graphs.Invariant.CanonicalLabeler">
            <summary>
            Canonically labels an atom container implementing
            the algorithm published in David Weininger et al. <token>cdk-cite-WEI89</token>.
            The Collections.Sort() method uses a merge sort which is
            stable and runs in n Log(n).
            </summary>
        </member>
        <member name="M:NCDK.Graphs.Invariant.CanonicalLabeler.CanonLabel(NCDK.IAtomContainer)">
            <summary>
            Canonically label the fragment.  The labels are set as atom property InvPair.CANONICAL_LABEL of type int, indicating the canonical order.
            This is an implementation of the algorithm published in
            David Weininger et.al. <token>cdk-cite-WEI89</token>.
            <para>The Collections.Sort() method uses a merge sort which is
            stable and runs in n Log(n).
            </para>
            <para>It is assumed that a chemically valid AtomContainer is provided:
            this method does not check
            the correctness of the AtomContainer. Negative H counts will
            cause a FormatException to be thrown.
            </para>
            </summary>
            <param name="atomContainer">The molecule to label</param>
        </member>
        <member name="M:NCDK.Graphs.Invariant.CanonicalLabeler.Step2(System.Collections.Generic.List{NCDK.Smiles.InvPair},NCDK.IAtomContainer)">
            <summary>
            </summary>
            <param name="v">the invariance pair vector</param>
            <param name="atoms"></param>
        </member>
        <member name="M:NCDK.Graphs.Invariant.CanonicalLabeler.Step3(System.Collections.Generic.List{NCDK.Smiles.InvPair},NCDK.IAtomContainer)">
            <summary>
            </summary>
            <param name="v">the invariance pair vector</param>
            <param name="atoms"></param>
        </member>
        <member name="M:NCDK.Graphs.Invariant.CanonicalLabeler.CreateInvarLabel(NCDK.IAtomContainer)">
            <summary>
            Create initial invariant labeling corresponds to step 1
            </summary>
            <returns>List containing the</returns>
        </member>
        <member name="M:NCDK.Graphs.Invariant.CanonicalLabeler.PrimeProduct(System.Collections.Generic.List{NCDK.Smiles.InvPair},NCDK.IAtomContainer)">
            <summary>
            Calculates the product of the neighbouring primes.
            </summary>
            <param name="v">the invariance pair vector</param>
            <param name="atomContainer"></param>
        </member>
        <member name="M:NCDK.Graphs.Invariant.CanonicalLabeler.SortArrayList(System.Collections.Generic.List{NCDK.Smiles.InvPair})">
            <summary>
            Sorts the vector according to the current invariance, corresponds to step 3
            </summary>
            <param name="v">the invariance pair vector</param>
        </member>
        <member name="M:NCDK.Graphs.Invariant.CanonicalLabeler.RankArrayList(System.Collections.Generic.List{NCDK.Smiles.InvPair})">
            <summary>
            Rank atomic vector, corresponds to step 4.
            </summary>
            <param name="v">the invariance pair vector</param>
        </member>
        <member name="M:NCDK.Graphs.Invariant.CanonicalLabeler.IsInvPart(System.Collections.Generic.List{NCDK.Smiles.InvPair})">
            <summary>
            Checks to see if the vector is invariantly partitioned
            </summary>
            <param name="v">the invariance pair vector</param>
            <returns>true if the vector is invariantly partitioned, false otherwise</returns>
        </member>
        <member name="M:NCDK.Graphs.Invariant.CanonicalLabeler.BreakTies(System.Collections.Generic.List{NCDK.Smiles.InvPair})">
            <summary>
            Break ties. Corresponds to step 7
            </summary>
            <param name="v">the invariance pair vector</param>
        </member>
        <member name="M:NCDK.Graphs.Invariant.ConjugatedPiSystemsDetector.Detect(NCDK.IAtomContainer)">
            <summary>
             Detect all conjugated pi systems in an AtomContainer. This method returns a AtomContainerSet
             with Atom and Bond objects from the original AtomContainer. The aromaticity has to be known
             before calling this method.
            </summary>
            <example>
            <!-- No matching elements were found for the following include tag --><include file="IncludeExamples.xml" path="Comments/Codes[@id=&quot;NCDK.Graphs.InChI.ConjugatedPiSystemsDetector_Example.cs+Detect&quot;]/*" />
            </example>
            <param name="ac">The AtomContainer for which to detect conjugated pi systems</param>
            <returns>The set of AtomContainers with conjugated pi systems</returns>
        </member>
        <member name="M:NCDK.Graphs.Invariant.ConjugatedPiSystemsDetector.CheckAtom(NCDK.IAtomContainer,NCDK.IAtom)">
            <summary>
             Check an Atom whether it may be conjugated or not.
            </summary>
            <param name="ac">The AtomContainer containing currentAtom</param>
            <param name="currentAtom">The Atom to check</param>
            <returns>-1 if isolated, 0 if conjugated, 1 if cumulative db</returns>
        </member>
        <member name="T:NCDK.Graphs.Invariant.InChINumbersTools">
            <summary>
            Tool for calculating atom numbers using the InChI algorithm.
            </summary>
        </member>
        <member name="M:NCDK.Graphs.Invariant.InChINumbersTools.GetNumbers(NCDK.IAtomContainer)">
            <summary>
            Makes an array containing the InChI atom numbers of the non-hydrogen
            atoms in the atomContainer. It returns zero for all hydrogens.
            </summary>
            <param name="atomContainer">The <see cref="T:NCDK.IAtomContainer"/> to analyze.</param>
            <returns>The number from 1 to the number of heavy atoms.</returns>
            <exception cref="T:NCDK.CDKException">When the InChI could not be generated</exception>
        </member>
        <member name="M:NCDK.Graphs.Invariant.InChINumbersTools.ParseAuxInfo(System.String,System.Int64[])">
            <summary>
            Parse the atom numbering from the auxinfo.
            </summary>
            <param name="aux">InChI AuxInfo</param>
            <param name="numbers">the atom numbers</param>
        </member>
        <member name="M:NCDK.Graphs.Invariant.InChINumbersTools.GetUSmilesNumbers(NCDK.IAtomContainer)">
            <summary>
            Obtain the InChI numbers for the input container to be used to order
            atoms in Universal SMILES <token>cdk-cite-OBoyle12</token>. The numbers are obtained
            using the fixedH and RecMet options of the InChI. All non-bridged
            hydrogens are labelled as 0.
            </summary>
            <param name="container">the structure to obtain the numbers of</param>
            <returns>the atom numbers</returns>
        </member>
        <member name="M:NCDK.Graphs.Invariant.InChINumbersTools.ParseUSmilesNumbers(System.String,NCDK.IAtomContainer)">
            <summary>
            Parse the InChI canonical atom numbers (from the AuxInfo) to use in
            Universal SMILES.
            <para>
            The parsing follows: "Rule A: The correspondence between the input atom
            order and the InChI canonical labels should be obtained from the
            reconnected metal layer (/R:) in preference to the initial layer, and
            then from the fixed hydrogen labels (/F:) in preference to the standard
            labels (/N:)."
            </para>
            <para>
            The labels are also adjust for "Rule E: If the start atom is a negatively
            charged oxygen atom, start instead at any carbonyl oxygen attached to the
            same neighbour."
            </para>
            <para>
            All unlabelled atoms (e.g. hydrogens) are assigned the same label which
            is different but larger then all other labels. The hydrogen
            labelling then needs to be adjusted externally as universal SMILES
            suggests hydrogens should be visited first.
            </para>
            </summary>
            <param name="aux">inchi AuxInfo</param>
            <param name="container">the structure to obtain the numbering of</param>
            <returns>the numbers string to use</returns>
        </member>
        <member name="M:NCDK.Graphs.Invariant.InChINumbersTools.Exch(System.Int64[],System.Int32,System.Int32)">
            <summary>
            Exchange the elements at index i with that at index <paramref name="j"/>.
            </summary>
            <param name="values">an array of values</param>
            <param name="i">an index</param>
            <param name="j">another index</param>
        </member>
        <member name="M:NCDK.Graphs.Invariant.InChINumbersTools.FindPiBondedOxygen(NCDK.IAtomContainer,NCDK.IAtom)">
            <summary>
            Find a neutral oxygen bonded to the <paramref name="atom"/> with a pi bond.
            </summary>
            <param name="container">the container</param>
            <param name="atom">an atom from the container</param>
            <returns>a pi bonded oxygen (or null if not found)</returns>
        </member>
        <member name="M:NCDK.Graphs.Invariant.InChINumbersTools.AuxInfo(NCDK.IAtomContainer,NCDK.NInChI.INCHI_OPTION[])">
            <summary>
            Obtain the InChI auxiliary info for the provided structure using
            using the specified InChI options.
            </summary>
            <param name="container">the structure to obtain the numbers of</param>
            <param name="options"></param>
            <returns>auxiliary info</returns>
            <exception cref="T:NCDK.CDKException">the inchi could not be generated</exception>
        </member>
        <member name="T:NCDK.Graphs.Invariant.InvariantRanker">
            <summary>
            A utility for ranking indices by invariants. The ranking is built around
            a merge/insertion sort with the primary interaction through <see cref="M:NCDK.Graphs.Invariant.InvariantRanker.Rank(System.Int32[],System.Int32[],System.Int32,System.Int64[],System.Int64[])"/> .
            </summary>
            <seealso href="http://algs4.cs.princeton.edu/22mergesort/">Mergesort</seealso >
            <seealso cref="T:NCDK.Graphs.Invariant.Canon"/>
        </member>
        <member name="F:NCDK.Graphs.Invariant.InvariantRanker.aux">
            <summary>Auxiliary array for merge sort.</summary>
        </member>
        <member name="F:NCDK.Graphs.Invariant.InvariantRanker.InsertionSortThreshold">
            <summary>
            Length at which the sub-array should be sorted using insertion sort. As
            insertion sort is adaptive and in-place it's advantageous to use a high
            threshold for this use-case. Once we do the first sort, the invariants
            will always be 'almost' sorted which is the best case for the insertion
            sort.
            </summary>
        </member>
        <member name="M:NCDK.Graphs.Invariant.InvariantRanker.#ctor(System.Int32)">
            <summary>
            Create an invariant ranker for <paramref name="n"/> invariants.
            </summary>
            <param name="n">number of values</param>
        </member>
        <member name="M:NCDK.Graphs.Invariant.InvariantRanker.Rank(System.Int32[],System.Int32[],System.Int32,System.Int64[],System.Int64[])">
            <summary>
            Given an array of equivalent indices (currEq) and their values (curr)
            assign a rank to the values. The values are sorted using 'prev' and
            'curr' invariants and once ranked the new ranks placed in 'prev'. The
            values which are still equivalent are placed in 'nextEq' and terminated
            by a '-1'.
            </summary>
            <param name="currEq">currently equivalent vertices (initially identity)</param>
            <param name="nextEq">equivalent vertices (to refine) will be set by this method</param>
            <param name="n">the number of currently equivalent vertices</param>
            <param name="curr">the current invariants</param>
            <param name="prev">the prev invariants (initially = curr) used to sort and then store ranks (set by this method)</param>
            <returns>the number of ranks</returns>
        </member>
        <member name="M:NCDK.Graphs.Invariant.InvariantRanker.SortBy(System.Int32[],System.Int32,System.Int32,System.Int64[],System.Int64[])">
            <summary>
            Sort the values (using merge sort) in <paramref name="vs"/> from <paramref name="lo"/> (until
            <paramref name="len"/>) by the <paramref name="prev"/>[] and then <paramref name="curr"/>[] invariants to
            determine rank. The values in <paramref name="vs"/> are indices into the invariant
            arrays.
            </summary>
            <param name="vs">values (indices)</param>
            <param name="lo">the first value to start sorting from</param>
            <param name="len">the len of values to consider</param>
            <param name="curr">the current invariants</param>
            <param name="prev">the previous invariants</param>
        </member>
        <member name="M:NCDK.Graphs.Invariant.InvariantRanker.Merge(System.Int32[],System.Int32,System.Int32,System.Int32,System.Int64[],System.Int64[])">
            <summary>
            Merge the values which are sorted between <paramref name="lo"/> - <paramref name="split"/> and
            <paramref name="split"/> - <paramref name="len"/>.
            </summary>
            <param name="vs">vertices</param>
            <param name="lo">start index</param>
            <param name="split">the middle index (partition)</param>
            <param name="len">the range to merge</param>
            <param name="curr">the current invariants</param>
            <param name="prev">the previous invariants</param>
        </member>
        <member name="M:NCDK.Graphs.Invariant.InvariantRanker.InsertionSortBy(System.Int32[],System.Int32,System.Int32,System.Int64[],System.Int64[])">
            <summary>
            Sort the values (using insertion sort) in <paramref name="vs"/> from <paramref name="lo"/>
            (until <paramref name="len"/>) by the <paramref name="prev"/>[] and then <paramref name="curr"/>[]
            invariants to determine rank. The values in <paramref name="vs"/> are indices into
            the invariant arrays.
            </summary>
            <param name="vs">values (indices)</param>
            <param name="lo">the first value to start sorting from</param>
            <param name="len">the len of values to consider</param>
            <param name="curr">the current invariants</param>
            <param name="prev">the previous invariants</param>
        </member>
        <member name="M:NCDK.Graphs.Invariant.InvariantRanker.Less(System.Int32,System.Int32,System.Int64[],System.Int64[])">
            <summary>
            Using the <paramref name="prev"/> and <paramref name="curr"/> invariants is value in index i
            less than <paramref name="j"/>. Value i is less than j if it was previously less than <paramref name="j"/>
            (<paramref name="prev"/>[]) or it was equal and it is now (<paramref name="curr"/>[]) less than <paramref name="j"/>.
            </summary>
            <param name="i">an index</param>
            <param name="j">an index</param>
            <param name="curr">current invariants</param>
            <param name="prev">previous invariants</param>
            <returns>is the value in index i less than j</returns>
        </member>
        <member name="T:NCDK.Graphs.AllCycles">
            <summary>
            Compute all simple cycles (rings) in a graph. Generally speaking one does not
            need all the cycles and tractable subsets offer good alternatives.
            <list type="bullet">
            <item><see cref="T:NCDK.Graphs.EdgeShortCycles" /> - the smallest cycle through each edge</item>
            <item><see cref="T:NCDK.Graphs.RelevantCycles" /> - union of all minimum cycle bases - unique but may be exponential</item> 
            <item><see cref="T:NCDK.Graphs.EssentialCycles" /> - intersection of all minimum cycle bases </item> 
            <item><see cref="T:NCDK.Graphs.MinimumCycleBasis" /> - a minimum cycles basis, may not be unique. Often used interchangeable with the term SSSR.</item>
            </list>
            </summary>
            <example>
            For maximum performance the algorithm should be run only on ring systems (a
            biconnected component with at least one tri-connected vertex). An example of
            this is shown below:
            <code>using NCDK.RingSearches;
using NCDK.Templates;

namespace NCDK.Graphs
{
    class AllCycles_Example
    {
        public static void Main(string[] args)
        {
            // convert the molecule to adjacency list - may be redundant in future
            IAtomContainer m = TestMoleculeFactory.MakeAlphaPinene();
            int[][] g = GraphUtil.ToAdjList(m);

            // efficient computation/partitioning of the ring systems
            RingSearch rs = new RingSearch(m, g);

            // isolated cycles don't need to be run
            rs.Isolated();

            // process fused systems separately
            foreach (var fused in rs.Fused())
            {
                const int maxDegree = 100;
                // given the fused subgraph, max cycle size is
                // the number of vertices
                AllCycles ac = new AllCycles(GraphUtil.Subgraph(g, fused), fused.Length, maxDegree);
                // cyclic walks
                int[][] paths = ac.GetPaths();
            }
        }
    }
}
</code>
            </example>
            <seealso href="http://efficientbits.blogspot.co.uk/2013/06/allringsfinder-sport-edition.html">Performance Analysis (Blog Post)</seealso>
            <seealso cref="T:NCDK.Graphs.RegularPathGraph" />
            <seealso cref="T:NCDK.Graphs.JumboPathGraph" />
            <seealso cref="T:NCDK.Graphs.GraphUtil" />
            <seealso cref="T:NCDK.RingSearches.RingSearch" />
        </member>
        <member name="F:NCDK.Graphs.AllCycles.cycles">
            <summary>All simple cycles.</summary>
        </member>
        <member name="F:NCDK.Graphs.AllCycles.completed">
            <summary>Indicates whether the perception completed.</summary>
        </member>
        <member name="M:NCDK.Graphs.AllCycles.#ctor(System.Int32[][],System.Int32,System.Int32)">
            <summary>
            Compute all simple cycles up to given <paramref name="maxCycleSize"/> in the provided
            <paramref name="graph"/>. In some graphs the topology makes it impracticable to
            compute all the simple. To avoid running forever on these molecules the
            <paramref name="maxDegree"/> provides an escape clause. The value doesn't quantify
            how many cycles we get. 
            </summary>
            <remarks>
            The percentage of molecules in PubChem Compound
            (Dec '12) which would successfully complete for a given Degree are listed
            below.
            <list type="table">
            <listheader>Table 1. Num of structures processable in PubChem Compound (Dec 2012) as a result of
            setting the max degree</listheader>
            <item><term>Percent</term><term>Max Degree</term></item>
            <item><term>99%</term><term>9</term></item> <item><term>99.95%</term><term>72</term></item>
            <item><term>99.96%</term><term>84</term></item> <item><term>99.97%</term><term>126</term></item>
            <item><term>99.98%</term><term>216</term></item> <item><term>99.99%</term><term>684</term></item>
            </list>
            </remarks>
            <param name="graph">adjacency list representation of a graph</param>
            <param name="maxCycleSize">the maximum cycle size to perceive</param>
            <param name="maxDegree">escape clause to stop the algorithm running forever</param>
        </member>
        <member name="M:NCDK.Graphs.AllCycles.GetVerticesInOrder(System.Int32[])">
            <summary>
            Using the pre-computed rank, get the vertices in order.
            </summary>
            <param name="rank">see <see cref="M:NCDK.Graphs.AllCycles.GetRank(System.Int32[][])"/></param>
            <returns>vertices in order</returns>
        </member>
        <member name="M:NCDK.Graphs.AllCycles.GetRank(System.Int32[][])">
            <summary>
            Compute a rank for each vertex. This rank is based on the Degree and
            indicates the position each vertex would be in a sorted array.
            </summary>
            <param name="g">a graph in adjacent list representation</param>
            <returns>array indicating the rank of each vertex.</returns>
        </member>
        <member name="M:NCDK.Graphs.AllCycles.GetPaths">
            <summary>
            The paths describing all simple cycles in the given graph. The path stats
            and ends vertex.
            </summary>
            <returns>2d array of paths</returns>
        </member>
        <member name="P:NCDK.Graphs.AllCycles.Count">
            <summary>
            Cardinality of the set.
            </summary>
            <returns>number of cycles</returns>
        </member>
        <member name="P:NCDK.Graphs.AllCycles.Completed">
            <summary>
            Did the cycle perception complete - if not the molecule was considered
            impractical and computation was aborted.
            </summary>
            <returns>algorithm completed</returns>
        </member>
        <member name="T:NCDK.Graphs.CycleFinder">
            <summary>
            Defines a method to find the cycles of a molecule. The distinction between a
            cycle and a ring is that cycles are stored as indices (int[]) while rings are
            stored as atoms (<see cref="T:NCDK.IAtom"/>[]) in a <see cref="T:NCDK.IRing"/>.
            </summary>
        </member>
        <member name="M:NCDK.Graphs.CycleFinder.Find(NCDK.IAtomContainer)">
            <summary>
            Find the cycles of the provided molecule.
            </summary>
            <param name="molecule">a molecule, can be disconnected.</param>
            <returns>an instance for querying the cycles (rings) in the molecule</returns>
            <exception cref="T:System.Exception">if problem could not be solved within some predefined bounds.</exception>
        </member>
        <member name="M:NCDK.Graphs.CycleFinder.Find(NCDK.IAtomContainer,System.Int32)">
            <summary>
            Find the cycles of the provided molecule.
            </summary>
            <param name="molecule">a molecule, can be disconnected.</param>
            <param name="length">maximum length cycle to find (set to molecule.Atoms.Count for all)</param>
            <returns>an instance for querying the cycles (rings) in the molecule</returns>
            <exception cref="T:NCDK.IntractableException">if problem could not be solved within some  predefined bounds.</exception>
        </member>
        <member name="M:NCDK.Graphs.CycleFinder.Find(NCDK.IAtomContainer,System.Int32[][],System.Int32)">
            <summary>
            Find the cycles of the provided molecule when an adjacent relation
            (graph) is already available. The graph can be obtained through 
            <see cref="M:NCDK.Graphs.GraphUtil.ToAdjList(NCDK.IAtomContainer)"/>, for convenience
            <see cref="M:NCDK.Graphs.CycleFinder.Find(NCDK.IAtomContainer,System.Int32)"/> will automatically create the graph.
            </summary>
            <param name="molecule">input structure</param>
            <param name="graph">adjacency list representation for fast traversal</param>
            <param name="length">maximum length cycle to find (set to molecule.Atoms.Count for all)</param>
            <returns>an instance for querying the cycles (rings) in the molecule</returns>
            <exception cref="T:NCDK.IntractableException">if problem could not be solved within some predefined bounds.</exception>
        </member>
        <member name="T:NCDK.Graphs.Cycles">
            <summary>
            A utility class for storing and computing the cycles of a chemical graph.
            Utilities are also provided for converting the cycles to <see cref="T:NCDK.IRing"/>s. A
            brief description of each cycle set is given below - for a more comprehensive
            review please see - <token>cdk-cite-Berger04</token>.
            </summary>
            <remarks>
            <list type="bullet">
            <item><see cref="P:NCDK.Graphs.Cycles.AllFinder"/> - all simple cycles in the graph, the number of
            cycles generated may be very large and may not be feasible for some
            molecules, such as, fullerene.</item> <item><see cref="P:NCDK.Graphs.Cycles.MCBFinder"/> (aka. SSSR) - minimum
            cycle basis (MCB) of a graph, these cycles are linearly independent and can
            be used to generate all of cycles in the graph. It is important to note the
            MCB is not unique and a that there may be multiple equally valid MCBs. The
            smallest set of smallest rings (SSSR) is often used to refer to the MCB but
            originally SSSR was defined as a strictly fundamental cycle basis<token>cdk-cite-Berger04</token>
            Not every graph has a strictly fundamental cycle basis the
            definition has come to mean the MCB. Due to the non-uniqueness of the
            MCB/SSSR its use is discouraged.</item> <item><see cref="P:NCDK.Graphs.Cycles.RelevantFinder"/> - relevant
            cycles of a graph, the smallest set of uniquely defined short cycles. If a
            graph has a single MCB then the relevant cycles and MCB are the same. If the
            graph has multiple MCB then the relevant cycles is the union of all MCBs. The
            number of relevant cycles may be exponential but it is possible to determine
            how many relevant cycles there are in polynomial time without generating
            them. For chemical graphs the number of relevant cycles is usually within
            manageable bounds. </item> <item><see cref="P:NCDK.Graphs.Cycles.EssentialFinder"/> - essential cycles of a
            graph. Similar to the relevant cycles the set is unique for a graph. If a
            graph has a single MCB then the essential cycles and MCB are the same. If the
            graph has multiple MCB then the essential cycles is the intersect of all
            MCBs. That is the cycles which appear in every MCB. This means that is is
            possible to have no essential cycles in a molecule which clearly has cycles
            (e.g. bridged system like bicyclo[2.2.2]octane). </item> 
            <item><see cref="P:NCDK.Graphs.Cycles.TripletShortFinder"/> - the triple short cycles are the shortest cycle through
            each triple of vertices. This allows one to generate the envelope rings of
            some molecules (e.g. naphthalene) without generating all cycles. The cycles
            are primarily useful for the CACTVS Substructure Keys (PubChem fingerprint).
            </item> <item> <see cref="P:NCDK.Graphs.Cycles.VertexShortFinder"/> - the shortest cycles through each vertex.
            Unlike the MCB, linear independence is not checked and it may not be possible
            to generate all other cycles from this set. In practice the vertex/edge short
            cycles are similar to MCB. </item> <item> <see cref="P:NCDK.Graphs.Cycles.EdgeShort"/> - the shortest
            cycles through each edge. Unlike the MCB, linear independence is not checked
            and it may not be possible to generate all other cycles from this set. In
            practice the vertex/edge short cycles are similar to MCB. </item>
            </list>
            </remarks>
        </member>
        <member name="F:NCDK.Graphs.Cycles.paths">
            <summary>Vertex paths for each cycle.</summary>
        </member>
        <member name="F:NCDK.Graphs.Cycles.container">
            <summary>The input container - allows us to create 'Ring' objects.</summary>
        </member>
        <member name="F:NCDK.Graphs.Cycles.bondMap">
            <summary>Mapping for quick lookup of bond mapping.</summary>
        </member>
        <member name="M:NCDK.Graphs.Cycles.#ctor(System.Int32[][],NCDK.IAtomContainer,NCDK.Graphs.GraphUtil.EdgeToBondMap)">
            <summary>
            Internal constructor - may change in future but currently just takes the
            cycle paths and the container from which they came.
            </summary>
            <param name="paths">the cycle paths (closed vertex walks)</param>
            <param name="container">the input container</param>
            <param name="bondMap"></param>
        </member>
        <member name="M:NCDK.Graphs.Cycles.GetNumberOfCycles">
            <summary>
            How many cycles are stored.
            </summary>
            <returns>number of cycles</returns>
        </member>
        <member name="M:NCDK.Graphs.Cycles.ToRingSet">
            <summary>
            Convert the cycles to a <see cref="T:NCDK.IRingSet"/> containing the <see cref="T:NCDK.IAtom"/>s
            and <see cref="T:NCDK.IBond"/>s of the input molecule.
            </summary>
            <returns>ringset for the cycles</returns>
        </member>
        <member name="P:NCDK.Graphs.Cycles.AllFinder">
            <summary>
            A cycle finder which will compute all simple cycles in a molecule.
            The threshold values can not be tuned and is set at a value which will
            complete in reasonable time for most molecules. To change the threshold
            values please use the stand-alone <see cref="T:NCDK.Graphs.AllCycles" /> or <see cref="T:NCDK.RingSearches.AllRingsFinder" />.
            All cycles is every
            possible simple cycle (i.e. non-repeating vertices) in the chemical
            graph. As an example - all simple cycles of anthracene includes, 3 cycles
            of length 6, 2 of length 10 and 1 of length 14.
            </summary>
            <example>
            <code>                CycleFinder cf = Cycles.AllFinder;
                foreach (var container in containers) 
                {
                    try
                    {
                        Cycles cycles = cf.Find(container);
                        IRingSet rings  = cycles.ToRingSet();
                    } 
                    catch (IntractableException) 
                    {
                        // handle error - note it is common that finding all simple cycles in chemical graphs is intractable
                    }
                }
</code>
            </example>
            <returns>finder for all simple cycles</returns>
            <seealso cref="M:NCDK.Graphs.Cycles.FindAll(NCDK.IAtomContainer)" />
            <seealso cref="T:NCDK.Graphs.AllCycles" />
            <seealso cref="T:NCDK.RingSearches.AllRingsFinder" />
        </member>
        <member name="M:NCDK.Graphs.Cycles.GetAllFinder(System.Int32)">
            <summary>
            All cycles of smaller than or equal to the specified length. If a length
            is also provided to <see cref="M:NCDK.Graphs.CycleFinder.Find(NCDK.IAtomContainer,System.Int32)"/> the
            minimum of the two limits is used.
            </summary>
            <param name="length">maximum size or cycle to find</param>
            <returns>cycle finder</returns>
        </member>
        <member name="P:NCDK.Graphs.Cycles.MCBFinder">
            <summary>
            A cycle finder which will compute the minimum cycle basis (MCB) of
            a molecule.
            </summary>
            <example>
            <code>                CycleFinder cf = Cycles.AllFinder;
                foreach (var container in containers) 
                {
                    try
                    {
                        Cycles cycles = cf.Find(container);
                        IRingSet rings  = cycles.ToRingSet();
                    } 
                    catch (IntractableException) 
                    {
                        // ignore error - MCB should never be intractable
                    }
                }
</code>
            </example>
            <returns>finder for all simple cycles</returns>
            <seealso cref="M:NCDK.Graphs.Cycles.FindMCB(NCDK.IAtomContainer)" />
            <seealso cref="T:NCDK.Graphs.MinimumCycleBasis" />
        </member>
        <member name="P:NCDK.Graphs.Cycles.RelevantFinder">
            <summary>
            A cycle finder which will compute the relevant cycle basis (RC) of a molecule.
            </summary>
            <example>
            <code>                CycleFinder cf = Cycles.AllFinder;
                foreach (var container in containers) 
                {
                    try
                    {
                        Cycles cycles = cf.Find(container);
                        IRingSet rings  = cycles.ToRingSet();
                    } 
                    catch (IntractableException) 
                    {
                        // ignore error - there may be an exponential number of cycles but this is not currently checked
                    }
                }
</code>
            </example>
            <seealso cref="M:NCDK.Graphs.Cycles.FindRelevant(NCDK.IAtomContainer)" />
            <seealso cref="T:NCDK.Graphs.RelevantCycles" />
        </member>
        <member name="P:NCDK.Graphs.Cycles.EssentialFinder">
            <summary>
            A cycle finder which will compute the essential cycles of a molecule.
            </summary>
            <example>
            <code>                CycleFinder cf = Cycles.AllFinder;
                foreach (var container in containers) 
                {
                    try
                    {
                        Cycles cycles = cf.Find(container);
                        IRingSet rings  = cycles.ToRingSet();
                    } 
                    catch (IntractableException) 
                    {
                        // ignore error - essential cycles do not check tractability
                    }
                }
</code>
            </example>
            <returns>finder for essential cycles</returns>
            <seealso cref="M:NCDK.Graphs.Cycles.FindRelevant(NCDK.IAtomContainer)" />
            <seealso cref="T:NCDK.Graphs.RelevantCycles" />
        </member>
        <member name="P:NCDK.Graphs.Cycles.TripletShortFinder">
            <summary>
            A cycle finder which will compute the triplet short cycles of a
            molecule. These cycles are the shortest through each triplet of vertices
            are utilised in the generation of CACTVS Substructure Keys (PubChem
            Fingerprint). Currently the triplet cycles are non-canonical (which in
            this algorithms case means unique). For finer tuning of options please
            use the <see cref="T:NCDK.Graphs.TripletShortCycles" />.
            </summary>
            <example>
            <code>                CycleFinder cf = Cycles.AllFinder;
                foreach (var container in containers) 
                {
                    try
                    {
                        Cycles cycles = cf.Find(container);
                        IRingSet rings  = cycles.ToRingSet();
                    } 
                    catch (IntractableException) 
                    {
                        // ignore error - triple short cycles do not check tractability
                    }
                }
</code>
            </example>
            <seealso cref="M:NCDK.Graphs.Cycles.FindTripletShort(NCDK.IAtomContainer)" />
            <seealso cref="T:NCDK.Graphs.TripletShortCycles" />
        </member>
        <member name="P:NCDK.Graphs.Cycles.VertexShortFinder">
            <summary>
            Create a cycle finder which will compute the shortest cycles of each
            vertex in a molecule. Unlike the SSSR/MCB computation linear independence
            is not required and provides some performance gain. In practise typical
            chemical graphs are small and the linear independence check is relatively
            fast.
            </summary>
            <example>
            <code>                CycleFinder cf = Cycles.AllFinder;
                foreach (var container in containers) 
                {
                    try
                    {
                        Cycles cycles = cf.Find(container);
                        IRingSet rings  = cycles.ToRingSet();
                    } 
                    catch (IntractableException) 
                    {
                        // ignore error - vertex short cycles do not check tractability
                    }
                }
</code>
            </example>
            <returns>finder for vertex short cycles</returns>
            <seealso cref="M:NCDK.Graphs.Cycles.FindVertexShort(NCDK.IAtomContainer)" />
        </member>
        <member name="P:NCDK.Graphs.Cycles.EdgeShort">
            <summary>
            Create a cycle finder which will compute the shortest cycles of each
            vertex in a molecule. Unlike the SSSR/MCB computation linear independence
            is not required and provides some performance gain. In practise typical
            chemical graphs are small and the linear independence check is relatively
            fast.
            </summary>
            <example>
            <code>                CycleFinder cf = Cycles.AllFinder;
                foreach (var container in containers) 
                {
                    try
                    {
                        Cycles cycles = cf.Find(container);
                        IRingSet rings  = cycles.ToRingSet();
                    } 
                    catch (IntractableException) 
                    {
                        // ignore error - edge short cycles do not check tractability
                    }
                }
</code>
            </example>
            <returns>finder for edge short cycles</returns>
            <seealso cref="M:NCDK.Graphs.Cycles.FindEdgeShort(NCDK.IAtomContainer)" />
        </member>
        <member name="P:NCDK.Graphs.Cycles.CDKAromaticSetFinder">
            <summary>
            Finder for cdk aromatic cycles.
            </summary>
            <remarks>
            A cycle finder which will compute a set of cycles traditionally
            used by the CDK to test for aromaticity. This set of cycles is the
            MCB/SSSR and <see cref="P:NCDK.Graphs.Cycles.AllFinder" /> cycles for fused systems with 3 or less rings.
            This allows on to test aromaticity of envelope rings in compounds such as
            azulene without generating an huge number of cycles for large fused
            systems (e.g. fullerenes). The use case was that computation of all
            cycles previously took a long time and ring systems with more than 2
            rings were too difficult. However it is now more efficient to simply
            check all cycles/rings without using the MCB/SSSR. This computation will
            fail for complex fused systems but the failure is fast and one can easily
            'fall back' to a smaller set of cycles after catching the exception.
            </remarks>
            <example>
            <code>                CycleFinder cf = Cycles.AllFinder;
                foreach (var container in containers) 
                {
                    try
                    {
                        Cycles cycles = cf.Find(container);
                        IRingSet rings  = cycles.ToRingSet();
                    } 
                    catch (IntractableException) 
                    {
                        // ignore error - edge short cycles do not check tractability
                    }
                }
</code>
            </example>
            <seealso cref="M:NCDK.Graphs.Cycles.FindEdgeShort(NCDK.IAtomContainer)" />
        </member>
        <member name="P:NCDK.Graphs.Cycles.AllOrVertexShortFinder">
            <summary>
            Find all cycles in a fused system or if there were too many cycles
            fallback and use the shortest cycles through each vertex. Typically the
            types of molecules which the vertex short cycles are provided for are
            fullerenes. This cycle finder is well suited to aromaticity.
            </summary>
            <example>
            <!-- No matching elements were found for the following include tag --><include file="IncludeExamples.xml" path="Comments/Codes[@id=&quot;NCDK.Graphs.Cycles_Example.cs+FindAllOrVertexShort&quot;]/*" />
            </example>
            <returns>a cycle finder which computes all cycles if possible or provides the vertex short cycles</returns>
        </member>
        <member name="M:NCDK.Graphs.Cycles.MarkRingAtomsAndBonds(NCDK.IAtomContainer)">
            <summary>
            Find and mark all cyclic atoms and bonds in the provided molecule.
            </summary>
            <param name="mol">molecule</param>
            <returns>Number of rings found (circuit rank)</returns>
            <seealso cref="P:NCDK.IMolecularEntity.IsInRing"/>
            <seealso href="https://en.wikipedia.org/wiki/Circuit_rank">Circuit Rank</seealso> 
        </member>
        <member name="M:NCDK.Graphs.Cycles.MarkRingAtomsAndBonds(NCDK.IAtomContainer,System.Int32[][],NCDK.Graphs.GraphUtil.EdgeToBondMap)">
            <summary>
            Find and mark all cyclic atoms and bonds in the provided molecule. This optimised version
            allows the caller to optionally provided indexed fast access structure which would otherwise
            be created.
            </summary>
            <param name="mol">molecule</param>
            <param name="adjList"></param>
            <param name="bondMap"></param>
            <returns>Number of rings found (circuit rank)</returns>
            <seealso cref="P:NCDK.IMolecularEntity.IsInRing"/>
            <seealso href="https://en.wikipedia.org/wiki/Circuit_rank">Circuit Rank</seealso> 
        </member>
        <member name="M:NCDK.Graphs.Cycles.Or(NCDK.Graphs.CycleFinder,NCDK.Graphs.CycleFinder)">
            <summary>
            Use an auxiliary cycle finder if the primary method was intractable.
            </summary>
            <example>
            <code>                // all cycles or all cycles size &lt;= 6
                CycleFinder cf = Cycles.Or(Cycles.AllFinder, Cycles.GetAllFinder(6));
</code>
            It is possible to nest multiple levels.
            <code>                // all cycles or relevant or essential
                CycleFinder cf = Cycles.Or(Cycles.AllFinder, Cycles.Or(Cycles.RelevantFinder, Cycles.EssentialFinder));
</code>
            </example>
            <param name="primary">primary cycle finding method</param>
            <param name="auxiliary">auxiliary cycle finding method if the primary failed</param>
            <returns>a new cycle finder</returns>
        </member>
        <member name="M:NCDK.Graphs.Cycles.FindAll(NCDK.IAtomContainer)">
            <summary>
            Find all simple cycles in a molecule. The threshold values can not be
            tuned and is set at a value which will complete in reasonable time for
            most molecules. To change the threshold values please use the stand-alone
            <see cref="T:NCDK.Graphs.AllCycles" /> or <see cref="T:NCDK.RingSearches.AllRingsFinder" />.
            All cycles is every possible simple cycle (i.e. non-repeating vertices)
            in the chemical graph. As an example - all simple cycles of anthracene
            includes, 3 cycles of length 6, 2 of length 10 and 1 of length 14.
            </summary>
            <example>
            <code>                foreach (var container in containers)
                {
                    try
                    {
                        Cycles cycles = Cycles.FindAll(container);
                        IRingSet rings = cycles.ToRingSet();
                    }
                    catch (IntractableException)
                    {
                        // handle error - note it is common that finding all simple cycles in chemical graphs is intractable
                    }
                }
</code>
            </example>
            <returns>all simple cycles</returns>
            <exception cref="T:NCDK.IntractableException">the algorithm reached a limit which caused it to abort in reasonable time</exception>
            <seealso cref="P:NCDK.Graphs.Cycles.AllFinder" />
            <seealso cref="T:NCDK.Graphs.AllCycles" />
            <seealso cref="T:NCDK.RingSearches.AllRingsFinder" />
        </member>
        <member name="M:NCDK.Graphs.Cycles.FindAll(NCDK.IAtomContainer,System.Int32)">
            <summary>
            All cycles of smaller than or equal to the specified length.
            </summary>
            <param name="container">input container</param>
            <param name="length">maximum size or cycle to find</param>
            <returns>all cycles</returns>
            <exception cref="T:NCDK.IntractableException">computation was not feasible</exception>
        </member>
        <member name="M:NCDK.Graphs.Cycles.FindMCB(NCDK.IAtomContainer)">
            <summary>
            Find the minimum cycle basis (MCB) of a molecule.
            </summary>
            <example>
            <code>                        Cycles cycles = Cycles.FindMCB(container);
                        IRingSet rings = cycles.ToRingSet();
</code>
            </example>
            <returns>cycles belonging to the minimum cycle basis</returns>
            <seealso cref="P:NCDK.Graphs.Cycles.MCBFinder" />
            <seealso cref="T:NCDK.Graphs.MinimumCycleBasis" />
        </member>
        <member name="M:NCDK.Graphs.Cycles.FindSSSR(NCDK.IAtomContainer)">
            <summary>
            Find the smallest set of smallest rings (SSSR) - aka minimum cycle basis
            (MCB) of a molecule.
            </summary>
            <example>
            <code>                        Cycles cycles = Cycles.FindSSSR(container);
                        IRingSet rings = cycles.ToRingSet();
</code>
            </example>
            <returns>cycles belonging to the minimum cycle basis</returns>
            <seealso cref="P:NCDK.Graphs.Cycles.MCBFinder" />
            <seealso cref="M:NCDK.Graphs.Cycles.FindMCB(NCDK.IAtomContainer)" />
            <seealso cref="T:NCDK.Graphs.MinimumCycleBasis" />
        </member>
        <member name="M:NCDK.Graphs.Cycles.FindRelevant(NCDK.IAtomContainer)">
            <summary>
            Find the relevant cycles of a molecule.
            </summary>
            <example>
            <code>                        Cycles cycles = Cycles.FindRelevant(container);
                        IRingSet rings = cycles.ToRingSet();
</code>
            </example>
            <returns>relevant cycles</returns>
            <seealso cref="P:NCDK.Graphs.Cycles.RelevantFinder" />
            <seealso cref="T:NCDK.Graphs.RelevantCycles" />
        </member>
        <member name="M:NCDK.Graphs.Cycles.FindEssential(NCDK.IAtomContainer)">
            <summary>
            Find the essential cycles of a molecule.
            </summary>
            <example>
            <code>                        Cycles cycles = Cycles.FindEssential(container);
                        IRingSet rings = cycles.ToRingSet();
</code>
            </example>
            <returns>essential cycles</returns>
            <seealso cref="P:NCDK.Graphs.Cycles.RelevantFinder" />
            <seealso cref="T:NCDK.Graphs.RelevantCycles" />
        </member>
        <member name="M:NCDK.Graphs.Cycles.FindTripletShort(NCDK.IAtomContainer)">
            <summary>
            Find the triplet short cycles of a molecule.
            </summary>
            <example>
            <code>                        Cycles cycles = Cycles.FindTripletShort(container);
                        IRingSet rings = cycles.ToRingSet();
</code>
            </example>
            <returns>triplet short cycles</returns>
            <seealso cref="P:NCDK.Graphs.Cycles.TripletShortFinder" />
            <seealso cref="T:NCDK.Graphs.TripletShortCycles" />
        </member>
        <member name="M:NCDK.Graphs.Cycles.FindVertexShort(NCDK.IAtomContainer)">
            <summary>
            Find the vertex short cycles of a molecule.
            </summary>
            <example>
            <code>                        Cycles cycles = Cycles.FindVertexShort(container);
                        IRingSet rings = cycles.ToRingSet();
</code>
            </example>
            <returns>triplet short cycles</returns>
            <seealso cref="P:NCDK.Graphs.Cycles.VertexShortFinder" />
            <seealso cref="T:NCDK.Graphs.VertexShortCycles" />
        </member>
        <member name="M:NCDK.Graphs.Cycles.FindEdgeShort(NCDK.IAtomContainer)">
            <summary>
            Find the edge short cycles of a molecule.
            </summary>
            <example>
            <code>                        Cycles cycles = Cycles.FindEdgeShort(container);
                        IRingSet rings = cycles.ToRingSet();
</code>
            </example>
            <returns>edge short cycles</returns>
            <seealso cref="P:NCDK.Graphs.Cycles.EdgeShort" />
            <seealso cref="T:NCDK.Graphs.EdgeShortCycles" />
        </member>
        <member name="M:NCDK.Graphs.Cycles.GetUnchorded(NCDK.Graphs.CycleFinder)">
            <summary>
            Derive a new cycle finder that only provides cycles without a chord.
            </summary>
            <param name="original">find the initial cycles before filtering</param>
            <returns>cycles or the original without chords</returns>
        </member>
        <member name="M:NCDK.Graphs.Cycles._invoke(NCDK.Graphs.CycleFinder,NCDK.IAtomContainer)">
            <summary>
            Internal method to wrap cycle computations which <i>should</i> be
            tractable. That is they currently won't throw the exception - if the
            method does throw an exception an internal error is triggered as a sanity
            check.
            </summary>
            <param name="finder">the cycle finding method</param>
            <param name="container">the molecule to find the cycles of</param>
            <returns>the cycles of the molecule</returns>
        </member>
        <member name="M:NCDK.Graphs.Cycles._invoke(NCDK.Graphs.CycleFinder,NCDK.IAtomContainer,System.Int32)">
            <summary>
            Internal method to wrap cycle computations which <i>should</i> be
            tractable. That is they currently won't throw the exception - if the
            method does throw an exception an internal error is triggered as a sanity
            check.
            </summary>
            <param name="finder">the cycle finding method</param>
            <param name="container">the molecule to find the cycles of</param>
            <param name="length">maximum size or cycle to find</param>
            <returns>the cycles of the molecule</returns>
        </member>
        <member name="T:NCDK.Graphs.Cycles.CycleComputation">
            <summary>Interbank enumeration of cycle finders.</summary>
        </member>
        <member name="M:NCDK.Graphs.Cycles.CycleComputation.MCB_CycleComputation.Apply(System.Int32[][],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Graphs.Cycles.CycleComputation.ESSENTIAL_CycleComputation.Apply(System.Int32[][],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Graphs.Cycles.CycleComputation.RELEVANT_CycleComputation.Apply(System.Int32[][],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Graphs.Cycles.CycleComputation.ALL_CycleComputation.Apply(System.Int32[][],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Graphs.Cycles.CycleComputation.TRIPLET_SHORT_CycleComputation.Apply(System.Int32[][],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Graphs.Cycles.CycleComputation.VERTEX_SHORT_CycleComputation.Apply(System.Int32[][],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Graphs.Cycles.CycleComputation.EDGE_SHORT_CycleComputation.Apply(System.Int32[][],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Graphs.Cycles.CycleComputation.CDK_AROMATIC_CycleComputation.Apply(System.Int32[][],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Graphs.Cycles.CycleComputation.ALL_OR_VERTEX_SHORT_CycleComputation.Apply(System.Int32[][],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Graphs.Cycles.CycleComputation.Apply(System.Int32[][],System.Int32)">
            <summary>
            Apply cycle perception to the graph (g) - graph is expeced to be
            biconnected.
            </summary>
            <param name="graph">the graph (adjacency list)</param>
            <param name="length"></param>
            <returns>the cycles of the graph</returns>
            <exception cref="T:System.Exception">the computation reached a set limit</exception>
        </member>
        <member name="M:NCDK.Graphs.Cycles.CycleComputation.Find(NCDK.IAtomContainer)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Graphs.Cycles.CycleComputation.Find(NCDK.IAtomContainer,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Graphs.Cycles.CycleComputation.Find(NCDK.IAtomContainer,System.Int32[][],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Graphs.Cycles.Lift(System.Int32[],System.Int32[])">
            <summary>
            Internal - lifts a path in a subgraph back to the original graph.
            </summary>
            <param name="path">a path</param>
            <param name="mapping">vertex mapping</param>
            <returns>the lifted path</returns>
        </member>
        <member name="M:NCDK.Graphs.Cycles.ToRingSet(NCDK.IAtomContainer,System.Int32[][],NCDK.Graphs.GraphUtil.EdgeToBondMap)">
            <summary>
            Internal - convert a set of cycles to an ring set.
            </summary>
            <param name="container">molecule</param>
            <param name="cycles">a cycle of the chemical graph</param>
            <param name="bondMap">mapping of the edges (int,int) to the bonds of the container</param>
            <returns>the ring set</returns>
        </member>
        <member name="M:NCDK.Graphs.Cycles.ToRing(NCDK.IAtomContainer,System.Int32[],NCDK.Graphs.GraphUtil.EdgeToBondMap)">
            <summary>
            Internal - convert a set of cycles to a ring.
            </summary>
            <param name="container">molecule</param>
            <param name="cycle">a cycle of the chemical graph</param>
            <param name="bondMap">mapping of the edges (int,int) to the bonds of the container</param>
            <returns>the ring for the specified cycle</returns>
        </member>
        <member name="M:NCDK.Graphs.Cycles.GetBond(NCDK.IAtomContainer,NCDK.Graphs.GraphUtil.EdgeToBondMap,System.Int32,System.Int32)">
            <summary>
            Obtain the bond between the atoms at index <paramref name="u"/> and 'v'. If the 'bondMap'
            is non-null it is used for direct lookup otherwise the slower linear
            lookup in 'container' is used.
            </summary>
            <param name="container">a structure</param>
            <param name="bondMap">optimised map of atom indices to bond instances</param>
            <param name="u">an atom index</param>
            <param name="v">an atom index (connected to u)</param>
            <returns>the bond between u and v</returns>
        </member>
        <member name="T:NCDK.Graphs.Cycles.AllUpToLength">
            <summary>
            All cycles smaller than or equal to a specified length.
            </summary>
        </member>
        <member name="F:NCDK.Graphs.Cycles.AllUpToLength.threshold">
            <summary>
            See <see cref="F:NCDK.RingSearches.AllRingsFinder.Threshold.PubChem_99"/>.
            </summary>
        </member>
        <member name="M:NCDK.Graphs.Cycles.AllUpToLength.Find(NCDK.IAtomContainer)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Graphs.Cycles.AllUpToLength.Find(NCDK.IAtomContainer,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Graphs.Cycles.AllUpToLength.Find(NCDK.IAtomContainer,System.Int32[][],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Graphs.Cycles.AllUpToLength.FindInFused(System.Int32[][],System.Int32)">
            <summary>
            Find rings in a biconnected component.
            </summary>
            <param name="g">adjacency list</param>
            <param name="length"></param>
            <returns></returns>
            <exception cref="T:NCDK.IntractableException">computation was not feasible</exception>
        </member>
        <member name="T:NCDK.Graphs.Cycles.Fallback">
            <summary>
            Find cycles using a primary cycle finder, if the computation was
            intractable fallback to an auxiliary cycle finder.
            </summary>
        </member>
        <member name="M:NCDK.Graphs.Cycles.Fallback.#ctor(NCDK.Graphs.CycleFinder,NCDK.Graphs.CycleFinder)">
            <summary>
            Create a fallback for two cycle finders.
            </summary>
            <param name="primary">the primary cycle finder</param>
            <param name="auxiliary">the auxiliary cycle finder</param>
        </member>
        <member name="M:NCDK.Graphs.Cycles.Fallback.Find(NCDK.IAtomContainer)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Graphs.Cycles.Fallback.Find(NCDK.IAtomContainer,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Graphs.Cycles.Fallback.Find(NCDK.IAtomContainer,System.Int32[][],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Graphs.Cycles.Unchorded">
            <summary>
            Remove cycles with a chord from an existing set of cycles.
            </summary>
        </member>
        <member name="M:NCDK.Graphs.Cycles.Unchorded.#ctor(NCDK.Graphs.CycleFinder)">
            <summary>
            Filter any cycles produced by the <paramref name="primary"/> cycle finder and
            only allow those without a chord.
            </summary>
            <param name="primary">the primary cycle finder</param>
        </member>
        <member name="M:NCDK.Graphs.Cycles.Unchorded.Find(NCDK.IAtomContainer)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Graphs.Cycles.Unchorded.Find(NCDK.IAtomContainer,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Graphs.Cycles.Unchorded.Find(NCDK.IAtomContainer,System.Int32[][],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Graphs.Cycles.Unchorded.Accept(System.Int32[],System.Int32[][])">
            <summary>
            The cycle path is accepted if it does not have chord.
            </summary>
            <param name="path">a path</param>
            <param name="graph">the adjacency of atoms</param>
            <returns>accept the path as unchorded</returns>
        </member>
        <member name="T:NCDK.Graphs.JumboPathGraph">
            <summary>
            A Path graph (<b>P-Graph</b>) for graphs with more than 64 vertices - the
            P-Graph provides efficient generation of all simple cycles in a graph
            <token>cdk-cite-HAN96</token>. Vertices are sequentially Removed from the graph by
            reducing incident edges and forming new 'Path edges'. The order in which the
            vertices are to be Removed should be pre-defined in the constructor as the
            <see cref="F:NCDK.Graphs.JumboPathGraph.rank"/>[] parameter.
            </summary>
            <seealso href="http://en.wikipedia.org/wiki/Biconnected_component">Wikipedia: Biconnected Component</seealso>
            <seealso cref="T:NCDK.Graphs.GraphUtil"/>
            <seealso cref="T:NCDK.RingSearches.RingSearch"/>
        </member>
        <member name="F:NCDK.Graphs.JumboPathGraph.graph">
            <summary>Path edges, indexed by their end points (incidence list).</summary>
        </member>
        <member name="F:NCDK.Graphs.JumboPathGraph.limit">
            <summary>Limit on the maximum Length of cycle to be found.</summary>
        </member>
        <member name="F:NCDK.Graphs.JumboPathGraph.rank">
            <summary>Indicates when each vertex will be Removed, '0' = first, '|V|' = last.</summary>
        </member>
        <member name="M:NCDK.Graphs.JumboPathGraph.#ctor(System.Int32[][],System.Int32[],System.Int32)">
            <summary>
            Create a regular Path graph (<b>P-Graph</b>) for the given molecule graph (<b>M-Graph</b>).
            </summary>
            <param name="mGraph">The molecule graph (M-Graph) in adjacency list representation.</param>
            <param name="rank">Unique rank of each vertex - indicates when it will be removed.</param>
            <param name="limit">Limit for size of cycles found, to find all cycles specify the limit as the number of vertices in the graph.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">limit was invalid or the graph was too large</exception>
            <exception cref="T:System.ArgumentNullException">the molecule graph was not provided</exception>
        </member>
        <member name="M:NCDK.Graphs.JumboPathGraph.Add(NCDK.Graphs.JumboPathGraph.PathEdge)">
            <summary>
            Add a Path-edge to the Path-graph. Edges are only Added to the vertex of
            lowest rank (see. constructor).
            </summary>
            <param name="edge">Path edge</param>
        </member>
        <member name="M:NCDK.Graphs.JumboPathGraph.Degree(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Graphs.JumboPathGraph.Remove(System.Int32)">
            <summary>
            Access edges which are incident to <i>x</i> and Remove them from the graph.
            </summary>
            <param name="x">a vertex</param>
            <returns>vertices incident to x</returns>
        </member>
        <member name="M:NCDK.Graphs.JumboPathGraph.Combine(System.Collections.Generic.List{NCDK.Graphs.JumboPathGraph.PathEdge},System.Int32)">
            <summary>
            Pairwise combination of all Disjoint <i>edges</i> incident to a vertex <paramref name="x"/>.
            </summary>
            <param name="edges">edges which are currently incident to <i>x</i></param>
            <param name="x">a vertex in the graph</param>
            <returns>reduced edges</returns>
        </member>
        <member name="M:NCDK.Graphs.JumboPathGraph.Remove(System.Int32,System.Collections.Generic.IList{System.Int32[]})">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Graphs.JumboPathGraph.PathEdge">
            <summary>
            An abstract Path edge. A Path edge has two end points and 0 or more
            reduced vertices which represent a Path between those endpoints.
            </summary>
        </member>
        <member name="F:NCDK.Graphs.JumboPathGraph.PathEdge.u">
            <summary>Endpoints of the edge.</summary>
        </member>
        <member name="F:NCDK.Graphs.JumboPathGraph.PathEdge.v">
            <summary>Endpoints of the edge.</summary>
        </member>
        <member name="F:NCDK.Graphs.JumboPathGraph.PathEdge.xs">
            <summary>Bits indicate reduced vertices between endpoints (exclusive).</summary>
        </member>
        <member name="M:NCDK.Graphs.JumboPathGraph.PathEdge.#ctor(System.Int32,System.Int32,System.Collections.BitArray)">
            <summary>
            A new edge specified by two endpoints and a bit set indicating which
            vertices have been reduced.
            </summary>
            <param name="u">an endpoint</param>
            <param name="v">the Other endpoint</param>
            <param name="xs">reduced vertices between endpoints</param>
        </member>
        <member name="M:NCDK.Graphs.JumboPathGraph.PathEdge.Disjoint(NCDK.Graphs.JumboPathGraph.PathEdge)">
            <summary>
            Check if the edges are disjoint with respect to their reduced
            vertices. That is, excluding the endpoints, no reduced vertices are
            shared.
            </summary>
            <param name="other">another edge</param>
            <returns>the edges reduced vertices are disjoint.</returns>
        </member>
        <member name="P:NCDK.Graphs.JumboPathGraph.PathEdge.IsLoop">
            <summary>
            Is the edge a loop and connects a vertex to its self.
            </summary>
            <returns>whether the edge is a loop</returns>
        </member>
        <member name="P:NCDK.Graphs.JumboPathGraph.PathEdge.Either">
            <summary>
            Access either endpoint of the edge.
            </summary>
            <returns>Either endpoint.</returns>
        </member>
        <member name="M:NCDK.Graphs.JumboPathGraph.PathEdge.Other(System.Int32)">
            <summary>
            Given one endpoint, retrieve the other endpoint.
            </summary>
            <param name="x">an endpoint</param>
            <returns>the other endpoint.</returns>
        </member>
        <member name="P:NCDK.Graphs.JumboPathGraph.PathEdge.Length">
            <summary>
            Total Length of the Path formed by this edge. The value includes
            endpoints and reduced vertices.
            </summary>
            <returns>Length of Path</returns>
        </member>
        <member name="M:NCDK.Graphs.JumboPathGraph.PathEdge.Reconstruct(NCDK.Graphs.JumboPathGraph.ArrayBuilder)">
            <summary>
            Reconstruct the Path through the edge by appending vertices to a
            mutable <see cref="T:NCDK.Graphs.JumboPathGraph.ArrayBuilder"/>.
            </summary>
            <param name="ab">array builder to append vertices to</param>
            <returns>the array builder parameter for convenience</returns>
        </member>
        <member name="M:NCDK.Graphs.JumboPathGraph.PathEdge.Path">
            <summary>
            The Path stored by the edge as a fixed size array of vertices.
            </summary>
            <returns>fixed size array of vertices which are in the Path.</returns>
        </member>
        <member name="T:NCDK.Graphs.JumboPathGraph.SimpleEdge">
            <summary>A simple non-reduced edge, just the two end points.</summary>
        </member>
        <member name="M:NCDK.Graphs.JumboPathGraph.SimpleEdge.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            A new simple edge, with two endpoints.
            </summary>
            <param name="u">an endpoint</param>
            <param name="v">anOther endpoint</param>
            <param name="size"></param>
        </member>
        <member name="M:NCDK.Graphs.JumboPathGraph.SimpleEdge.Reconstruct(NCDK.Graphs.JumboPathGraph.ArrayBuilder)">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.Graphs.JumboPathGraph.SimpleEdge.Length">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Graphs.JumboPathGraph.ReducedEdge">
            <summary>
            A reduced edge, made from two existing Path edges and an endpoint they
            have in common.
            </summary>
        </member>
        <member name="F:NCDK.Graphs.JumboPathGraph.ReducedEdge.e">
            <summary>Reduced edges.</summary>
        </member>
        <member name="F:NCDK.Graphs.JumboPathGraph.ReducedEdge.f">
            <summary>Reduced edges.</summary>
        </member>
        <member name="M:NCDK.Graphs.JumboPathGraph.ReducedEdge.#ctor(NCDK.Graphs.JumboPathGraph.PathEdge,NCDK.Graphs.JumboPathGraph.PathEdge,System.Int32)">
            <summary>
            Create a new reduced edge from two existing edges and vertex they
            have in common.
            </summary>
            <param name="e">an edge</param>
            <param name="f">anOther edge</param>
            <param name="x">a common vertex</param>
        </member>
        <member name="M:NCDK.Graphs.JumboPathGraph.ReducedEdge.Reconstruct(NCDK.Graphs.JumboPathGraph.ArrayBuilder)">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.Graphs.JumboPathGraph.ReducedEdge.Length">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Graphs.JumboPathGraph.ArrayBuilder">
            <summary>
            A simple helper class for constructing a fixed size int[] array and
            sequentially appending vertices.
            </summary>
        </member>
        <member name="M:NCDK.Graphs.JumboPathGraph.ArrayBuilder.#ctor(System.Int32)">
            <summary>
            A new array builder of fixed size.
            </summary>
            <param name="n">size of the array</param>
        </member>
        <member name="M:NCDK.Graphs.JumboPathGraph.ArrayBuilder.Append(System.Int32)">
            <summary>
            Append a value to the end of the sequence.
            </summary>
            <param name="x">a new value</param>
            <returns>self-reference for chaining</returns>
        </member>
        <member name="M:NCDK.Graphs.JumboPathGraph.ArrayBuilder.Prev">
            <summary>
            Previously value in the sequence.
            </summary>
            <returns>previous value</returns>
        </member>
        <member name="T:NCDK.Graphs.Matrix.AdjacencyMatrix">
            <summary>
            Calculator for a adjacency matrix representation of this AtomContainer. An
            adjacency matrix is a matrix of quare NxN matrix, where N is the number of
            atoms in the AtomContainer. The element i,j of the matrix is 1, if the i-th
            and the j-th atom in the atomcontainer share a bond. Otherwise it is zero.
            See <token>cdk-cite-TRI92</token>.
            </summary>
        </member>
        <member name="M:NCDK.Graphs.Matrix.AdjacencyMatrix.GetMatrix(NCDK.IAtomContainer)">
            <summary>
            Returns the adjacency matrix for the given AtomContainer.
            </summary>
            <param name="container">The AtomContainer for which the matrix is calculated</param>
            <returns>An adjacency matrix representing this AtomContainer</returns>
        </member>
        <member name="T:NCDK.Graphs.Matrix.ConnectionMatrix">
            <summary>
            Calculator for a connection matrix representation of this AtomContainer. An
            adjacency matrix is a matrix of square NxN matrix, where N is the number of
            atoms in the AtomContainer. If the i-th and the j-th atom in the
            atomcontainer share a bond, the element i,j in the matrix is set to the
            bond order value. Otherwise it is zero. See <token>cdk-cite-TRI92</token>.
            </summary>
        </member>
        <member name="M:NCDK.Graphs.Matrix.ConnectionMatrix.GetMatrix(NCDK.IAtomContainer)">
            <summary>
            Returns the connection matrix representation of this AtomContainer.
            </summary>
            <param name="container">The AtomContainer for which the matrix is calculated</param>
            <returns>A connection matrix representing this AtomContainer</returns>
        </member>
        <member name="T:NCDK.Graphs.Matrix.TopologicalMatrix">
            <summary>
            Calculator for a topological matrix representation of this AtomContainer. An
            topological matrix is a matrix of quare NxN matrix, where N is the number of
            atoms in the AtomContainer. The element i,j of the matrix is the distance between
            two atoms in a molecule.
            </summary>
        </member>
        <member name="M:NCDK.Graphs.Matrix.TopologicalMatrix.GetMatrix(NCDK.IAtomContainer)">
            <summary>
            Returns the topological matrix for the given AtomContainer.
            </summary>
            <param name="container">The AtomContainer for which the matrix is calculated</param>
            <returns>A topological matrix representating this AtomContainer</returns>
        </member>
        <member name="T:NCDK.Graphs.GraphUtil">
            <summary>
            Collection of static utilities for manipulating adjacency list
            representations stored as a <see cref="T:System.Int32"/>[][]. May well be replaced in
            future with a <i>Graph</i> data type.
            </summary>
            <seealso cref="T:NCDK.Graphs.ShortestPaths"/>
            <seealso cref="T:NCDK.RingSearches.RingSearch"/>
        </member>
        <member name="M:NCDK.Graphs.GraphUtil.ToAdjList(NCDK.IAtomContainer)">
            <summary>
            Create an adjacent list representation of the <paramref name="container"/>.
            </summary>
            <param name="container">the molecule</param>
            <returns>adjacency list representation stored as an <see cref="T:System.Int32"/>[][].</returns>
            <exception cref="T:System.ArgumentNullException">the container was null</exception>
            <exception cref="T:System.ArgumentException">a bond was found which contained atoms not in the molecule</exception>
        </member>
        <member name="M:NCDK.Graphs.GraphUtil.ToAdjList(NCDK.IAtomContainer,NCDK.Graphs.GraphUtil.EdgeToBondMap)">
            <summary>
            Create an adjacent list representation of the <paramref name="container"/> and
            fill in the <paramref name="bondMap"/> for quick lookup.
            </summary>
            <param name="container">the molecule</param>
            <param name="bondMap">a map to index the bonds into</param>
            <returns>adjacency list representation stored as an <see cref="T:System.Int32"/>[][].</returns>
            <exception cref="T:System.ArgumentNullException">the container was null</exception>
            <exception cref="T:System.ArgumentException">a bond was found which contained atoms not in the molecule</exception>
        </member>
        <member name="M:NCDK.Graphs.GraphUtil.ToAdjListSubgraph(NCDK.IAtomContainer,System.Collections.Generic.ISet{NCDK.IBond})">
            <summary>
            Create an adjacent list representation of the {@literal container} that only
            includes bonds that are in the set provided as an argument.
            </summary>
            <param name="container">the molecule</param>
            <returns>adjacency list representation stored as an {@literal int[][]}.</returns>
            <exception cref="T:System.ArgumentNullException">the container was null</exception>
            <exception cref="T:System.ArgumentException">a bond was found which contained atoms                                  not in the molecule</exception>
        </member>
        <member name="M:NCDK.Graphs.GraphUtil.Subgraph(System.Int32[][],System.Int32[])">
            <summary>
            Create a subgraph by specifying the vertices from the original <paramref name="graph" />
            to <paramref name="include" /> in the subgraph. The provided vertices also
            provide the mapping between vertices in the subgraph and the original.
            </summary>
            <example>
            <code>            int[][] g = GraphUtil.ToAdjList(naphthalene);
            int[] vs = new int[] { 0, 1, 2, 3, 4, 5 };

            int[][] h = GraphUtil.Subgraph(g, vs);
            // for the vertices in h, the provided 'vs' gives the original index
            for (int v = 0; v &lt; h.Length; v++)
            {
                // vs[v] is 'v' in 'g'
            }
</code>
            </example>
            <param name="graph">adjacency list graph</param>
            <param name="include">the vertices of he graph to include in the subgraph</param>
            <returns>the subgraph</returns>
        </member>
        <member name="M:NCDK.Graphs.GraphUtil.Cycle(System.Int32[][],System.Int32[])">
            <summary>
            Arrange the <paramref name="vertices"/> in a simple cyclic path. 
            </summary>
            <param name="graph">a graph</param>
            <param name="vertices">set of vertices</param>
            <returns>vertices in a walk which makes a cycle (first and last are the same)</returns>
            <exception cref="T:System.ArgumentException">If the vertices do not form a cycle</exception>
            <seealso cref="M:NCDK.RingSearches.RingSearch.Isolated"/>
        </member>
        <member name="M:NCDK.Graphs.GraphUtil.FirstMarked(System.Int32[],System.Boolean[])">
            <summary>
            Find the first value in <paramref name="xs"/> which is <paramref name="marked"/>.
            </summary>
            <param name="xs">array of values</param>
            <param name="marked">marked values</param>
            <returns>first marked value, -1 if none found</returns>
        </member>
        <member name="T:NCDK.Graphs.GraphUtil.EdgeToBondMap">
            <summary>Utility for storing <see cref="T:NCDK.IBond"/>s indexed by vertex end points.</summary>
        </member>
        <member name="M:NCDK.Graphs.GraphUtil.EdgeToBondMap.Add(System.Int32,System.Int32,NCDK.IBond)">
            <summary>
            Index a bond by the endpoints.
            </summary>
            <param name="v">an endpoint</param>
            <param name="w">another endpoint</param>
            <param name="bond">the bond value</param>
        </member>
        <member name="P:NCDK.Graphs.GraphUtil.EdgeToBondMap.Item(System.Int32,System.Int32)">
            <summary>
            Access the bond store at the end points v and w. If no bond is
            store, null is returned.
            </summary>
            <param name="v">an endpoint</param>
            <param name="w">another endpoint</param>
            <returns>the bond stored for the endpoints</returns>
        </member>
        <member name="M:NCDK.Graphs.GraphUtil.EdgeToBondMap.WithSpaceFor(NCDK.IAtomContainer)">
            <summary>
            Create a map with enough space for all the bonds in the molecule,
            <paramref name="container"/>. Note - the map is not filled by this method.
            </summary>
            <param name="container">the container</param>
            <returns>a map with enough space for the container</returns>
        </member>
        <member name="T:NCDK.Graphs.GraphUtil.EdgeToBondMap.Tuple">
            <summary>
            Unordered storage of two int values. Mainly useful to index bonds by
            it's vertex end points.
            </summary>
        </member>
        <member name="M:NCDK.Graphs.GraphUtil.EdgeToBondMap.Tuple.#ctor(System.Int32,System.Int32)">
            <summary>
            Create a new tuple with the specified values.
            </summary>
            <param name="u">a value</param>
            <param name="v">another value</param>
        </member>
        <member name="T:NCDK.Graphs.PathGraph">
            <summary>
            Describes a path graph (<b>P-Graph</b>) to find all cycles in a graph
            <token>cdk-cite-HAN96</token>.
            </summary>
        </member>
        <member name="M:NCDK.Graphs.PathGraph.Degree(System.Int32)">
            <summary>
            The current degree of vertex <paramref name="x"/>. The degree provides an upper bound
            on the number of new edges that could be introduced by
            <see cref="M:NCDK.Graphs.PathGraph.Remove(System.Int32,System.Collections.Generic.IList{System.Int32[]})"/>. The number of new edges is at most
            <i>d</i>(<i>d</i>-1)/2 where d is the degree of the vertex being
            removed.
            </summary>
            <param name="x">a vertex</param>
            <returns>degree</returns>
            <seealso cref="M:NCDK.Graphs.PathGraph.Remove(System.Int32,System.Collections.Generic.IList{System.Int32[]})"/>
        </member>
        <member name="M:NCDK.Graphs.PathGraph.Remove(System.Int32,System.Collections.Generic.IList{System.Int32[]})">
            <summary>
            Remove vertex <paramref name="x"/> from the P-graph and reduce all incident edges.Any
            newly discovered cycles are added to the provided list of <paramref name="cycles"/>.
            Removing a vertex with a large number of incident edges may create many
            edges in the graph. To avoid generating a potentially exponential number
            of cycles checking the <see cref="M:NCDK.Graphs.PathGraph.Degree(System.Int32)"/> of a vertex before removal
            can provide a fast fail approach.
            </summary>
            <param name="x">a vertex</param>
            <param name="cycles">a list to add newly discovered cycles to</param>
            <seealso cref="M:NCDK.Graphs.PathGraph.Degree(System.Int32)"/>
        </member>
        <member name="T:NCDK.Graphs.RegularPathGraph">
            <summary>
            A path graph (<b>P-Graph</b>) for graphs with less than 64 vertices - the
            P-Graph provides efficient generation of all simple cycles in a graph
            <token>cdk-cite-HAN96</token>. Vertices are sequentially removed from the graph by
            reducing incident edges and forming new 'path edges'. The order in which the
            vertices are to be removed should be pre-defined in the constructor as the
            <see cref="F:NCDK.Graphs.RegularPathGraph.rank"/> parameter.
            </summary>
            <seealso href="http://en.wikipedia.org/wiki/Biconnected_component">Wikipedia: Biconnected Component</seealso>
            <seealso cref="T:NCDK.RingSearches.RingSearch"/>
            <seealso cref="T:NCDK.Graphs.GraphUtil"/>
        </member>
        <member name="F:NCDK.Graphs.RegularPathGraph.graph">
            <summary>Path edges, indexed by their end points (incidence list).</summary>
        </member>
        <member name="F:NCDK.Graphs.RegularPathGraph.limit">
            <summary>Limit on the maximum Length of cycle to be found.</summary>
        </member>
        <member name="F:NCDK.Graphs.RegularPathGraph.rank">
            <summary>Indicates when each vertex will be removed, '0' = first, '|V|' = last.</summary>
        </member>
        <member name="M:NCDK.Graphs.RegularPathGraph.#ctor(System.Int32[][],System.Int32[],System.Int32)">
            <summary>
            Create a regular path graph (<b>P-Graph</b>) for the given molecule graph (<b>M-Graph</b>).
            </summary>
            <param name="mGraph">The molecule graph (M-Graph) in adjacency list representation.</param>
            <param name="rank">Unique rank of each vertex - indicates when it will be removed.</param>
            <param name="limit">Limit for size of cycles found, to find all cycles specify the limit as the number of vertices in the graph.</param>
            <exception cref="T:System.ArgumentException">limit was invalid or the graph was too large</exception>
            <exception cref="T:System.ArgumentNullException">the molecule graph was not provided</exception>
        </member>
        <member name="M:NCDK.Graphs.RegularPathGraph.Add(NCDK.Graphs.RegularPathGraph.PathEdge)">
            <summary>
            Add a path-edge to the path-graph. Edges are only added to the vertex of
            lowest rank (see. constructor).
            </summary>
            <param name="edge">path edge</param>
        </member>
        <member name="M:NCDK.Graphs.RegularPathGraph.Degree(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Graphs.RegularPathGraph.Remove(System.Int32)">
            <summary>
            Access edges which are incident to <paramref name="x"/> and remove them from the graph.
            </summary>
            <param name="x">a vertex</param>
            <returns>vertices incident to <paramref name="x"/></returns>
        </member>
        <member name="M:NCDK.Graphs.RegularPathGraph.Combine(System.Collections.Generic.IList{NCDK.Graphs.RegularPathGraph.PathEdge},System.Int32)">
            <summary>
            Pairwise combination of all disjoint <i>edges</i> incident to a vertex <paramref name="x"/>.
            </summary>
            <param name="edges">edges which are currently incident to <paramref name="x"/></param>
            <param name="x">a vertex in the graph</param>
            <returns>reduced edges</returns>
        </member>
        <member name="M:NCDK.Graphs.RegularPathGraph.Remove(System.Int32,System.Collections.Generic.IList{System.Int32[]})">
            <inheritdoc/>
        </member>
        <member name="F:NCDK.Graphs.RegularPathGraph.EMPTY_SET">
            <summary>Empty bit set.</summary>
        </member>
        <member name="T:NCDK.Graphs.RegularPathGraph.PathEdge">
            <summary>
            An abstract path edge. A path edge has two end points and 0 or more
            reduced vertices which represent a path between those endpoints.
            </summary>
        </member>
        <member name="F:NCDK.Graphs.RegularPathGraph.PathEdge.u">
            <summary>Endpoints of the edge.</summary>
        </member>
        <member name="F:NCDK.Graphs.RegularPathGraph.PathEdge.v">
            <summary>Endpoints of the edge.</summary>
        </member>
        <member name="F:NCDK.Graphs.RegularPathGraph.PathEdge.xs">
            <summary>Bits indicate reduced vertices between endpoints (exclusive).</summary>
        </member>
        <member name="M:NCDK.Graphs.RegularPathGraph.PathEdge.#ctor(System.Int32,System.Int32,System.Int64)">
            <summary>
            A new edge specified by two endpoints and a bit set indicating which
            vertices have been reduced.
            </summary>
            <param name="u">an endpoint</param>
            <param name="v">the other endpoint</param>
            <param name="xs">reduced vertices between endpoints</param>
        </member>
        <member name="M:NCDK.Graphs.RegularPathGraph.PathEdge.Disjoint(NCDK.Graphs.RegularPathGraph.PathEdge)">
            <summary>
            Check if the edges are disjoint with respect to their reduced
            vertices. That is, excluding the endpoints, no reduced vertices are
            shared.
            </summary>
            <param name="other">another edge</param>
            <returns>the edges reduced vertices are disjoint.</returns>
        </member>
        <member name="P:NCDK.Graphs.RegularPathGraph.PathEdge.IsLoop">
            <summary>
            Is the edge a loop and connects a vertex to its self.
            </summary>
            <returns>whether the edge is a loop</returns>
        </member>
        <member name="M:NCDK.Graphs.RegularPathGraph.PathEdge.Either">
            <summary>
            Access either endpoint of the edge.
            </summary>
            <returns>either endpoint.</returns>
        </member>
        <member name="M:NCDK.Graphs.RegularPathGraph.PathEdge.Other(System.Int32)">
            <summary>
            Given one endpoint, retrieve the other endpoint.
            </summary>
            <param name="x">an endpoint</param>
            <returns>the other endpoint.</returns>
        </member>
        <member name="P:NCDK.Graphs.RegularPathGraph.PathEdge.Length">
            <summary>
            Total Length of the path formed by this edge. The value includes
            endpoints and reduced vertices.
            </summary>
            <returns>Length of path</returns>
        </member>
        <member name="M:NCDK.Graphs.RegularPathGraph.PathEdge.Reconstruct(NCDK.Graphs.RegularPathGraph.ArrayBuilder)">
            <summary>
            Reconstruct the path through the edge by appending vertices to a
            mutable <see cref="T:NCDK.Graphs.RegularPathGraph.ArrayBuilder"/>.
            </summary>
            <param name="ab">array builder to append vertices to</param>
            <returns>the array builder parameter for convenience</returns>
        </member>
        <member name="M:NCDK.Graphs.RegularPathGraph.PathEdge.Path">
            <summary>
            The path stored by the edge as a fixed size array of vertices.
            </summary>
            <returns>fixed size array of vertices which are in the path.</returns>
        </member>
        <member name="T:NCDK.Graphs.RegularPathGraph.SimpleEdge">
            <summary>A simple non-reduced edge, just the two end points.</summary>
        </member>
        <member name="M:NCDK.Graphs.RegularPathGraph.SimpleEdge.#ctor(System.Int32,System.Int32)">
            <summary>
            A new simple edge, with two endpoints.
            </summary>
            <param name="u">an endpoint</param>
            <param name="v">another endpoint</param>
        </member>
        <member name="M:NCDK.Graphs.RegularPathGraph.SimpleEdge.Reconstruct(NCDK.Graphs.RegularPathGraph.ArrayBuilder)">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.Graphs.RegularPathGraph.SimpleEdge.Length">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Graphs.RegularPathGraph.ReducedEdge">
            <summary>
            A reduced edge, made from two existing path edges and an endpoint they
            have in common.
            </summary>
        </member>
        <member name="F:NCDK.Graphs.RegularPathGraph.ReducedEdge.e">
            <summary>Reduced edges.</summary>
        </member>
        <member name="F:NCDK.Graphs.RegularPathGraph.ReducedEdge.f">
            <summary>Reduced edges.</summary>
        </member>
        <member name="M:NCDK.Graphs.RegularPathGraph.ReducedEdge.#ctor(NCDK.Graphs.RegularPathGraph.PathEdge,NCDK.Graphs.RegularPathGraph.PathEdge,System.Int32)">
            <summary>
            Create a new reduced edge from two existing edges and vertex they
            have in common.
            </summary>
            <param name="e">an edge</param>
            <param name="f">another edge</param>
            <param name="x">a common vertex</param>
        </member>
        <member name="M:NCDK.Graphs.RegularPathGraph.ReducedEdge.Reconstruct(NCDK.Graphs.RegularPathGraph.ArrayBuilder)">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.Graphs.RegularPathGraph.ReducedEdge.Length">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Graphs.RegularPathGraph.ArrayBuilder">
            <summary>
            A simple helper class for constructing a fixed size int[] array and
            sequentially appending vertices.
            </summary>
        </member>
        <member name="M:NCDK.Graphs.RegularPathGraph.ArrayBuilder.#ctor(System.Int32)">
            <summary>
            A new array builder of fixed size.
            </summary>
            <param name="n">size of the array</param>
        </member>
        <member name="M:NCDK.Graphs.RegularPathGraph.ArrayBuilder.Append(System.Int32)">
            <summary>
            Append a value to the end of the sequence.
            </summary>
            <param name="x">a new value</param>
            <returns>self-reference for chaining</returns>
        </member>
        <member name="M:NCDK.Graphs.RegularPathGraph.ArrayBuilder.Prev">
            <summary>
            Previously value in the sequence.
            </summary>
            <returns>previous value</returns>
        </member>
        <member name="T:NCDK.Graphs.InitialCycles">
            <summary>
            Compute the set of initial cycles (<i>C'<sub>I</sub></i>) in a graph. The
            super-set contains the minimum cycle basis (<i>C<sub>B</sub></i>) and the
            relevant cycles (<i>C<sub>R</sub></i>) of the provided graph <token>cdk-cite-Vismara97</token>.
            This class is intend for internal use by other cycle processing
            algorithms.
            </summary>
            <seealso cref="T:NCDK.Graphs.RelevantCycles"/>
        </member>
        <member name="F:NCDK.Graphs.InitialCycles.graph">
            <summary>Adjacency list representation of a chemical graph.</summary>
        </member>
        <member name="F:NCDK.Graphs.InitialCycles.ordering">
            <summary>Vertex ordering.</summary>
        </member>
        <member name="F:NCDK.Graphs.InitialCycles.cycles">
            <summary>Cycle prototypes indexed by their length.</summary>
        </member>
        <member name="F:NCDK.Graphs.InitialCycles.edges">
            <summary>Index of edges in the graph</summary>
        </member>
        <member name="F:NCDK.Graphs.InitialCycles.DEFAULT_DEGREE">
            <summary>
            Initial array size for 'GetOrdering()'. This method sorts vertices by degree
            by counting how many of each degree there is then putting values in place
            directly. This is known as key-value counting and is used in radix
            sorts.
            </summary>
            <seealso href="https://en.wikipedia.org/wiki/Radix_sort#Least_significant_digit_radix_sorts">Radix Sort</seealso>
        </member>
        <member name="F:NCDK.Graphs.InitialCycles.nDeg2Vertices">
            <summary>Number of vertices which have degree 2.</summary>
        </member>
        <member name="F:NCDK.Graphs.InitialCycles.limit">
            <summary>Limit the size of cycles discovered.</summary>
        </member>
        <member name="F:NCDK.Graphs.InitialCycles.biconnected">
            <summary>
            Is the graph known to be a biconnected component. This allows a small
            optimisation.
            </summary>
        </member>
        <member name="M:NCDK.Graphs.InitialCycles.#ctor(System.Int32[][])">
            <summary>
            Create a set of initial cycles for the provided graph.
            </summary>
            <param name="graph">input graph</param>
            <exception cref="T:System.ArgumentNullException">the <paramref name="graph"/> was null</exception>
        </member>
        <member name="M:NCDK.Graphs.InitialCycles.#ctor(System.Int32[][],System.Int32)">
            <summary>
            Create a set of initial cycles for the provided graph.
            </summary>
            <param name="graph">input graph</param>
            <param name="limit">the maximum size of cycle found</param>
            <exception cref="T:System.ArgumentNullException">the <paramref name="graph"/> was null</exception>
        </member>
        <member name="M:NCDK.Graphs.InitialCycles.#ctor(System.Int32[][],System.Int32,System.Boolean)">
            <summary>
            Internal constructor - takes a graph and a flag that the graph is a
            biconnected component. This allows a minor optimisation to trigger.
            </summary>
            <param name="graph">input graph</param>
            <param name="limit"></param>
            <param name="biconnected">the graph is known to be biconnected</param>
            <exception cref="T:System.ArgumentNullException">the <paramref name="graph"/> was null</exception>
        </member>
        <member name="P:NCDK.Graphs.InitialCycles.Graph">
            <summary>
            Access to graph used to calculate the initial cycle set.
            </summary>
            <returns>the graph</returns>
        </member>
        <member name="P:NCDK.Graphs.InitialCycles.Lengths">
            <summary>
            Unique lengths of all cycles found in natural order.
            </summary>
            <returns>lengths of the discovered cycles</returns>
        </member>
        <member name="M:NCDK.Graphs.InitialCycles.GetCyclesOfLength(System.Int32)">
            <summary>
            Access all the prototype cycles of the given length. If no cycles were
            found of given length an empty list is returned.
            </summary>
            <param name="length">desired length of cycles</param>
            <returns>cycles of the given length</returns>
            <seealso cref="P:NCDK.Graphs.InitialCycles.Lengths"/>
        </member>
        <member name="M:NCDK.Graphs.InitialCycles.GetCycles">
            <summary>
            Construct a list of all cycles.
            </summary>
            <returns>list of cycles</returns>
        </member>
        <member name="M:NCDK.Graphs.InitialCycles.GetNumberOfCycles">
            <summary>
            Number of cycles in the initial set.
            </summary>
            <returns>number of cycles</returns>
        </member>
        <member name="M:NCDK.Graphs.InitialCycles.GetNumberOfEdges">
            <summary>
            The number of edges (<i>m</i>) in the graph.
            </summary>
            <returns>number of edges</returns>
        </member>
        <member name="M:NCDK.Graphs.InitialCycles.GetEdge(System.Int32)">
            <summary>
            Access the <see cref="F:NCDK.Graphs.InitialCycles.edges"/> at the given index.
            </summary>
            <param name="i">index of edge</param>
            <returns>the edge at the given index</returns>
        </member>
        <member name="M:NCDK.Graphs.InitialCycles.IndexOfEdge(System.Int32,System.Int32)">
            <summary>
            Lookup the index of the edge formed by the vertices <paramref name="u"/> and
            <paramref name="v"/>.
            </summary>
            <param name="u">a vertex adjacent to <paramref name="v"/></param>
            <param name="v">a vertex adjacent to <paramref name="u"/></param>
            <returns>the index of the edge</returns>
        </member>
        <member name="M:NCDK.Graphs.InitialCycles.ToEdgeVector(System.Int32[])">
            <summary>
            Convert a path of vertices to a binary vector of edges. It is possible to
            convert the vector back to the path using <see cref="F:NCDK.Graphs.InitialCycles.edges"/>.
            </summary>
            <param name="path">the vertices which define the cycle</param>
            <returns>vector edges which make up the path</returns>
            <seealso cref="M:NCDK.Graphs.InitialCycles.IndexOfEdge(System.Int32,System.Int32)"/>
        </member>
        <member name="M:NCDK.Graphs.InitialCycles.Compute">
            <summary>
            Compute the initial cycles. The code corresponds to algorithm 1 from
            <token>cdk-cite-Vismara97</token>, where possible the variable names have been kept
            the same.
            </summary>
        </member>
        <member name="M:NCDK.Graphs.InitialCycles.Add(NCDK.Graphs.InitialCycles.Cycle)">
            <summary>
            Add a newly discovered initial cycle.
            </summary>
            <param name="cycle">the cycle to add</param>
        </member>
        <member name="M:NCDK.Graphs.InitialCycles.GetOrdering(System.Int32[][])">
            <summary>
            Compute the vertex ordering (œÄ). The ordering is based on the vertex
            degree and <![CDATA[œÄ(x) < œÄ(y) => Deg(x) ‚â§ Deg(y)]]>. The ordering
            guarantees the number of elements in <i>C<sub>I</sub></i> is 
            <i>2m<sup>2</sup> + vn</i>. See Lemma 3 of <token>cdk-cite-Vismara97</token>.
            </summary>
            <returns>the order of each vertex</returns>
        </member>
        <member name="M:NCDK.Graphs.InitialCycles.GetSingletonIntersect(System.Int32[],System.Int32[])">
            <summary>
            Given two paths from a common start vertex <c>r</c> check whether there
            are any intersects. If the paths are different length the shorter of the
            two should be given as <paramref name="p"/>.
            </summary>
            <param name="p">a path from <c>r</c></param>
            <param name="q">a path from <c>r</c></param>
            <returns>whether the only intersect is <c>r</c></returns>
        </member>
        <member name="M:NCDK.Graphs.InitialCycles.Join(System.Int32[],System.Int32[])">
            <summary>
            Join the two paths end on end and ignore the first vertex of the second
            path. {0, 1, 2} and {0, 3, 4} becomes {0, 1, 2, 4, 3}.
            </summary>
            <param name="pathToY">first path</param>
            <param name="pathToZ">second path</param>
            <returns>the paths joined end on end and the last vertex truncated</returns>
        </member>
        <member name="M:NCDK.Graphs.InitialCycles.Join(System.Int32[],System.Int32,System.Int32[])">
            <summary>
            Join the two paths end on end using 'y'. The first vertex of the second
            path is truncated. {0, 1, 2}, {5} and {0, 3, 4} becomes {0, 1, 2, 5, 4,
            3}.
            </summary>
            <param name="pathToP">first path</param>
            <param name="y">how to join the two paths</param>
            <param name="pathToQ">second path</param>
            <returns>the paths joined end on end and the last vertex truncated</returns>
        </member>
        <member name="M:NCDK.Graphs.InitialCycles.OfBiconnectedComponent(System.Int32[][])">
            <summary>
            Compute the initial cycles of a biconnected graph.
            </summary>
            <param name="graph">the biconnected graph</param>
            <returns>computed initial cycles</returns>
            <exception cref="T:System.ArgumentNullException">the <paramref name="graph"/> was null</exception>
        </member>
        <member name="M:NCDK.Graphs.InitialCycles.OfBiconnectedComponent(System.Int32[][],System.Int32)">
            <summary>
            Compute the initial cycles of a biconnected graph.
            </summary>
            <param name="graph">the biconnected graph</param>
            <param name="limit">maximum size of the cycle to find</param>
            <returns>computed initial cycles</returns>
            <exception cref="T:System.ArgumentNullException">the <paramref name="graph"/> was null</exception>
        </member>
        <member name="T:NCDK.Graphs.InitialCycles.Cycle">
            <summary>
            Abstract description of a cycle. Stores the path and computes the edge
            vector representation.
            </summary>
        </member>
        <member name="M:NCDK.Graphs.InitialCycles.Cycle.GetEdges(System.Int32[])">
            <summary>
            Provides the edges of <i>path</i>, this method only exists so we can
            refer to the class in a static context.
            </summary>
            <param name="path">path of vertices</param>
            <returns>set of edges</returns>
        </member>
        <member name="P:NCDK.Graphs.InitialCycles.Cycle.EdgeVector">
            <summary>
            Access the edge vector for this cycle.
            </summary>
            <returns>edge vector</returns>
        </member>
        <member name="P:NCDK.Graphs.InitialCycles.Cycle.Path">
            <summary>
            Access the path of this cycle.
            </summary>
            <returns>the path of the cycle</returns>
        </member>
        <member name="M:NCDK.Graphs.InitialCycles.Cycle.GetFamily">
            <summary>
            Reconstruct the entire cycle family (may be exponential).
            </summary>
            <returns>all cycles in this family.</returns>
        </member>
        <member name="M:NCDK.Graphs.InitialCycles.Cycle.SizeOfFamily">
            <summary>
            The number of cycles in this prototypes family. This method be used
            to avoid the potentially exponential reconstruction of all the cycles
            using <see cref="M:NCDK.Graphs.InitialCycles.Cycle.GetFamily"/>.
            </summary>
            <returns>number of cycles</returns>
        </member>
        <member name="P:NCDK.Graphs.InitialCycles.Cycle.Length">
            <summary>
            The length of the cycles (number of vertices in the path).
            </summary>
            <returns>cycle length</returns>
        </member>
        <member name="T:NCDK.Graphs.InitialCycles.Cycle.EvenCycle">
            <summary>
            An even cycle is formed from two shortest paths of the same length
            and 'two' edges to a common vertex. The cycle formed by these is
            even, 2n + 2 = even.
            </summary>
            <seealso cref="M:NCDK.Graphs.InitialCycles.Compute"/>
        </member>
        <member name="M:NCDK.Graphs.InitialCycles.Cycle.EvenCycle.GetEdges(System.Int32[])">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Graphs.InitialCycles.Cycle.EvenCycle.GetFamily">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Graphs.InitialCycles.Cycle.EvenCycle.SizeOfFamily">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Graphs.InitialCycles.Cycle.OddCycle">
            <summary>
            An odd cycle is formed from two shortest paths of the same length
            and 'one' edge to a common vertex. The cycle formed by these is odd,
            2n + 1 = odd.
            </summary>
            <seealso cref="M:NCDK.Graphs.InitialCycles.Compute"/>
        </member>
        <member name="M:NCDK.Graphs.InitialCycles.Cycle.OddCycle.GetEdges(System.Int32[])">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Graphs.InitialCycles.Cycle.OddCycle.GetFamily">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Graphs.InitialCycles.Cycle.OddCycle.SizeOfFamily">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Graphs.InitialCycles.Cycle.Edge">
            <summary>
            A simple value which acts as an immutable unordered tuple for two
            primitive integers. This allows to index edges of a graph.
            </summary>
        </member>
        <member name="T:NCDK.Graphs.ShortestPaths">
            <summary>
            Find and reconstruct the shortest paths from a given start atom to any other
            connected atom. The number of shortest paths (<see cref="M:NCDK.Graphs.ShortestPaths.GetNPathsTo(System.Int32)" />) and the
            distance (<see cref="M:NCDK.Graphs.ShortestPaths.GetDistanceTo(System.Int32)" />) can be accessed before reconstructing all
            the paths. When no path is found (i.e. not-connected) an empty path is always
            returned. 
            </summary>
            <example>
            <code>                IAtomContainer benzene = TestMoleculeFactory.MakeBenzene();

                IAtom c1 = benzene.Atoms[0];
                IAtom c4 = benzene.Atoms[3];

                // shortest paths from C1
                ShortestPaths sp = new ShortestPaths(benzene, c1);

                // number of paths from C1 to C4
                int nPaths = sp.GetNPathsTo(c4);

                // distance between C1 to C4
                int distance = sp.GetDistanceTo(c4);

                // reconstruct a path to the C4 - determined by storage order
                int[] path = sp.GetPathTo(c4);

                // reconstruct all paths
                int[][] paths = sp.GetPathsTo(c4);
                int[] org = paths[0];  // paths[0] == path
                int[] alt = paths[1];
</code>
            </example>
            <remarks>
            If shortest paths from multiple start atoms are required 
            <see cref="T:NCDK.Graphs.AllPairsShortestPaths" /> will have a small performance advantage. Please use
            <see cref="T:NCDK.Graphs.Matrix.TopologicalMatrix" /> if only the
            shortest distances between atoms is required.
            </remarks>
            <seealso cref="T:NCDK.Graphs.AllPairsShortestPaths" />
            <seealso cref="T:NCDK.Graphs.Matrix.TopologicalMatrix" />
        </member>
        <member name="M:NCDK.Graphs.ShortestPaths.#ctor(NCDK.IAtomContainer,NCDK.IAtom)">
            <summary>
            Create a new shortest paths tool for a single start atom. If shortest
            paths from multiple start atoms are required <see cref="T:NCDK.Graphs.AllPairsShortestPaths"/>
            will have a small performance advantage.
            </summary>
            <param name="container">an atom container to find the paths of</param>
            <param name="start">the start atom to which all shortest paths will be computed</param>
            <seealso cref="T:NCDK.Graphs.AllPairsShortestPaths"/>
        </member>
        <member name="M:NCDK.Graphs.ShortestPaths.#ctor(System.Int32[][],NCDK.IAtomContainer,System.Int32)">
            <summary>
            Internal constructor for use by <see cref="T:NCDK.Graphs.AllPairsShortestPaths"/>. This
            constructor allows the passing of adjacency list directly so the
            representation does not need to be rebuilt for a different start atom.
            </summary>
            <param name="adjacent">adjacency list representation - built from <see cref="M:NCDK.Graphs.GraphUtil.ToAdjList(NCDK.IAtomContainer)"/></param>
            <param name="container">container used to access atoms and their indices</param>
            <param name="start">the start atom index of the shortest paths</param>
        </member>
        <member name="M:NCDK.Graphs.ShortestPaths.#ctor(System.Int32[][],NCDK.IAtomContainer,System.Int32,System.Int32[])">
            <summary>
            Create a new shortest paths search for the given graph from the <paramref name="start"/>
            vertex. The ordering for use by <see cref="M:NCDK.Graphs.ShortestPaths.IsPrecedingPathTo(System.Int32)"/>
            can also be specified.
            </summary>
            <param name="adjacent">adjacency list representation - built from <see cref="M:NCDK.Graphs.GraphUtil.ToAdjList(NCDK.IAtomContainer)"/></param>
            <param name="container">container used to access atoms and their indices</param>
            <param name="start">the start atom index of the shortest paths</param>
            <param name="ordering">vertex ordering for preceding path (null = don't use)</param>
        </member>
        <member name="M:NCDK.Graphs.ShortestPaths.#ctor(System.Int32[][],NCDK.IAtomContainer,System.Int32,System.Int32,System.Int32[])">
            <summary>
            Create a new shortest paths search for the given graph from the <paramref name="start"/>
            vertex. The ordering for use by <see cref="M:NCDK.Graphs.ShortestPaths.IsPrecedingPathTo(System.Int32)"/>
            can also be specified.
            </summary>
            <param name="adjacent">adjacency list representation - built from <see cref="M:NCDK.Graphs.GraphUtil.ToAdjList(NCDK.IAtomContainer)"/></param>
            <param name="container">container used to access atoms and their indices</param>
            <param name="start">the start atom index of the shortest paths</param>
            <param name="limit">the maximum length path to find</param>
            <param name="ordering">vertex ordering for preceding path (null = don't use)</param>
        </member>
        <member name="M:NCDK.Graphs.ShortestPaths.Compute(System.Int32[][])">
            <summary>
            Perform a breath-first-search (BFS) from the start atom. The <see cref="F:NCDK.Graphs.ShortestPaths.distTo"/>[]
            is updated on each iteration. The <see cref="F:NCDK.Graphs.ShortestPaths.routeTo"/>[] keeps track of our route back
            to the source. The method has aspects similar to Dijkstra's shortest path
            but we are working with vertices and thus our edges are unweighted and is
            more similar to a simple BFS.
            </summary>
        </member>
        <member name="M:NCDK.Graphs.ShortestPaths.Compute(System.Int32[][],System.Int32[])">
            <summary>
            Perform a breath-first-search (BFS) from the start atom. The <see cref="F:NCDK.Graphs.ShortestPaths.distTo"/>[]
            is updated on each iteration. The <see cref="F:NCDK.Graphs.ShortestPaths.routeTo"/>[] keeps track of our route back
            to the source. The method has aspects similar to Dijkstra's shortest path
            but we are working with vertices and thus our edges are unweighted and is
            more similar to a simple BFS. The ordering limits the paths found to only
            those in which all vertices precede the <see cref="F:NCDK.Graphs.ShortestPaths.start"/> in the given ordering.
            This ordering limits ensure we only generate paths in one direction.
            </summary>
        </member>
        <member name="M:NCDK.Graphs.ShortestPaths.GetPathTo(System.Int32)">
            <summary>
            Reconstruct a shortest path to the provided <paramref name="end" /> vertex. 
            </summary>
            <remarks>
            The path
            is an inclusive fixed size array of vertex indices. If there are multiple
            shortest paths the first shortest path is determined by vertex storage
            order. When there is no path an empty array is returned. It is considered
            there to be no path if the end vertex belongs to the same container but
            is a member of a different fragment, or the vertex is not present in the
            container at all.
            </remarks>
            <example>
            <code>                ShortestPaths sp = new ShortestPaths(benzene, c1);

                // reconstruct first path
                int[] path = sp.GetPathTo(5);

                // check there is only one path
                if (sp.GetNPathsTo(5) == 1)
                {
                    path = sp.GetPathTo(5); // reconstruct the path
                }
</code>
            </example>
            <param name="end">the <paramref name="end" /> vertex to find a path to</param>
            <returns>path from the <see cref="F:NCDK.Graphs.ShortestPaths.start" /> to the <paramref name="end" /> vertex</returns>
            <seealso cref="M:NCDK.Graphs.ShortestPaths.GetPathTo(NCDK.IAtom)" />
            <seealso cref="M:NCDK.Graphs.ShortestPaths.GetAtomsTo(System.Int32)" />
            <seealso cref="M:NCDK.Graphs.ShortestPaths.GetAtomsTo(NCDK.IAtom)" />
        </member>
        <member name="M:NCDK.Graphs.ShortestPaths.GetPathTo(NCDK.IAtom)">
            <summary>
            Reconstruct a shortest path to the provided <paramref name="end" /> atom. The path is
            an inclusive fixed size array of vertex indices. If there are multiple
            shortest paths the first shortest path is determined by vertex storage
            order. When there is no path an empty array is returned. It is considered
            there to be no path if the end atom belongs to the same container but is
            a member of a different fragment, or the atom is not present in the
            container at all.
            </summary>
            <example>
            <code>                ShortestPaths sp = new ShortestPaths(benzene, c1);
                IAtom end = benzene.Atoms[3];

                // reconstruct first path
                int[] path = sp.GetPathTo(end);

                // check there is only one path
                if (sp.GetNPathsTo(end) == 1)
                {
                    path = sp.GetPathTo(end); // reconstruct the path
                }
</code>
            </example>
            <param name="end">the <paramref name="end" /> vertex to find a path to</param>
            <returns>path from the <see cref="F:NCDK.Graphs.ShortestPaths.start" /> to the <paramref name="end" /> vertex</returns>
            <seealso cref="M:NCDK.Graphs.ShortestPaths.GetAtomsTo(NCDK.IAtom)" />
            <seealso cref="M:NCDK.Graphs.ShortestPaths.GetAtomsTo(System.Int32)" />
            <seealso cref="M:NCDK.Graphs.ShortestPaths.GetPathTo(System.Int32)" />
        </member>
        <member name="M:NCDK.Graphs.ShortestPaths.IsPrecedingPathTo(System.Int32)">
            <summary>
            Returns whether the first shortest path from the <see cref="F:NCDK.Graphs.ShortestPaths.start"/> to a given
            <paramref name="end"/> vertex which only passed through vertices smaller then
            <see cref="F:NCDK.Graphs.ShortestPaths.start"/>. This is useful for reducing the search space, the idea is
            used by <token>cdk-cite-Vismara97</token> in the computation of cycle prototypes.
            </summary>
            <param name="end">the end vertex</param>
            <returns>whether the path to the <paramref name="end"/> only passed through vertices preceding the <see cref="F:NCDK.Graphs.ShortestPaths.start"/></returns>
        </member>
        <member name="M:NCDK.Graphs.ShortestPaths.GetPathsTo(System.Int32)">
            <summary>
            Reconstruct all shortest paths to the provided <paramref name="end" /> vertex. The
            paths are <i>n</i> (where n is <see cref="M:NCDK.Graphs.ShortestPaths.GetNPathsTo(System.Int32)" />) inclusive fixed
            size arrays of vertex indices. When there is no path an empty array is
            returned. It is considered there to be no path if the end vertex belongs
            to the same container but is a member of a different fragment, or the
            vertex is not present in the container at all.
            </summary>
            <remarks>
            <b>Important:</b> for every possible branch the number of possible paths
            doubles and could be in the order of tens of thousands. Although the
            chance of finding such a molecule is highly unlikely (C720 fullerene has
            at maximum 1024 paths). It is safer to check the number of paths (
            <see cref="M:NCDK.Graphs.ShortestPaths.GetNPathsTo(System.Int32)" />) before attempting to reconstruct all shortest paths.
            </remarks>
            <example>
            <code>                int threshold = 20;
                ShortestPaths sp = new ShortestPaths(benzene, c1);

                // reconstruct shortest paths
                int[][] paths = sp.GetPathsTo(5);

                // only reconstruct shortest paths below a threshold
                if (sp.GetNPathsTo(5) &lt; threshold)
                {
                    int[][] path = sp.GetPathsTo(5); // reconstruct shortest paths
                }
</code>
            </example>
            <param name="end">the end vertex</param>
            <returns>all shortest paths from the start to the end vertex</returns>
        </member>
        <member name="M:NCDK.Graphs.ShortestPaths.GetPathsTo(NCDK.IAtom)">
            <summary>
            Reconstruct all shortest paths to the provided <paramref name="end" /> vertex. The
            paths are <i>n</i> (where n is <see cref="M:NCDK.Graphs.ShortestPaths.GetNPathsTo(System.Int32)" />) inclusive fixed
            size arrays of vertex indices. When there is no path an empty array is
            returned. It is considered there to be no path if the end vertex belongs
            to the same container but is a member of a different fragment, or the
            vertex is not present in the container at all. 
            </summary>
            <remarks>
            <note type="important">
            For every possible branch the number of possible paths
            doubles and could be in the order of tens of thousands. Although the
            chance of finding such a molecule is highly unlikely (C720 fullerene has
            at maximum 1024 paths). It is safer to check the number of paths 
            (<see cref="M:NCDK.Graphs.ShortestPaths.GetNPathsTo(System.Int32)" />) before attempting to reconstruct all shortest paths.
            </note>
            </remarks>
            <example>
            <code>                int threshold = 20;
                ShortestPaths sp = new ShortestPaths(benzene, c1);
                IAtom end = benzene.Atoms[3];

                // reconstruct all shortest paths
                int[][] paths = sp.GetPathsTo(end);

                // only reconstruct shortest paths below a threshold
                if (sp.GetNPathsTo(end) &lt; threshold)
                {
                    paths = sp.GetPathsTo(end); // reconstruct shortest paths
                }
</code>
            </example>
            <param name="end">the end atom</param>
            <returns>all shortest paths from the start to the end vertex</returns>
        </member>
        <member name="M:NCDK.Graphs.ShortestPaths.GetAtomsTo(System.Int32)">
            <summary>
            Reconstruct a shortest path to the provided <paramref name="end" /> vertex. The path
            is an inclusive fixed size array <see cref="T:NCDK.IAtom" />s. If there are multiple
            shortest paths the first shortest path is determined by vertex storage
            order. When there is no path an empty array is returned. It is considered
            there to be no path if the end vertex belongs to the same container but
            is a member of a different fragment, or the vertex is not present in the
            container at all.
            </summary>
            <example>
            <code>                ShortestPaths sp = new ShortestPaths(benzene, c1);

                // reconstruct a shortest path
                IAtom[] path = sp.GetAtomsTo(5);

                // ensure single shortest path
                if (sp.GetNPathsTo(5) == 1)
                {
                    path = sp.GetAtomsTo(5); // reconstruct shortest path
                }
</code>
            </example>
            <param name="end">the <paramref name="end" /> vertex to find a path to</param>
            <returns>path from the <see cref="F:NCDK.Graphs.ShortestPaths.start" /> to the <paramref name="end" /> atoms as fixed size array of <see cref="T:NCDK.IAtom" />s</returns>
            <seealso cref="M:NCDK.Graphs.ShortestPaths.GetAtomsTo(System.Int32)" />
            <seealso cref="M:NCDK.Graphs.ShortestPaths.GetPathTo(System.Int32)" />
            <seealso cref="M:NCDK.Graphs.ShortestPaths.GetPathTo(NCDK.IAtom)" />
        </member>
        <member name="M:NCDK.Graphs.ShortestPaths.GetAtomsTo(NCDK.IAtom)">
            <summary>
            Reconstruct a shortest path to the provided <paramref name="end" /> atom. The path is
            an inclusive fixed size array <see cref="T:NCDK.IAtom" />s. If there are multiple
            shortest paths the first shortest path is determined by vertex storage
            order. When there is no path an empty array is returned. It is considered
            there to be no path if the end atom belongs to the same container but is
            a member of a different fragment, or the atom is not present in the
            container at all.
            </summary>
            <example>
            <code>                ShortestPaths sp = new ShortestPaths(benzene, c1);
                IAtom end = benzene.Atoms[3];

                // reconstruct a shortest path
                IAtom[] path = sp.GetAtomsTo(end);

                // ensure single shortest path
                if (sp.GetNPathsTo(end) == 1)
                {
                    path = sp.GetAtomsTo(end); // reconstruct shortest path
                }
</code>
            </example>
            <param name="end">the <paramref name="end" /> atom to find a path to</param>
            <returns>path from the <see cref="F:NCDK.Graphs.ShortestPaths.start" /> to the <paramref name="end" /> atoms as fixed size array of <see cref="T:NCDK.IAtom" />s.</returns>
            <seealso cref="M:NCDK.Graphs.ShortestPaths.GetAtomsTo(System.Int32)" />
            <seealso cref="M:NCDK.Graphs.ShortestPaths.GetPathTo(System.Int32)" />
            <seealso cref="M:NCDK.Graphs.ShortestPaths.GetPathTo(NCDK.IAtom)" />
        </member>
        <member name="M:NCDK.Graphs.ShortestPaths.GetNPathsTo(System.Int32)">
            <summary>
            Access the number of possible paths to the <paramref name="end" /> vertex. When there
            is no path 0 is returned. It is considered there to be no path if the end
            vertex belongs to the same container but is a member of a different
            fragment, or the vertex is not present in the container at all.
            </summary>
            <example>
            <code>                ShortestPaths sp = new ShortestPaths(benzene, c1);

                sp.GetNPathsTo(5); // number of paths

                sp.GetNPathsTo(-1); // returns 0 - there are no paths
</code>
            </example>
            <param name="end">the <paramref name="end" /> vertex to which the number of paths will be returned</param>
            <returns>the number of paths to the end vertex</returns>
        </member>
        <member name="M:NCDK.Graphs.ShortestPaths.GetNPathsTo(NCDK.IAtom)">
            <summary>
            Access the number of possible paths to the <paramref name="end" /> atom. When there is
            no path 0 is returned. It is considered there to be no path if the end
            atom belongs to the same container but is a member of a different
            fragment, or the atom is not present in the container at all.<p />
            </summary>
            <example>
            <code>                ShortestPaths sp = new ShortestPaths(benzene, c1);
                IAtom end = benzene.Atoms[3];

                sp.GetNPathsTo(end); // number of paths

                sp.GetNPathsTo(null);           // returns 0 - there are no paths
                sp.GetNPathsTo(new Atom("C"));  // returns 0 - there are no paths
</code>
            </example>
            <param name="end">the <paramref name="end" /> vertex to which the number of paths will be  returned</param>
            <returns>the number of paths to the end vertex</returns>
        </member>
        <member name="M:NCDK.Graphs.ShortestPaths.GetDistanceTo(System.Int32)">
            <summary>
            Access the distance to the provided <paramref name="end" /> vertex. If the two are not
            connected the distance is returned as <see cref="F:System.Int32.MaxValue" />.
            Formally, there is a path if the distance is less then the number of
            vertices.
            </summary>
            <example>
            <code>                IAtomContainer container = TestMoleculeFactory.MakeBenzene();
                IAtom c1 = container.Atoms[0];
                ShortestPaths sp = new ShortestPaths(container, c1); // start = 0

                int n = container.Atoms.Count;

                if (sp.GetDistanceTo(5) &lt; n)
                {
                    // these is a path from 0 to 5
                }
</code>
            Conveniently the distance is also the index of the last vertex in the path.
            <code>                IAtomContainer container = TestMoleculeFactory.MakeBenzene();
                IAtom c1 = container.Atoms[0];
                ShortestPaths sp = new ShortestPaths(container, c1); // start = 0

                int[] path = sp.GetPathTo(5);
                
                 int start = path[0];
                 int end   = path[sp.GetDistanceTo(5)];                
</code>
            </example>
            <param name="end">vertex to measure the distance to</param>
            <returns>distance to this vertex</returns>
            <seealso cref="M:NCDK.Graphs.ShortestPaths.GetDistanceTo(NCDK.IAtom)" />
        </member>
        <member name="M:NCDK.Graphs.ShortestPaths.GetDistanceTo(NCDK.IAtom)">
            <summary>
            Access the distance to the provided <paramref name="end" /> atom. If the two are not
            connected the distance is returned as <see cref="F:System.Int32.MaxValue" />.
            Formally, there is a path if the distance is less then the number of
            atoms.
            </summary>
            <example>
            <code>                 IAtomContainer container = TestMoleculeFactory.MakeBenzene();
                IAtom c1 = container.Atoms[0];
                ShortestPaths sp = new ShortestPaths(container, c1); // start atom
                IAtom end = container.Atoms[3];

                int n = container.Atoms.Count;
                
                 if( sp.GetDistanceTo(end) &lt; n) {
                     // these is a path from start to end
                 }
</code>
            Conveniently the distance is also the index of the last vertex in the path.
            <code>                 IAtomContainer container = TestMoleculeFactory.MakeBenzene();
                IAtom c1 = container.Atoms[0];
                ShortestPaths  sp = new ShortestPaths(container, c1); // start atom
                IAtom end = container.Atoms[3];

                IAtom[] atoms = sp.GetAtomsTo(end);
                Console.WriteLine(end == atoms[sp.GetDistanceTo(end)]); // true
</code>
            </example>
            <param name="end">atom to measure the distance to</param>
            <returns>distance to the given atom</returns>
            <seealso cref="M:NCDK.Graphs.ShortestPaths.GetDistanceTo(System.Int32)" />
        </member>
        <member name="T:NCDK.Graphs.ShortestPaths.Route">
            <summary>Helper class for building a route to the shortest path</summary>
        </member>
        <member name="M:NCDK.Graphs.ShortestPaths.Route.GetToPaths(System.Int32)">
            <summary>
            Recursively convert this route to all possible shortest paths. The length
            is passed down the methods until the source is reached and the first path
            created
            </summary>
            <param name="n">length of the path</param>
            <returns>2D array of all shortest paths</returns>
        </member>
        <member name="M:NCDK.Graphs.ShortestPaths.Route.GetToPath(System.Int32)">
            <summary>
            Recursively convert this route to the first shortest path. The length is
            passed down the methods until the source is reached and the first path
            created
            </summary>
            <param name="n">length of the path</param>
            <returns>first shortest path</returns>
        </member>
        <member name="T:NCDK.Graphs.ShortestPaths.Source">
            <summary>The source of a route, the source is always the start atom.</summary>
        </member>
        <member name="M:NCDK.Graphs.ShortestPaths.Source.#ctor(System.Int32)">
            <summary>
            Create new source with a given vertex.
            </summary>
            <param name="v">start vertex</param>
        </member>
        <member name="M:NCDK.Graphs.ShortestPaths.Source.GetToPaths(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Graphs.ShortestPaths.Source.GetToPath(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Graphs.ShortestPaths.SequentialRoute">
            <summary>A sequential route is vertex appended to a parent route.</summary>
        </member>
        <member name="M:NCDK.Graphs.ShortestPaths.SequentialRoute.#ctor(NCDK.Graphs.ShortestPaths,NCDK.Graphs.ShortestPaths.Route,System.Int32)">
            <summary>
            Create a new sequential route from the parent and include the new vertex <paramref name="v"/>.
            </summary>
            <param name="parentObject"></param>
            <param name="parent">parent route</param>
            <param name="v">additional vertex</param>
        </member>
        <member name="M:NCDK.Graphs.ShortestPaths.SequentialRoute.GetToPaths(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Graphs.ShortestPaths.SequentialRoute.GetToPath(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Graphs.ShortestPaths.Branch">
            <summary>
            A more complex route which represents a branch in our path. A branch is
            composed of a left and a right route. A n-way branches can be constructed by
            simply nesting a branch within a branch.
            </summary>
        </member>
        <member name="M:NCDK.Graphs.ShortestPaths.Branch.#ctor(NCDK.Graphs.ShortestPaths.Route,NCDK.Graphs.ShortestPaths.Route)">
            <summary>
            Create a branch with a left and right
            </summary>
            <param name="left">route to the left</param>
            <param name="right">route to the right</param>
        </member>
        <member name="M:NCDK.Graphs.ShortestPaths.Branch.GetToPaths(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Graphs.ShortestPaths.Branch.GetToPath(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Graphs.MinimumCycleBasis">
            <summary>
            Compute the minimum cycle basis (MCB) of a graph. A cycle basis is a set of
            cycles that can be combined to generate all the cycles of a graph. The MCB is
            the basis of minimum weight (.Length). As an example, there are three cycles
            in <see href="http://en.wikipedia.org/wiki/Naphthalene"><i>naphthalene</i></see>.
            To generate the three cycles (cycle space) we actually only need two of the
            three cycles. The third cycle can be generated by combining the other two.
            Each combination of the two cycles is called a cycle basis. There is one
            basis with the two rings of size six and two bases with either ring of size
            six and the perimeter ring of size 10. The weights of each basis are 12
            (6+6), 16 (6+10), 16 (6+10). The basis of the two six member rings has
            minimum weight (12) and is thus the MCB of <i>naphthalene</i>.
            </summary>
            <remarks>
            The Smallest Set of Smallest Rings (SSSR) is normally used interchangeably
            with MCB although traditionally their meaning was different <token>cdk-cite-Berger04</token>
            Although the MCB can be used to generate all other cycles of a
            graph it may not be unique. A compound with a bridged ring system, such as 
            <see href="http://www.ebi.ac.uk/chebi/searchId.do?chebiId=CHEBI:115239"><i>3-quinuclidinol</i></see>, 
            has three equally valid minimum cycle bases. From
            any two six member rings the third ring can be generated by ‚äï-sum
            (xor-ing) their edges. As there may be more than one MCB it should not be used
            as a <i>unique</i> descriptor. The smallest (but potentially exponential)
            <i>unique</i> set of short cycles which generates the cycle space is the
            union of all minimum cycle bases. This set is known as the <see cref="T:NCDK.Graphs.RelevantCycles"/>.
            The intersect of all minimum cycle bases (<see cref="T:NCDK.Graphs.EssentialCycles"/>) 
            is also unique. Although the number of <see cref="T:NCDK.Graphs.EssentialCycles"/>
            is polynomial it can not always be used to generate the cycle space.
            <see href="http://en.wikipedia.org/wiki/Cycle_space">Cycle Basis</see>
            </remarks>
            <seealso cref="T:NCDK.Graphs.RelevantCycles"/>
        </member>
        <member name="F:NCDK.Graphs.MinimumCycleBasis.basis">
            <summary>The minimum cycle basis.</summary>
        </member>
        <member name="F:NCDK.Graphs.MinimumCycleBasis.graph">
            <summary>The graph used to form the basis.</summary>
        </member>
        <member name="M:NCDK.Graphs.MinimumCycleBasis.#ctor(System.Int32[][])">
            <summary>
            Generate the minimum cycle basis for a graph.
            </summary>
            <param name="graph">undirected adjacency list</param>
            <seealso cref="M:NCDK.RingSearches.RingSearch.Fused"/>
            <seealso cref="M:NCDK.Graphs.GraphUtil.Subgraph(System.Int32[][],System.Int32[])"/>
        </member>
        <member name="M:NCDK.Graphs.MinimumCycleBasis.#ctor(NCDK.Graphs.InitialCycles)">
            <summary>
            Generate the minimum cycle basis from a precomputed set of initial cycles.
            </summary>
            <param name="initial">set of initial cycles.</param>
            <exception cref="T:System.ArgumentNullException">null InitialCycles provided</exception>
        </member>
        <member name="M:NCDK.Graphs.MinimumCycleBasis.#ctor(NCDK.Graphs.InitialCycles,System.Boolean)">
            <summary>
            Generate the minimum cycle basis from a precomputed set of initial
            cycles. This constructor allows on to specify that the graph is
            connected which allows an optimisation to be used.
            </summary>
            <param name="initial">set of initial cycles.</param>
            <param name="connected">the graph is known to be connected</param>
            <exception cref="T:System.ArgumentNullException">null InitialCycles provided</exception>
        </member>
        <member name="M:NCDK.Graphs.MinimumCycleBasis.GetPaths">
            <summary>
            The paths of all cycles in the minimum cycle basis.
            </summary>
            <returns>array of vertex paths</returns>
        </member>
        <member name="P:NCDK.Graphs.MinimumCycleBasis.Count">
            <summary>
            The number of the cycles in the minimum cycle basis.
            </summary>
            <returns>size of minimum cycle set</returns>
        </member>
        <member name="T:NCDK.Graphs.GreedyBasis">
            <summary>
            Greedily compute a cycle basis from a provided set of initial cycles using
            Gaussian elimination.
            </summary>
            <seealso cref="T:NCDK.Graphs.RelevantCycles"/>
        </member>
        <member name="F:NCDK.Graphs.GreedyBasis.basis">
            <summary>Cycles which are members of the basis</summary>
        </member>
        <member name="F:NCDK.Graphs.GreedyBasis.edgesOfBasis">
            <summary>Edges of the current basis.</summary>
        </member>
        <member name="F:NCDK.Graphs.GreedyBasis.m">
            <summary>Number of edges</summary>
        </member>
        <member name="M:NCDK.Graphs.GreedyBasis.#ctor(System.Int32,System.Int32)">
            <summary>
            Create a new basis for the <i>potential</i> number of cycles and the
            <i>exact</i> number of edges. These values can be obtained from an
            <see cref="T:NCDK.Graphs.InitialCycles"/> instance.
            </summary>
            <param name="n">potential number of cycles in the basis</param>
            <param name="m">number of edges in the graph</param>
            <seealso cref="M:NCDK.Graphs.InitialCycles.GetNumberOfCycles"/>
            <seealso cref="M:NCDK.Graphs.InitialCycles.GetNumberOfEdges"/>
        </member>
        <member name="P:NCDK.Graphs.GreedyBasis.Members">
            <summary>
            Access the members of the basis.
            </summary>
            <returns>cycles ordered by length</returns>
        </member>
        <member name="P:NCDK.Graphs.GreedyBasis.Count">
            <summary>
            The size of the basis.
            </summary>
            <returns>number of cycles in the basis</returns>
        </member>
        <member name="M:NCDK.Graphs.GreedyBasis.Add(NCDK.Graphs.InitialCycles.Cycle)">
            <summary>
            Add a cycle to the basis.
            </summary>
            <param name="cycle">new basis member</param>
        </member>
        <member name="M:NCDK.Graphs.GreedyBasis.AddAll(System.Collections.Generic.IEnumerable{NCDK.Graphs.InitialCycles.Cycle})">
            <summary>
            Add all cycles to the basis.
            </summary>
            <param name="cycles">new members of the basis</param>
        </member>
        <member name="M:NCDK.Graphs.GreedyBasis.IsSubsetOfBasis(NCDK.Graphs.InitialCycles.Cycle)">
            <summary>
            Check if all the edges of the <paramref name="cycle"/> are present in the current
            <see cref="F:NCDK.Graphs.GreedyBasis.basis"/>.
            </summary>
            <param name="cycle">an initial cycle</param>
            <returns>any edges of the basis are present</returns>
        </member>
        <member name="M:NCDK.Graphs.GreedyBasis.IsIndependent(NCDK.Graphs.InitialCycles.Cycle)">
            <summary>
            Determine whether the <paramref name="candidate"/> cycle is linearly
            <i>independent</i> from the current basis.
            </summary>
            <param name="candidate">a cycle not in currently in the basis</param>
            <returns>the candidate is independent</returns>
        </member>
        <member name="M:NCDK.Graphs.GreedyBasis.And(System.Collections.BitArray,System.Collections.BitArray)">
            <summary>and <paramref name="s"/> and <paramref name="t"/> without modifying <paramref name="s"/></summary>
        </member>
        <member name="T:NCDK.Graphs.BitMatrix">
            <summary>
            Mutable bit matrix which can eliminate linearly dependent rows and check
            which rows were eliminated. These operations are useful when constructing a
            cycle basis. From a graph we can represent the cycles as a binary vector of
            incidence (edges). When processing cycles as these vectors we determine
            whether a cycle can be made of other cycles in our basis. In the example
            below each row can be made by XORing the other two rows.
            </summary>
            <example>
            <pre>
            1:   111000111   (can be made by 2 XOR 3)
            2:   111000000   (can be made by 1 XOR 3)
            3:   000000111   (can be made by 1 XOR 2)
            </pre>
            <code>
            BitMatrix m = new BitMatrix(9, 3);
            m.Add(ToBitArray("111000111"));
            m.Add(ToBitArray("111000000"));
            m.Add(ToBitArray("111000000"));
            if (m.Eliminate() &lt; 3) {
              // rows are not independent
            }
            </code></example>
        </member>
        <member name="F:NCDK.Graphs.BitMatrix.rows">
            <summary>rows of the matrix.</summary>
        </member>
        <member name="F:NCDK.Graphs.BitMatrix.indices">
            <summary>keep track of row swaps.</summary>
        </member>
        <member name="F:NCDK.Graphs.BitMatrix.max">
            <summary>maximum number of rows.</summary>
        </member>
        <member name="F:NCDK.Graphs.BitMatrix.n">
            <summary>number of columns.</summary>
        </member>
        <member name="F:NCDK.Graphs.BitMatrix.m">
            <summary>current number of rows.</summary>
        </member>
        <member name="M:NCDK.Graphs.BitMatrix.#ctor(System.Int32,System.Int32)">
            <summary>
            Create a new bit matrix with the given number of columns and rows. Note
            the rows is the <i>maximum</i> number of rows we which to store. The
            actual row count only increases with <see cref="M:NCDK.Graphs.BitMatrix.Add(System.Collections.BitArray)"/>.
            </summary>
            <param name="columns">number of columns</param>
            <param name="rows">number of rows</param>
        </member>
        <member name="M:NCDK.Graphs.BitMatrix.Swap(System.Int32,System.Int32)">
            <summary>
            Swap the rows <paramref name="i"/> and <paramref name="j"/>, the swap is kept track of
            internally allowing <see cref="M:NCDK.Graphs.BitMatrix.Row(System.Int32)"/> and <see cref="M:NCDK.Graphs.BitMatrix.Eliminated(System.Int32)"/> to
            access the index of the original row.
            </summary>
            <param name="i">row index</param>
            <param name="j">row index</param>
        </member>
        <member name="M:NCDK.Graphs.BitMatrix.RowIndex(System.Int32)">
            <summary>
            Find the current index of row <paramref name="j"/>.
            </summary>
            <param name="j">original row index to find</param>
            <returns>the index now or &lt; 0 if not found</returns>
        </member>
        <member name="M:NCDK.Graphs.BitMatrix.Row(System.Int32)">
            <summary>
            Access the row which was added at index <paramref name="j"/>.
            </summary>
            <param name="j">index of row</param>
            <returns>the row which was added at index <paramref name="j"/></returns>
        </member>
        <member name="M:NCDK.Graphs.BitMatrix.Eliminated(System.Int32)">
            <summary>
            Check whether the row which was added at index <paramref name="j"/> has been
            eliminated. <see cref="M:NCDK.Graphs.BitMatrix.Eliminate"/> should be invoked first.
            </summary>
            <param name="j">row index</param>
            <returns>whether the row was eliminated</returns>
            <seealso cref="M:NCDK.Graphs.BitMatrix.Eliminate"/>
        </member>
        <member name="M:NCDK.Graphs.BitMatrix.Clear">
            <summary>Clear the matrix, setting the number of rows to 0.</summary>
        </member>
        <member name="M:NCDK.Graphs.BitMatrix.Add(System.Collections.BitArray)">
             <summary>
             Add a row to the matrix.
            
             <param name="row">the row</param>
             </summary>
        </member>
        <member name="M:NCDK.Graphs.BitMatrix.Eliminate">
            <summary>
            Eliminate rows from the matrix which can be made by linearly combinations
            of other rows.
            </summary>
            <returns>rank of the matrix</returns>
            <seealso cref="M:NCDK.Graphs.BitMatrix.Eliminated(System.Int32)"/>
        </member>
        <member name="M:NCDK.Graphs.BitMatrix.Eliminate(System.Int32,System.Int32)">
            <summary>
            Gaussian elimination.
            </summary>
            <param name="x">current column index</param>
            <param name="y">current row index</param>
            <returns>the rank of the matrix</returns>
        </member>
        <member name="M:NCDK.Graphs.BitMatrix.IndexOf(System.Int32,System.Int32)">
            <summary>
            Index of the the first row after <paramref name="y"/> where <paramref name="x"/> is set.
            </summary>
            <param name="x">column index</param>
            <param name="y">row index</param>
            <returns>the first index where <paramref name="x"/> is set, index is &lt; 0 if none</returns>
        </member>
        <member name="M:NCDK.Graphs.BitMatrix.ToString">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Graphs.BitMatrix.Xor(System.Collections.BitArray,System.Collections.BitArray)">
            <summary>
            Utility method xors the vectors <paramref name="u"/> and <paramref name="v"/>. Neither
            input is modified.
            </summary>
            <param name="u">a bit set</param>
            <param name="v">a bit set</param>
            <returns>the 'xor' of <paramref name="u"/> and <paramref name="v"/></returns>
        </member>
        <member name="M:NCDK.Graphs.BitMatrix.From(System.Collections.Generic.IEnumerable{NCDK.Graphs.InitialCycles.Cycle})">
             <summary>
             Simple creation of a BitMatrix from a collection of cycles.
            
             <param name="cycles">cycles to create the matrix from</param>
             <returns>instance of a BitMatrix for the cycles</returns>
             </summary>
        </member>
        <member name="M:NCDK.Graphs.BitMatrix.From(System.Collections.Generic.IEnumerable{NCDK.Graphs.InitialCycles.Cycle},NCDK.Graphs.InitialCycles.Cycle)">
             <summary>
             Simple creation of a BitMatrix from a collection of cycles. The final
             cycle will be added as the last row of the matrix. The <i>cycle</i>
             should no be found in <i>cycles</i>.
            
             <param name="cycles">cycles to create</param>
             <param name="cycle">final cycle to add</param>
             <returns>instance of a BitMatrix for the cycles</returns>
             </summary>
        </member>
        <member name="T:NCDK.Graphs.RelevantCycles">
            <summary>
            Compute the relevant cycles (<i>C<sub>R</sub></i>) of a graph. A cycle is
            relevant if it cannot be represented as the ‚äï-sum (xor) of strictly
            shorter cycles <token>cdk-cite-Berger04</token>. This is the smallest set of short cycles
            which is <i>uniquely</i> defined for a graph. The set can also be thought of
            as the union of all minimum cycle bases. The set of cycles may be exponential
            in number but can be checked (see <see cref="M:NCDK.Graphs.RelevantCycles.Count" />) before construction
            <token>cdk-cite-Vismara97</token>.
            </summary>
            <example>
            <code>                // using NCDK.Graphs.GraphUtil;
                IAtomContainer m = TestMoleculeFactory.MakeAnthracene();

                // compute on the whole graph
                RelevantCycles relevant = new RelevantCycles(ToAdjList(m));

                // it is much faster to compute on the separate ring systems of the molecule
                int[][] graph = ToAdjList(m);
                RingSearch ringSearch = new RingSearch(m, graph);

                // all isolated cycles are relevant
                foreach (int[] isolated in ringSearch.Isolated())
                {
                    int[] path = Cycle(graph, isolated);
                }

                // compute the relevant cycles for each system
                foreach (int[] fused in ringSearch.Fused())
                {
                    int[][] subgraph = Subgraph(graph, fused);
                    RelevantCycles relevantOfSubgraph = new RelevantCycles(subgraph);

                    foreach (int[] path in relevantOfSubgraph.GetPaths())
                    {
                        // convert the sub graph vertices back to the super graph indices
                        for (int i = 0; i &lt; path.Length; i++)
                        {
                            path[i] = fused[path[i]];
                        }
                    }
                }
</code>
            </example>
            <seealso cref="T:NCDK.RingSearches.RingSearch" />
            <seealso cref="T:NCDK.Graphs.GreedyBasis" />
        </member>
        <member name="F:NCDK.Graphs.RelevantCycles.basis">
            <summary>The relevant cycle basis.</summary>
        </member>
        <member name="M:NCDK.Graphs.RelevantCycles.#ctor(System.Int32[][])">
            <summary>
            Generate the relevant cycle basis for a graph.
            </summary>
            <param name="graph">undirected adjacency list</param>
            <seealso cref="M:NCDK.RingSearches.RingSearch.Fused"/>
            <seealso cref="M:NCDK.Graphs.GraphUtil.Subgraph(System.Int32[][],System.Int32[])"/>
        </member>
        <member name="M:NCDK.Graphs.RelevantCycles.#ctor(NCDK.Graphs.InitialCycles)">
            <summary>
            Generate the relevant cycle basis from a precomputed set of initial
            cycles.
            </summary>
            <param name="initial">set of initial cycles.</param>
            <exception cref="T:System.ArgumentNullException">null InitialCycles provided</exception>
        </member>
        <member name="M:NCDK.Graphs.RelevantCycles.Independent(System.Collections.Generic.IEnumerable{NCDK.Graphs.InitialCycles.Cycle})">
            <summary>
            Given a list of cycles return those which are independent (‚äï-sum)
            from the current basis.
            </summary>
            <param name="cycles">cycles of a given .Length</param>
            <returns>cycles which were independent</returns>
        </member>
        <member name="M:NCDK.Graphs.RelevantCycles.GetPaths">
            <summary>
            Reconstruct the paths of all relevant cycles.
            </summary>
            <example>
            <code>                RelevantCycles relevant = new RelevantCycles(ToAdjList(mol));

                // ensure the number is manageable
                if (relevant.Count() &lt; 100) {
                    foreach (int[] path in relevant.GetPaths())
                    {
                        // process the path
                    }
                }
</code>
            </example>
            <returns>array of vertex paths</returns>
        </member>
        <member name="M:NCDK.Graphs.RelevantCycles.Count">
            <summary>
            The number of the relevant cycles.
            </summary>
            <returns>size of relevant cycle set</returns>
        </member>
        <member name="T:NCDK.Graphs.EssentialCycles">
            <summary>
            Determine the uniquely defined essential cycles of a graph. A cycle is
            essential if it a member of all minimum cycle bases. If a graph has a single
            minimum cycle basis (MCB) then all of its cycles are essential. Unlikely the
            <see cref="T:NCDK.Graphs.RelevantCycles"/> the number of essential cycles is always polynomial
            however may not be able generate the cycle space of a graph.
            </summary>
            <seealso cref="T:NCDK.Graphs.RelevantCycles"/>
            <seealso cref="T:NCDK.Graphs.MinimumCycleBasis"/>
            <seealso cref="T:NCDK.Graphs.GraphUtil"/>
        </member>
        <member name="F:NCDK.Graphs.EssentialCycles.essential">
            <summary>Cycles which are essential.</summary>
        </member>
        <member name="F:NCDK.Graphs.EssentialCycles.initial">
            <summary>Initial cycles.</summary>
        </member>
        <member name="F:NCDK.Graphs.EssentialCycles.basis">
            <summary>An MCB extracted from the relevant cycles.</summary>
        </member>
        <member name="M:NCDK.Graphs.EssentialCycles.#ctor(System.Int32[][])">
            <summary>
            Determine the essential cycles given a graph. Adjacency list
            representation. For maximum performance the graph should be preprocessed
            and run on separate biconnected components or fused cycles (see.
            <see cref="T:NCDK.RingSearches.RingSearch"/>.
            </summary>
            <param name="graph">a molecule graph</param>
            <seealso cref="M:NCDK.Graphs.GraphUtil.ToAdjList(NCDK.IAtomContainer)"/>
            <seealso cref="T:NCDK.RingSearches.RingSearch"/>
        </member>
        <member name="M:NCDK.Graphs.EssentialCycles.#ctor(NCDK.Graphs.InitialCycles)">
            <summary>
            Determine the essential cycles from a precomputed set of initial cycles.
            </summary>
            <param name="initial">a molecule graph</param>
        </member>
        <member name="M:NCDK.Graphs.EssentialCycles.#ctor(NCDK.Graphs.RelevantCycles,NCDK.Graphs.InitialCycles)">
            <summary>
            Determine the essential cycles from a precomputed set of initial cycles
            and relevant cycles.
            </summary>
            <param name="relevant"></param>
            <param name="initial">a molecule graph</param>
        </member>
        <member name="M:NCDK.Graphs.EssentialCycles.GetPaths">
            <summary>
            The paths for each essential cycle.
            </summary>
            <returns>array of vertex paths</returns>
        </member>
        <member name="P:NCDK.Graphs.EssentialCycles.Count">
            <summary>
            Number of essential cycles.
            </summary>
            <returns>number of cycles</returns>
        </member>
        <member name="M:NCDK.Graphs.EssentialCycles.GroupByLength(NCDK.Graphs.RelevantCycles)">
            <summary>
            Reconstruct all relevant cycles and group then by length.
            </summary>
            <param name="relevant">precomputed relevant cycles</param>
            <returns>all relevant cycles groped by weight</returns>
        </member>
        <member name="M:NCDK.Graphs.EssentialCycles.GetMembersOfBasis(System.Collections.Generic.IEnumerable{NCDK.Graphs.InitialCycles.Cycle})">
            <summary>
            For a list of equal length cycles return those which are members of the
            minimum cycle basis.
            </summary>
            <param name="cycles">cycles to add to the basis</param>
            <returns>cycles which were added to the basis</returns>
        </member>
        <member name="M:NCDK.Graphs.EssentialCycles.IsEssential(NCDK.Graphs.InitialCycles.Cycle,System.Collections.Generic.ICollection{NCDK.Graphs.InitialCycles.Cycle})">
            <summary>
            Determines whether the <i>cycle</i> is essential.
            </summary>
            <param name="candidate">a cycle which is a member of the MCB</param>
            <param name="relevant">relevant cycles of the same length as <i>cycle</i></param>
            <returns>whether the candidate is essential</returns>
        </member>
        <member name="T:NCDK.Graphs.EssentialCycles.MyCycle">
            <summary>
            Simple class for helping find the essential cycles from the relevant
            cycles.
            </summary>
        </member>
        <member name="M:NCDK.Graphs.EssentialCycles.MyCycle.GetEdges(System.Int32[])">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Graphs.EssentialCycles.MyCycle.GetFamily">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Graphs.EssentialCycles.MyCycle.SizeOfFamily">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Graphs.EssentialCycles.MyCycle.ToString">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Graphs.TripletShortCycles">
            <summary>
            Compute the shortest cycles through each vertex triple. This allows one to
            directly obtain the envelope rings of bicyclic fused system. These cycles
            can be thought of as the 'ESSSR' (extended smallest set of smallest rings)
            and 'envelope' rings as used by PubChem fingerprints (CACTVS Substructure
            Keys). The PubChem fingerprint documentation exclusively refers to the ESSSR
            and envelopes as just the ESSSR and the rest of this documentation does the
            same. This class provides the cycles (vertex paths) for each ring in the
            ESSSR.
            </summary>
            <remarks> 
            <para>
            The ESSSR should not be confused with the extended set of smallest rings
            (ESSR) <token>cdk-cite-Downs89</token>.
            </para>
            <b>Algorithm</b> 
            <para>
            To our knowledge no algorithm has been published for
            the ESSSR. The <see href="ftp://ftp.ncbi.nlm.nih.gov/pubchem/specifications/pubchem_fingerprints.pdf">PubChem Specifications</see>
            states - <i>"An ESSSR ring is any ring which does not
            share three consecutive atoms with any other ring in the chemical structure.
            For example, naphthalene has three ESSSR rings (two phenyl fragments and the
            10-membered envelope), while biphenyl will yield a count of only two ESSSR
            rings"</i>. The name implies the use of the smallest set of smallest rings
            (SSSR). Not every graph has an SSSR and so the minimum cycle basis is used
            instead. With this modification the algorithm is outlined below. 
            </para>
            <list type="bullet">
            <item>Compute a minimum cycle basis (or SSSR) of the graph (may not be unique)</item> 
            <item>For each vertex 'v' and two adjacent vertices ('u' and <i>w</i>) check if the path <i>-u-v-w-</i> belongs to any cycles already in the basis</item> 
            <item>If no such cycle can be found compute the shortest cycle which travels through <i>-u-v-w-</i> and add it to the basis. The shortest cycle is the shortest path from 'u' to <i>w</i> which does not travel through 'v'</item>
            </list>
            <para>
            In the case of <i>naphthalene</i> the
            minimum cycle basis is the two phenyl rings. Taking either bridgehead atom of
            <i>naphthalene</i> to be 'v' and choosing 'u' and <i>w</i> to be in
            different phenyl rings it is easy to see the shortest cycle through
            <i>-u-v-w-</i> is the 10 member envelope ring.
            </para>
            <b>Canonical and Non-Canonical Generation</b>
            <para>
            The algorithm can generate a canonical or non-canonical (preferred) set of
            cycles. As one can see from the above description depending on the order we
            check each triple (-u-v-w-) and add it to basis we may end up with a
            different set.
            </para>
            <para>
            To avoid this PubChem fingerprints uses a canonical labelling ensuring the
            vertices are always checked in the same order. The vertex order used by this
            class is the natural order of the vertices as provided in the graph. To
            ensure the generated set is always the same vertices should be ordered
            beforehand or the non-canonical option should be used.
            </para>
            <para>
            Although this canonical sorting allows one to reliable generate the same set
            of cycles for a graph this is not true for subgraphs. For two graphs
            <i>G</i>, <i>H</i> and a canonical ordering (<i>œÄ</i>). If <i>H</i> is a
            subgraph of <i>G</i> then for two vertices 'u', 'v'. It follows
            that <i>œÄ(u)</i> &lt; <i>œÄ(v)</i> ‚àà <i>H</i> ‚áè <i>œÄ(u)</i> &lt; <i>œÄ(v)</i> ‚àà
            <i>G</i>. In other words, we can canonically label a graph and inspect the
            ordering of vertices 'u' and 'v'. We now take a subgraph which
            contains both 'u' and 'v' - the ordering does not need to be the
            same as the full graph. This means that a subgraph may contain a ring in its
            ESSSR which does not belong to the ESSSR of the full graph.
            </para>
            <para>
            To resolve this problem you can turn off the <see cref="F:NCDK.Graphs.TripletShortCycles.canonical"/> option. This
            relaxes the existing condition (Step 2.) and adds all shortest cycles through
            each triple (-u-v-w-) to the basis. The number of cycles generated may be
            larger however it is now possible to ensure that if <i>H</i> is a subgraph of
            <i>G</i> then ESSSR of <i>H</i> will be a subset of the ESSSR or <i>G</i>.
            Alternatively one may consider using the <see cref="T:NCDK.Graphs.RelevantCycles"/> which is the
            the smallest set of short cycles which is <i>uniquely</i> defined for a
            graph.
            </para>
            <para>
            To better explain the issue with the canonical labelling several examples are
            shown below. The table outlining the size of rings found for each molecule
            when using canonical and non-canonical generation. Also shown are the sizes
            of rings stored in the PubChem fingerprint associated with the entry. The
            fingerprints were obtained directly from PubChem and decoded using the 
            <see href="ftp://ftp.ncbi.nlm.nih.gov/pubchem/specifications/pubchem_fingerprints.pdf">specification</see>.
            Sizes underlined and coloured red represent rings which may
            or may not be present depending on the atom ordering. It can be seen from the
            PubChem fingerprint that even using a consistent canonical labelling rings
            may be absent which would be present if the subgraph was used.
            </para>
            <list type="table">
            <listheader>
            <term>PubChem CID</term>
            <term>Diagram</term>
            <term>Size of Rings in ESSSR (fingerprints only store cycles |C| &lt;=10)</term>
            <term>Source</term>
            </listheader>
            <item>
            <term>CID <see href="http://pubchem.ncbi.nlm.nih.gov/summary/summary.cgi?cid=135973">135973</see></term>
            <term><img src="http://pubchem.ncbi.nlm.nih.gov/image/imgsrv.fcgi?cid=135973"  alt="Compound Image"/></term>
            <term>
                <list type="table">
                    <item><term>{3, 3, 4}</term></item>
                    <item><term>{3, 3, 4}</term></item>
                    <item><term>{3, 3, 4}</term></item>
                </list>
            </term>
            <term>
                <list type="table">
                    <item><term>Canonical</term></item>
                    <item><term>Non-canonical</term></item>
                    <item><term>PubChem Fingerprint</term></item>
                </list>
            </term>
            </item>
            <item>
            <term>CID <see href="http://pubchem.ncbi.nlm.nih.gov/summary/summary.cgi?cid=9249">9249</see></term>
            <term><img src="http://pubchem.ncbi.nlm.nih.gov/image/imgsrv.fcgi?cid=9249"  alt="Compound Image"/></term>
            <term><list type="table">
            <item><term>{3, 3, <b style="color: #FF4444;"><u>4</u></b>, 6, 6}</term> </item>
            <item><term>{3, 3, 4, 6, 6}</term></item>
            <item><term>{3, 3, 6, 6}</term></item>
            </list></term>
            <term><list type="table">
            <item><term>Canonical - <i>4 member cycle only added if found before larger 6
            member cycles</i></term></item>
            <item><term>Non-canonical</term></item>
            <item><term>PubChem Fingerprint - <i>4 member cycle not found</i> </term></item>
            </list></term>
            </item>
            <item>
            <term>CID <see href="http://pubchem.ncbi.nlm.nih.gov/summary/summary.cgi?cid=931">931</see></term>
            <term><img src="http://pubchem.ncbi.nlm.nih.gov/image/imgsrv.fcgi?cid=931"  alt="Compound Image"/></term>
            <term><list type="table">
            <item><term>{6, 6, 10}</term></item>
            <item><term>{6, 6, 10}</term></item>
            <item><term>{6, 6, 10}</term></item>
            </list></term>
            <term><list type="table">
            <item><term>Canonical</term></item>
            <item><term>Non-canonical</term></item>
            <item><term>PubChem Fingerprint</term></item>
            </list></term>
            </item>
            <item>
            <term>CID <see href="http://pubchem.ncbi.nlm.nih.gov/summary/summary.cgi?cid=5702">5702</see></term>
            <term><img src="http://pubchem.ncbi.nlm.nih.gov/image/imgsrv.fcgi?cid=5702" alt="Compound Image"/></term>
            <term><list type="table">
            <item><term>{6, 6, 6, 6, <b style="color: #FF4444;"><u>10</u></b>, <b
            style="color: #FF4444;"><u>10</u></b>, 20, 22, 22, 24, 24}</term></item>
            <item><term>{6, 6, 6, 6, 10, 10, 20, 22, 22, 24, 24}</term></item>
            <item><term>{6, 6, 6, 6}</term></item>
            </list></term>
            <term><list type="table">
            <item><term>Canonical - <i>10 member cycles only added if found before larger
            cycles</i></term></item>
            <item><term>Non-canonical</term></item>
            <item><term>PubChem Fingerprint - <i>10 member cycles not found</i> </term></item>
            </list></term>
            </item>
            <item>
            <term>CID <see href="http://pubchem.ncbi.nlm.nih.gov/summary/summary.cgi?cid=1211">1211</see></term>
            <term><img src="http://pubchem.ncbi.nlm.nih.gov/image/imgsrv.fcgi?cid=1211" alt="Compound Image"/></term>
            <term><list type="table">
            <item><term>{6, 6, 6, 6, 6, 6, <b style="color: #FF4444;"><u>10</u></b>, <b><u>10</u></b>, 18, 18, 20, 20, 22, 22, 22}</term></item>
            <item><term>{6, 6, 6, 6, 6, 6, 10, 10, 18, 18, 20, 20, 22, 22, 22}</term></item>
            <item><term>{6, 6, 6, 6, 6, 6, 10, 10}</term></item>
            </list></term>
            <term><list type="table">
            <item><term>Canonical - <i>10 member cycles only added if found before larger cycles</i></term></item>
            <item><term>Non-canonical</term></item>
            <item><term>PubChem Fingerprint - <i>10 member cycles were found</i> </term></item>
            </list></term>
            </item>
            <item>
            <term>CID <see href="http://pubchem.ncbi.nlm.nih.gov/summary/summary.cgi?cid=17858819">17858819</see></term>
            <term><img src="http://pubchem.ncbi.nlm.nih.gov/image/imgsrv.fcgi?cid=17858819" alt="Compound Image"/></term>
            <term><list type="table">
            <item><term>{5, 6, 9}</term></item>
            <item><term>{5, 6, 9}</term></item>
            <item><term>{5, 6, 9}</term></item>
            </list></term>
            <term><list type="table">
            <item><term>Canonical</term></item>
            <item><term>Non-canonical</term></item>
            <item><term>PubChem Fingerprint</term></item>
            </list></term>
            </item>
            <item>
            <term>CID <see href="http://pubchem.ncbi.nlm.nih.gov/summary/summary.cgi?cid=1909">1909</see></term>
            <term><img src="http://pubchem.ncbi.nlm.nih.gov/image/imgsrv.fcgi?cid=1909" alt="Compound Image"/></term>
            <term><list type="table">
            <item><term>{5, 5, 5, 6, <b style="color: #FF4444;"><u>9</u></b>, 16, 17, 17, 17, 18}</term></item>
            <item><term>{5, 5, 5, 6, 9, 16, 17, 17, 17, 18}</term></item>
            <item><term>{5, 5, 5, 6}</term></item>
            </list></term>
            <term><list type="table">
            <item><term>Canonical - <i>9 member cycle only added if found before larger cycles</i></term></item>
            <item><term>Non-canonical</term></item>
            <item><term>PubChem Fingerprint - <i>9 member cycle not found</i></term></item>
            </list></term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="F:NCDK.Graphs.TripletShortCycles.graph">
            <summary>Adjacency list representation of the graph.</summary>
        </member>
        <member name="F:NCDK.Graphs.TripletShortCycles.canonical">
            <summary>
            Whether the basis should be canonical. By definition a canonical set
            depends on the atom order.
            </summary>
        </member>
        <member name="F:NCDK.Graphs.TripletShortCycles.basis">
            <summary>The current cycle basis.</summary>
        </member>
        <member name="M:NCDK.Graphs.TripletShortCycles.#ctor(NCDK.Graphs.MinimumCycleBasis,System.Boolean)">
            <summary>
            Compute the cycles of the extended smallest set of smallest rings (ESSSR)
            for an existing minimum cycle basis. Choosing the set to be canonical
            means the set depends on the order of the vertices and may <b>not</b> be
            consistent in subgraphs. Given a different order of vertices the same
            cycles may not be found.
            </summary>
            <param name="mcb">minimum cycle basis</param>
            <param name="canonical">should the set be canonical (non-unique)</param>
        </member>
        <member name="M:NCDK.Graphs.TripletShortCycles.GetPaths">
            <summary>
            Access the vertex paths for all cycles of the basis.
            </summary>
            <returns>paths of the basis</returns>
        </member>
        <member name="P:NCDK.Graphs.TripletShortCycles.Count">
            <summary>
            Size of the cycle basis, cardinality of the ESSSR.
            </summary>
        </member>
        <member name="M:NCDK.Graphs.TripletShortCycles.FindTriple(System.Int32)">
            <summary>
            Try and find cycles through the triple formed from <paramref name="v"/> and any two
            of it's neighbours.
            </summary>
            <param name="v">a vertex in the graph</param>
        </member>
        <member name="M:NCDK.Graphs.TripletShortCycles.Exists(System.Int32,System.Int32,System.Int32)">
            <summary>
            Is there a cycle already in the basis in which vertices <paramref name="u"/>,
            <paramref name="v"/> and <paramref name="w"/> can be found in succession.
            </summary>
            <param name="u">a vertex adjacent to <paramref name="v"/></param>
            <param name="v">a vertex adjacent to <paramref name="u"/> and <paramref name="w"/></param>
            <param name="w">a vertex adjacent to <paramref name="v"/></param>
            <returns>whether a member of basis contains -u-v-w- in succession</returns>
        </member>
        <member name="M:NCDK.Graphs.TripletShortCycles.Disconnect(System.Int32[],System.Int32)">
            <summary>
            Temporarily disconnect <paramref name="v"/> from the <see cref="F:NCDK.Graphs.TripletShortCycles.graph"/> by forming loops
            for each of it's neighbours, <paramref name="ws"/>. A loop is an edge in which both
            end points are the. Technically <paramref name="v"/> is never removed but we can't
            reach <paramref name="v"/> from any other vertex which is sufficient to trace the
            triple cycles using <see cref="T:NCDK.Graphs.ShortestPaths"/>.
            </summary>
            <param name="ws">vertices adjacent to <paramref name="v"/></param>
            <param name="v">a vertex <paramref name="v"/></param>
            <seealso cref="M:NCDK.Graphs.TripletShortCycles.Reconnect(System.Int32[],System.Int32)"/>
        </member>
        <member name="M:NCDK.Graphs.TripletShortCycles.Reconnect(System.Int32[],System.Int32)">
            <summary>
            Reconnect <paramref name="v"/> with the <see cref="F:NCDK.Graphs.TripletShortCycles.graph"/> by un-looping each of it's
            neighbours, <paramref name="ws"/>.
            </summary>
            <param name="ws">vertices adjacent to <paramref name="v"/></param>
            <param name="v">a vertex <paramref name="v"/></param>
            <seealso cref="M:NCDK.Graphs.TripletShortCycles.Disconnect(System.Int32[],System.Int32)"/>
        </member>
        <member name="M:NCDK.Graphs.TripletShortCycles.Append(System.Int32[],System.Int32)">
            <summary>
            Append the vertex <paramref name="v"/> to the end of the path <paramref name="p"/>.
            </summary>
            <param name="p">a path</param>
            <param name="v">a vertex to append</param>
            <returns>the path with <paramref name="v"/> appended</returns>
        </member>
        <member name="M:NCDK.Graphs.TripletShortCycles.NCycles(System.Collections.Generic.IEnumerable{NCDK.Graphs.TripletShortCycles.Path},System.Int32)">
            <summary>
            Count how many cycles each vertex belongs to in the given basis.
            </summary>
            <param name="basis">current basis</param>
            <param name="ord">order of the graph</param>
            <returns></returns>
        </member>
        <member name="M:NCDK.Graphs.TripletShortCycles.Lexicographic(System.Int32[])">
            <summary>
            Transform the cycle to that of lowest lexicographic rank. For example the
            paths {3,2,1,0} , {3,0,1,2} and {2,1,0,3} are all the same and in the
            lexicographic order are {0,1,2,3}.
            </summary>
            <param name="p">path forming a simple cycle</param>
            <returns>path of lowest rank</returns>
        </member>
        <member name="M:NCDK.Graphs.TripletShortCycles.Min(System.Int32[])">
            <summary>
            Find the index of lowest value in array.
            </summary>
            <param name="xs">array of integers</param>
            <returns>minimum value</returns>
        </member>
        <member name="M:NCDK.Graphs.TripletShortCycles.Copy(System.Int32[][])">
            <summary>
            Copy the graph <paramref name="g"/>.
            </summary>
            <param name="g">graph</param>
            <returns>copy of the graph</returns>
        </member>
        <member name="T:NCDK.Graphs.TripletShortCycles.Path">
            <summary>
            Simple wrapper class for a path of vertices (specified as an int[]). The
            class provides comparison with other paths. This is required as the
            algorithm can generate the same cycle more then once, and so the cycles
            must be stored in a <see cref="T:System.Collections.Generic.ISet`1"/>.
            </summary>
        </member>
        <member name="F:NCDK.Graphs.TripletShortCycles.Path.vertices">
            <summary>Path of vertices.</summary>
        </member>
        <member name="M:NCDK.Graphs.TripletShortCycles.Path.#ctor(System.Int32[])">
            <summary>
            Create a new path from the given vertices.
            </summary>
            <param name="vertices">vertices</param>
        </member>
        <member name="M:NCDK.Graphs.TripletShortCycles.Path.Contains(System.Int32,System.Int32,System.Int32)">
            <summary>
            Does this path contain the vertices <paramref name="u"/>, <paramref name="v"/> and <paramref name="w"/> in succession.
            </summary>
            <param name="u">a vertex connected to <paramref name="v"/></param>
            <param name="v">a vertex connected to <paramref name="u"/> and <paramref name="w"/></param>
            <param name="w">a vertex connected to <paramref name="v"/></param>
            <returns>whether the path contains the triple in succession</returns>
        </member>
        <member name="P:NCDK.Graphs.TripletShortCycles.Path.Length">
            <summary>
            Length of the path.
            </summary>
        </member>
        <member name="M:NCDK.Graphs.TripletShortCycles.Path.ToArray">
            <summary>
            The path as an array of vertices.
            </summary>
            <returns>array of vertices</returns>
        </member>
        <member name="T:NCDK.Graphs.VertexShortCycles">
            <summary>
            Determine the set of cycles which are the shortest through each vertex.
            Unlike the Smallest Set of Smallest Rings (SSSR), linear dependence of
            each cycle does not need to be verified.
            </summary>
        </member>
        <member name="F:NCDK.Graphs.VertexShortCycles.paths">
            <summary>Shortest cycles stored as closed walks.</summary>
        </member>
        <member name="M:NCDK.Graphs.VertexShortCycles.#ctor(System.Int32[][])">
            <summary> Construct the vertex short cycles for the given graph. </summary>
        </member>
        <member name="M:NCDK.Graphs.VertexShortCycles.#ctor(NCDK.Graphs.InitialCycles)">
            <summary> Construct the vertex short cycles for the given initial cycles.</summary>
        </member>
        <member name="M:NCDK.Graphs.VertexShortCycles.GetPaths">
            <summary>
            The paths of the shortest cycles, that paths are closed walks such that
            the last and first vertex is the same.
            </summary>
            <returns>the paths</returns>
        </member>
        <member name="P:NCDK.Graphs.VertexShortCycles.Count">
            <summary>
            The size of the shortest cycles set.
            </summary>
            <returns>number of cycles</returns>
        </member>
        <member name="T:NCDK.Graphs.EdgeShortCycles">
            <summary>
            Determine the set of cycles which are the shortest through each edge.
            Unlike the Smallest Set of Smallest Rings (SSSR), linear dependence of
            each cycle does not need to be verified.
            </summary>
        </member>
        <member name="F:NCDK.Graphs.EdgeShortCycles.paths">
            <summary>Shortest cycles stored as closed walks.</summary>
        </member>
        <member name="M:NCDK.Graphs.EdgeShortCycles.#ctor(System.Int32[][])">
            <summary> Construct the edge short cycles for the
             given graph. </summary>
        </member>
        <member name="M:NCDK.Graphs.EdgeShortCycles.#ctor(NCDK.Graphs.InitialCycles)">
            <summary> Construct the edge short cycles for the
             given initial cycles. </summary>
        </member>
        <member name="M:NCDK.Graphs.EdgeShortCycles.GetPaths">
            <summary>
            The paths of the shortest cycles, that paths are closed walks such that
            the first and last vertex is the same.
            </summary>
            <returns>the paths</returns>
        </member>
        <member name="P:NCDK.Graphs.EdgeShortCycles.Count">
            <summary>
            The size of the shortest cycles set.
            </summary>
            <returns>number of cycles</returns>
        </member>
        <member name="T:NCDK.Graphs.AllPairsShortestPaths">
            <summary>
            Utility to determine the shortest paths between all pairs of atoms in a molecule.
            </summary>
            <example>
            <code>                IAtomContainer benzene = TestMoleculeFactory.MakeBenzene();
                AllPairsShortestPaths apsp = new AllPairsShortestPaths(benzene);
                for (int i = 0; i &lt; benzene.Atoms.Count; i++)
                {
                    // only to half the comparisons, we can reverse the
                    // path[] to get all j to i
                    for (int j = i + 1; j &lt; benzene.Atoms.Count; j++)
                    {
                        // reconstruct shortest path from i to j
                        int[] path = apsp.From(i).GetPathTo(j);

                        // reconstruct all shortest paths from i to j
                        int[][] paths = apsp.From(i).GetPathsTo(j);

                        // reconstruct the atoms in the path from i to j
                        IAtom[] atoms = apsp.From(i).GetAtomsTo(j);

                        // access the number of paths from i to j
                        int nPaths = apsp.From(i).GetNPathsTo(j);

                        // access the distance from i to j
                        int distance = apsp.From(i).GetNPathsTo(j);
                    }
                }
</code>
            </example>
            <seealso cref="T:NCDK.Graphs.ShortestPaths" />
        </member>
        <member name="M:NCDK.Graphs.AllPairsShortestPaths.#ctor(NCDK.IAtomContainer)">
            <summary>
            Create a new all shortest paths utility for an <see cref="T:NCDK.IAtomContainer"/>.
            </summary>
            <param name="container">the molecule of which to find the shortest paths</param>
        </member>
        <member name="M:NCDK.Graphs.AllPairsShortestPaths.From(System.Int32)">
            <summary>
            Access the shortest paths object for provided start vertex.
            </summary>
            <example>
            <!-- No matching elements were found for the following include tag --><include file="IncludeExamples.xml" path="Comments/Codes[@id=&quot;NCDK.Graphs.AllPairsShortestPaths_Example.cs+From_int&quot;]/*" />
            </example>
            <param name="start">the start vertex of the path</param>
            <returns>The shortest paths from the given state vertex</returns>
            <seealso cref="T:NCDK.Graphs.ShortestPaths" />
        </member>
        <member name="M:NCDK.Graphs.AllPairsShortestPaths.From(NCDK.IAtom)">
            <summary>
            Access the shortest paths object for provided start atom.
            </summary>
            <example>
            <code>                AllPairsShortestPaths apsp = new AllPairsShortestPaths(molecule);
                IAtom start = molecule.Atoms[0];
                IAtom end = molecule.Atoms[1];

                // access explicitly
                ShortestPaths sp = apsp.From(start);
                
                 // or chain the method calls together
                
                 // first path from start to end atom
                 int[] path = apsp.From(start).GetPathTo(end);
                
                 // first atom path from start to end atom
                 IAtom[] atoms = apsp.From(start).GetAtomsTo(end);
</code>
            </example>
            <param name="start">the start atom of the path</param>
            <returns>The shortest paths from the given state vertex</returns>
            <seealso cref="T:NCDK.Graphs.ShortestPaths" />
        </member>
        <member name="F:NCDK.Graphs.AllPairsShortestPaths.EMPTY_CONTAINER">
            <summary>
            an empty atom container so we can handle invalid vertices/atoms better.
            Not very pretty but we can't access the domain model from cdk-core.
            </summary>
        </member>
        <member name="F:NCDK.Graphs.AllPairsShortestPaths.EMPTY_SHORTEST_PATHS">
            <summary>
            pseudo shortest-paths - when an invalid atom is given. this will always
            return 0 .Length paths and distances.
            </summary>
        </member>
        <member name="T:NCDK.Graphs.ConnectedComponents">
            <summary>
            Compute the connected components of an adjacency list.
            </summary>
            <example>
            <code>            int[][] g = GraphUtil.ToAdjList(container);
            ConnectedComponents cc = new ConnectedComponents(g);
            int[] components = cc.Components();
            for (int v = 0; v &lt; g.Length; v++)
                Console.WriteLine(components[v]);
</code>
            </example>
        </member>
        <member name="F:NCDK.Graphs.ConnectedComponents.g">
            <summary>Adjacency-list representation of a graph.</summary>
        </member>
        <member name="F:NCDK.Graphs.ConnectedComponents.component">
            <summary>Stores the component of each vertex.</summary>
        </member>
        <member name="F:NCDK.Graphs.ConnectedComponents.components">
            <summary>The number of components.</summary>
        </member>
        <member name="F:NCDK.Graphs.ConnectedComponents.remaining">
            <summary>The number remaining vertices.</summary>
        </member>
        <member name="M:NCDK.Graphs.ConnectedComponents.#ctor(System.Int32[][])">
            <summary>
            Compute the connected components of an adjacency list, <paramref name="g"/>.
            </summary>
            <param name="g">graph (adjacency list representation)</param>
        </member>
        <member name="M:NCDK.Graphs.ConnectedComponents.Visit(System.Int32,System.Int32)">
            <summary>
            Visit a vertex and mark it a member of component <paramref name="c"/>.
            </summary>
            <param name="v">vertex</param>
            <param name="c">component</param>
        </member>
        <member name="M:NCDK.Graphs.ConnectedComponents.Components">
            <summary>
            Access the components each vertex belongs to.
            </summary>
            <returns>component labels</returns>
        </member>
        <member name="T:NCDK.Graphs.PathTools">
            <summary>
            Tools class with methods for handling molecular graphs.
            </summary>
        </member>
        <member name="F:NCDK.Graphs.PathTools.CanDebug">
            <summary>bool with which debugging can be turned on.</summary>
        </member>
        <member name="M:NCDK.Graphs.PathTools.GetInt2DColumnSum(System.Int32[][])">
            <summary>
            Sums up the columns in a 2D int matrix.
            </summary>
            <param name="apsp">The 2D int matrix</param>
            <returns>A 1D matrix containing the column sum of the 2D matrix</returns>
        </member>
        <member name="M:NCDK.Graphs.PathTools.ComputeFloydAPSP(System.Int32[][])">
            <summary>
            All-Pairs-Shortest-Path computation based on Floyd's
            algorithm <token>cdk-cite-FLO62</token>. It takes an nxn
            matrix C of edge costs and produces an nxn matrix A of lengths of shortest paths.
            </summary>
            <param name="costMatrix">edge cost matrix</param>
            <returns>the topological distance matrix</returns>
        </member>
        <member name="M:NCDK.Graphs.PathTools.ComputeFloydAPSP(System.Double[][])">
            <summary>
            All-Pairs-Shortest-Path computation based on Floyd's
            algorithm <token>cdk-cite-FLO62</token>. It takes an nxn
            matrix C of edge costs and produces an nxn matrix A of lengths of shortest
            paths.
            </summary>
            <param name="costMatrix">edge cost matrix</param>
            <returns>the topological distance matrix</returns>
        </member>
        <member name="M:NCDK.Graphs.PathTools.DepthFirstTargetSearch(NCDK.IAtomContainer,NCDK.IAtom,NCDK.IAtom,NCDK.IAtomContainer)">
            <summary>
            Recursively performs a depth first search in a molecular graphs contained in
            the AtomContainer molecule, starting at the root atom and returning when it
            hits the target atom.
            <para>
            CAUTION: This recursive method sets the VISITED flag of each atom
            does not reset it after finishing the search. If you want to do the
            operation on the same collection of atoms more than once, you have
            to set all the VISITED flags to false before each operation
            by looping of the atoms and doing a
            "atom.Flag = (CDKConstants.VISITED, false);"
            </para>
            <para>
            Note that the path generated by the search will not contain the root atom,
            but will contain the target atom
            </para>
            </summary>
            <param name="molecule">The AtomContainer to be searched</param>
            <param name="root">The root atom to start the search at</param>
            <param name="target">The target</param>
            <param name="path">An AtomContainer to be filled with the path</param>
            <returns><see langword="true"/> if the target atom was found during this function call</returns>
        </member>
        <member name="M:NCDK.Graphs.PathTools.BreadthFirstSearch(NCDK.IAtomContainer,System.Collections.Generic.IEnumerable{NCDK.IAtom},NCDK.IAtomContainer)">
            <summary>
            Performs a BreadthFirstSearch in an AtomContainer starting with a
            particular sphere, which usually consists of one start atom. While
            searching the graph, the method marks each visited atom. It then puts all
            the atoms connected to the atoms in the given sphere into a new vector
            which forms the sphere to search for the next recursive method call. All
            atoms that have been visited are put into a molecule container. This
            BreadthFirstSearch does thus find the connected graph for a given start
            atom.
            </summary>
            <param name="atomContainer">The AtomContainer to be searched</param>
            <param name="sphere">A sphere of atoms to start the search with</param>
            <param name="molecule">A molecule into which all the atoms and bonds are stored that are found during search</param>
        </member>
        <member name="M:NCDK.Graphs.PathTools.FindClosestByBond(NCDK.IAtomContainer,NCDK.IAtom,System.Int32)">
            <summary>
            Returns the atoms which are closest to an atom in an AtomContainer by bonds.
            If number of atoms in or below sphere x&lt;max and number of atoms in or below sphere x+1&gt;max then
            atoms in or below sphere x+1 are returned.
            </summary>
            <param name="atomContainer">The AtomContainer to examine</param>
            <param name="atom">the atom to start from</param>
            <param name="max">the number of neighbours to return</param>
            <returns> the average bond length</returns>
        </member>
        <member name="M:NCDK.Graphs.PathTools.BreadthFirstSearch(NCDK.IAtomContainer,System.Collections.Generic.IEnumerable{NCDK.IAtom},NCDK.IAtomContainer,System.Int32)">
            <summary>
            Performs a BreadthFirstSearch in an AtomContainer starting with a
            particular sphere, which usually consists of one start atom. While
            searching the graph, the method marks each visited atom. It then puts all
            the atoms connected to the atoms in the given sphere into a new vector
            which forms the sphere to search for the next recursive method call. All
            atoms that have been visited are put into a molecule container. This
            BreadthFirstSearch does thus find the connected graph for a given start
            atom.
            <para>IMPORTANT: this method does not reset the VISITED flags, which must be
            done if calling this method twice!
            </para>
            </summary>
            <param name="atomContainer">The AtomContainer to be searched</param>
            <param name="sphere">A sphere of atoms to start the search with</param>
            <param name="molecule">A molecule into which all the atoms and bonds are stored that are found during search</param>
            <param name="max">max</param>
        </member>
        <member name="M:NCDK.Graphs.PathTools.BreadthFirstTargetSearch(NCDK.IAtomContainer,System.Collections.Generic.IEnumerable{NCDK.IAtom},NCDK.IAtom,System.Int32,System.Int32)">
            <summary>
            Performs a BreadthFirstTargetSearch in an AtomContainer starting with a
            particular sphere, which usually consists of one start atom. While
            searching the graph, the method marks each visited atom. It then puts all
            the atoms connected to the atoms in the given sphere into a new vector
            which forms the sphere to search for the next recursive method call.
            The method keeps track of the sphere count and returns it as soon
            as the target atom is encountered.
            </summary>
            <param name="atomContainer">The AtomContainer in which the path search is to be performed.</param>
            <param name="sphere">The sphere of atoms to start with. Usually just the starting atom</param>
            <param name="target">The target atom to be searched</param>
            <param name="pathLength">The current path length, incremented and passed in recursive calls. Call this method with "zero".</param>
            <param name="cutOff">Stop the path search when this cutOff sphere count has been reatomContainerhed</param>
            <returns>The shortest path between the starting sphere and the target atom</returns>
        </member>
        <member name="M:NCDK.Graphs.PathTools.GetMolecularGraphRadius(NCDK.IAtomContainer)">
            <summary>
            Returns the radius of the molecular graph.
            </summary>
            <param name="atomContainer">The molecule to consider</param>
            <returns>The topological radius</returns>
        </member>
        <member name="M:NCDK.Graphs.PathTools.GetMolecularGraphDiameter(NCDK.IAtomContainer)">
            <summary>
            Returns the diameter of the molecular graph.
            </summary>
            <param name="atomContainer">The molecule to consider</param>
            <returns>The topological diameter</returns>
        </member>
        <member name="M:NCDK.Graphs.PathTools.GetVertexCountAtDistance(NCDK.IAtomContainer,System.Int32)">
            <summary>
            Returns the number of vertices that are a distance 'd' apart.
            <para>In this method, d is the topological distance (ie edge count).</para>
            </summary>
            <param name="atomContainer">The molecule to consider</param>
            <param name="distance">The distance to consider</param>
            <returns>The number of vertices</returns>
        </member>
        <member name="M:NCDK.Graphs.PathTools.GetShortestPath(NCDK.IAtomContainer,NCDK.IAtom,NCDK.IAtom)">
            <summary>
            Returns a list of atoms in the shortest path between two atoms.
            <para>This method uses the Djikstra algorithm to find all the atoms in the shortest
            path between the two specified atoms. The start and end atoms are also included
            in the path returned</para>
            </summary>
            <remarks>This implementation recalculates all shortest paths from the start atom
            for each method call and does not indicate if there are equally short paths
            from the start to the end. Replaced by <see cref="M:NCDK.Graphs.ShortestPaths.GetAtomsTo(NCDK.IAtom)"/></remarks>
            <param name="atomContainer">The molecule to search in</param>
            <param name="start">The starting atom</param>
            <param name="end">The ending atom</param>
            <returns>A <see cref="T:System.Collections.Generic.IList`1"/> containing the atoms in the shortest path between <paramref name="start"/> and
            <paramref name="end"/> inclusive</returns>
            <seealso cref="T:NCDK.Graphs.ShortestPaths"/>
            <seealso cref="M:NCDK.Graphs.ShortestPaths.GetAtomsTo(NCDK.IAtom)"/>
            <seealso cref="T:NCDK.Graphs.AllPairsShortestPaths"/>
        </member>
        <member name="M:NCDK.Graphs.PathTools.GetAllPaths(NCDK.IAtomContainer,NCDK.IAtom,NCDK.IAtom)">
            <summary>
            Get a list of all the paths between two atoms.
            <para>
            If the two atoms are the same an empty list is returned. Note that this problem
            is NP-hard and so can take a long time for large graphs.</para>
            </summary>
            <param name="atomContainer">The molecule to consider</param>
            <param name="start">The starting Atom of the path</param>
            <param name="end">The ending Atom of the path</param>
            <returns>A <see cref="T:System.Collections.Generic.IList`1"/> containing all the paths between the specified atoms</returns>
        </member>
        <member name="M:NCDK.Graphs.PathTools.GetPathsOfLength(NCDK.IAtomContainer,NCDK.IAtom,System.Int32)">
            <summary>
            Get the paths starting from an atom of specified length.
            <para>This method returns a set of paths. Each path is a <see cref="T:System.Collections.Generic.IList`1"/> that make up the path (ie they are sequentially connected).</para>
            </summary>
            <param name="atomContainer">The molecule to consider</param>
            <param name="start">The starting atom</param>
            <param name="length">The length of paths to look for</param>
            <returns>A <see cref="T:System.Collections.Generic.IList`1"/> of <see cref="T:System.Collections.Generic.IList`1"/> of <see cref="T:NCDK.IAtom"/> containing the paths found</returns>
        </member>
        <member name="M:NCDK.Graphs.PathTools.GetPathsOfLengthUpto(NCDK.IAtomContainer,NCDK.IAtom,System.Int32)">
            <summary>
            Get all the paths starting from an atom of length 0 upto the specified length.
            <para>This method returns a set of paths. Each path is a <see cref="T:System.Collections.Generic.IList`1"/> of atoms that make up the path (ie they are sequentially connected).</para>
            </summary>
            <param name="atomContainer">The molecule to consider</param>
            <param name="start">The starting atom</param>
            <param name="length">The maximum length of paths to look for</param>
            <returns>A <see cref="T:System.Collections.Generic.IList`1"/> of <see cref="T:System.Collections.Generic.IList`1"/> of <see cref="T:NCDK.IAtom"/> containing the paths found</returns>
        </member>
        <member name="M:NCDK.Graphs.PathTools.GetLimitedPathsOfLengthUpto(NCDK.IAtomContainer,NCDK.IAtom,System.Int32,System.Int32)">
            <summary>
            Get all the paths starting from an atom of length 0 up to the specified
            length. If the number of paths exceeds the the set <paramref name="limit"/> then an
            exception is thrown. <p/> This method returns a set of paths. Each path
            is a <see cref="T:System.Collections.Generic.IList`1"/> of <see cref="T:NCDK.IAtom"/> that make up the path (ie they are
            sequentially connected).
            </summary>
            <param name="atomContainer">The molecule to consider</param>
            <param name="start">The starting atom</param>
            <param name="length">The maximum length of paths to look for</param>
            <param name="limit">Limit the number of paths - thrown an exception if exceeded</param>
            <returns>A <see cref="T:System.Collections.Generic.IList`1"/> of <see cref="T:System.Collections.Generic.IList`1"/> of <see cref="T:NCDK.IAtom"/> containing the paths found</returns>
            <exception cref="T:NCDK.CDKException">if the number of paths generated was larger than the limit.</exception>
        </member>
        <member name="T:NCDK.Graphs.SpanningTree">
            <summary>
            Spanning tree of a molecule.
            Used to discover the number of cyclic bonds in order to prevent the
            inefficient AllRingsFinder to run for too long.
            </summary>
        </member>
        <member name="P:NCDK.Graphs.SpanningTree.IsDisconnected">
            <summary>
            Is the molecule disconnected and has more then one component.
            </summary>
            <returns>the molecule is disconnected</returns>
        </member>
        <member name="M:NCDK.Graphs.SpanningTree.#ctor(NCDK.IAtomContainer)">
            <summary>
            Create a new spanning tree for the provided molecule.
            </summary>
            <param name="atomContainer">molecule to make a spanning tree for.</param>
        </member>
        <member name="M:NCDK.Graphs.SpanningTree.BuildSpanningTree(NCDK.IAtomContainer)">
            <summary>
            Kruskal algorithm
            </summary>
        </member>
        <member name="M:NCDK.Graphs.SpanningTree.GetSpanningTree">
            <summary>
            Access the computed spanning tree of the input molecule.
            </summary>
            <returns>acyclic tree of the input molecule</returns>
        </member>
        <member name="M:NCDK.Graphs.SpanningTree.GetPath(NCDK.IAtomContainer,NCDK.IAtom,NCDK.IAtom)">
            <summary>
            Find a path connected <i>a1</i> and <i>a2</i> in the tree. If there was
            an edge between <i>a1</i> and <i>a2</i> this path is a cycle.
            </summary>
            <param name="spt">spanning tree</param>
            <param name="atom1">start of path (source)</param>
            <param name="atom2">end of path (target)</param>
            <returns>a path through the spanning tree from the source to the target</returns>
            <exception cref="T:NCDK.NoSuchAtomException">if the atom is not in the spanning tree</exception>
        </member>
        <member name="M:NCDK.Graphs.SpanningTree.GetBasicRings">
            <summary>
            The basic rings of the spanning tree. Using the pruned edges, return any path
            which connects the end points of the pruned edge in the tree. These paths form
            cycles.
            </summary>
            <returns>basic rings</returns>
            <exception cref="T:NCDK.NoSuchAtomException">atoms not found in the molecule</exception>
        </member>
        <member name="M:NCDK.Graphs.SpanningTree.GetCyclicFragmentsContainer">
            <summary>
            Returns an IAtomContainer which contains all the atoms and bonds which
            are involved in ring systems.
            </summary>
            <seealso cref="M:NCDK.Graphs.SpanningTree.GetAllRings"/>
            <seealso cref="M:NCDK.Graphs.SpanningTree.GetBasicRings"/>
            <returns>the IAtomContainer as described above</returns>
        </member>
        <member name="M:NCDK.Graphs.SpanningTree.IdentifyBonds">
            <summary>
            Identifies whether bonds are cyclic or not. It is used by several other methods.
            </summary>
        </member>
        <member name="M:NCDK.Graphs.SpanningTree.GetAllRings">
            <summary>
            All basic rings and the all pairs of basic rings share at least one edge combined.
            </summary>
            <returns>subset of all rings</returns>
            <exception cref="T:NCDK.NoSuchAtomException">atom was not found in the molecule</exception>
            <seealso cref="M:NCDK.Graphs.SpanningTree.GetBasicRings"/>
        </member>
        <member name="M:NCDK.Graphs.SpanningTree.GetSpanningTreeSize">
            <summary>
            Size of the spanning tree specified as the number of edges in the tree.
            </summary>
            <returns>number of edges in the spanning tree</returns>
        </member>
        <member name="M:NCDK.Graphs.SpanningTree.GetBondsAcyclicCount">
            <summary>
            Number of acyclic bonds.
            </summary>
            <returns>Returns the bondsAcyclicCount.</returns>
        </member>
        <member name="M:NCDK.Graphs.SpanningTree.GetBondsCyclicCount">
            <summary>
            Number of cyclic bonds.
            </summary>
            <returns>Returns the bondsCyclicCount.</returns>
        </member>
        <member name="T:NCDK.Graphs.AtomContainerAtomPermutor">
            <summary>
            An atom container atom permutor that uses ranking and unranking to calculate
            the next permutation in the series.
            </summary>
            <example>
            <!-- No matching elements were found for the following include tag --><include file="IncludeExamples.xml" path="Comments/Codes[@id=&quot;NCDK.Graphs.AtomContainerAtomPermutor.cs&quot;]/*" />
            </example>
        </member>
        <member name="M:NCDK.Graphs.AtomContainerAtomPermutor.#ctor(NCDK.IAtomContainer)">
            <summary>
            A permutor wraps the original atom container, and produces cloned
            (and permuted!) copies on demand.
            </summary>
            <param name="atomContainer">the atom container to permute</param>
        </member>
        <member name="M:NCDK.Graphs.AtomContainerAtomPermutor.ContainerFromPermutation(System.Int32[])">
            <summary>
            Generate the atom container with this permutation of the atoms.
            </summary>
            <param name="permutation">the permutation to use</param>
            <returns></returns>
        </member>
        <member name="T:NCDK.Graphs.AtomContainerBondPermutor">
            <summary>
            This class allows the user to iterate through the set of all possible
            permutations of the bond order in a given atom container. This provides a
            means to check the dependency of an algorithm's results on the bond order of
            the input atom container.
            </summary>
            <example>
            <code>            AtomContainerBondPermutor permutor = new AtomContainerBondPermutor(container);
            while (permutor.MoveNext())
            {
                IAtomContainer permutedContainer = permutor.Current;
                // ...
            }
</code>
            </example>
        </member>
        <member name="M:NCDK.Graphs.AtomContainerBondPermutor.#ctor(NCDK.IAtomContainer)">
            <summary>
            A permutor wraps the original atom container, and produces cloned
            (and permuted!) copies on demand.
            </summary>
            <param name="atomContainer">the atom container to permute</param>
        </member>
        <member name="M:NCDK.Graphs.AtomContainerBondPermutor.ContainerFromPermutation(System.Int32[])">
            <seealso cref="M:NCDK.Graphs.AtomContainerPermutor.ContainerFromPermutation(System.Int32[])"/>
        </member>
        <member name="T:NCDK.Graphs.AtomContainerPermutor">
            <summary>
            The base class for permutors of atom containers, with a single abstract
            method <see cref="M:NCDK.Graphs.AtomContainerPermutor.ContainerFromPermutation(System.Int32[])"/> that should be implemented in
            concrete derived classes.
            </summary>
        </member>
        <member name="F:NCDK.Graphs.AtomContainerPermutor.atomContainer">
            <summary>
            The atom container that is permuted at each step.
            </summary>
        </member>
        <member name="M:NCDK.Graphs.AtomContainerPermutor.#ctor(System.Int32,NCDK.IAtomContainer)">
            <summary>
            Start the permutor off with an initial atom container, and the size of
            the permutation.
            </summary>
            <param name="size"></param>
            <param name="atomContainer"></param>
        </member>
        <member name="M:NCDK.Graphs.AtomContainerPermutor.ContainerFromPermutation(System.Int32[])">
            <summary>
            Convert a permutation (expressed as a list of numbers) into a permuted
            atom container. This will differ depending on the desired effect of the
            permutation (atoms or bonds, for example).
            </summary>
            <returns>the atom container corresponding to this permutation</returns>
        </member>
        <member name="M:NCDK.Graphs.AtomContainerPermutor.RandomNext">
            <summary>
            Get a new container, but randomly skip forwards in the list of possible
            permutations to generate it.
            </summary>
            <returns>a random next permuted atom container</returns>
        </member>
        <member name="T:NCDK.Graphs.ConnectivityChecker">
            <summary>
            Tool class for checking whether the (sub)structure in an <see cref="T:NCDK.IAtomContainer" /> is connected.
            </summary>
            <example>
            To check whether an <see cref="T:NCDK.IAtomContainer" /> is connected this code
            can be used:
            <code>            bool isConnected = ConnectivityChecker.IsConnected(container);
</code>
            A disconnected AtomContainer can be fragmented into connected
            fragments by using code like:
            <code>            var fragments = ConnectivityChecker.PartitionIntoMolecules(disconnectedContainer);
            int fragmentCount = fragments.Count;
</code>
            </example>
        </member>
        <member name="M:NCDK.Graphs.ConnectivityChecker.IsConnected(NCDK.IAtomContainer)">
            <summary>
            Check whether a set of atoms in an <see cref="T:NCDK.IAtomContainer"/> is connected.
            </summary>
            <param name="atomContainer">The <see cref="T:NCDK.IAtomContainer"/> to be check for connectedness</param>
            <returns>true if the <see cref="T:NCDK.IAtomContainer"/> is connected</returns>
        </member>
        <member name="M:NCDK.Graphs.ConnectivityChecker.PartitionIntoMolecules(NCDK.IAtomContainer)">
            <summary>
            Partitions the atoms in an <see cref="T:NCDK.IAtomContainer"/> into covalently connected components.
            </summary>
            <param name="container">The <see cref="T:NCDK.IAtomContainer"/> to be partitioned into connected components, i.e. molecules</param>
            <returns>A MoleculeSet.</returns>
        </member>
        <member name="T:NCDK.Graphs.EdmondsMaximumMatching">
            <summary>
            Maximum matching in general graphs using Edmond's Blossom Algorithm
            <token>cdk-cite-Edmonds65</token>. <p/>
            </summary>
            <remarks>
            This implementation was adapted from D Eppstein's python implementation 
            (<see href="http://www.ics.uci.edu/~eppstein/PADS/CardinalityMatching.py">src</see>)
            providing efficient tree traversal and handling of blossoms.
            <see href="http://en.wikipedia.org/wiki/Blossom_algorithm">Blossom algorithm, Wikipedia</see>
            <see href="http://research.microsoft.com/apps/video/dl.aspx?id=171055">Presentation from Vazirani on his and Micali O(|E| * Sqrt(|V|)) algorithm</see>
            </remarks>
        </member>
        <member name="F:NCDK.Graphs.EdmondsMaximumMatching.graph">
            <summary>The graph we are matching on.</summary>
        </member>
        <member name="F:NCDK.Graphs.EdmondsMaximumMatching.matching">
            <summary>The current matching.</summary>
        </member>
        <member name="F:NCDK.Graphs.EdmondsMaximumMatching.subset">
            <summary>Subset of vertices to be matched.</summary>
        </member>
        <member name="F:NCDK.Graphs.EdmondsMaximumMatching.even">
            <summary>Storage of the forest, even and odd levels</summary>
        </member>
        <member name="F:NCDK.Graphs.EdmondsMaximumMatching.odd">
            <summary>Storage of the forest, even and odd levels</summary>
        </member>
        <member name="F:NCDK.Graphs.EdmondsMaximumMatching.NIL">
            <summary>Special 'nil' vertex.</summary>
        </member>
        <member name="F:NCDK.Graphs.EdmondsMaximumMatching.queue">
            <summary>Queue of 'even' (free) vertices to start paths from.</summary>
        </member>
        <member name="F:NCDK.Graphs.EdmondsMaximumMatching.dsf">
            <summary>Union-Find to store blossoms.</summary>
        </member>
        <member name="F:NCDK.Graphs.EdmondsMaximumMatching.bridges">
            <summary>
            IDictionary stores the bridges of the blossom - indexed by with support vertices.
            </summary>
        </member>
        <member name="F:NCDK.Graphs.EdmondsMaximumMatching.path">
            <summary>Temporary array to fill with path information.</summary>
        </member>
        <member name="F:NCDK.Graphs.EdmondsMaximumMatching.vAncestors">
            <summary>
            Temporary bit sets when walking down 'trees' to check for paths/blossoms.
            </summary>
        </member>
        <member name="F:NCDK.Graphs.EdmondsMaximumMatching.wAncestors">
            <summary>
            Temporary bit sets when walking down 'trees' to check for paths/blossoms.
            </summary>
        </member>
        <member name="M:NCDK.Graphs.EdmondsMaximumMatching.#ctor(System.Int32[][],NCDK.Graphs.Matching,System.Collections.BitArray)">
            <summary>
            Internal constructor.
            </summary>
            <param name="graph">adjacency list graph representation</param>
            <param name="matching">the matching of the graph</param>
            <param name="subset">subset a subset of vertices</param>
        </member>
        <member name="M:NCDK.Graphs.EdmondsMaximumMatching.ExistAugmentingPath">
            <summary>
            Find an augmenting path an alternate it's matching. If an augmenting path
            was found then the search must be restarted. If a blossom was detected
            the blossom is contracted and the search continues.
            </summary>
            <returns>an augmenting path was found</returns>
        </member>
        <member name="M:NCDK.Graphs.EdmondsMaximumMatching.Check(System.Int32,System.Int32)">
            <summary>
            An edge was found which connects two 'even' vertices in the forest. If
            the vertices have the same root we have a blossom otherwise we have
            identified an augmenting path. This method checks for these cases and
            responds accordingly. 
            </summary>
            <remarks>
            If an augmenting path was found - then it's edges are alternated and the
            method returns true. Otherwise if a blossom was found - it is contracted
            and the search continues.
            </remarks>
            <param name="v">endpoint of an edge</param>
            <param name="w">another endpoint of an edge</param>
            <returns>a path was augmented</returns>
        </member>
        <member name="M:NCDK.Graphs.EdmondsMaximumMatching.GetNExtEvenVertex(System.Collections.BitArray,System.Int32)">
            <summary>
            Access the next ancestor in a tree of the forest. Note we go back two
            places at once as we only need check 'even' vertices.
            </summary>
            <param name="ancestors">temporary set which fills up the path we traversed</param>
            <param name="curr">the current even vertex in the tree</param>
            <returns>the next 'even' vertex</returns>
        </member>
        <member name="M:NCDK.Graphs.EdmondsMaximumMatching.CreatebBlossom(System.Int32,System.Int32,System.Int32)">
            <summary>
            Create a new blossom for the specified 'bridge' edge.
            </summary>
            <param name="v">adjacent to w</param>
            <param name="w">adjacent to v</param>
            <param name="base_">connected to the stem (common ancestor of <paramref name="v"/> and <paramref name="w"/>)</param>
        </member>
        <member name="M:NCDK.Graphs.EdmondsMaximumMatching.BlossomSupports(System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates the blossom 'supports' for the specified blossom 'bridge' edge
            (<paramref name="v"/>, <paramref name="w"/>). We travel down each side to the base of the blossom ('<paramref name="base_"/>')
            collapsing vertices and point any 'odd' vertices to the correct 'bridge'
            edge. We do this by indexing the birdie to each vertex in the 'bridges'
            map.
            </summary>
            <param name="v">an endpoint of the blossom bridge</param>
            <param name="w">another endpoint of the blossom bridge</param>
            <param name="base_">the base of the blossom</param>
        </member>
        <member name="M:NCDK.Graphs.EdmondsMaximumMatching.Augment(System.Int32)">
            <summary>
            Augment all ancestors in the tree of vertex 'v'.
            </summary>
            <param name="v">the leaf to augment from</param>
        </member>
        <member name="M:NCDK.Graphs.EdmondsMaximumMatching.BuildPath(System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Builds the path backwards from the specified 'start' vertex until the
            'goal'. If the path reaches a blossom then the path through the blossom
            is lifted to the original graph.
            </summary>
            <param name="path">path storage</param>
            <param name="i">offset (in path)</param>
            <param name="start">start vertex</param>
            <param name="goal">end vertex</param>
            <returns>the number of items set to the path[].</returns>
        </member>
        <member name="M:NCDK.Graphs.EdmondsMaximumMatching.Reverse(System.Int32[],System.Int32,System.Int32)">
            <summary>
            Reverse a section of a fixed size array.
            </summary>
            <param name="path">a path</param>
            <param name="i">start index</param>
            <param name="j">end index</param>
        </member>
        <member name="M:NCDK.Graphs.EdmondsMaximumMatching.Maxamise(NCDK.Graphs.Matching,System.Int32[][],System.Collections.BitArray)">
            <summary>
            Attempt to maximise the provided matching over a subset of vertices in a
            graph.
            </summary>
            <param name="matching">the independent edge set to maximise</param>
            <param name="graph">adjacency list graph representation</param>
            <param name="subset">subset of vertices</param>
            <returns>the matching</returns>
        </member>
        <member name="T:NCDK.Graphs.EdmondsMaximumMatching.Tuple">
            <summary>
            Storage and indexing of a two int values.
            </summary>
        </member>
        <member name="P:NCDK.Graphs.EdmondsMaximumMatching.Tuple.First">
            <summary>Values.</summary>
        </member>
        <member name="M:NCDK.Graphs.EdmondsMaximumMatching.Tuple.#ctor(System.Int32,System.Int32)">
            <summary>
            Create a new tuple.
            </summary>
            <param name="first">a value</param>
            <param name="second">another value</param>
        </member>
        <member name="M:NCDK.Graphs.EdmondsMaximumMatching.Tuple.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Graphs.EdmondsMaximumMatching.Tuple.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Graphs.Canon.MorganNumbersTools">
            <summary>
            Compute the extended connectivity values (Morgan Numbers) <token>cdk-cite-MOR65</token>.
            The tool does not produce the lexicographic smallest labelling on the graph
            and should not be used as a robust canonical labelling tool. To canonical
            label a graph please use <see cref="T:NCDK.Graphs.Invariant.InChINumbersTools"/> or <see cref="T:NCDK.Graphs.Invariant.CanonicalLabeler"/>.
            To determine equivalent classes of atoms please use <see cref="T:NCDK.Graphs.Invariant.HuLuIndexTool"/>
            or one of the discrete refines available in the 'cdk-group'
            module.
            </summary>
            <seealso cref="T:NCDK.Graphs.Invariant.InChINumbersTools"/>
            <seealso cref="T:NCDK.Graphs.Invariant.CanonicalLabeler"/>
            <seealso cref="T:NCDK.Graphs.Invariant.HuLuIndexTool"/>
        </member>
        <member name="F:NCDK.Graphs.Canon.MorganNumbersTools.InitialDegree">
            <summary>Default size of adjacency lists.</summary>
        </member>
        <member name="M:NCDK.Graphs.Canon.MorganNumbersTools.GetMorganNumbers(NCDK.IAtomContainer)">
            <summary>
            Makes an array containing the morgan numbers of the atoms of
            atomContainer. These number are the extended connectivity values and not
            the lexicographic smallest labelling on the graph.
            </summary>
            <param name="molecule">the molecule to analyse.</param>
            <returns>The morgan numbers value.</returns>
        </member>
        <member name="M:NCDK.Graphs.Canon.MorganNumbersTools.GetMorganNumbersWithElementSymbol(NCDK.IAtomContainer)">
            <summary>
            Makes an array containing the morgan numbers+element symbol of the atoms
            of <paramref name="atomContainer"/>. This method puts the element symbol before the
            morgan number, useful for finding out how many different rests are
            connected to an atom.
            </summary>
            <param name="atomContainer">The atomContainer to analyse.</param>
            <returns>The morgan numbers value.</returns>
        </member>
        <member name="T:NCDK.Graphs.Matching">
            <summary>
            A matching is an independent edge set of a graph. This is a set of edges that
            share no common vertices. A matching is perfect if every vertex in the graph
            is matched. Each vertex can be matched with exactly one other vertex.
            <para>
            This class provides storage and manipulation of a matching. A new match is
            added with <see cref="M:NCDK.Graphs.Matching.Match(System.Int32,System.Int32)"/>, any existing match for the newly matched
            vertices is no-longer available. The status of a vertex can be queried with
            <see cref="M:NCDK.Graphs.Matching.Matched(System.Int32)"/>  and the matched vertex obtained with <see cref="M:NCDK.Graphs.Matching.Other(System.Int32)"/>.
            </para>
            </summary>
            <seealso href="http://en.wikipedia.org/wiki/Matching_(graph_theory)">Matching (graph theory), Wikipedia</seealso>
        </member>
        <member name="F:NCDK.Graphs.Matching.NIL">
            <summary>Indicate an unmatched vertex.</summary>
        </member>
        <member name="F:NCDK.Graphs.Matching.match">
            <summary>Match storage.</summary>
        </member>
        <member name="M:NCDK.Graphs.Matching.#ctor(System.Int32)">
            <summary>
            Create a matching of the given size.
            </summary>
            <param name="n">number of items</param>
        </member>
        <member name="M:NCDK.Graphs.Matching.Match(System.Int32,System.Int32)">
            <summary>
            Add the edge '{<paramref name="u"/>, <paramref name="v"/>}' to the matched edge set. Any existing matches for
            <paramref name="u"/> or <paramref name="v"/> are removed from the matched set.
            </summary>
            <param name="u">a vertex</param>
            <param name="v">another vertex</param>
        </member>
        <member name="M:NCDK.Graphs.Matching.Other(System.Int32)">
            <summary>
            Access the vertex matched with 'v'.
            </summary>
            <param name="v">vertex</param>
            <returns>matched vertex</returns>
            <exception cref="T:System.ArgumentException">the vertex is currently unmatched</exception>
        </member>
        <member name="M:NCDK.Graphs.Matching.Unmatch(System.Int32)">
            <summary>
            Remove a matching for the specified vertex.
            </summary>
            <param name="v">vertex</param>
        </member>
        <member name="M:NCDK.Graphs.Matching.Matched(System.Int32)">
            <summary>
            Determine if a vertex has a match.
            </summary>
            <param name="v">vertex</param>
            <returns>the vertex is matched</returns>
        </member>
        <member name="M:NCDK.Graphs.Matching.Unmatched(System.Int32)">
            <summary>
            Determine if a vertex is not matched.
            </summary>
            <param name="v">a vertex</param>
            <returns>the vertex has no matching</returns>
        </member>
        <member name="M:NCDK.Graphs.Matching.Perfect(System.Int32[][],System.Collections.BitArray)">
            <summary>
            Attempt to augment the matching such that it is perfect over the subset
            of vertices in the provided graph.
            </summary>
            <param name="graph">adjacency list representation of graph</param>
            <param name="subset">subset of vertices</param>
            <returns>the matching was perfect</returns>
            <exception cref="T:System.ArgumentException">the graph was a different size to the matching capacity</exception>
        </member>
        <member name="M:NCDK.Graphs.Matching.ArbitaryMatching(System.Int32[][],System.Collections.BitArray)">
            <summary>
            Assign an arbitrary matching that covers the subset of vertices.
            </summary>
            <param name="graph">adjacency list representation of graph</param>
            <param name="subset">subset of vertices in the graph</param>
            <returns>the matching was perfect</returns>
        </member>
        <member name="M:NCDK.Graphs.Matching.WithCapacity(System.Int32)">
            <summary>
            Create an empty matching with the specified capacity.
            </summary>
            <param name="capacity">maximum number of vertices</param>
            <returns>empty matching</returns>
        </member>
        <member name="M:NCDK.Graphs.Matching.ToString">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Graphs.Permutor">
            <summary>
            General permutation generator, that uses orderly generation by ranking and
            unranking.
            </summary>
            <remarks>
            <para>
            The basic idea is that all permutations of length N can be ordered
            (lexicographically) like:<br/>
            0 [0, 1, 2]<br/>
            1 [0, 2, 1]<br/>
            2 [1, 0, 2]<br/>
            ...<br/>
            where the number to the left of each permutation is the <i>rank</i> - really
            just the index in this ordered list. The list is created on demand, by a
            process called <i>unranking</i> where the rank is converted to the
            permutation that appears at that point in the list.
            </para>
            <para>The algorithms used are from the book "Combinatorial Generation :
            Algorithms, Generation, and Search" (or C.A.G.E.S.) by D.L. Kreher and D.R.
            Stinson. CRC Press (18 Dec 1998). ISBN-13 : 978-0849339882.</para>
            </remarks>
        </member>
        <member name="P:NCDK.Graphs.Permutor.Rank">
            <summary>
            The current rank of the permutation to use
            </summary>
        </member>
        <member name="F:NCDK.Graphs.Permutor.maxRank">
            <summary>
            The maximum rank possible, given the size
            </summary>
        </member>
        <member name="F:NCDK.Graphs.Permutor.size">
            <summary>
            The number of objects to permute
            </summary>
        </member>
        <member name="F:NCDK.Graphs.Permutor.random">
            <summary>
            For accessing part of the permutation space
            </summary>
        </member>
        <member name="M:NCDK.Graphs.Permutor.#ctor(System.Int32)">
            <summary>
            Create a permutor that will generate permutations of numbers up to <paramref name="size"/>.
            </summary>
            <param name="size">the size of the permutations to generate</param>
        </member>
        <member name="M:NCDK.Graphs.Permutor.SetPermutation(System.Int32[])">
            <summary>
            Set the currently used permutation.
            </summary>
            <param name="permutation">the permutation to use, as an int array</param>
        </member>
        <member name="M:NCDK.Graphs.Permutor.GetRandomNextPermutation">
            <summary>
            Randomly skip ahead in the list of permutations.
            </summary>
            <returns>a permutation in the range (current, N!)</returns>
        </member>
        <member name="M:NCDK.Graphs.Permutor.GetNextPermutation">
            <summary>
            Get the next permutation in the list.
            </summary>
            <returns>the next permutation</returns>
        </member>
        <member name="M:NCDK.Graphs.Permutor.GetCurrentPermutation">
            <summary>
            Get the permutation that is currently being used.
            </summary>
            <returns>the permutation as an int array</returns>
        </member>
        <member name="M:NCDK.Graphs.Permutor.CalculateMaxRank">
            <summary>
            Calculate the max possible rank for permutations of N numbers.
            </summary>
            <returns>the maximum number of permutations</returns>
        </member>
        <member name="M:NCDK.Graphs.Permutor.RankPermutationLexicographically(System.Int32[])">
            <summary>
            Convert a permutation (in the form of an int array) into a 'rank' - which
            is just a single number that is the order of the permutation in a lexico-
            graphically ordered list.
            </summary>
            <param name="permutation">the permutation to use</param>
            <returns>the rank as a number</returns>
        </member>
        <member name="M:NCDK.Graphs.Permutor.UnrankPermutationLexicographically(System.Int32,System.Int32)">
            <summary>
            Performs the opposite to the rank method, producing the permutation that
            has the order <paramref name="rank"/> in the lexicographically ordered list.
            </summary>
            <remarks>
            As an implementation note, the algorithm assumes that the permutation is
            in the form [1,...N] not the more usual [0,...N-1] for a list of size N.
            This is why there is the final step of 'shifting' the permutation. The
            shift also reduces the numbers by one to make them array indices.
            </remarks>
            <param name="rank">the order of the permutation to generate</param>
            <param name="size">the length/size of the permutation</param>
            <returns>a permutation as an int array</returns>
        </member>
        <member name="T:NCDK.Graphs.Rebond.Bspt`1">
            <summary>
             BSP-Tree stands for Binary Space Partitioning Tree.
             The tree partitions n-dimensional space (in our case 3) into little
             boxes, facilitating searches for things which are *nearby*.
             For some useful background info, search the web for "bsp tree faq".
             Our application is somewhat simpler because we are storing points instead
             of polygons.
            </summary>
            <example>
            We are working with three dimensions. For the purposes of the Bspt code
             these dimensions are stored as 0, 1, or 2. Each node of the tree splits
             along the next dimension, wrapping around to 0.
            <code>
               mySplitDimension = (parentSplitDimension + 1) % 3;
            </code>
             A split value is stored in the node. Values which are ÔøΩÔøΩ splitValue are
             stored down the left branch. Values which are ÔøΩÔøΩ splitValue are stored
             down the right branch. When this happens, the search must proceed down
             both branches.
             Planar and crystalline substructures can generate values which are == along
             one dimension.
            </example>
            <remarks>
            <para>
            To get a good picture in your head, first think about it in one dimension,
             points on a number line. The tree just partitions the points.
             Now think about 2 dimensions. The first node of the tree splits the plane
             into two rectangles along the x dimension. The second level of the tree
             splits the subplanes (independently) along the y dimension into smaller
             rectangles. The third level splits along the x dimension.
             In three dimensions, we are doing the same thing, only working with
             3-d boxes.
             </para>
            Three enumerators are provided
            <list type="bullet">
               <item>EnumNear(Bspt.Tuple center, double distance)<br/>
                 returns all the points contained in of all the boxes which are within
                 distance from the center.</item>
               <item>EnumSphere(Bspt.Tuple center, double distance)<br/>
                 returns all the points which are contained within the sphere (inclusive)
                 defined by center + distance</item>
               <item>EnumHemiSphere(Bspt.Tuple center, double distance)<br/>
                 same as sphere, but only the points which are greater along the
                 x dimension</item>
            </list>
            </remarks>
        </member>
        <member name="T:NCDK.Graphs.Rebond.RebondTool">
            <summary>
            Provides tools to rebond a molecule from 3D coordinates only.
            The algorithm uses an efficient algorithm using a
            Binary Space Partitioning Tree (Bspt). It requires that the
            atom types are configured such that the covalent bond radii
            for all atoms are set. The AtomTypeFactory can be used for this.
            </summary>
            <seealso cref="T:NCDK.Graphs.Rebond.Bspt`1"/>
        </member>
        <member name="M:NCDK.Graphs.Rebond.RebondTool.Rebond(NCDK.IAtomContainer)">
            <summary>
            Rebonding using a Binary Space Partition Tree. Note, that any bonds
            defined will be deleted first. It assumes the unit of 3D space to
            be 1 ‚Ñ´.
            </summary>
        </member>
        <member name="M:NCDK.Graphs.Rebond.RebondTool.BondAtom(NCDK.IAtomContainer,NCDK.IAtom)">
            <summary>
            Rebonds one atom by looking up nearby atom using the binary space partition tree.
            </summary>
        </member>
        <member name="M:NCDK.Graphs.Rebond.RebondTool.IsBonded(System.Double,System.Double,System.Double)">
            <summary>
            Returns the bond order for the bond. At this moment, it only returns
            0 or 1, but not 2 or 3, or aromatic bond order.
            </summary>
        </member>
        <member name="T:NCDK.Groups.AtomContainerDiscretePartitionRefiner">
            <summary>
            A tool for determining the automorphism group of the atoms in a molecule, or
            for checking for a canonical form of a molecule.
            </summary>
            <example>
            If two atoms are equivalent under an automorphism in the group, then
            roughly speaking they are in symmetric positions in the molecule. For
            example, the C atoms in two methyl groups attached to a benzene ring
            are 'equivalent' in this sense.
            <para>There are a couple of ways to use it - firstly, get the automorphisms.</para>
            <code>
                IAtomContainer ac = ... // get an atom container somehow
                AtomContainerDiscretePartitionRefiner refiner =
                     PartitionRefinement.forAtoms().create()
                PermutationGroup autG = refiner.getAutomorphismGroup(ac);
                for (Permutation automorphism : autG.all()) {
                    ... // do something with the permutation
                }
            </code>
            
            <para>Another is to check an atom container to see if it is canonical:</para>
            
            <code>
                IAtomContainer ac = ... // get an atom container somehow
                AtomContainerDiscretePartitionRefiner refiner =
                     PartitionRefinement.forAtoms().create()
                if (refiner.isCanonical(ac)) {
                    ... // do something with the atom container
                }
            </code>
            
            Note that it is not necessary to call <see cref="M:NCDK.Groups.AtomContainerDiscretePartitionRefiner.Refine(NCDK.IAtomContainer)"/> before
            either of these methods. However if both the group and the canonical check
            are required, then the code should be:
            
            <code>
                AtomContainerDiscretePartitionRefiner refiner =
                     PartitionRefinement.forAtoms().create()
                refiner.refine(ac);
                boolean isCanon = refiner.isCanonical();
                PermutationGroup autG = refiner.getAutomorphismGroup();
            </code>
            
            This way, the refinement is not carried out multiple times.
            </example>
        </member>
        <member name="M:NCDK.Groups.AtomContainerDiscretePartitionRefiner.Refine(NCDK.IAtomContainer)">
            <summary>
            Refine an atom container, which has the side effect of calculating
            the automorphism group.
            </summary>
            <remarks>
            If the group is needed afterwards, call <see cref="M:NCDK.Groups.DiscretePartitionRefiner.GetAutomorphismGroup"/>
            instead of <see cref="M:NCDK.Groups.AtomContainerDiscretePartitionRefiner.GetAutomorphismGroup(NCDK.IAtomContainer)"/> otherwise the
            refine method will be called twice.
            </remarks>
            <param name="atomContainer">the atomContainer to refine</param>
        </member>
        <member name="M:NCDK.Groups.AtomContainerDiscretePartitionRefiner.Refine(NCDK.IAtomContainer,NCDK.Groups.Partition)">
            <summary>
            Refine an atom partition based on the connectivity in the atom container.
            </summary>
            <param name="atomContainer">the atom container to use</param>
            <param name="partition">the initial partition of the atoms</param>
        </member>
        <member name="M:NCDK.Groups.AtomContainerDiscretePartitionRefiner.IsCanonical(NCDK.IAtomContainer)">
            <summary>
            Checks if the atom container is canonical. Note that this calls
            <see cref="M:NCDK.Groups.AtomContainerDiscretePartitionRefiner.Refine(NCDK.IAtomContainer)"/> first.
            </summary>
            <param name="atomContainer">the atom container to check</param>
            <returns>true if the atom container is canonical</returns>
        </member>
        <member name="M:NCDK.Groups.AtomContainerDiscretePartitionRefiner.GetAutomorphismGroup(NCDK.IAtomContainer)">
            <summary>
            Gets the automorphism group of the atom container. By default it uses an
            initial partition based on the element symbols (so all the carbons are in
            one cell, all the nitrogens in another, etc). If this behaviour is not
            desired, then use the <see cref="F:NCDK.Groups.AtomDiscretePartitionRefiner.ignoreElements"/> flag in the constructor.
            </summary>
            <param name="atomContainer">the atom container to use</param>
            <returns>the automorphism group of the atom container</returns>
        </member>
        <member name="M:NCDK.Groups.AtomContainerDiscretePartitionRefiner.GetAutomorphismGroup(NCDK.IAtomContainer,NCDK.Groups.PermutationGroup)">
            <summary>
            Speed up the search for the automorphism group using the automorphisms in
            the supplied group. Note that the behaviour of this method is unknown if
            the group does not contain automorphisms...
            </summary>
            <param name="atomContainer">the atom container to use</param>
            <param name="group">the group of known automorphisms</param>
            <returns>the full automorphism group</returns>
        </member>
        <member name="M:NCDK.Groups.AtomContainerDiscretePartitionRefiner.GetAutomorphismGroup(NCDK.IAtomContainer,NCDK.Groups.Partition)">
            <summary>
            Get the automorphism group of the molecule given an initial partition.
            </summary>
            <param name="atomContainer">the atom container to use</param>
            <param name="initialPartition">an initial partition of the atoms</param>
            <returns>the automorphism group starting with this partition</returns>
        </member>
        <member name="M:NCDK.Groups.AtomContainerDiscretePartitionRefiner.GetAutomorphismPartition(NCDK.IAtomContainer)">
            <summary>
            Get the automorphism partition (equivalence classes) of the atoms.
            </summary>
            <param name="atomContainer">the molecule to calculate equivalence classes for</param>
            <returns>a partition of the atoms into equivalence classes</returns>
        </member>
        <member name="T:NCDK.Groups.AtomContainerDiscretePartitionRefinerImpl">
            <summary>
            Base class for discrete partition refiners of IAtomContainers.
            </summary>
        </member>
        <member name="M:NCDK.Groups.AtomContainerDiscretePartitionRefinerImpl.Refine(NCDK.IAtomContainer)">
            <summary>
            Refine an atom container, which has the side effect of calculating
            the automorphism group.
            
            If the group is needed afterwards, call <see cref="M:NCDK.Groups.DiscretePartitionRefiner.GetAutomorphismGroup"/>
            instead of <see cref="M:NCDK.Groups.AtomContainerDiscretePartitionRefinerImpl.GetAutomorphismGroup(NCDK.IAtomContainer)"/> otherwise the
            refine method will be called twice.
            </summary>
            <param name="atomContainer">the atomContainer to refine</param>
        </member>
        <member name="M:NCDK.Groups.AtomContainerDiscretePartitionRefinerImpl.Refine(NCDK.IAtomContainer,NCDK.Groups.Partition)">
            <summary>
            Refine an atom partition based on the connectivity in the atom container.
            </summary>
            <param name="atomContainer">the atom container to use</param>
            <param name="partition">the initial partition of the atoms</param>
        </member>
        <member name="M:NCDK.Groups.AtomContainerDiscretePartitionRefinerImpl.IsCanonical(NCDK.IAtomContainer)">
            <summary>
            Checks if the atom container is canonical.</summary>
            <remarks>
            <note type="note">
            This calls <see cref="M:NCDK.Groups.AtomContainerDiscretePartitionRefinerImpl.Refine(NCDK.IAtomContainer)"/> first.
            </note></remarks>
            <param name="atomContainer">the atom container to check</param>
            <returns>true if the atom container is canonical</returns>
        </member>
        <member name="M:NCDK.Groups.AtomContainerDiscretePartitionRefinerImpl.GetAutomorphismGroup(NCDK.IAtomContainer)">
            <summary>
            Gets the automorphism group of the atom container. By default it uses an
            initial partition based on the element symbols (so all the carbons are in
            one cell, all the nitrogens in another, etc). If this behaviour is not
            desired, then use the <see cref="F:NCDK.Groups.AtomDiscretePartitionRefiner.ignoreElements"/> flag in the constructor.
            </summary>
            <param name="atomContainer">the atom container to use</param>
            <returns>the automorphism group of the atom container</returns>
        </member>
        <member name="M:NCDK.Groups.AtomContainerDiscretePartitionRefinerImpl.GetAutomorphismGroup(NCDK.IAtomContainer,NCDK.Groups.PermutationGroup)">
            <summary>
            Speed up the search for the automorphism group using the automorphisms in
            the supplied group. Note that the behaviour of this method is unknown if
            the group does not contain automorphisms...
            </summary>
            <param name="atomContainer">the atom container to use</param>
            <param name="group">the group of known automorphisms</param>
            <returns>the full automorphism group</returns>
        </member>
        <member name="M:NCDK.Groups.AtomContainerDiscretePartitionRefinerImpl.GetAutomorphismGroup(NCDK.IAtomContainer,NCDK.Groups.Partition)">
            <summary>
            Get the automorphism group of the molecule given an initial partition.
            </summary>
            <param name="atomContainer">the atom container to use</param>
            <param name="initialPartition">an initial partition of the atoms</param>
            <returns>the automorphism group starting with this partition</returns>
        </member>
        <member name="M:NCDK.Groups.AtomContainerDiscretePartitionRefinerImpl.GetAutomorphismPartition(NCDK.IAtomContainer)">
            <summary>
            Get the automorphism partition (equivalence classes) of the atoms.
            </summary>
            <param name="atomContainer">the molecule to calculate equivalence classes for</param>
            <returns>a partition of the atoms into equivalence classes</returns>
        </member>
        <member name="M:NCDK.Groups.AtomContainerDiscretePartitionRefinerImpl.GetVertexCount">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Groups.AtomContainerDiscretePartitionRefinerImpl.GetConnectivity(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Groups.AtomRefinable">
            <summary>
            Wraps an atom container to provide information on the atom connectivity.
            </summary>
        </member>
        <member name="F:NCDK.Groups.AtomRefinable.connectionTable">
            <summary>
            A convenience lookup table for atom-atom connections.
            </summary>
        </member>
        <member name="F:NCDK.Groups.AtomRefinable.bondOrders">
            <summary>
            A convenience lookup table for bond orders.
            </summary>
        </member>
        <member name="F:NCDK.Groups.AtomRefinable.ignoreElements">
            <summary>
            Ignore the elements when creating the initial partition.
            </summary>
        </member>
        <member name="F:NCDK.Groups.AtomRefinable.ignoreBondOrders">
            <summary>
            Specialised option to allow generating automorphisms
            that ignore the bond order.
            </summary>
        </member>
        <member name="M:NCDK.Groups.AtomRefinable.#ctor(NCDK.IAtomContainer)">
            <summary>
            Create a refinable from an atom container with flags set to false.
            </summary>
            <param name="atomContainer">the atom and bond data</param>
        </member>
        <member name="M:NCDK.Groups.AtomRefinable.#ctor(NCDK.IAtomContainer,System.Boolean,System.Boolean)">
            <summary>
            Create a refinable from an atom container with supplied flags.
            </summary>
            <param name="atomContainer">the atom and bond data</param>
            <param name="ignoreElements"></param>
            <param name="ignoreBondOrders"></param>
        </member>
        <member name="M:NCDK.Groups.AtomRefinable.GetSimpleInvariant(System.Collections.Generic.ISet{System.Int32},System.Int32)">
            <returns>a simple count of the neighbours of vertexIndex that are in block</returns>
        </member>
        <member name="M:NCDK.Groups.AtomRefinable.GetMultipleInvariant(System.Collections.Generic.ISet{System.Int32},System.Int32)">
            <returns>a list of bond orders of connections to neighbours of vertexIndex that are in block</returns>
        </member>
        <member name="M:NCDK.Groups.AtomRefinable.GetInitialPartition">
            <summary>
            Get the element partition from an atom container, which is simply a list
            of sets of atom indices where all atoms in one set have the same element
            symbol.
            
            So for atoms [C0, N1, C2, P3, C4, N5] the partition would be
            [{0, 2, 4}, {1, 5}, {3}] with cells for elements C, N, and P.
            </summary>
            <returns>a partition of the atom indices based on the element symbols</returns>
        </member>
        <member name="M:NCDK.Groups.AtomRefinable.SetupConnectionTable(NCDK.IAtomContainer)">
            <summary>
            Makes a lookup table for the connection between atoms, to avoid looking
            through the bonds each time.
            </summary>
            <param name="atomContainer">the atom</param>
        </member>
        <member name="T:NCDK.Groups.BondRefinable">
            <summary>
            Wraps an atom container to provide information on the bond connectivity.
            </summary>
        </member>
        <member name="F:NCDK.Groups.BondRefinable.connectionTable">
            <summary>
            The connectivity between bonds; two bonds are connected
            if they share an atom.
            </summary>
        </member>
        <member name="F:NCDK.Groups.BondRefinable.ignoreBondOrders">
            <summary>
            Specialised option to allow generating automorphisms that ignore the bond order.
            </summary>
        </member>
        <member name="M:NCDK.Groups.BondRefinable.GetInitialPartition">
            <summary>
            Get the bond partition, based on the element types of the atoms at either end
            of the bond, and the bond order.
            </summary>
            <returns>a partition of the bonds based on the element types and bond order</returns>
        </member>
        <member name="T:NCDK.Groups.DiscretePartitionRefiner">
            <summary>
            A mechanism for refining partitions of graph-like objects.
            </summary>
        </member>
        <member name="M:NCDK.Groups.DiscretePartitionRefiner.GetBest">
            <summary>
            Get the best permutation found.
            </summary>
            <returns>the permutation that gives the maximal half-matrix string</returns>
        </member>
        <member name="M:NCDK.Groups.DiscretePartitionRefiner.GetAutomorphismPartition">
            <summary>
            The automorphism partition is a partition of the elements of the group.
            </summary>
            <returns>a partition of the elements of group</returns>
        </member>
        <member name="M:NCDK.Groups.DiscretePartitionRefiner.GetAutomorphismGroup">
            <summary>
            Get the automorphism group used to prune the search.
            </summary>
            <returns>the automorphism group</returns>
        </member>
        <member name="M:NCDK.Groups.DiscretePartitionRefiner.GetFirst">
            <summary>
            Get the first permutation reached by the search.
            </summary>
            <returns>the first permutation reached</returns>
        </member>
        <member name="M:NCDK.Groups.DiscretePartitionRefiner.FirstIsIdentity">
            <summary>
            Check that the first refined partition is the identity.
            </summary>
            <returns>true if the first is the identity permutation</returns>
        </member>
        <member name="T:NCDK.Groups.EquitablePartitionRefiner">
            <summary>
            Refines a 'coarse' partition (with more blocks) to a 'finer' partition that
            is equitable.
            </summary>
            <remarks>
            Closely follows algorithm 7.5 in CAGES <token>cdk-cite-Kreher98</token>. The basic idea is that the refiner
            maintains a queue of blocks to refine, starting with all the initial blocks
            in the partition to refine. These blocks are popped off the queue, and
            </remarks>
        </member>
        <member name="T:NCDK.Groups.EquitablePartitionRefiner.SplitOrders">
            <summary>
            A forward split order tends to favor partitions where the cells are
            refined from lowest to highest. A reverse split order is, of course, the
            opposite.
            </summary>
        </member>
        <member name="F:NCDK.Groups.EquitablePartitionRefiner.splitOrder">
            <summary>
            The bias in splitting cells when refining
            </summary>
        </member>
        <member name="F:NCDK.Groups.EquitablePartitionRefiner.currentBlockIndex">
            <summary>
            The block of the partition that is being refined
            </summary>
        </member>
        <member name="F:NCDK.Groups.EquitablePartitionRefiner.blocksToRefine">
            <summary>
            The blocks to be refined, or at least considered for refinement
            </summary>
        </member>
        <member name="M:NCDK.Groups.EquitablePartitionRefiner.SetSplitOrder(NCDK.Groups.EquitablePartitionRefiner.SplitOrders)">
            <summary>
            Set the preference for splitting cells.
            </summary>
            <param name="splitOrder">either FORWARD or REVERSE</param>
        </member>
        <member name="M:NCDK.Groups.EquitablePartitionRefiner.Refine(NCDK.Groups.Partition)">
            <summary>
            Refines the coarse partition <code>a</code> into a finer one.
            </summary>
            <param name="coarser">the partition to refine</param>
            <returns>a finer partition</returns>
        </member>
        <member name="M:NCDK.Groups.EquitablePartitionRefiner.GetInvariants(NCDK.Groups.Partition,System.Collections.Generic.ISet{System.Int32})">
            <summary>
            Gets the neighbor invariants for the block j as a map of
            |N<sub>g</sub>(v) ‚à© T| to elements of the block j. That is, the
            size of the intersection between the set of neighbors of element v in
            the graph and the target block T.
            </summary>
            <param name="partition">the current partition</param>
            <param name="targetBlock">the current target block of the partition</param>
            <returns>a map of set intersection invariants to elements</returns>
        </member>
        <member name="M:NCDK.Groups.EquitablePartitionRefiner.Split(System.Collections.Generic.IDictionary{NCDK.Groups.Invariant,System.Collections.Generic.SortedSet{System.Int32}},NCDK.Groups.Partition)">
            <summary>
            Split the current block using the invariants calculated in getInvariants.
            </summary>
            <param name="invariants">a map of neighbor counts to elements</param>
            <param name="partition">the partition that is being refined</param>
        </member>
        <member name="T:NCDK.Groups.Invariant">
            <summary>
            Marker interface for invariants.
            </summary>
        </member>
        <member name="T:NCDK.Groups.PartitionRefinement">
            <summary>
            Factory for partition refiners. 
            </summary>
            <example>
            Use like:
            
            <code>
                AtomContainerDiscretePartitionRefiner refiner = PartitionRefinement.forAtoms().create();
            </code>
            
            The methods forAtoms and forBonds return builders with methods to allow setting the
            switches for ignoring atom types and/or bond orders.
            </example>
        </member>
        <member name="M:NCDK.Groups.PartitionRefinement.ForAtoms">
            <returns>a builder that makes atom refiners</returns>
        </member>
        <member name="M:NCDK.Groups.PartitionRefinement.ForBonds">
            <returns>a builder that makes bond refiners</returns>
        </member>
        <member name="T:NCDK.Groups.Refinable">
            <summary>
            Implementors are graph-like objects that are refinable by the
            equitable and discrete partition refiners.
            </summary>
        </member>
        <member name="M:NCDK.Groups.Refinable.NeighboursInBlock(System.Collections.Generic.ISet{System.Int32},System.Int32)">
            <summary>
            Given a block (or cell) of a partition, determine the invariant that
            represents the intersection between the block and the neighbours of
            vertexIndex supplied.
            </summary>
            <param name="block">a cell of the partition under refinement</param>
            <param name="vertexIndex">the element to compare</param>
            <returns>the size of the intersection between the neighbours and the block</returns>
        </member>
        <member name="M:NCDK.Groups.Refinable.GetVertexCount">
            <summary>
            Get the number of vertices in the graph to be refined.
            </summary>
            <returns>a count of the vertices in the underlying graph</returns>
        </member>
        <member name="M:NCDK.Groups.Refinable.GetConnectivity(System.Int32,System.Int32)">
            <summary>
            Get the connectivity between two vertices as an integer, to allow
            for multigraphs : so a single edge is 1, a double edge 2, etc. If
            there is no edge, then 0 should be returned.
            </summary>
            <param name="vertexI">a vertex of the graph</param>
            <param name="vertexJ">a vertex of the graph</param>
            <returns>the multiplicity of the edge (0, 1, 2, 3, ...)</returns>
        </member>
        <member name="M:NCDK.Groups.Refinable.GetInitialPartition">
            <summary>
            Get an initial partition of the vertices of the refinable -
            for example, by color.
            </summary>
            <returns>a partition of the vertices</returns>
        </member>
        <member name="T:NCDK.Groups.DisjointSetForest">
            <summary>
            Implementation of a union-find data structure, largely copied from
            code due to Derrick Stolee.
            </summary>
        </member>
        <member name="F:NCDK.Groups.DisjointSetForest.forest">
            <summary>
            The sets stored as pointers to their parents. The root of each
            set is stored as the negated size of the set - ie a set of size
            5 with a root element 2 will mean forest[2] = -5.
            </summary>
        </member>
        <member name="M:NCDK.Groups.DisjointSetForest.#ctor(System.Int32)">
            <summary>
            Initialize a disjoint set forest with a number of elements.
            </summary>
            <param name="numberOfElements">the number of elements in the forest</param>
        </member>
        <member name="P:NCDK.Groups.DisjointSetForest.Item(System.Int32)">
            <summary>
            Get the value of the forest at this index - note that this will <i>not</i>
            necessarily give the set for that element : use <see cref="M:NCDK.Groups.DisjointSetForest.GetSets"/>  after
            union-ing elements.
            </summary>
            <param name="i">the index in the forest</param>
            <returns>the value at this index</returns>
        </member>
        <member name="M:NCDK.Groups.DisjointSetForest.GetRoot(System.Int32)">
            <summary>
            Travel up the tree that this element is in, until the root of the set
            is found, and return that root.
            </summary>
            <param name="element">the starting point</param>
            <returns>the root of the set containing element</returns>
        </member>
        <member name="M:NCDK.Groups.DisjointSetForest.MakeUnion(System.Int32,System.Int32)">
            <summary>
            Union these two elements - in other words, put them in the same set.
            </summary>
            <param name="elementX">an element</param>
            <param name="elementY">an element</param>
        </member>
        <member name="M:NCDK.Groups.DisjointSetForest.GetSets">
            <summary>
            Retrieve the sets as 2D-array of ints.
            </summary>
            <returns>the sets</returns>
        </member>
        <member name="T:NCDK.Groups.AbstractDiscretePartitionRefiner">
            <summary>
            Refines vertex partitions until they are discrete, and therefore equivalent
            to permutations. These permutations are automorphisms of the graph that was
            used during the refinement to guide the splitting of partition blocks.
            </summary>
        </member>
        <member name="T:NCDK.Groups.AbstractDiscretePartitionRefiner.Result">
            <summary>
            The result of a comparison between the current partition
            and the best permutation found so far.
            </summary>
        </member>
        <member name="F:NCDK.Groups.AbstractDiscretePartitionRefiner.bestExist">
            <summary>
            If true, then at least one partition has been refined
            to a permutation (IE extends to a discrete partition).
            </summary>
        </member>
        <member name="F:NCDK.Groups.AbstractDiscretePartitionRefiner.best">
            <summary>
            The best permutation is the one that gives the maximal
            half-matrix string (so far) when applied to the graph.
            </summary>
        </member>
        <member name="F:NCDK.Groups.AbstractDiscretePartitionRefiner.first">
            <summary>
            The first permutation seen when refining.
            </summary>
        </member>
        <member name="F:NCDK.Groups.AbstractDiscretePartitionRefiner.equitableRefiner">
            <summary>
            An equitable refiner.
            </summary>
        </member>
        <member name="F:NCDK.Groups.AbstractDiscretePartitionRefiner.group">
            <summary>
            The automorphism group that is used to prune the search.
            </summary>
        </member>
        <member name="M:NCDK.Groups.AbstractDiscretePartitionRefiner.#ctor">
            <summary>
            A refiner - it is necessary to call <see cref="M:NCDK.Groups.AbstractDiscretePartitionRefiner.Setup(NCDK.Groups.PermutationGroup,NCDK.Groups.EquitablePartitionRefiner)"/> before use.
            </summary>
        </member>
        <member name="M:NCDK.Groups.AbstractDiscretePartitionRefiner.GetVertexCount">
            <summary>
            Get the number of vertices in the graph to be refined.
            </summary>
            <returns>a count of the vertices in the underlying graph</returns>
        </member>
        <member name="M:NCDK.Groups.AbstractDiscretePartitionRefiner.GetConnectivity(System.Int32,System.Int32)">
            <summary>
            Get the connectivity between two vertices as an integer, to allow
            for multigraphs : so a single edge is 1, a double edge 2, etc. If
            there is no edge, then 0 should be returned.
            </summary>
            <param name="vertexI">a vertex of the graph</param>
            <param name="vertexJ">a vertex of the graph</param>
            <returns>the multiplicity of the edge (0, 1, 2, 3, ...)</returns>
        </member>
        <member name="M:NCDK.Groups.AbstractDiscretePartitionRefiner.Setup(NCDK.Groups.PermutationGroup,NCDK.Groups.EquitablePartitionRefiner)">
            <summary>
            Setup the group and refiner; it is important to call this method before
            calling <see cref="M:NCDK.Groups.AbstractDiscretePartitionRefiner.Refine(NCDK.Groups.Partition)"/>  otherwise the refinement process will fail.
            </summary>
            <param name="group">a group (possibly empty) of automorphisms</param>
            <param name="refiner">the equitable refiner</param>
        </member>
        <member name="M:NCDK.Groups.AbstractDiscretePartitionRefiner.FirstIsIdentity">
             <summary>
             Check that the first refined partition is the identity.
            
             <returns>true if the first is the identity permutation</returns>
             </summary>
        </member>
        <member name="M:NCDK.Groups.AbstractDiscretePartitionRefiner.GetAutomorphismPartition">
             <summary>
             The automorphism partition is a partition of the elements of the group.
            
             <returns>a partition of the elements of group</returns>
             </summary>
        </member>
        <member name="M:NCDK.Groups.AbstractDiscretePartitionRefiner.GetHalfMatrixString(NCDK.Groups.Permutation)">
            <summary>
            Get the upper-half of the adjacency matrix under the permutation.
            </summary>
            <param name="permutation">a permutation of the adjacency matrix</param>
            <returns>a string containing the permuted values of half the matrix</returns>
        </member>
        <member name="M:NCDK.Groups.AbstractDiscretePartitionRefiner.GetFirstHalfMatrixString">
            <summary>
            Get the half-matrix string under the first permutation.
            </summary>
            <returns>the upper-half adjacency matrix string permuted by the first</returns>
        </member>
        <member name="M:NCDK.Groups.AbstractDiscretePartitionRefiner.GetHalfMatrixString">
            <summary>
            Get the initial (unpermuted) half-matrix string.
            </summary>
            <returns>the upper-half adjacency matrix string</returns>
        </member>
        <member name="M:NCDK.Groups.AbstractDiscretePartitionRefiner.GetAutomorphismGroup">
            <summary>
            Get the automorphism group used to prune the search.
            </summary>
            <returns>the automorphism group</returns>
        </member>
        <member name="M:NCDK.Groups.AbstractDiscretePartitionRefiner.GetBest">
            <summary>
            Get the best permutation found.
            </summary>
            <returns>the permutation that gives the maximal half-matrix string</returns>
        </member>
        <member name="M:NCDK.Groups.AbstractDiscretePartitionRefiner.GetFirst">
            <summary>
            Get the first permutation reached by the search.
            </summary>
            <returns>the first permutation reached</returns>
        </member>
        <member name="M:NCDK.Groups.AbstractDiscretePartitionRefiner.IsCanonical">
            <summary>
            Check for a canonical graph, without generating the whole
            automorphism group.
            </summary>
            <returns>true if the graph is canonical</returns>
        </member>
        <member name="M:NCDK.Groups.AbstractDiscretePartitionRefiner.Refine(NCDK.Groups.Partition)">
            <summary>
            Refine the partition. The main entry point for subclasses.
            </summary>
            <param name="partition">the initial partition of the vertices</param>
        </member>
        <member name="M:NCDK.Groups.AbstractDiscretePartitionRefiner.Refine(NCDK.Groups.PermutationGroup,NCDK.Groups.Partition)">
            <summary>
            Does the work of the class, that refines a coarse partition into a finer
            one using the supplied automorphism group to prune the search.
            </summary>
            <param name="group">the automorphism group of the graph</param>
            <param name="coarser">the partition to refine</param>
        </member>
        <member name="M:NCDK.Groups.AbstractDiscretePartitionRefiner.CompareRowwise(NCDK.Groups.Permutation)">
            <summary>
            Check a permutation to see if it is better, equal, or worse than the
            current best.
            </summary>
            <param name="perm">the permutation to check</param>
            <returns><see cref="F:NCDK.Groups.AbstractDiscretePartitionRefiner.Result.Better"/>, <see cref="F:NCDK.Groups.AbstractDiscretePartitionRefiner.Result.Equal"/>, or <see cref="F:NCDK.Groups.AbstractDiscretePartitionRefiner.Result.Worse"/></returns>
        </member>
        <member name="T:NCDK.Groups.AbstractEquitablePartitionRefiner">
            <summary>
            Refines a 'coarse' partition (with more blocks) to a 'finer' partition that
            is equitable.
            </summary>
            <remarks>
            Closely follows algorithm 7.5 in CAGES <token>cdk-cite-Kreher98</token>. The basic idea is that the refiner
            maintains a queue of blocks to refine, starting with all the initial blocks
            in the partition to refine. These blocks are popped off the queue, and
            </remarks>
        </member>
        <member name="T:NCDK.Groups.AbstractEquitablePartitionRefiner.SplitOrders">
            <summary>
            A forward split order tends to favor partitions where the cells are
            refined from lowest to highest. A reverse split order is, of course, the
            opposite.
            </summary>
        </member>
        <member name="F:NCDK.Groups.AbstractEquitablePartitionRefiner.splitOrder">
            <summary>
            The bias in splitting cells when refining
            </summary>
        </member>
        <member name="F:NCDK.Groups.AbstractEquitablePartitionRefiner.currentBlockIndex">
            <summary>
            The block of the partition that is being refined
            </summary>
        </member>
        <member name="F:NCDK.Groups.AbstractEquitablePartitionRefiner.blocksToRefine">
            <summary>
            The blocks to be refined, or at least considered for refinement
            </summary>
        </member>
        <member name="M:NCDK.Groups.AbstractEquitablePartitionRefiner.GetVertexCount">
            <summary>
            Gets from the graph the number of vertices. Abstract to allow different
            graph classes to be used (eg: Graph or IAtomContainer, etc).
            </summary>
            <returns>the number of vertices</returns>
        </member>
        <member name="M:NCDK.Groups.AbstractEquitablePartitionRefiner.NeighboursInBlock(System.Collections.Generic.ISet{System.Int32},System.Int32)">
            <summary>
            Find |a ÔøΩÔøΩ b| - that is, the size of the intersection between a and b.
            </summary>
            <param name="block">a set of numbers</param>
            <param name="vertexIndex">the element to compare</param>
            <returns>the size of the intersection</returns>
        </member>
        <member name="M:NCDK.Groups.AbstractEquitablePartitionRefiner.SetSplitOrder(NCDK.Groups.AbstractEquitablePartitionRefiner.SplitOrders)">
            <summary>
            Set the preference for splitting cells.
            </summary>
            <param name="splitOrder">either <see cref="F:NCDK.Groups.AbstractEquitablePartitionRefiner.SplitOrders.Forward"/>  or <see cref="F:NCDK.Groups.AbstractEquitablePartitionRefiner.SplitOrders.Reverse"/></param>
        </member>
        <member name="M:NCDK.Groups.AbstractEquitablePartitionRefiner.Refine(NCDK.Groups.Partition)">
            <summary>
            Refines the coarse partition <c>a</c> into a finer one.
            </summary>
            <param name="coarser">the partition to refine</param>
            <returns>a finer partition</returns>
        </member>
        <member name="M:NCDK.Groups.AbstractEquitablePartitionRefiner.GetInvariants(NCDK.Groups.Partition,System.Collections.Generic.ISet{System.Int32})">
            <summary>
            Gets the neighbor invariants for the block j as a map of
            |N<sub>g</sub>(v) ÔøΩÔøΩ T| to elements of the block j. That is, the
            size of the intersection between the set of neighbors of element v in
            the graph and the target block T.
            </summary>
            <param name="partition">the current partition</param>
            <param name="targetBlock">the current target block of the partition</param>
            <returns>a map of set intersection sizes to elements</returns>
        </member>
        <member name="M:NCDK.Groups.AbstractEquitablePartitionRefiner.Split(System.Collections.Generic.IDictionary{System.Int32,System.Collections.Generic.SortedSet{System.Int32}},NCDK.Groups.Partition)">
            <summary>
            Split the current block using the invariants calculated in getInvariants.
            </summary>
            <param name="invariants">a map of neighbor counts to elements</param>
            <param name="partition">the partition that is being refined</param>
        </member>
        <member name="T:NCDK.Groups.AtomDiscretePartitionRefiner">
            <summary>
            An <see cref="T:NCDK.Groups.AtomContainerDiscretePartitionRefiner"/> for atoms.
            </summary>
        </member>
        <member name="F:NCDK.Groups.AtomDiscretePartitionRefiner.ignoreElements">
            <summary>
            Ignore the elements when creating the initial partition.
            </summary>
        </member>
        <member name="F:NCDK.Groups.AtomDiscretePartitionRefiner.ignoreBondOrders">
            <summary>
            Specialised option to allow generating automorphisms
            that ignore the bond order.
            </summary>
        </member>
        <member name="M:NCDK.Groups.AtomDiscretePartitionRefiner.#ctor">
            <summary>
            Default constructor - does not ignore elements or bond orders
            or bond orders.
            </summary>
        </member>
        <member name="M:NCDK.Groups.AtomDiscretePartitionRefiner.#ctor(System.Boolean,System.Boolean)">
            <summary>
            Make a refiner with various advanced options.
            </summary>
            <param name="ignoreElements">ignore element symbols when making automorphisms</param>
            <param name="ignoreBondOrders">ignore bond order when making automorphisms</param>
        </member>
        <member name="M:NCDK.Groups.AtomDiscretePartitionRefiner.CreateRefinable(NCDK.IAtomContainer)">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Groups.BondDiscretePartitionRefiner">
            <summary>
            An <see cref="T:NCDK.Groups.AtomContainerDiscretePartitionRefiner"/> for bonds.
            
            If two bonds are equivalent under an automorphism in the group, then
            roughly speaking they are in symmetric positions in the molecule. For
            example, the C-C bonds attaching two methyl groups to a benzene ring
            are 'equivalent' in this sense.
            </summary>
        </member>
        <member name="F:NCDK.Groups.BondDiscretePartitionRefiner.ignoreBondOrders">
            <summary>
            Specialised option to allow generating automorphisms that ignore the bond order.
            </summary>
        </member>
        <member name="M:NCDK.Groups.BondDiscretePartitionRefiner.#ctor">
            <summary>
            Make a bond partition refiner that takes bond-orders into account.
            </summary>
        </member>
        <member name="M:NCDK.Groups.BondDiscretePartitionRefiner.#ctor(System.Boolean)">
            <summary>
            Make a bond partition refiner and specify whether bonds-orders should be
            considered when calculating the automorphisms.
            </summary>
            <param name="ignoreBondOrders">if true, ignore the bond orders</param>
        </member>
        <member name="M:NCDK.Groups.BondDiscretePartitionRefiner.CreateRefinable(NCDK.IAtomContainer)">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Groups.Partition">
            <summary>
            A partition of a set of integers, such as the discrete partition {{1}, {2},
            {3}, {4}} or the unit partition {{1, 2, 3, 4}} or an intermediate like {{1,
            2}, {3, 4}}.
            </summary>
        </member>
        <member name="F:NCDK.Groups.Partition.cells">
            <summary>
            The subsets of the partition, known as cells.
            </summary>
        </member>
        <member name="M:NCDK.Groups.Partition.#ctor">
            <summary>
            Creates a new, empty partition with no cells.
            </summary>
        </member>
        <member name="M:NCDK.Groups.Partition.#ctor(NCDK.Groups.Partition)">
            <summary>
            Copy constructor to make one partition from another.
            </summary>
            <param name="other">the partition to copy</param>
        </member>
        <member name="M:NCDK.Groups.Partition.#ctor(System.Int32[][])">
            <summary>
            Constructor to make a partition from an array of int arrays.
            </summary>
            <param name="cellData">the partition to copy</param>
        </member>
        <member name="M:NCDK.Groups.Partition.Unit(System.Int32)">
            <summary>
            Create a unit partition - in other words, the coarsest possible partition
            where all the elements are in one cell.
            </summary>
            <param name="size">the number of elements</param>
            <returns>a new Partition with one cell containing all the elements</returns>
        </member>
        <member name="P:NCDK.Groups.Partition.Count">
            <summary>
            Gets the size of the partition, in terms of the number of cells.
            </summary>
            <returns>the number of cells in the partition</returns>
        </member>
        <member name="M:NCDK.Groups.Partition.NumberOfElements">
            <summary>
            Calculate the size of the partition as the sum of the sizes of the cells.
            </summary>
            <returns>the number of elements in the partition</returns>
        </member>
        <member name="M:NCDK.Groups.Partition.IsDiscrete">
            <summary>
            Checks that all the cells are singletons - that is, they only have one
            element. A discrete partition is equivalent to a permutation.
            </summary>
            <returns>true if all the cells are discrete</returns>
        </member>
        <member name="M:NCDK.Groups.Partition.ToPermutation">
            <summary>
            Converts the whole partition into a permutation.
            </summary>
            <returns>the partition as a permutation</returns>
        </member>
        <member name="M:NCDK.Groups.Partition.InOrder">
            <summary>
            Check whether the cells are ordered such that for cells i and j,
            First(j)  &gt; First(i) and Last(j)  &gt; Last(i).
            </summary>
            <returns>true if all cells in the partition are ordered</returns>
        </member>
        <member name="M:NCDK.Groups.Partition.GetFirstInCell(System.Int32)">
            <summary>
            Gets the first element in the specified cell.
            </summary>
            <param name="cellIndex">the cell to use</param>
            <returns>the first element in this cell</returns>
        </member>
        <member name="M:NCDK.Groups.Partition.GetCell(System.Int32)">
            <summary>
            Gets the cell at this index.
            </summary>
            <param name="cellIndex">the index of the cell to return</param>
            <returns>the cell at this index</returns>
        </member>
        <member name="M:NCDK.Groups.Partition.SplitBefore(System.Int32,System.Int32)">
            <summary>
            Splits this partition by taking the cell at cellIndex and making two
            new cells - the first with the singleton splitElement and the second
            with the rest of the elements from that cell.
            </summary>
            <param name="cellIndex">the index of the cell to split on</param>
            <param name="splitElement">the element to put in its own cell</param>
            <returns>a new (finer) Partition</returns>
        </member>
        <member name="M:NCDK.Groups.Partition.SplitAfter(System.Int32,System.Int32)">
            <summary>
            Splits this partition by taking the cell at cellIndex and making two
            new cells - the first with the the rest of the elements from that cell
            and the second with the singleton splitElement.
            </summary>
            <param name="cellIndex">the index of the cell to split on</param>
            <param name="splitElement">the element to put in its own cell</param>
            <returns>a new (finer) Partition</returns>
        </member>
        <member name="M:NCDK.Groups.Partition.SetAsPermutation(System.Int32)">
            <summary>
            Fill the elements of a permutation from the first element of each
            cell, up to the point <paramref name="upTo"/>.
            </summary>
            <param name="upTo">take values from cells up to this one</param>
            <returns>the permutation representing the first element of each cell</returns>
        </member>
        <member name="M:NCDK.Groups.Partition.IsDiscreteCell(System.Int32)">
            <summary>
            Check to see if the cell at <paramref name="cellIndex"/> is discrete - that is,
            it only has one element.
            </summary>
            <param name="cellIndex">the index of the cell to check</param>
            <returns>true of the cell at this index is discrete</returns>
        </member>
        <member name="M:NCDK.Groups.Partition.GetIndexOfFirstNonDiscreteCell">
            <summary>
            Gets the index of the first cell in the partition that is discrete.
            </summary>
            <returns>the index of the first discrete cell</returns>
        </member>
        <member name="M:NCDK.Groups.Partition.AddSingletonCell(System.Int32)">
            <summary>
            Add a new singleton cell to the end of the partition containing only
            this element.
            </summary>
            <param name="element">the element to add in its own cell</param>
        </member>
        <member name="M:NCDK.Groups.Partition.RemoveCell(System.Int32)">
            <summary>
            Removes the cell at the specified index.
            </summary>
            <param name="index">the index of the cell to remove</param>
        </member>
        <member name="M:NCDK.Groups.Partition.AddCell(System.Int32[])">
            <summary>
            Adds a new cell to the end of the partition containing these elements.
            </summary>
            <param name="elements">the elements to add in a new cell</param>
        </member>
        <member name="M:NCDK.Groups.Partition.AddCell(System.Collections.Generic.ICollection{System.Int32})">
            <summary>
            Adds a new cell to the end of the partition.
            </summary>
            <param name="elements">the collection of elements to put in the cell</param>
        </member>
        <member name="M:NCDK.Groups.Partition.AddToCell(System.Int32,System.Int32)">
            <summary>
            Add an element to a particular cell.
            </summary>
            <param name="index">the index of the cell to add to</param>
            <param name="element">the element to add</param>
        </member>
        <member name="M:NCDK.Groups.Partition.InsertCell(System.Int32,System.Collections.Generic.SortedSet{System.Int32})">
            <summary>
            Insert a cell into the partition at the specified index.
            </summary>
            <param name="index">the index of the cell to add</param>
            <param name="cell">the cell to add</param>
        </member>
        <member name="M:NCDK.Groups.Partition.CopyBlock(System.Int32)">
            <summary>
            Creates and returns a copy of the cell at cell index.
            </summary>
            <param name="cellIndex">the cell to copy</param>
            <returns>the copy of the cell</returns>
        </member>
        <member name="M:NCDK.Groups.Partition.Order">
            <summary>
            Sort the cells in increasing order.
            </summary>
        </member>
        <member name="M:NCDK.Groups.Partition.InSameCell(System.Int32,System.Int32)">
            <summary>
            Check that two elements are in the same cell of the partition.
            </summary>
            <param name="elementI">an element in the partition</param>
            <param name="elementJ">an element in the partition</param>
            <returns>true if both elements are in the same cell</returns>
        </member>
        <member name="M:NCDK.Groups.Partition.FromString(System.String)">
            <summary>
            Parse a string like "[0,2|1,3]" to form the partition; cells are
            separated by '|' characters and elements within the cell by commas.
            </summary>
            <param name="strForm">the partition in string form</param>
            <returns>the partition corresponding to the string</returns>
            <exception cref="T:System.ArgumentException">thrown if the provided strFrom is null or empty</exception>
        </member>
        <member name="T:NCDK.Groups.Permutation">
            <summary>
            A permutation with some associated methods to multiply, invert, and convert
            to cycle strings. Much of the code in this was implemented from the
            C.A.G.E.S. book <token>cdk-cite-Kreher98</token>.
            </summary>
        </member>
        <member name="M:NCDK.Groups.Permutation.#ctor(System.Int32)">
            <summary>
            Constructs an identity permutation with <paramref name="size"/> elements.
            </summary>
            <param name="size">the number of elements in the permutation</param>
        </member>
        <member name="M:NCDK.Groups.Permutation.#ctor(System.Int32[])">
            <summary>
            Make a permutation from a set of values such that p[i] = x for  the value x at position i.
            </summary>
            <param name="values">the elements of the permutation</param>
        </member>
        <member name="M:NCDK.Groups.Permutation.#ctor(NCDK.Groups.Permutation)">
            <summary>
            Construct a permutation from another one by cloning the values.
            </summary>
            <param name="other">the other permutation</param>
        </member>
        <member name="M:NCDK.Groups.Permutation.IsIdentity">
            <summary>
            Check to see if this permutation is the identity permutation.
            </summary>
            <returns><see langword="true"/> if for all i, p[i] = i</returns>
        </member>
        <member name="P:NCDK.Groups.Permutation.Count">
            <summary>
            The number of elements in the permutation.
            </summary>
        </member>
        <member name="P:NCDK.Groups.Permutation.Item(System.Int32)">
            <summary>
            The permutation value
            </summary>
            <param name="index">Index</param>
        </member>
        <member name="P:NCDK.Groups.Permutation.Values">
            <summary>
            All the values as an array.
            </summary>
        </member>
        <member name="M:NCDK.Groups.Permutation.FirstIndexOfDifference(NCDK.Groups.Permutation)">
            <summary>
            Find an r such that <c>this[r] != other[r]</c>.
            </summary>
            <param name="other">the other permutation to compare with</param>
            <returns>the first point at which the two permutations differ</returns>
        </member>
        <member name="M:NCDK.Groups.Permutation.GetOrbit(System.Int32)">
            <summary>
            Get all the elements in the same orbit in the permutation (unsorted).
            </summary>
            <param name="element">any element in the orbit</param>
            <returns>the list of elements reachable in this permutation</returns>
        </member>
        <member name="M:NCDK.Groups.Permutation.SetTo(NCDK.Groups.Permutation)">
            <summary>
            Alter a permutation by setting it to the values in the other permutation.
            </summary>
            <param name="other">the other permutation to use</param>
            <exception cref="T:System.ArgumentException"> if the permutations are of different size</exception>
        </member>
        <member name="M:NCDK.Groups.Permutation.Multiply(NCDK.Groups.Permutation)">
            <summary>
            Multiply this permutation by another such that for all i, this[i] = this[other[i]].
            </summary>
            <param name="other">the other permutation to use</param>
            <returns>a new permutation with the result of multiplying the permutations</returns>
        </member>
        <member name="M:NCDK.Groups.Permutation.Invert">
            <summary>
            Invert the permutation, so that for all i : inv[p[i]] = i.
            </summary>
            <returns>the inverse of this permutation</returns>
        </member>
        <member name="M:NCDK.Groups.Permutation.ToCycleString">
            <summary>
            An easily-readable version of the permutation as a product of cycles.
            </summary>
            <returns>the cycle form of the permutation as a string</returns>
        </member>
        <member name="T:NCDK.Groups.PermutationGroup">
             <summary>
             A permutation group with a Schreier-Sims representation. For a number n, a
             list of permutation sets is stored (U<sub>0</sub>,...,U<sub>n-1</sub>). All n! permutations of
             [0...n-1] can be reconstructed from this list by backtracking - see, for
             example, the <see cref="M:NCDK.Groups.PermutationGroup.GenerateAll"/> method.
             </summary>
             <remarks>
             <para>
             So if G is a group on X = {0, 1, 2, 3, ..., n-1}, then:
                 G<sub>0</sub> = {g ÔøΩÔøΩ G  : g(0) = 0}<br/>
                 G<sub>1</sub> = {g ÔøΩÔøΩ G<sub>0</sub> : g(1) = 1}<br/>
                 G<sub>2</sub> = {g ÔøΩÔøΩ G<sub>1</sub> : g(2) = 2}<br/>
                 ...<br/>
                 G<sub>n-1</sub> = {g in G<sub>n-2</sub> : g(n - 1) = n - 1} = {I}<br/>
             and G<sub>0</sub>, G<sub>1</sub>, G<sub>2</sub>, ..., G<sub>n-1</sub> are
             subgroups of G.
             </para>
             <para>
             Now let orb(0) = {g(0) : g ÔøΩÔøΩ G} be the orbit of 0 under G. Then |orb(0)|
             (the size of the orbit) is n<sub>0</sub> for some integer 0 &lt; n<sub>0</sub>
             ÔøΩÔøΩ n and write orb(0) = {x<sub>0,1</sub>, x<sub>0,2</sub>, ...,
             x<sub>0</sub>,n<sub>0</sub>} and for each i, 1 ÔøΩÔøΩ i ÔøΩÔøΩ n<sub>0</sub> choose
             some h<sub>0,1</sub> in G such that h<sub>0,i</sub>(0) = x<sub>0,1</sub>. Set
             U<sub>0</sub> = {h<sub>0,1</sub>, ..., h<sub>0</sub>,n<sub>0</sub>}.
             </para>
            
             <para>
             Given the above, the list of permutation sets in this class is
             [U<sub>0</sub>,..,U<sub>n</sub>]. Also, for all i = 1, ..., n-1 the set U<sub>i</sub> is
             a left transversal of G<sub>i</sub> in G<sub>i-1</sub>.
             </para>
            
             <para>
             This is port of the code from the C.A.G.E.S. book <token>cdk-cite-Kreher98</token>. The
             mathematics in the description above is also from that book (pp. 203).
             </para>
             </remarks>
        </member>
        <member name="T:NCDK.Groups.PermutationGroup.Backtracker">
            <summary>
            An interface for use with the apply method, which runs through all the
            permutations in this group.
            </summary>
        </member>
        <member name="M:NCDK.Groups.PermutationGroup.Backtracker.ApplyTo(NCDK.Groups.Permutation)">
            <summary>
            Do something to the permutation
            </summary>
            <param name="p">a permutation in the full group</param>
        </member>
        <member name="M:NCDK.Groups.PermutationGroup.Backtracker.IsFinished">
            <summary>
            Check to see if the backtracker is finished.
            </summary>
            <returns>true if complete</returns>
        </member>
        <member name="F:NCDK.Groups.PermutationGroup.permutations">
            <summary>
            The compact list of permutations that make up this group
            </summary>
        </member>
        <member name="F:NCDK.Groups.PermutationGroup.size">
            <summary>
            The size of the group - strictly, the size of the permutation
            </summary>
        </member>
        <member name="F:NCDK.Groups.PermutationGroup.basePermutation">
            <summary>
            The base of the group
            </summary>
        </member>
        <member name="M:NCDK.Groups.PermutationGroup.#ctor(System.Int32)">
            <summary>
            Make a group with just a single identity permutation of size n.
            </summary>
            <param name="size">the number of elements in the base permutation</param>
        </member>
        <member name="M:NCDK.Groups.PermutationGroup.#ctor(NCDK.Groups.Permutation)">
            <summary>
            Creates the initial group, with the base <paramref name="basePermutation"/>.
            </summary>
            <param name="basePermutation">the permutation that the group is based on</param>
        </member>
        <member name="M:NCDK.Groups.PermutationGroup.#ctor(System.Int32,System.Collections.Generic.IEnumerable{NCDK.Groups.Permutation})">
            <summary>
            Creates a group from a set of generators. See the makeSymN method for
            where this is used to make the symmetric group on N using the two
            generators (0, 1) and (1, 2, ..., n - 1, 0)
            </summary>
            <param name="size">the size of the group</param>
            <param name="generators">the generators to use to make the group</param>
        </member>
        <member name="M:NCDK.Groups.PermutationGroup.MakeSymN(System.Int32)">
            <summary>
            Make the symmetric group Sym(N) for N. That is, a group of permutations
            that represents _all_ permutations of size N.
            </summary>
            <param name="size">the size of the permutation</param>
            <returns>a group for all permutations of N</returns>
        </member>
        <member name="P:NCDK.Groups.PermutationGroup.Count">
            <summary>
            The number of elements in each permutation in the group.
            </summary>
        </member>
        <member name="M:NCDK.Groups.PermutationGroup.Order">
            <summary>
            Calculates the size of the group.
            </summary>
            <returns>the (total) number of permutations in the group</returns>
        </member>
        <member name="P:NCDK.Groups.PermutationGroup.Item(System.Int32,System.Int32)">
            <summary>
            One of the permutations that make up the compact representation.
            </summary>
            <param name="uIndex">the index of the set U.</param>
            <param name="uSubIndex">the index of the permutation within Ui.</param>
        </member>
        <member name="M:NCDK.Groups.PermutationGroup.GetLeftTransversal(System.Int32)">
            <summary>
            Get the traversal U<sub>i</sub> from the list of transversals.
            </summary>
            <param name="index">the index of the transversal</param>
            <returns>a list of permutations</returns>
        </member>
        <member name="M:NCDK.Groups.PermutationGroup.Transversal(NCDK.Groups.PermutationGroup)">
            <summary>
            Generate a transversal of a subgroup in this group.
            </summary>
            <param name="subgroup">the subgroup to use for the transversal</param>
            <returns>a list of permutations</returns>
        </member>
        <member name="M:NCDK.Groups.PermutationGroup.Apply(NCDK.Groups.PermutationGroup.Backtracker)">
            <summary>
            Apply the backtracker to all permutations in the larger group.
            </summary>
            <param name="backtracker">a hook for acting on the permutations</param>
        </member>
        <member name="M:NCDK.Groups.PermutationGroup.GenerateAll">
            <summary>
            Generate the whole group from the compact list of permutations.
            </summary>
            <returns>a list of permutations</returns>
        </member>
        <member name="M:NCDK.Groups.PermutationGroup.ChangeBase(NCDK.Groups.Permutation)">
            <summary>
            Change the base of the group to the new base <paramref name="newBase"/>.
            </summary>
            <param name="newBase">the new base for the group</param>
        </member>
        <member name="M:NCDK.Groups.PermutationGroup.Enter(NCDK.Groups.Permutation)">
            <summary>
            Enter the permutation <paramref name="g"/> into this group.
            </summary>
            <param name="g">a permutation to add to the group</param>
        </member>
        <member name="M:NCDK.Groups.PermutationGroup.Test(NCDK.Groups.Permutation)">
            <summary>
            Test a permutation to see if it is in the group. Note that this also
            alters the permutation passed in.
            </summary>
            <param name="permutation">the one to test</param>
            <returns>the position it should be in the group, if any</returns>
        </member>
        <member name="T:NCDK.IChemObject">
            <summary>
            The base class for all chemical objects in this cdk. It provides methods for
            adding listeners and for their notification of events, as well a a hash
            table for administration of physical or chemical properties
            </summary>
        </member>
        <member name="M:NCDK.IChemObject.SetProperty(System.Object,System.Object)">
            <summary>
            Sets a property for a <see cref="T:NCDK.IChemObject"/>.
            </summary>
            <param name="description">An object description of the property (most likely a unique string)</param>
            <param name="property">An object with the property itself</param>
            <seealso cref="M:NCDK.IChemObject.GetProperty``1(System.Object)"/>
            <seealso cref="M:NCDK.IChemObject.RemoveProperty(System.Object)"/>
        </member>
        <member name="M:NCDK.IChemObject.SetProperties(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.Object,System.Object}})">
            <summary>
            Set the properties of this object to the provided map (shallow copy). Any
            existing properties are removed.
            </summary>
            <param name="properties">key-value pairs</param>
        </member>
        <member name="M:NCDK.IChemObject.AddProperties(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.Object,System.Object}})">
            <summary>
            Add properties to this object, duplicate keys will replace any existing value.
            </summary>
            <param name="properties"><see cref="T:System.Collections.Generic.KeyValuePair`2"/>s specifying the property values</param>
        </member>
        <member name="M:NCDK.IChemObject.RemoveProperty(System.Object)">
            <summary>
            Removes a property for a <see cref="T:NCDK.IChemObject"/>.
            </summary>
            <param name="description">The object description of the property (most likely a unique string)</param>
            <seealso cref="M:NCDK.IChemObject.SetProperty(System.Object,System.Object)"/>
            <seealso cref="M:NCDK.IChemObject.GetProperty``1(System.Object)"/>
        </member>
        <member name="M:NCDK.IChemObject.GetProperty``1(System.Object)">
            <summary>
            Returns a property for the <see cref="T:NCDK.IChemObject" /> - the object is automatically
            cast to <typeparamref name="T" /> type. 
            </summary>
            <typeparam name="T">Generic return type</typeparam>
            <param name="description">An object description of the property</param>
            <returns>The property</returns>
            <exception cref="T:System.InvalidCastException">If the wrong type is provided.</exception>
            <example>
            <code>using NCDK.Default;
using System;

namespace NCDK
{
    class Property_Example
    {
        static void Main(string[] args)
        {
            IAtom atom = new Atom("C");
            atom.SetProperty("number", 1); // set an integer property
            {
                // access the property and cast to an int
                int number = atom.GetProperty&lt;int&gt;("number");
            }
            {
                // the type cannot be checked and so...
                try
                {
                    string number = atom.GetProperty&lt;string&gt;("number");
                }
                catch (InvalidCastException)
                {
                    Console.WriteLine($"{nameof(InvalidCastException)} is thrown");
                }
            }
        }
    }
}
</code>
            </example>
            <seealso cref="M:NCDK.IChemObject.SetProperty(System.Object,System.Object)" />
            <seealso cref="M:NCDK.IChemObject.GetProperties" />
            <seealso cref="M:NCDK.IChemObject.RemoveProperty(System.Object)" />
        </member>
        <member name="M:NCDK.IChemObject.GetProperty``1(System.Object,``0)">
            <summary>
            Returns a property for the <see cref="T:NCDK.IChemObject"/> or <paramref name="defaultValue"/> if the <paramref name="description"/> key is not in it. 
            </summary>
            <typeparam name="T">Generic return type</typeparam>
            <param name="description">An object description of the property</param>
            <param name="defaultValue">A default value</param>
            <returns>The property</returns>
        </member>
        <member name="M:NCDK.IChemObject.GetProperties">
            <summary>
            Returns a <see cref="T:System.Collections.Generic.IDictionary`2"/> with the <see cref="T:NCDK.IChemObject"/>'s properties.
            </summary>
            <returns>The object's properties as an <see cref="T:System.Collections.Generic.IDictionary`2"/></returns>
            <seealso cref="M:NCDK.IChemObject.AddProperties(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.Object,System.Object}})"/>
        </member>
        <member name="M:NCDK.IChemObject.Compare(System.Object)">
            <summary>
            Deep comparator of <see cref="T:NCDK.IChemObject"/>.  
            </summary>
            <param name="obj">Object to compare with.</param>
            <returns><see langword="true"/> if all properties of this object equals to <paramref name="obj"/>.</returns>
        </member>
        <member name="P:NCDK.IChemObject.Listeners">
            <summary>
            <see cref="T:NCDK.IChemObjectListener"/>s of this <see cref="T:NCDK.IChemObject"/>.
            </summary>
        </member>
        <member name="P:NCDK.IChemObject.Notification">
            <summary>
            The flag that indicates whether notification messages are sent around.
            </summary>
        </member>
        <member name="M:NCDK.IChemObject.NotifyChanged">
            <summary>
            This should be triggered by an method that changes the content of an object
            to that the registered listeners can react to it.
            </summary>
        </member>
        <member name="P:NCDK.IChemObject.Id">
            <summary>
            Identifier (ID) of this object.
            </summary>
        </member>
        <member name="P:NCDK.IChemObject.IsPlaced">
            <summary>Flag that is set if the <see cref="T:NCDK.IChemObject"/> is placed (somewhere).</summary>
        </member>
        <member name="P:NCDK.IChemObject.IsVisited">
            <summary>Flag is set if <see cref="T:NCDK.IChemObject"/> has been visited</summary>
        </member>
        <member name="T:NCDK.IMolecularFormula">
            <summary>
            Class defining a molecular formula object. It maintains a list of <see cref="T:NCDK.IIsotope"/>.
            </summary>
            <remarks>
            Examples:
            <list type="bullet">
            <item>[C5H5]-</item>
            <item>C6H6</item>
            <item><sup>12</sup>C<sub>5</sub><sup>13</sup>CH<sub>6</sub></item>
            </list>
            </remarks>
        </member>
        <member name="M:NCDK.IMolecularFormula.SetProperty(System.Object,System.Object)">
            <summary>
            Sets a property for a <see cref="T:NCDK.IMolecularFormula"/>.
            </summary>
            <param name="description">An object description of the property (most likely a unique string)</param>
            <param name="property">An object with the property itself</param>
            <seealso cref="M:NCDK.IMolecularFormula.GetProperty``1(System.Object)"/>
            <seealso cref="M:NCDK.IMolecularFormula.RemoveProperty(System.Object)"/>
        </member>
        <member name="M:NCDK.IMolecularFormula.SetProperties(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.Object,System.Object}})">
            <summary>
            Set the properties of this object to the provided map (shallow copy). Any
            existing properties are removed.
            </summary>
            <param name="properties">key-value pairs</param>
        </member>
        <member name="M:NCDK.IMolecularFormula.AddProperties(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.Object,System.Object}})">
            <summary>
            Add properties to this object, duplicate keys will replace any existing value.
            </summary>
            <param name="properties"><see cref="T:System.Collections.Generic.KeyValuePair`2"/>s specifying the property values</param>
        </member>
        <member name="M:NCDK.IMolecularFormula.RemoveProperty(System.Object)">
            <summary>
            Removes a property for a <see cref="T:NCDK.IMolecularFormula"/>.
            </summary>
            <param name="description">The object description of the property (most likely a unique string)</param>
            <seealso cref="M:NCDK.IMolecularFormula.SetProperty(System.Object,System.Object)"/>
            <seealso cref="M:NCDK.IMolecularFormula.GetProperty``1(System.Object)"/>
        </member>
        <member name="M:NCDK.IMolecularFormula.GetProperty``1(System.Object)">
            <summary>
            Returns a property for the <see cref="T:NCDK.IMolecularFormula" /> - the object is automatically
            cast to <typeparamref name="T" /> type. 
            </summary>
            <typeparam name="T">Generic return type</typeparam>
            <param name="description">An object description of the property</param>
            <returns>The property</returns>
            <exception cref="T:System.InvalidCastException">If the wrong type is provided.</exception>
            <example>
            <code>using NCDK.Default;
using System;

namespace NCDK
{
    class Property_Example
    {
        static void Main(string[] args)
        {
            IAtom atom = new Atom("C");
            atom.SetProperty("number", 1); // set an integer property
            {
                // access the property and cast to an int
                int number = atom.GetProperty&lt;int&gt;("number");
            }
            {
                // the type cannot be checked and so...
                try
                {
                    string number = atom.GetProperty&lt;string&gt;("number");
                }
                catch (InvalidCastException)
                {
                    Console.WriteLine($"{nameof(InvalidCastException)} is thrown");
                }
            }
        }
    }
}
</code>
            </example>
            <seealso cref="M:NCDK.IMolecularFormula.SetProperty(System.Object,System.Object)" />
            <seealso cref="M:NCDK.IMolecularFormula.GetProperties" />
            <seealso cref="M:NCDK.IMolecularFormula.RemoveProperty(System.Object)" />
        </member>
        <member name="M:NCDK.IMolecularFormula.GetProperty``1(System.Object,``0)">
            <summary>
            Returns a property for the <see cref="T:NCDK.IMolecularFormula"/> or <paramref name="defaultValue"/> if the <paramref name="description"/> key is not in it. 
            </summary>
            <typeparam name="T">Generic return type</typeparam>
            <param name="description">An object description of the property</param>
            <param name="defaultValue">A default value</param>
            <returns>The property</returns>
        </member>
        <member name="M:NCDK.IMolecularFormula.GetProperties">
            <summary>
            Returns a <see cref="T:System.Collections.Generic.IDictionary`2"/> with the <see cref="T:NCDK.IMolecularFormula"/>'s properties.
            </summary>
            <returns>The object's properties as an <see cref="T:System.Collections.Generic.IDictionary`2"/></returns>
            <seealso cref="M:NCDK.IMolecularFormula.AddProperties(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.Object,System.Object}})"/>
        </member>
        <member name="M:NCDK.IMolecularFormula.Add(NCDK.IMolecularFormula)">
            <summary>
            Adds an <see cref="T:NCDK.IMolecularFormula"/> to this <see cref="T:NCDK.IMolecularFormula"/>.
            </summary>
            <param name="formula">The <see cref="T:NCDK.IMolecularFormula"/> to be added to this <see cref="T:NCDK.IChemObject"/></param>
            <returns>the new molecular formula</returns>
        </member>
        <member name="M:NCDK.IMolecularFormula.Add(NCDK.IIsotope)">
            <summary>
            Adds an <see cref="T:NCDK.IIsotope"/> to this <see cref="T:NCDK.IMolecularFormula"/> one time.
            </summary>
            <param name="isotope">The isotope to be added to this <see cref="T:NCDK.IMolecularFormula"/></param>
            <returns>the new molecular formula</returns>
            <seealso cref="M:NCDK.IMolecularFormula.Add(NCDK.IIsotope,System.Int32)"/>
        </member>
        <member name="M:NCDK.IMolecularFormula.Add(NCDK.IIsotope,System.Int32)">
            <summary>
             Adds an <see cref="T:NCDK.IIsotope"/> to this <see cref="T:NCDK.IMolecularFormula"/> in a number of occurrences.
            </summary>
            <param name="isotope">The isotope to be added to this <see cref="T:NCDK.IMolecularFormula"/></param>
            <param name="count">The number of occurrences to add</param>
            <returns>the new molecular formula</returns>
            <seealso cref="M:NCDK.IMolecularFormula.Add(NCDK.IIsotope)"/>
        </member>
        <member name="M:NCDK.IMolecularFormula.GetCount(NCDK.IIsotope)">
            <summary>
            Checks a set of Nodes for the occurrence of the isotope in the
            <see cref="T:NCDK.IMolecularFormula"/> from a particular isotope. It returns 0 if the does not exist.
            </summary>
            <param name="isotope">The <see cref="T:NCDK.IIsotope"/> to look for</param>
            <returns>The occurrence of this isotope in this IMolecularFormula</returns>
        </member>
        <member name="P:NCDK.IMolecularFormula.Isotopes">
            <summary>
             Returns an <see cref="T:System.Collections.Generic.IEnumerable`1"/> for looping over all isotopes in this <see cref="T:NCDK.IMolecularFormula"/>.
            </summary>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> with the isotopes in this <see cref="T:NCDK.IMolecularFormula"/></returns>
        </member>
        <member name="P:NCDK.IMolecularFormula.Count">
            <summary>
            Checks a set of Nodes for the number of different isotopes in the
            <see cref="T:NCDK.IMolecularFormula"/>.
            </summary>
            <value>The the number of different isotopes in this <see cref="T:NCDK.IMolecularFormula"/></value>
        </member>
        <member name="M:NCDK.IMolecularFormula.Contains(NCDK.IIsotope)">
            <summary>
            <see langword="true"/>, if the <see cref="T:NCDK.IMolecularFormula"/> contains the given <see cref="T:NCDK.IIsotope"/> object. Not
            the instance. The method looks for other isotopes which has the same
            symbol, natural abundance and exact mass.
            </summary>
            <param name="isotope">The <see cref="T:NCDK.IIsotope"/> this IMolecularFormula is searched for</param>
            <returns>True, if the <see cref="T:NCDK.IMolecularFormula"/> contains the given isotope object</returns>
        </member>
        <member name="M:NCDK.IMolecularFormula.Remove(NCDK.IIsotope)">
            <summary>
            Removes the given isotope from the <see cref="T:NCDK.IMolecularFormula"/>.
            </summary>
            <param name="isotope">The IIsotope to be removed</param>
        </member>
        <member name="M:NCDK.IMolecularFormula.Clear">
            <summary>
            Removes all isotopes of this molecular formula.
            </summary>
        </member>
        <member name="P:NCDK.IMolecularFormula.Charge">
            <summary>
            Sets the charge of this IMolecularFormula, since there is no atom
            associated with the charge the number of a given isotope is not modified.
            </summary>
            <example>
            <code>
            // Correct usage
            IMolecularFormula phenolate = MolecularFormulaManipulator.GetMolecularFormula("C6H5O", builder)
            mf.Charge = -1;
            // MF=C6H5O-
            
            // Wrong! the H6 is not automatically adjust
            IMolecularFormula phenolate = MolecularFormulaManipulator.getMolecularFormula("C6H6O", builder)
            mf.Charge = -1;
            // MF=C6H6O- (wrong)
            </code>
            
            If you wish to adjust the protonation of a formula try the convenience method of the <see cref="T:NCDK.Tools.Manipulator.MolecularFormulaManipulator"/>:
            
            <code>
            IMolecularFormula mf = MolecularFormulaManipulator.getMolecularFormula("[C6H5O]-", bldr);
            MolecularFormulaManipulator.AdjustProtonation(mf, +1);
            MolecularFormulaManipulator.GetString(mf); // "C6H6O"
            </code>
            </example>
            <value>
            If the charge has not been set the return value is <see langword="null"/>.</value>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.SMARTS.ReactionRoleQueryAtom">
            <summary>
            Matches atoms with a particular role in a reaction.
            </summary>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.SMARTS.AliphaticAtom">
            <summary>
            This matcher any non-aromatic atom. This assumes that aromaticity in the
            molecule has been perceived.
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.AliphaticAtom.#ctor(NCDK.IChemObjectBuilder)">
            <summary>
            Creates a new instance
            </summary>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.SMARTS.AliphaticSymbolAtom">
            <summary>
            This smarts atom matches aliphatic atom with element symbol specified.
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.AliphaticSymbolAtom.#ctor(System.String,NCDK.IChemObjectBuilder)">
            <summary>
            Creates a new instance.
            </summary>
            <param name="symbol">the atom symbol</param>
            <param name="builder"></param>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.SMARTS.AnyAtom">
            <summary>
            This matcher any Atom including explicit hydrogens.
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.AnyAtom.#ctor(NCDK.IChemObjectBuilder)">
            <summary>
            Creates a new instance
            </summary>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.SMARTS.AnyOrderQueryBond">
            <summary>
            This matches a bond of any order.
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.AnyOrderQueryBond.#ctor(NCDK.Isomorphisms.Matchers.IQueryAtom,NCDK.Isomorphisms.Matchers.IQueryAtom,NCDK.BondOrder,NCDK.IChemObjectBuilder)">
            <summary>
            Creates a new instance.
            </summary>
            <param name="atom1"></param>
            <param name="atom2"></param>
            <param name="order"></param>
            <param name="builder"></param>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.SMARTS.AromaticAtom">
            <summary>
            This matcher any aromatic atom. This assumes that aromaticity in the molecule
            has been perceived.
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.AromaticAtom.#ctor(NCDK.IChemObjectBuilder)">
            <summary>
            Creates a new instance
            </summary>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.SMARTS.AromaticOrSingleQueryBond">
            <summary>
            This matches an aromatic or a single bond, used when no bond is specified between an atom.
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.AromaticOrSingleQueryBond.#ctor(NCDK.IChemObjectBuilder)">
            <summary>
            Creates a new instance.
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.AromaticOrSingleQueryBond.#ctor(NCDK.Isomorphisms.Matchers.IQueryAtom,NCDK.Isomorphisms.Matchers.IQueryAtom,NCDK.BondOrder,NCDK.IChemObjectBuilder)">
            <summary>
            Creates a new instance
            </summary>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.SMARTS.AromaticQueryBond">
            <summary>
            This matches an aromatic bond.
            </summary>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.SMARTS.AromaticSymbolAtom">
            <summary>
            This class matches aromatic atom with element symbol specified.
            </summary>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.SMARTS.AtomicNumberAtom">
            <summary>
            This matches an atom using the atomic number.
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.AtomicNumberAtom.#ctor(System.Int32,NCDK.IChemObjectBuilder)">
            <summary>
            Creates a new instance.
            </summary>
            <param name="atomicNumber"></param>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.SMARTS.ChiralityAtom">
            <summary>
            This matches an atom with chirality property. It is not implemented yet.
            It'll match any atom right now.
            </summary>
        </member>
        <member name="P:NCDK.Isomorphisms.Matchers.SMARTS.ChiralityAtom.Degree">
            <summary>
            The degree of the chirality
            </summary>
        </member>
        <member name="P:NCDK.Isomorphisms.Matchers.SMARTS.ChiralityAtom.IsUnspecified">
            <summary>
            Whether unspecified chirality should be taken into consideration
            </summary>
        </member>
        <member name="P:NCDK.Isomorphisms.Matchers.SMARTS.ChiralityAtom.IsClockwise">
            <summary>
            Whether the chirality is clockwise
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.ChiralityAtom.#ctor(NCDK.IChemObjectBuilder)">
            <summary>
            Creates a new instance
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.ChiralityAtom.ChiralityMatches(NCDK.IAtom,System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.SMARTS.ExplicitConnectionAtom">
            <summary>
            Match an atom with the defined degree. The degree is also referred to as the
            explicit connectivity and is encoded in smarts using <c>D&lt;NUMBER&gt;</c>.
            </summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Matchers.SMARTS.ExplicitConnectionAtom.degree">
            <summary>Number of explicit connections.</summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.ExplicitConnectionAtom.#ctor(System.Int32,NCDK.IChemObjectBuilder)">
            <summary>
            Create a query atom for matching the degree of an atom. The degree is the
            number connected atoms.
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.ExplicitConnectionAtom.Matches(NCDK.IAtom)">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.SMARTS.FormalChargeAtom">
            <summary>
            This matcher checks the formal charge of the Atom.
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.FormalChargeAtom.#ctor(System.Int32,NCDK.IChemObjectBuilder)">
            <summary>
            Creates a new instance
            </summary>
            <param name="charge"></param>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.SMARTS.HybridizationNumberAtom">
            <summary>
            This matcher checks the hybridization state of an atom.
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.HybridizationNumberAtom.#ctor(System.Int32,NCDK.IChemObjectBuilder)">
            <summary>
            Creates a new instance
            </summary>
            <param name="hybridizationNumber">the hybridiation</param>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.SMARTS.HydrogenAtom">
            <summary>
            This matches Hydrogen atoms.
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.HydrogenAtom.#ctor(NCDK.IChemObjectBuilder)">
            <summary>Creates a new instance.</summary>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.SMARTS.ImplicitHCountAtom">
            <summary>
            This matcher checks the number of implicit hydrogens of the Atom.
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.ImplicitHCountAtom.#ctor(System.Int32,NCDK.IChemObjectBuilder)">
            <summary>
            Creates a new instance
            </summary>
            <param name="hcount"></param>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.SMARTS.LogicalOperatorAtom">
            <summary>
            This class matches a logical operator that connects two query atoms. Logical
            matchers are created with,  <see cref="M:NCDK.Isomorphisms.Matchers.SMARTS.LogicalOperatorAtom.And(NCDK.Isomorphisms.Matchers.IQueryAtom,NCDK.Isomorphisms.Matchers.IQueryAtom)"/>, 
            <see cref="M:NCDK.Isomorphisms.Matchers.SMARTS.LogicalOperatorAtom.Not(NCDK.Isomorphisms.Matchers.IQueryAtom)"/> and <see cref="M:NCDK.Isomorphisms.Matchers.SMARTS.LogicalOperatorAtom.Or(NCDK.Isomorphisms.Matchers.IQueryAtom,NCDK.Isomorphisms.Matchers.IQueryAtom)"/>.
            </summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Matchers.SMARTS.LogicalOperatorAtom.left">
            <summary>Left child</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Matchers.SMARTS.LogicalOperatorAtom.operator_">
            <summary>Name of operator</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Matchers.SMARTS.LogicalOperatorAtom.right">
            <summary>Right child</summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.LogicalOperatorAtom.Matches(NCDK.IAtom)">
            <summary>
            </summary>
            <param name="atom"></param>
            <returns></returns>
            <see cref="M:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtom.Matches(NCDK.IAtom)"/>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.LogicalOperatorAtom.And(NCDK.Isomorphisms.Matchers.IQueryAtom,NCDK.Isomorphisms.Matchers.IQueryAtom)">
            <summary>
            Conjunction the provided expressions.
            </summary>
            <param name="left">expression</param>
            <param name="right">expression</param>
            <returns>conjunction of the left and right expressions</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.LogicalOperatorAtom.Or(NCDK.Isomorphisms.Matchers.IQueryAtom,NCDK.Isomorphisms.Matchers.IQueryAtom)">
            <summary>
            Disjunction the provided expressions.
            </summary>
            <param name="left">expression</param>
            <param name="right">expression</param>
            <returns>disjunction of the left and right expressions</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.LogicalOperatorAtom.Not(NCDK.Isomorphisms.Matchers.IQueryAtom)">
            <summary>
            Negate the provided expression.
            </summary>
            <param name="expr">expression to negate</param>
            <returns>a SMARTS atom which is the negation of the expression</returns>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.SMARTS.LogicalOperatorAtom.Conjunction">
            <summary>Defines a conjunction (AND) between two query atoms.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Matchers.SMARTS.LogicalOperatorAtom.Conjunction.left">
            <summary>left and right of the operator.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Matchers.SMARTS.LogicalOperatorAtom.Conjunction.right">
            <summary>left and right of the operator.</summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.LogicalOperatorAtom.Conjunction.#ctor(NCDK.IChemObjectBuilder,NCDK.Isomorphisms.Matchers.IQueryAtom,NCDK.Isomorphisms.Matchers.IQueryAtom)">
            <summary>
            Create a disjunction of <see cref="P:NCDK.Isomorphisms.Matchers.SMARTS.LogicalOperatorAtom.Conjunction.Left"/> or <see cref="F:NCDK.Isomorphisms.Matchers.SMARTS.LogicalOperatorAtom.Conjunction.right"/>.
            </summary>
            <param name="builder">chem object builder</param>
            <param name="left">the expression to negate</param>
            <param name="right">the expression to negate</param>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.LogicalOperatorAtom.Conjunction.Matches(NCDK.IAtom)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.LogicalOperatorAtom.Conjunction.ChiralityMatches(NCDK.IAtom,System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.SMARTS.LogicalOperatorAtom.Disjunction">
            <summary>Defines a disjunction (or) between two query atoms.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Matchers.SMARTS.LogicalOperatorAtom.Disjunction.left">
            <summary>left of the operator.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Matchers.SMARTS.LogicalOperatorAtom.Disjunction.right">
            <summary>right of the operator.</summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.LogicalOperatorAtom.Disjunction.#ctor(NCDK.IChemObjectBuilder,NCDK.Isomorphisms.Matchers.IQueryAtom,NCDK.Isomorphisms.Matchers.IQueryAtom)">
            <summary>
            Create a disjunction of <see cref="P:NCDK.Isomorphisms.Matchers.SMARTS.LogicalOperatorAtom.Disjunction.Left"/> or <see cref="F:NCDK.Isomorphisms.Matchers.SMARTS.LogicalOperatorAtom.Disjunction.right"/>.
            </summary>
            <param name="builder">chem object builder</param>
            <param name="left">the expression to negate</param>
            <param name="right">the expression to negate</param>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.LogicalOperatorAtom.Disjunction.Matches(NCDK.IAtom)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.LogicalOperatorAtom.Disjunction.ChiralityMatches(NCDK.IAtom,System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.SMARTS.LogicalOperatorAtom.Negation">
            <summary>Defines a negation (not) of a query atom.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Matchers.SMARTS.LogicalOperatorAtom.Negation.expression">
            <summary>Expression to negate.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Matchers.SMARTS.LogicalOperatorAtom.Negation.chiral">
            <summary>Is the expression chiral - if so, always true!</summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.LogicalOperatorAtom.Negation.#ctor(NCDK.IChemObjectBuilder,NCDK.Isomorphisms.Matchers.IQueryAtom)">
            <summary>
            Create a negation of <paramref name="expression"/>.
            </summary>
            <param name="builder">chem object builder</param>
            <param name="expression">the expression to negate</param>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.LogicalOperatorAtom.Negation.Matches(NCDK.IAtom)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.LogicalOperatorAtom.Negation.ChiralityMatches(NCDK.IAtom,System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.SMARTS.LogicalOperatorBond">
            <summary>
            This class matches a logical operator that connects two query bonds.
            </summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Matchers.SMARTS.LogicalOperatorBond.left">
            <summary>
            Left child
            </summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Matchers.SMARTS.LogicalOperatorBond.operator_">
            <summary>
            Name of the operator
            </summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Matchers.SMARTS.LogicalOperatorBond.right">
            <summary>
            Right child
            </summary>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.SMARTS.MassAtom">
            <summary>
            This class matches an atom based on the atomic mass.
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.MassAtom.#ctor(System.Int32,NCDK.IChemObjectBuilder)">
            <summary>
            Creates a new instance
            </summary>
            <param name="mass"></param>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.SMARTS.NonCHHeavyAtom">
            <summary>
            This matcher any heavy atom that is not C or H.
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.NonCHHeavyAtom.#ctor(NCDK.IChemObjectBuilder)">
            <summary>
            Creates a new instance
            </summary>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.SMARTS.OrderQueryBond">
             <summary>
             This matches a bond with a certain bond order.
            
             Daylight spec indicates that if match a single bond
             using '-', it should be an aliphatic single bond
             </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.OrderQueryBond.#ctor(NCDK.BondOrder,NCDK.IChemObjectBuilder)">
            <summary>
            Creates a new instance
            </summary>
            <param name="order">the order of bond</param>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.SMARTS.PeriodicGroupNumberAtom">
            <summary>
            This matcher checks the periodic group number of an atom.
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.PeriodicGroupNumberAtom.#ctor(System.Int32,NCDK.IChemObjectBuilder)">
            <summary>
            Creates a new instance
            </summary>
            <param name="groupNumber">the periodic group number</param>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.SMARTS.RecursiveSmartsAtom">
            <summary>
            This matches recursive smarts atoms.
            </summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Matchers.SMARTS.RecursiveSmartsAtom.query">
            <summary>The IQueryAtomContainer created by parsing the recursive smarts</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Matchers.SMARTS.RecursiveSmartsAtom.cache">
            <summary>Query cache.</summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.RecursiveSmartsAtom.#ctor(NCDK.Isomorphisms.Matchers.IQueryAtomContainer)">
            <summary>
            Creates a new instance
            </summary>
            <param name="query"></param>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.SMARTS.RingBond">
            <summary>
            This smarts bond matches any bond that is in a ring.
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.RingBond.#ctor(NCDK.IChemObjectBuilder)">
            <summary>
            Creates a new instance
            </summary>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.SMARTS.RingIdentifierAtom">
            <summary>
            This encapsulates an atom with a ring identifier, with an optional ring
            bond specified. For example, <c>C=1CCCCC1</c>.
            </summary>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.SMARTS.RingMembershipAtom">
            <summary>
            This query is found in a specified number of ring. The ring membership is
            specified with the SMARTS <c>R&lt;NUMBER&gt;</c>. The membership depends on the
            ring set used and as such is not a portable term. If the Smallest Set of
            Smallest Rings (SSSR) is used then changing the order of atoms
            <i>may</i> change which atoms match in a pattern.
            </summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Matchers.SMARTS.RingMembershipAtom.ringNumber">
            <summary>
            Number of rings to which this atom belongs, if &lt; 0 check any ring
            membership.
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.RingMembershipAtom.#ctor(System.Int32,NCDK.IChemObjectBuilder)">
            <summary>
            Ring membership query atom. Check if the an atom belongs to <i>num</i> of
            rings. To specify any ring membership, <i>num</i> should be specified as
            &lt; 0. Generally in SMARTS it's better negate ring membership with <pre>[!R]</pre>
            however for legacy reasons <pre>[R0]</pre> was accepted and checks
            this atoms belongs to 0 rings.
            </summary>
            <param name="num">number of rings which this atom belongs to, &lt; 0 any ring.</param>
            <param name="builder"></param>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.RingMembershipAtom.Matches(NCDK.IAtom)">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.SMARTS.SmallestRingAtom">
            <summary>
            Match an atom in a specific size ring. The ring size is specified by <c>r&lt;NUMBER&gt;</c>
            in a SMARTS pattern. This term is non-portable, depending on the
            set of rings chosen and which ring sizes are used. The default implementation
            (Daylight) only stores the smallest ring each atom belongs to whilst other
            implementations may store multiple values. A more portable term is the
            ring connectivity which is specified as <c>x&lt;NUMBER&gt;</c>.
            </summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Matchers.SMARTS.SmallestRingAtom.ringSize">
            <summary>Ring size to check.</summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.SmallestRingAtom.#ctor(System.Int32,NCDK.IChemObjectBuilder)">
            <summary>
            Creates a matcher for specified ring size.
            </summary>
            <param name="ringSize">size of the ring to check.</param>
            <param name="builder"></param>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.SmallestRingAtom.Matches(NCDK.IAtom)">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtom">
            <summary>
            Abstract smarts atom.
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtom.Invariants(NCDK.IAtom)">
            <summary>
            Access the atom invariants for this atom. If the invariants have not been
            set an exception is thrown.
            </summary>
            <param name="atom">the atom to obtain the invariants of</param>
            <returns>the atom invariants for the atom</returns>
            <exception cref="T:System.NullReferenceException">thrown if the invariants were not set</exception>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtom.ChiralityMatches(NCDK.IAtom,System.Int32,System.Int32)">
             <summary>
             Check if the atom-based chirality of the target matches. This check is
             done post-matching and should only be checked on atoms which are know to
             have already been matched (<see cref="M:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtom.Matches(NCDK.IAtom)"/>).
            
             Currently the only atom-based chirality allowed is tetrahedral stereo-chemistry. 
             </summary>
             <param name="target">the matched target (required to verify 'OR' conditions)</param>
             <param name="tParity">the parity (winding) of the target centre, 0=unspecified, 1=clockwise and -1=anticlockwise</param>
             <param name="permParity">permutation parity of the query neighbors (will be multiplied by the query parity)</param>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtomInvariants">
            <summary>
            Computes and stores atom invariants in a single object. The atom invariants
            are utilised as additional information for the <see cref="T:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtom"/>s to match.
            The values provide additional invariants which are not defined in the <see cref="T:NCDK.IAtom"/> 
            API and avoids storing multiple properties in a type unsafe map
            (<see cref="M:NCDK.IChemObject.SetProperty(System.Object,System.Object)"/>). 
            </summary>
            <remarks>
            <para>Depending on the SMARTS
            implementation different values for the ring information may be set. The
            choice of ring set affects <see cref="P:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtomInvariants.RingNumber"/> and <see cref="P:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtomInvariants.RingSize"/> .
            Some implementations store all ring sizes whilst others (Daylight) store only
            the smallest. The <see cref="P:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtomInvariants.Degree"/>  also depends on whether hydrogens are
            suppressed or represented as explicit atoms. </para>
            <para>The <see cref="M:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtomInvariants.ConfigureDaylightWithRingInfo(NCDK.IAtomContainer)"/> and
            <see cref="M:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtomInvariants.ConfigureDaylightWithoutRingInfo(NCDK.IAtomContainer)"/>
            static utilities create
            and set the invariants following the Daylight implementation. The invariants
            are set on the <see cref="F:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtomInvariants.Key"/>  property of each atom.
            </para>
            </remarks>
        </member>
        <member name="F:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtomInvariants.Key">
            <summary>Property key to index the class by.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtomInvariants.target">
            <summary>the molecule which this atom belongs.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtomInvariants.valence">
            <summary>Total number of bonds formed - also refereed to as bond order sum.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtomInvariants.ringNumber">
            <summary>The number of rings this atom can be found in.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtomInvariants.ringSize">
            <summary>The size of rings an atom is found in.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtomInvariants.connectivity">
            <summary>Total number of connected atoms including implicit hydrogens.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtomInvariants.ringConnectivity">
            <summary>Total number of connected ring bonds.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtomInvariants.degree">
            <summary>Total number of explicitly connected atoms.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtomInvariants.totalHydrogenCount">
            <summary>The total number of hydrogens on an atom.</summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtomInvariants.#ctor(NCDK.IAtomContainer,System.Int32,System.Int32,System.Collections.Generic.ICollection{System.Int32},System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Internal constructor - simple takes all the values.
            </summary>
            <param name="valence">the valence value</param>
            <param name="ringNumber">number of rings an atom belongs to (variable)</param>
            <param name="ringSize">the size of the rings (variable)</param>
            <param name="ringConnectivity">the number of connected ring bonds (or atoms)</param>
            <param name="degree">the degree of an atom</param>
            <param name="connectivity">the number of connections (degree + implicit H count)</param>
            <param name="totalHydrogenCount">the total number of hydrogens</param>
        </member>
        <member name="P:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtomInvariants.Valence">
            <summary>
            Access the valence of this atom. The valence is matched by the <c>v&lt;NUMBER&gt;</c>
            SMARTS token. The valence is the total number of bonds formed
            by this atom and <b>NOT</b> the number of valence electrons. As such
            <c>[v3]</c> will match a 3 valent nitrogen and <c>[v5]</c> will match a
            5 valent nitrogen. The value is separate from <see cref="P:NCDK.IAtomType.Valency"/> 
            so it can be cleaned up after matching and avoid confusion with what the
            value should be.
            </summary>
            <returns>the valence of the atom.</returns>
        </member>
        <member name="P:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtomInvariants.RingNumber">
            <summary>
            The number of rings this atom belong to. The value is matched by the
            <c>R&lt;NUMBER&gt;</c> token and depends on the ring set used. The Daylight
            implementation uses the non-unique Smallest Set of Smallest Rings (SSSR)
            which can lead to inconsistent matches.
            </summary>
            <returns>number or rings</returns>
        </member>
        <member name="P:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtomInvariants.RingSize">
            <summary>
            The sizes of rings this atoms belongs to. The value is matched by the
            <c>r&lt;NUMBER&gt;</c> token and depends on the ring set used. The Daylight
            implementation uses this value to match the smallest ring to which this
            atom is a member. It may be beneficial to match multiple ring sizes (not
            yet defined by OpenSMARTS).
            </summary>
            <returns>ring sizes</returns>
        </member>
        <member name="P:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtomInvariants.RingConnectivity">
            <summary>
            The number of connected ring bonds (or atoms). This value is matched by
            the <c>x&lt;NUMBER&gt;</c> token. The Daylight implementation counts the
            number of connected ring bonds but it may be beneficial to match the atom
            ring connectivity (not yet defined by OpenSMARTS).
            </summary>
            <returns>ring connectivity</returns>
        </member>
        <member name="P:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtomInvariants.Connectivity">
            <summary>
            The number of connected bonds including those to hydrogens. This value is
            matched by the <c>X&lt;NUMBER&gt;</c> token. This value depends on whether the
            hydrogens have been suppressed or are represented as explicit atoms.
            </summary>
            <returns>connectivity</returns>
        </member>
        <member name="P:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtomInvariants.Degree">
            <summary>
            The degree of a vertex defined as the number of explicit connected bonds.
            This value is matched by the <c>D&lt;NUMBER&gt;</c> token. This value depends
            on whether the hydrogens have been suppressed or are represented as
            explicit atoms.
            </summary>
            <returns>connectivity</returns>
        </member>
        <member name="P:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtomInvariants.TotalHydrogenCount">
            <summary>
            The total number of hydrogens attached to an atom.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtomInvariants.ConfigureDaylightWithoutRingInfo(NCDK.IAtomContainer)">
            <summary>
            Computes <see cref="T:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtomInvariants"/> and stores on the <see cref="F:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtomInvariants.Key"/> or
            each <see cref="T:NCDK.IAtom"/> in the <paramref name="container"/>. The <see cref="P:NCDK.IMolecularEntity.IsInRing"/>  
            is also set for each bond. This configuration does
            not include ring information and values are left as unset.
            Ring membership is still configured but not ring size.
            </summary>
            <example>
            <code>
                IAtomContainer container = ...;
                SMARTSAtomInvariants.ConfigureDaylightWithoutRingInfo(container);
                foreach (var atom in container.Atoms) {
                    SMARTSAtomInvariants inv = atom.GetProperty&lt;SMARTSAtomInvariants&gt;(SMARTSAtomInvariants.Key);
                }
            </code>
            </example>
            <param name="container">the container to configure</param>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtomInvariants.ConfigureDaylightWithRingInfo(NCDK.IAtomContainer)">
            <summary>
            Computes <see cref="T:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtomInvariants"/> and stores on the <see cref="F:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtomInvariants.Key"/> or
            each <see cref="T:NCDK.IAtom"/> in the <paramref name="container"/>. The <see cref="P:NCDK.IMolecularEntity.IsInRing"/>  
            is also set for each bond. This configuration
            includes the ring information as used by the Daylight implementation.
            That is the Smallest Set of Smallest Rings (SSSR) is used and only the
            smallest ring is stored for the <see cref="P:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtomInvariants.RingSize"/> .
            </summary>
            <example>
            <code>
                IAtomContainer container = ...;
                SMARTSAtomInvariants.ConfigureDaylightWithRingInfo(container);
                foreach (var atom in container.Atoms) {
                    SMARTSAtomInvariants inv = atom.GetProperty&lt;SMARTSAtomInvariants&gt;(SMARTSAtomInvariants.Key);
                }
            </code>
            </example>
            <param name="container">the container to configure</param>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtomInvariants.ConfigureDaylight(NCDK.IAtomContainer,System.Int32[][],NCDK.Graphs.GraphUtil.EdgeToBondMap,System.Boolean)">
            <summary>
            Computes invariants - see <see cref="M:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtomInvariants.ConfigureDaylightWithRingInfo(NCDK.IAtomContainer)"/> 
            and <see cref="M:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtomInvariants.ConfigureDaylightWithoutRingInfo(NCDK.IAtomContainer)"/>.
            </summary>
            <param name="container">the container to configure</param>
            <param name="graph">the graph for quick traversal</param>
            <param name="bondMap">the bond map for quick bond lookup</param>
            <param name="ringInfo">logical condition as whether ring info should be included</param>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSBond">
            <summary>
            Abstract smarts bond.
            </summary>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.SMARTS.SmartsMatchers">
            <summary>
            Bridging class between the SMARTS matcher and the parser/query tool. The
            class are currently split across different packages. This classes temporary
            functionality is to expose package private functionality through a single
            location.
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.SmartsMatchers.Prepare(NCDK.IAtomContainer,System.Boolean)">
             <summary>
             Do not use - temporary method until the SMARTS packages are cleaned up.
            
             Prepares a target molecule for matching with SMARTS.
             </summary>
             <param name="container">the container to initialise</param>
             <param name="ringQuery">whether the smarts will check ring size queries</param>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.SMARTS.StereoBond">
            <summary>
            This query bond indicates a particular geometric stereo configuration.
            </summary>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.SMARTS.TotalConnectionAtom">
            <summary>
            This matches an atom using total number of connections - referred to in
            SMARTS as the connectivity. The connectivity is specified using the <c>X&lt;NUMBER&gt;</c> pattern.
            </summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Matchers.SMARTS.TotalConnectionAtom.connectivity">
            <summary>Total number of connections from an atom including H count.</summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.TotalConnectionAtom.#ctor(System.Int32,NCDK.IChemObjectBuilder)">
            <summary>Creates a new instance.</summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.TotalConnectionAtom.Matches(NCDK.IAtom)">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.SMARTS.TotalHCountAtom">
            <summary>
            SMARTS query atom for matching the total hydrogen count. This count is
            specified in SMARTS using <c>H&lt;NUMBER&gt;</c>.
            </summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Matchers.SMARTS.TotalHCountAtom.totalHCount">
            <summary>The total hydrogen count to match.</summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.TotalHCountAtom.Matches(NCDK.IAtom)">
            <summary>
            Check if the total hydrogen count of the <paramref name="atom"/> is equal to the
            query.
            </summary>
            <param name="atom">the atom to match</param>
            <returns>the hydrogen count matches</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.TotalHCountAtom.ToString">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.SMARTS.TotalRingConnectionAtom">
            <summary>
            This matcher checks the number of ring connections of the checked Atom with
            other Atom's. This cannot be matched without prepossessing Atom - <see cref="T:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtomInvariants"/>.
            The ring connectivity is encoded in smarts using <c>x&lt;NUMBER&gt;</c>.
            </summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Matchers.SMARTS.TotalRingConnectionAtom.ringConnectivity">
            <summary>Number of rings.</summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.TotalRingConnectionAtom.#ctor(System.Int32,NCDK.IChemObjectBuilder)">
            <summary>
            Create a matcher for the number of rings an atom belongs to.
            </summary>
            <param name="ringConnectivity">number of ring bonds this atom is adjacent to</param>
            <param name="builder"></param>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.TotalRingConnectionAtom.Matches(NCDK.IAtom)">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.SMARTS.TotalValencyAtom">
            <summary>
            This matcher checks the valence of the Atom. The valence is the number of
            bonds formed by an atom (including bonds to implicit hydrogens).
            </summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Matchers.SMARTS.TotalValencyAtom.valence">
            <summary>
            The valence to match.
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.TotalValencyAtom.#ctor(System.Int32,NCDK.IChemObjectBuilder)">
            <summary>
            Match the valence of atom.
            </summary>
            <param name="valence">valence value</param>
            <param name="builder">chem object builder (required for ChemObject.getBuilder)</param>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.TotalValencyAtom.Matches(NCDK.IAtom)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.QueryAtomContainer.#ctor(NCDK.IAtomContainer,NCDK.IChemObjectBuilder)">
            <summary>
            Constructs an AtomContainer with a copy of the atoms and electronContainers
            of another AtomContainer (A shallow copy, i.e., with the same objects as in
            the original AtomContainer).
            </summary>
            <param name="container">An AtomContainer to copy the atoms and electronContainers from</param>
            <param name="builder"></param>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.QueryAtomContainer.#ctor(NCDK.IChemObjectBuilder)">
            <summary>
             Constructs an empty AtomContainer that will contain a certain number of
             atoms and electronContainers. It will set the starting array lengths to the
             defined values, but will not create any Atom or ElectronContainer's.
            </summary>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.IQueryAtom">
            <summary>
            Defines the ability to be matched against <see cref="T:NCDK.IAtom"/>'s. Most prominent application
            is in isomorphism and substructure matching in the <see cref="T:NCDK.Isomorphisms.UniversalIsomorphismTester"/>.
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.IQueryAtom.Matches(NCDK.IAtom)">
            <summary>
            Returns true of the given <paramref name="atom"/> matches this <see cref="T:NCDK.Isomorphisms.Matchers.IQueryAtom"/>.
            </summary>
            <param name="atom"><see cref="T:NCDK.IAtom"/> to match against</param>
            <returns>true, if this <see cref="T:NCDK.Isomorphisms.Matchers.IQueryAtom"/> matches the given <see cref="T:NCDK.IAtom"/></returns>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.IQueryAtomContainer">
            <summary>
            General concept of a IAtomContainer aimed at doing molecular subgraph queries using the UniversalIsomorphismTester.
            </summary>
            <seealso cref="T:NCDK.Isomorphisms.UniversalIsomorphismTester"/>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.IQueryBond">
            <summary>
            Defines the abililty to be matched against IBond's. Most prominent application
            is in isomorphism and substructure matching in the UniversalIsomorphismTester.
            </summary>
            <seealso cref="T:NCDK.Isomorphisms.UniversalIsomorphismTester"/>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.CTFileQueryBond">
            <summary>
            Captures query bond types defined in the CTFile.
            </summary>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.CTFileQueryBond.BondTypes">
            <summary>
            Bond types, as stated in the CTFile manual
            </summary>
        </member>
        <member name="P:NCDK.Isomorphisms.Matchers.CTFileQueryBond.Type">
            <summary>
            The type of this bond.
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.CTFileQueryBond.OfType(NCDK.IBond,System.Int32)">
            <summary>
            Create a CTFileQueryBond of the specified type (from the MDL spec). The
            bond copies the atoms and sets the type using the value 'type', 5 = single
            or double, 8 = any, etc.
            </summary>
            <param name="bond">an existing bond</param>
            <param name="type">the specified type</param>
            <returns>a new CTFileQueryBond</returns>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.InverseSymbolSetQueryAtom">
            <summary>
             A QueryAtom that matches all symbols but those in this container. You may
             add symbols to this container. This QueryAtom will only give a match if it
             does NOT contain the symbol of the Atom to match (example: add "C" to get a
             match for all non-"C"-Atoms).
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.InverseSymbolSetQueryAtom.#ctor(NCDK.IChemObjectBuilder)">
            <summary>
             Constructor for the InverseSymbolSetQueryAtom object
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.InverseSymbolSetQueryAtom.Matches(NCDK.IAtom)">
            <summary>
             The matches implementation of the <see cref="T:NCDK.Isomorphisms.Matchers.QueryAtom"/> interface.
            </summary>
            <param name="atom">The atom to be matched by this <see cref="T:NCDK.Isomorphisms.Matchers.QueryAtom"/></param>
            <returns>true if Atom matched</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.InverseSymbolSetQueryAtom.AddSymbol(System.String)">
            <summary>
             Add a symbol to this <see cref="T:NCDK.Isomorphisms.Matchers.QueryAtom"/>
            </summary>
            <param name="symbol">The symbol to add</param>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.InverseSymbolSetQueryAtom.RemoveSymbol(System.String)">
            <summary>
            Remove a symbol from this <see cref="T:NCDK.Isomorphisms.Matchers.QueryAtom"/>
            </summary>
            <param name="symbol">The symbol to remove</param>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.InverseSymbolSetQueryAtom.HasSymbol(System.String)">
            <summary>
            Check whether a symbol is already registered
            </summary>
            <param name="symbol">The symbol to check for</param>
            <returns>true if symbol already registered</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.InverseSymbolSetQueryAtom.GetSymbolSet">
             <summary>
             Retrieve the Set of symbols
            
             <returns>The symbol Set</returns>
             </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.InverseSymbolSetQueryAtom.ToString">
            <summary>
             The ToString method
            </summary>
            <returns>The string representation of this object.</returns>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.IRGroupQuery">
            <summary>
            Interface definition for Rgroup query classes. These must provide a root
            structure, root attachment points and Rgroup definitions.
            </summary>
        </member>
        <member name="P:NCDK.Isomorphisms.Matchers.IRGroupQuery.RootStructure">
            <summary>
            The root structure (or scaffold) container
            </summary>
        </member>
        <member name="P:NCDK.Isomorphisms.Matchers.IRGroupQuery.RootAttachmentPoints">
            <summary>
            Root attachment points = bonds that connect R pseudo-atoms to the scaffold.
            </summary>
        </member>
        <member name="P:NCDK.Isomorphisms.Matchers.IRGroupQuery.RGroupDefinitions">
            <summary>
            the R-group definitions (substituents).
            </summary>
        </member>
        <member name="P:NCDK.Isomorphisms.Matchers.IRGroupQuery.Count">
            <summary>
            the total number of atom containers (count the root plus all substituents).
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.IRGroupQuery.GetSubstituents">
            <summary>
            All the substituent atom containers, in other words the atom containers
            defined in this <see cref="T:NCDK.Isomorphisms.Matchers.IRGroupQuery"/> except for the root structure.
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.IRGroupQuery.AreSubstituentsDefined">
            <summary>
            Checks validity of the RGroupQuery.
            Each distinct R# in the root must have a
            a corresponding <see cref="T:NCDK.Isomorphisms.Matchers.RGroupList"/> definition.
            <para>
            In file terms: $RGP blocks must be defined for each R-group number.</para>
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.IRGroupQuery.AreRootAtomsDefined">
            <summary>
            Checks validity of RGroupQuery.
            Each <see cref="T:NCDK.Isomorphisms.Matchers.RGroupList"/> definition must have one or more corresponding
            R# atoms in the root block. 
            Returns <see langword="true"/> when valid
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.IRGroupQuery.GetAllConfigurations">
            <summary>
            Produces all combinations of the root structure (scaffold) with the R-groups
            substituted in valid ways, using each R-group's definitions and conditions.
            </summary>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.OrderQueryBondOrderOnly">
            <summary>
            <see cref="T:NCDK.Isomorphisms.Matchers.IQueryBond"/> that matches IBond object only based on bond order, and
            disregarding any aromaticity flag.
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.QueryAtomContainerCreator.CreateBasicQueryContainer(NCDK.IAtomContainer)">
            <summary>
            Creates a <see cref="T:NCDK.Isomorphisms.Matchers.QueryAtomContainer"/> with <see cref="T:NCDK.Isomorphisms.Matchers.SymbolQueryAtom"/>'s, <see cref="T:NCDK.Isomorphisms.Matchers.QueryAtomContainerCreator.AromaticQueryBond"/>'s and
            <see cref="T:NCDK.Isomorphisms.Matchers.OrderQueryBond"/>'s. If a IBond of the input <paramref name="container"/> is flagged
            aromatic, then it disregards bond order information and only match against
            an aromatic target atom instead.
            </summary>
            <param name="container">The <see cref="T:NCDK.IAtomContainer"/> that stands as model</param>
            <returns>The new <see cref="T:NCDK.Isomorphisms.Matchers.QueryAtomContainer"/> created from container.</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.QueryAtomContainerCreator.CreateSymbolAndBondOrderQueryContainer(NCDK.IAtomContainer)">
            <summary>
            Creates a <see cref="T:NCDK.Isomorphisms.Matchers.QueryAtomContainer"/> with SymbolQueryAtom's and OrderQueryBond's. Unlike
            <see cref="M:NCDK.Isomorphisms.Matchers.QueryAtomContainerCreator.CreateBasicQueryContainer(NCDK.IAtomContainer)"/>, it disregards aromaticity flags.
            </summary>
            <param name="container">The AtomContainer that stands as model</param>
            <returns>The new QueryAtomContainer created from container.</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.QueryAtomContainerCreator.CreateSymbolAndChargeQueryContainer(NCDK.IAtomContainer)">
            <summary>
             Creates a <see cref="T:NCDK.Isomorphisms.Matchers.QueryAtomContainer"/> with <see cref="T:NCDK.Isomorphisms.Matchers.SymbolAndChargeQueryAtom"/>'s and
             <see cref="T:NCDK.Isomorphisms.Matchers.OrderQueryBond"/>'s.
            </summary>
            <param name="container">The <see cref="T:NCDK.IAtomContainer"/> that stands as model</param>
            <returns>The new <see cref="T:NCDK.Isomorphisms.Matchers.QueryAtomContainer"/> created from container.</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.QueryAtomContainerCreator.CreateAnyAtomContainer(NCDK.IAtomContainer,System.Boolean)">
            <summary>
             Creates a QueryAtomContainer with AnyAtoms / Aromatic Atoms and OrderQueryBonds / AromaticQueryBonds.
             It uses the CDKConstants.ISAROMATIC flag to determine the aromaticity of container.
            </summary>
            <param name="container">The AtomContainer that stands as model</param>
            <param name="aromaticity">True = use aromaticity flags to create AtomaticAtoms and AromaticQueryBonds</param>
            <returns>The new QueryAtomContainer created from container</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.QueryAtomContainerCreator.CreateAnyAtomAnyBondContainer(NCDK.IAtomContainer,System.Boolean)">
            <summary>
            Creates a <see cref="T:NCDK.Isomorphisms.Matchers.QueryAtomContainer"/> with wildcard atoms and wildcard bonds.
            <para>
            This method thus allows the user to search based only on connectivity.</para>
            </summary>
            <param name="container">The AtomContainer that stands as the model</param>
            <param name="aromaticity">If True, aromaticity flags are checked to create AromaticAtoms and AromaticQueryBonds</param>
            <returns>The new QueryAtomContainer</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.QueryAtomContainerCreator.CreateAnyAtomForPseudoAtomQueryContainer(NCDK.IAtomContainer)">
            <summary>
             Creates a <see cref="T:NCDK.Isomorphisms.Matchers.QueryAtomContainer"/> with <see cref="T:NCDK.Isomorphisms.Matchers.SymbolQueryAtom"/>'s and
             <see cref="T:NCDK.Isomorphisms.Matchers.OrderQueryBond"/>'s. Each <see cref="T:NCDK.IPseudoAtom"/> will be replaced by a
             <see cref="T:NCDK.Isomorphisms.Matchers.QueryAtomContainerCreator.AnyAtom"/>
            </summary>
            <param name="container">The AtomContainer that stands as model</param>
            <returns>The new QueryAtomContainer created from container.</returns>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.QueryAtomContainerCreator.AnyAtom">
            <summary>Match any atom.</summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.QueryAtomContainerCreator.AnyAtom.Matches(NCDK.IAtom)">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.QueryAtomContainerCreator.AromaticAtom">
            <summary>Match any aromatic atom.</summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.QueryAtomContainerCreator.AromaticAtom.Matches(NCDK.IAtom)">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.QueryAtomContainerCreator.AnyOrderBond">
            <summary>Match any bond which doesn't have a null or unset bond order.</summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.QueryAtomContainerCreator.AnyOrderBond.Matches(NCDK.IBond)">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.QueryAtomContainerCreator.AromaticQueryBond">
            <summary>Match any aromatic bond.</summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.QueryAtomContainerCreator.AromaticQueryBond.Matches(NCDK.IBond)">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.QueryBond">
            <summary>
            Implements the concept of a "query bond" between two or more atoms.
            Query bonds can be used to capture types such as "Single or Double" or "Any".
            </summary>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.RGroup">
            <summary>
            Represents a single substitute structure in an <see cref="T:NCDK.Isomorphisms.Matchers.RGroupList"/>.
            <para>
            The order of attachment points is provided (first and second only, conform
            RGFile spec). This order is relevant when the structure connects to the root
            with more than one bond.</para>
            </summary>
            <seealso cref="T:NCDK.Isomorphisms.Matchers.RGroupList"/>
            <seealso cref="T:NCDK.Isomorphisms.Matchers.RGroupQuery"/>
        </member>
        <member name="F:NCDK.Isomorphisms.Matchers.RGroup.ROOT_LABEL">
            <summary>
            Standard label/title to be used for the root atom container.
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.RGroup.MakeLabel(System.Int32)">
            <summary>
            Makes a label/title to be used for a substituent.
            </summary>
            <param name="rgroupNum">R-Group number (1..32)</param>
            <returns>label for substituent, like "R3"</returns>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.RGroupList">
            <summary>
            Represents a list of Rgroup substitutes to be associated with some
            <see cref="T:NCDK.Isomorphisms.Matchers.RGroupQuery"/>.
            </summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Matchers.RGroupList.DEFAULT_OCCURRENCE">
            <summary>
            Default value for occurrence field.
            </summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Matchers.RGroupList.rGroupNumber">
            <summary>
            Unique number to identify the Rgroup.
            </summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Matchers.RGroupList.IsRestH">
            <summary>
            Indicates that sites labeled with this Rgroup may only be
            substituted with a member of the Rgroup or with hydrogen.
            </summary>
        </member>
        <member name="P:NCDK.Isomorphisms.Matchers.RGroupList.RGroups">
            <summary>
            List of substitute structures.
            </summary>
        </member>
        <member name="P:NCDK.Isomorphisms.Matchers.RGroupList.RequiredRGroupNumber">
            <summary>
            The rGroup (say B) that is required when this one (say A) exists.
            This captures the "LOG" information 'IF A (this) THEN B'.
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.RGroupList.#ctor(System.Int32)">
            <summary>
            Default constructor.
            </summary>
            <param name="rGroupNumber"></param>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.RGroupList.#ctor(System.Int32,System.Boolean,System.String,System.Int32)">
            <summary>
            Constructor with attributes given.
            </summary>
            <param name="rGroupNumber">R-Group number</param>
            <param name="restH">restH</param>
            <param name="occurrence">occurrence</param>
            <param name="requiredRGroupNumber">number of other R-Group required</param>
        </member>
        <member name="P:NCDK.Isomorphisms.Matchers.RGroupList.RGroupNumber">
            <summary>
            R-Group number, checks for valid range.
            Spec: "value from 1 to 32 *, labels position of Rgroup on root."
            </summary>
        </member>
        <member name="P:NCDK.Isomorphisms.Matchers.RGroupList.Occurrence">
            <summary>
            The occurrence value. Validates user input to be conform the(Symyx) specification.
            <see cref="M:NCDK.Isomorphisms.Matchers.RGroupList.IsValidOccurrenceSyntax(System.String)"/>
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.RGroupList.IsValidOccurrenceSyntax(System.String)">
            <summary>
            Validates the occurrence value.
            <list type="bullet">
            <item>n : exactly n ;</item>
            <item>n - m : n through m ;</item>
            <item>&#62; n : greater than n ;</item>
            <item>&#60; n : fewer than n ;</item>
            <item>default (blank) is &gt; 0 ;</item>
            </list> 
            Any non-contradictory combination of the preceding values is also
            allowed; for example "1, 3-7, 9, &gt;11".
            </summary>
            <param name="occ">string to validate.</param>
            <returns><see langword="true"/> if valid string provided.</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.RGroupList.Match(System.String,System.String)">
            <summary>
            Helper method for regular expression matching.
            </summary>
            <param name="regExp">regular expression string</param>
            <param name="userInput">user's input</param>
            <returns>the regular expression matched the user input</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.RGroupList.MatchOccurence(System.Int32)">
            <summary>
            Matches the 'occurrence' condition with a provided maximum number of
            RGroup attachments. Returns the valid occurrences (numeric) for these
            two combined. If none found, returns empty list.
            </summary>
            <remarks>
            <para>
            Example: if R1 occurs 3 times attached to some root structure, then
            stating "&gt;5" as an occurrence for that RGoupList does not make
            sense: the example R1 can occur 0..3 times. Empty would be returned.
            </para>
            <para>
            If the occurence would be &gt;2, then 3 would be returned. Etcetera.
            </para>
            </remarks>
            <param name="maxAttachments">number of attachments</param>
            <returns>valid values by combining a max for R# with the occurrence cond.</returns>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.RGroupQuery">
            <summary>
            Represents information contained in a Symyx RGfile (R-group query file).
            </summary>
            <remarks>
            <para>
            It contains a root structure (the scaffold if you like), a map with
            R-group definitions (each of which can contain multiple substitutes) and
            a map with attachment points. The attachment points define a connection
            order for the substitutes, which is relevant when an Rgroup is connected
            to the scaffold with more than one bond.
            </para>
            <para>
            This class can also be used to produce all the valid configurations
            for the combination of its root,definitions and conditions.
            </para>
            <para>
            This Javadoc does not contain a code sample how to create a new RGroupQuery
            from scratch, because a sensible RGroupQuery has quite a few attributes to be set
            including a root plus a bunch of substituents, which are all atom containers.
            So that would be a lot of sample code here.
            </para>
            <para>
            The best way to get a feel for the way the RGroup objects are populated is to
            run the RGroupQueryReaderTest and look at the sample
            input RGroup query files contained in the CDK and how they translate into
            RGroupXX objects. The JChempaint application can visualize the input files for you.
            </para>
            </remarks>
        </member>
        <member name="P:NCDK.Isomorphisms.Matchers.RGroupQuery.RootStructure">
            <summary>
            The root structure (or scaffold) to which R-groups r attached.
            </summary>
        </member>
        <member name="P:NCDK.Isomorphisms.Matchers.RGroupQuery.RGroupDefinitions">
            <summary>
            Rgroup definitions, each a list of possible substitutes for the
            given R number.
            </summary>
        </member>
        <member name="P:NCDK.Isomorphisms.Matchers.RGroupQuery.RootAttachmentPoints">
            <summary>
            For each Rgroup Atom there may be a map containing (number,bond), 
            being the attachment order (1,2) and the bond to attach to.
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.RGroupQuery.GetRgroupQueryAtoms(System.Nullable{System.Int32})">
            <summary>
            Returns all R# type atoms (pseudo atoms) found in the root structure
            for a certain provided RGgroup number.
            </summary>
            <param name="rgroupNumber">R# number, 1..32</param>
            <returns>list of (pseudo) atoms with the provided rgroupNumber as label</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.RGroupQuery.GetAllRgroupQueryAtoms">
            <summary>
            Returns all R# type atoms (pseudo atoms) found in the root structure.
            </summary>
            <returns>list of (pseudo) R# atoms</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.RGroupQuery.IsValidRgroupQueryLabel(System.String)">
            <summary>
            Validates a Pseudo atom's label to be valid RGroup query label (R1..R32).
            </summary>
            <param name="Rxx">R-group label like R1 or R10</param>
            <returns>true if R1..R32, otherwise false</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.RGroupQuery.FindConfigurationsRecursively(System.Collections.Generic.IList{System.Int32},System.Collections.Generic.IList{System.Collections.Generic.IList{System.Int32}},System.Collections.Generic.IList{System.Int32},System.Collections.Generic.IList{System.Int32[]},System.Collections.Generic.IList{System.Collections.Generic.IList{NCDK.Isomorphisms.Matchers.RGroup}},System.Int32,System.Collections.Generic.IList{NCDK.IAtomContainer})">
            <summary>
            Recursive function to produce valid configurations for <see cref="M:NCDK.Isomorphisms.Matchers.RGroupQuery.GetAllConfigurations"/>. 
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.RGroupQuery.FindDistributions(System.Int32,System.Int32[],System.Collections.Generic.IList{System.Int32[]},System.Int32)">
            <summary>
            Finds valid distributions for a given R# group and it occurrence
            condition taken from the LOG line.
            </summary>
            <remarks>
            For example: if we have three Rn group atoms, and ">2" for
            the occurrence, then there are fours possible ways to make a
            distribution: 3 ways to put in two atoms, and one way
            to put in all 3 atoms. Etc.</remarks>
            <param name="occur"></param>
            <param name="candidate"></param>
            <param name="distributions"></param>
            <param name="level"></param>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.RGroupQuery.MapSubstitutes(NCDK.Isomorphisms.Matchers.RGroupList,System.Int32,System.Int32[],NCDK.Isomorphisms.Matchers.RGroup[],System.Collections.Generic.IList{System.Collections.Generic.IList{NCDK.Isomorphisms.Matchers.RGroup}})">
            <summary>
            Maps the distribution of an R-group to all possible substitute combinations.
            </summary> 
            <remarks>
            This is best illustrated by an example.
            Say R2 occurs twice in the root, and has condition >0. So a valid
            output configuration can have either one or two substitutes.
            The distributions will have been calculated to be the following
            solutions: 
            <para>[0,1], [1,0], [1,1]</para>
            To start with [1,1], assume two possible substitutes have been
            defined for R2, namely *C=O and *C-N. Then the distribution [1,1]
            should lead to four mappings: 
            <para>[*C=O,*C=O], [*C-N,*C-N], [*C=O,*C-N], [*C-N,*C=O].</para>
            These mappings are generated in this function, as well as the other valid mappings
            for [0,1] and [1,0]: 
            <para>[*C=O,null], [*C-N,null], [null,*C=O], [null,*C-N]. </para>
            So the example would have this function produce eight mappings (result list size==8).
            </remarks>
            <param name="rgpList"></param>
            <param name="listOffset"></param>
            <param name="distribution"></param>
            <param name="mapping"></param>
            <param name="result"></param>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.RGroupQuery.GetAtomPosition(NCDK.IAtom,NCDK.IAtomContainer)">
            <summary>
            Helper method, used to help construct a configuration.
            </summary>
            <param name="atom"></param>
            <param name="container"></param>
            <returns>the array position of atom in container</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.RGroupQuery.GetBondPosition(NCDK.IBond,NCDK.IAtomContainer)">
            <summary>
            Helper method, used to help construct a configuration.
            </summary>
            <param name="bond"></param>
            <param name="container"></param>
            <returns>the array position of the bond in the container</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.RGroupQuery.AllZeroArray(System.Int32[])">
            <summary>
            Helper method to see if an array is all zeroes or not.
            Used to check if the distribution of substitutes over an R-group
            is all zeroes, meaning there will be no substitution done.
            </summary>
            <param name="arr"></param>
            <returns>true if arr's values are all zero.</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.RGroupQuery.CheckIfThenConditionsMet(System.Collections.Generic.IList{System.Int32},System.Collections.Generic.IList{System.Int32[]})">
            <summary>
            Checks whether IF..THEN conditions that can be set for the R-groups are met.
            It is used to filter away invalid configurations in <see cref="M:NCDK.Isomorphisms.Matchers.RGroupQuery.FindConfigurationsRecursively(System.Collections.Generic.IList{System.Int32},System.Collections.Generic.IList{System.Collections.Generic.IList{System.Int32}},System.Collections.Generic.IList{System.Int32},System.Collections.Generic.IList{System.Int32[]},System.Collections.Generic.IList{System.Collections.Generic.IList{NCDK.Isomorphisms.Matchers.RGroup}},System.Int32,System.Collections.Generic.IList{NCDK.IAtomContainer})"/>.
            </summary>
            <remarks>
            Scenario: suppose R1 is substituted 0 times, whereas R2 is substituted.
            Also suppose there is a condition IF R2 THEN R1. Because R1 does not
            occur but R2 does, the IF..THEN condition is not met: this function
            will return false, the configuration should be discarded.
            </remarks>
            <param name="rGroupNumbers"></param>
            <param name="distributions"></param>
            <returns>true if all IF..THEN RGroup conditions are met.</returns>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.SymbolSetQueryAtom">
            <summary>
             A QueryAtom that matches all symbols in this container. You may add symbols
             to this container. This QueryAtom will only give a match if it contains the
             symbol of the Atom to match (example: add "F", "Cl", "Br", "I" to get a
             match for the most common halogens).
            </summary>
            <seealso cref="T:NCDK.Isomorphisms.Matchers.InverseSymbolSetQueryAtom"/>
        </member>
        <member name="P:NCDK.Isomorphisms.Matchers.SymbolSetQueryAtom.Symbols">
            <summary>
            The symbol Set
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SymbolSetQueryAtom.#ctor(NCDK.IChemObjectBuilder)">
            <summary>
             Constructor for the <see cref="T:NCDK.Isomorphisms.Matchers.SymbolSetQueryAtom"/> object
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SymbolSetQueryAtom.Matches(NCDK.IAtom)">
            <summary>
            The matches implementation of the <see cref="T:NCDK.Isomorphisms.Matchers.QueryAtom"/> interface.
            </summary>
            <param name="atom">The atom to be matched by this <see cref="T:NCDK.Isomorphisms.Matchers.QueryAtom"/></param>
            <returns>true if Atom matched</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SymbolSetQueryAtom.ToString">
            <summary>
             The ToString method
            </summary>
            <returns>The string representation of this object.</returns>
        </member>
        <member name="T:NCDK.Isomorphisms.AbstractVFState">
            <summary>
            A state for the Vento-Foggia (VF) algorithm. The state allows adding and
            removing of mappings as well as generating the new candidate mappings <see cref="M:NCDK.Isomorphisms.AbstractVFState.NextN(System.Int32)"/> 
            and <see cref="M:NCDK.Isomorphisms.AbstractVFState.NextM(System.Int32,System.Int32)"/>. The feasibility check is left for
            subclasses to implement.
            </summary>
        </member>
        <member name="F:NCDK.Isomorphisms.AbstractVFState.UNMAPPED">
            <summary>Value indicates a vertex is unmapped.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.AbstractVFState.g1">
            <summary>Adjacency list representation of the containers.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.AbstractVFState.g2">
            <summary>Adjacency list representation of the containers.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.AbstractVFState.m1">
            <summary>Mapping - m1 is the the mapping from g1 to g1, m2 is from g2 to g1.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.AbstractVFState.m2">
            <summary>Mapping - m1 is the the mapping from g1 to g1, m2 is from g2 to g1.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.AbstractVFState.t1">
            <summary>The (terminal) vertices which are adjacent to each mapped pair.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.AbstractVFState.t2">
            <summary>The (terminal) vertices which are adjacent to each mapped pair.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.AbstractVFState.size">
            <summary>Size of current solution - the number of vertices matched.</summary>
        </member>
        <member name="M:NCDK.Isomorphisms.AbstractVFState.#ctor(System.Int32[][],System.Int32[][])">
            <summary>
            Create a state which will be used to match g1 in g2.
            </summary>
            <param name="g1">find this graph</param>
            <param name="g2">search this graph</param>
        </member>
        <member name="M:NCDK.Isomorphisms.AbstractVFState.NextN(System.Int32)">
            <summary>
            Given the current query candidate (n), find the next candidate. The next
            candidate is the next vertex > n (in some ordering) that is unmapped and
            is adjacent to a mapped vertex (terminal). If there is no such vertex
            (disconnected) the next unmapped vertex is returned. If there are no more
            candidates m == |V| of G1.
            </summary>
            <param name="n">previous candidate n</param>
            <returns>the next value of n</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.AbstractVFState.NextM(System.Int32,System.Int32)">
            <summary>
            Given the current target candidate (m), find the next candidate. The next
            candidate is the next vertex > m (in some ordering) that is unmapped and
            is adjacent to a mapped vertex (terminal). If there is no such vertex
            (disconnected) the next unmapped vertex is returned. If there are no more
            candidates m == |V| of G2.
            </summary>
            <param name="n"></param>
            <param name="m">previous candidate m</param>
            <returns>the next value of m</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.AbstractVFState.NMax">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Isomorphisms.AbstractVFState.MMax">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Isomorphisms.AbstractVFState.Add(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Isomorphisms.AbstractVFState.Remove(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Isomorphisms.AbstractVFState.Feasible(System.Int32,System.Int32)">
            <summary>
            Is the candidate pair {n, m} feasible. Verifies if the adding candidate
            pair {n, m} to the state would lead to an invalid mapping.
            </summary>
            <param name="n">query vertex</param>
            <param name="m">target vertex</param>
            <returns>the mapping is feasible</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.AbstractVFState.Mapping">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.Isomorphisms.AbstractVFState.Count">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Isomorphisms.AtomMappingTools.MapAtomsOfAlignedStructures(NCDK.IAtomContainer,NCDK.IAtomContainer,System.Collections.Generic.IDictionary{System.Int32,System.Int32})">
            <summary>
            Returns a IDictionary with the AtomNumbers, the first number corresponds to the first (or the largest
            AtomContainer) atomContainer.
            </summary>
            <remarks>Only for similar and aligned molecules with coordinates!</remarks>
            <param name="firstAtomContainer">the (largest) first aligned AtomContainer which is the reference</param>
            <param name="secondAtomContainer">the second aligned AtomContainer</param>
            <param name="mappedAtoms"></param>
            <returns>a IDictionary of the mapped atoms</returns>
            <exception cref="T:NCDK.CDKException">if there is an error in the UniversalIsomorphismTester</exception>
        </member>
        <member name="T:NCDK.Isomorphisms.AtomMatcher">
            <summary>
            Defines compatibility checking of atoms for (subgraph)-isomorphism mapping.
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.AtomMatcher.Matches(NCDK.IAtom,NCDK.IAtom)">
            <summary>
            Are the semantics of <paramref name="atom1"/> compatible with <paramref name="atom2"/>.
            </summary>
            <param name="atom1">an atom from a query container</param>
            <param name="atom2">an atom from the target container</param>
            <returns>the <paramref name="atom1"/> can be paired with <paramref name="atom2"/></returns>
        </member>
        <member name="M:NCDK.Isomorphisms.AtomMatcher.CreateAnyMatcher">
            <summary>
            Atoms are always compatible.
            </summary>
            <returns>a matcher for which all atoms match</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.AtomMatcher.CreateElementMatcher">
            <summary>
            Atoms are compatible if they are the same element.
            </summary>
            <returns>a matcher which checks element compatibility</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.AtomMatcher.CreateQueryMatcher">
            <summary>
            Atoms are compatible if the second atom (<c>atom2</c>) is accepted by
            the <see cref="T:NCDK.Isomorphisms.Matchers.IQueryAtom"/>, <c>atom1</c>.
            </summary>
            <returns>a matcher which checks query atom compatibility</returns>
        </member>
        <member name="T:NCDK.Isomorphisms.AtomMatcher.AnyMatcher">
            <summary>A matcher defines all atoms as compatible.</summary>
        </member>
        <member name="M:NCDK.Isomorphisms.AtomMatcher.AnyMatcher.Matches(NCDK.IAtom,NCDK.IAtom)">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Isomorphisms.AtomMatcher.QueryMatcher">
            <summary>
            A matcher to use when all atoms are <see cref="T:NCDK.Isomorphisms.Matchers.IQueryAtom"/>s. <c>atom1</c> is
            cast to a query atom and matched against <c>atom2</c> .
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.AtomMatcher.QueryMatcher.Matches(NCDK.IAtom,NCDK.IAtom)">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Isomorphisms.AtomMatcher.ElementMatcher">
            <summary>
            A matcher to use when all atoms are <see cref="T:NCDK.Isomorphisms.Matchers.IQueryAtom"/>s. <c>atom1</c> is
            cast to a query atom and matched against <c>atom2</c>.
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.AtomMatcher.ElementMatcher.Matches(NCDK.IAtom,NCDK.IAtom)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Isomorphisms.AtomMatcher.ElementMatcher.GetAtomicNumber(NCDK.IAtom)">
            <summary>
            Null safe atomic number access.
            </summary>
            <param name="atom">an atom</param>
            <returns>the atomic number</returns>
        </member>
        <member name="T:NCDK.Isomorphisms.BondMatcher">
            <summary>
            Defines compatibility checking of bonds for (subgraph)-isomorphism mapping.
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.BondMatcher.Matches(NCDK.IBond,NCDK.IBond)">
            <summary>
            Determines if <paramref name="bond1"/> is compatible with <paramref name="bond2"/>.
            </summary>
            <param name="bond1">a bond from the query structure</param>
            <param name="bond2">a bond from the target structure</param>
            <returns>the bonds are compatible</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.BondMatcher.CreateAnyMatcher">
             <summary>
             All bonds are compatible.
            
             <returns>a bond matcher</returns>
             </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.BondMatcher.CreateStrictOrderMatcher">
            <summary>
            Bonds are compatible if they are both aromatic or their orders are equal
            and they are non-aromatic. Under this matcher a single/double bond will
            not match a single/double bond which is aromatic.
            </summary>
            <returns>a bond matcher</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.BondMatcher.CreateOrderMatcher">
            <summary>
            Bonds are compatible if they are both aromatic or their orders are equal.
            This matcher allows a single/double bond to match a single/double
            aromatic bond.
            </summary>
            <returns>a bond matcher</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.BondMatcher.CreateQueryMatcher">
            <summary>
            Bonds are compatible if the first <c>bond1</c> (an <see cref="T:NCDK.Isomorphisms.Matchers.IQueryBond"/>)
            matches the second, <c>bond2</c>.
            </summary>
            <returns>a bond matcher</returns>
        </member>
        <member name="T:NCDK.Isomorphisms.BondMatcher.OrderMatcher">
            <summary>
            Bonds are compatible if they are both aromatic or their orders are
            equal.
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.BondMatcher.OrderMatcher.Matches(NCDK.IBond,NCDK.IBond)">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Isomorphisms.BondMatcher.StrictOrderMatcher">
            <summary>
            Bonds are compatible if they are both aromatic or their orders are equal
            and they are non-aromatic. In this matcher a single or double bond will
            not match a single or double bond which is part of an aromatic system.
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.BondMatcher.StrictOrderMatcher.Matches(NCDK.IBond,NCDK.IBond)">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Isomorphisms.BondMatcher.AnyMatcher">
            <summary>All bonds are considered compatible.</summary>
        </member>
        <member name="M:NCDK.Isomorphisms.BondMatcher.AnyMatcher.Matches(NCDK.IBond,NCDK.IBond)">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Isomorphisms.BondMatcher.QueryMatcher">
            <summary>
            Bonds are compatible if the first <c>bond1</c> (an <see cref="T:NCDK.Isomorphisms.Matchers.IQueryBond"/>)
            matches the second, <c>bond2</c>.
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.BondMatcher.QueryMatcher.Matches(NCDK.IBond,NCDK.IBond)">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Isomorphisms.CompatibilityMatrix">
             <summary>
             A compatibility matrix defines which query vertices (rows) could possible be
             mapped to a target vertex (columns). The matrix is used in the Ullmann and
             Ullmann-like algorithms to provide top-down pruning.
            
             Instead of using a binary matrix this implementation uses int values. This
             allows us to remove a mapping but put it back in later (backtrack).
             </summary>
             <seealso cref="T:NCDK.Isomorphisms.UllmannState"/>
        </member>
        <member name="F:NCDK.Isomorphisms.CompatibilityMatrix.data">
            <summary>Value storage.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.CompatibilityMatrix.nRows">
            <summary>Size of the matrix.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.CompatibilityMatrix.mCols">
            <summary>Size of the matrix.</summary>
        </member>
        <member name="M:NCDK.Isomorphisms.CompatibilityMatrix.#ctor(System.Int32,System.Int32)">
            <summary>
            Create a matrix of the given size.
            </summary>
            <param name="nRows">number of rows</param>
            <param name="mCols">number of columns</param>
        </member>
        <member name="M:NCDK.Isomorphisms.CompatibilityMatrix.Set1(System.Int32,System.Int32)">
            <summary>
            Set the value in row, <paramref name="i"/> and column <paramref name="j"/>.
            </summary>
            <param name="i">row index</param>
            <param name="j">column index</param>
        </member>
        <member name="M:NCDK.Isomorphisms.CompatibilityMatrix.Get1(System.Int32)">
            <summary>
            Access the value at index <paramref name="i"/>, values wrap around to the next row.
            </summary>
            <param name="i">index</param>
            <returns>the value is set</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.CompatibilityMatrix.Get1(System.Int32,System.Int32)">
            <summary>
            Access the value at row <paramref name="i"/> and column <paramref name="j"/>. The values wrap around to the
            next row.
            <param name="i">row index</param>
            <param name="j">column index</param>
            <returns>the value is set</returns>
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.CompatibilityMatrix.Mark(System.Int32,System.Int32,System.Int32)">
            <summary>
            Mark the value in row <paramref name="i"/> and column <paramref name="j"/> allowing it to be reset later.
            </summary>
            <param name="i">row index</param>
            <param name="j">column index</param>
            <param name="marking">the marking to store (should be negative)</param>
        </member>
        <member name="M:NCDK.Isomorphisms.CompatibilityMatrix.MarkRow(System.Int32,System.Int32)">
            <summary>
            Mark all values in row <paramref name="i"/> allowing it to be reset later.
            </summary>
            <param name="i">row index</param>
            <param name="marking">the marking to store (should be negative)</param>
        </member>
        <member name="M:NCDK.Isomorphisms.CompatibilityMatrix.ResetRows(System.Int32,System.Int32)">
            <summary>
            Reset all values marked with (marking) from row <paramref name="i"/> onwards.
            </summary>
            <param name="i">row index</param>
            <param name="marking">the marking to reset (should be negative)</param>
        </member>
        <member name="M:NCDK.Isomorphisms.CompatibilityMatrix.Fix">
            <summary>
            Create a fixed-size 2D array of the matrix (useful for debug).
            </summary>
            <returns>a fixed version of the matrix</returns>
        </member>
        <member name="T:NCDK.Isomorphisms.ComponentGrouping">
            <summary>
            A predicate for verifying component level grouping in query/target structure
            matching. The grouping is used by SMARTS and is critical to querying
            reactions. The grouping specifies that substructures in the query should
            match to separate components in the target. The grouping specification is
            indicated by an <see cref="T:System.Int32" />[] array of length (|V(query)| + 1). The final
            index indicates the maximum component group (in the query). A specification
            of '0' indicates there are no grouping restrictions.
            </summary>
            <example>
            <code>            // grouping is actually set by SMARTS parser but this shows how it's stored
            query.SetProperty(ComponentGrouping.Key, grouping);

            IAtomContainer target = someTarget;
            Pattern pattern = somePattern; // create pattern for query

            // filter for mappings which respect component grouping in the query
            var filter = new ComponentGrouping(query, target);
            pattern.MatchAll(target).Where(n =&gt; filter.Apply(n));
</code>
            </example>
            <seealso cref="T:NCDK.Isomorphisms.Pattern" />
        </member>
        <member name="F:NCDK.Isomorphisms.ComponentGrouping.Key">
            <summary>
            Key indicates where the grouping should be store in the query
            properties.
            </summary>
        </member>
        <member name="F:NCDK.Isomorphisms.ComponentGrouping.queryComponents">
            <summary>The required  (query) and the targetComponents of the target.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.ComponentGrouping.targetComponents">
            <summary>The required  (query) and the targetComponents of the target.</summary>
        </member>
        <member name="M:NCDK.Isomorphisms.ComponentGrouping.#ctor(NCDK.IAtomContainer,NCDK.IAtomContainer)">
            <summary>
            Create a predicate to match components for the provided query and target.
            The target is converted to an adjacency list (<see cref="M:NCDK.Graphs.GraphUtil.ToAdjList(NCDK.IAtomContainer)"/> 
            ) and the query components extracted
            from the property <see cref="F:NCDK.Isomorphisms.ComponentGrouping.Key"/> in the query.
            </summary>
            <param name="query">query structure</param>
            <param name="target">target structure</param>
        </member>
        <member name="M:NCDK.Isomorphisms.ComponentGrouping.#ctor(System.Int32[],System.Int32[])">
            <summary>
            Create a predicate to match components for the provided query (grouping)
            and target (connected components).
            </summary>
            <param name="grouping">query grouping</param>
            <param name="targetComponents">connected component of the target</param>
        </member>
        <member name="M:NCDK.Isomorphisms.ComponentGrouping.Apply(System.Int32[])">
            <summary>
            Does the mapping respected the component grouping specified by the
            query.
            </summary>
            <param name="mapping">a permutation of the query vertices</param>
            <returns>the mapping preserves the specified grouping</returns>
        </member>
        <member name="T:NCDK.Isomorphisms.IsomorphismTester">
            <summary>
            A too simplistic implementation of an isomorphism test for chemical graphs.
            </summary>
            <remarks>
            <b>Important:</b> as it uses the MorganNumbersTools it does not take bond
            order into account.
            <para>Alternatively, you can use the <see cref="T:NCDK.Isomorphisms.UniversalIsomorphismTester"/>.</para>
            </remarks>
            <seealso cref="T:NCDK.Graphs.Canon.MorganNumbersTools"/>
            <seealso cref="T:NCDK.Isomorphisms.UniversalIsomorphismTester"/>
        </member>
        <member name="M:NCDK.Isomorphisms.IsomorphismTester.#ctor">
            <summary>
             Constructor for the IsomorphismTester object
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.IsomorphismTester.#ctor(NCDK.IAtomContainer)">
            <summary>
             Constructor for the IsomorphismTester object
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.IsomorphismTester.IsIsomorphic(NCDK.IAtomContainer,NCDK.IAtomContainer)">
            <summary>
             Checks whether a given molecule is isomorphic with the one
             that has been assigned to this IsomorphismTester at construction time.
            </summary>
            <param name="mol1">A first molecule to check against the second one</param>
            <param name="mol2">A second molecule to check against the first</param>
            <returns>True, if the two molecules are isomorphic</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.IsomorphismTester.IsIsomorphic(NCDK.IAtomContainer)">
            <summary>
             Checks whether a given molecule is isomorphic with the one
             that has been assigned to this IsomorphismTester at construction time.
            </summary>
            <param name="mol2">A molecule to check</param>
            <returns>True, if the two molecules are isomorphic</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.IsomorphismTester.SetBaseTable(NCDK.IAtomContainer)">
            <summary>
             Sets the BaseTable attribute of the IsomorphismTester object
            </summary>
            <param name="mol">The new BaseTable value</param>
        </member>
        <member name="M:NCDK.Isomorphisms.IsomorphismTester.SetCompareTable(NCDK.IAtomContainer)">
            <summary>
             Sets the CompareTable attribute of the IsomorphismTester object
            </summary>
            <param name="mol">The new CompareTable value</param>
        </member>
        <member name="T:NCDK.Isomorphisms.Mappings">
            <summary>
            A fluent interface for handling (sub)-graph mappings from a query to a target
            structure. The utility allows one to modify the mappings and provides
            convenience utilities. <see cref="T:NCDK.Isomorphisms.Mappings" /> are obtained from a (sub)-graph
            matching using <see cref="T:NCDK.Isomorphisms.Pattern" />.
            </summary>
            <example>
            <code>                IAtomContainer query = queryStructure;
                IAtomContainer target = targetStructure;

                Mappings mappings = Pattern.FindSubstructure(query).MatchAll(target);
</code>
            The primary function is to provide an iterable of matches - each match is
            a permutation (mapping) of the query graph indices (atom indices).
            <code>                foreach (int[] p in mappings)
                {
                    for (int i = 0; i &lt; p.Length; i++)
                    {
                        // query.Atoms[i] is mapped to target.Atoms[p[i]];
                    }
                }
</code>
            The matches can be filtered to provide only those that have valid
            stereochemistry.
            <code>                foreach (int[] p in mappings.GetStereochemistry())
                {
                    // ...
                }
</code>
            Unique matches can be obtained for both atoms and bonds.
            <code>                foreach (int[] p in mappings.GetUniqueAtoms())
                {
                    // ...
                }

                foreach (int[] p in mappings.GetUniqueBonds())
                {
                    // ...
                }
</code>
            As matches may be lazily generated - iterating over the match twice (as
            above) will actually perform two graph matchings. If the mappings are needed
            for subsequent use the <see cref="M:NCDK.Isomorphisms.Mappings.ToArray" /> provides the permutations as a
            fixed size array.
            <code>                    int[][] ps = mappings.ToArray();
                    foreach (int[] p in ps)
                    {
                        // ...
                    }
</code>
            Graphs with a high number of automorphisms can produce many valid matchings.
            Operations can be combined such as to limit the number of matches we
            retrieve.
            <code>                    // first ten matches
                    foreach (int[] p in mappings.Limit(10))
                    {
                        // ...
                    }

                    // first 10 unique matches
                    foreach (int[] p in mappings.GetUniqueAtoms().Limit(10))
                    {
                        // ...
                    }

                    // ensure we don't waste memory and only 'fix' up to 100 unique matches
                    int[][] ps = mappings.GetUniqueAtoms().Limit(100).ToArray();
</code>
            There is no restrictions on which operation can be applied and how many times
            but the order of operations may change the result.
            <code>                // first 100 unique matches
                Mappings m1 = mappings.GetUniqueAtoms().Limit(100);

                // unique matches in the first 100 matches
                Mappings m2 = mappings.Limit(100).GetUniqueAtoms();

                // first 10 unique matches in the first 100 matches
                Mappings m3 = mappings.Limit(100).GetUniqueAtoms().Limit(10);

                // number of unique atom matches
                int n1 = mappings.CountUnique();

                // number of unique atom matches with correct stereochemistry
                int n2 = mappings.GetStereochemistry().CountUnique();
</code>
            </example>
            <seealso cref="T:NCDK.Isomorphisms.Pattern" />
        </member>
        <member name="F:NCDK.Isomorphisms.Mappings.iterable">
            <summary>Iterable permutations of the query vertices.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Mappings.query">
            <summary>Query and target structures.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Mappings.target">
            <summary>Query and target structures.</summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Mappings.#ctor(NCDK.IAtomContainer,NCDK.IAtomContainer,System.Collections.Generic.IEnumerable{System.Int32[]})">
            <summary>
            Create a fluent mappings instance for the provided query / target and an
            iterable of permutations on the query vertices (specified as indices).
            </summary>
            <param name="query">the structure to be found</param>
            <param name="target">the structure being searched</param>
            <param name="iterable">iterable of permutation</param>
            <seealso cref="T:NCDK.Isomorphisms.Pattern"/>
        </member>
        <member name="M:NCDK.Isomorphisms.Mappings.Filter(System.Predicate{System.Int32[]})">
            <summary>
            Filter the mappings and keep only those which match the provided
            predicate (Guava).
            </summary>
            <example>
            <code>                IAtomContainer query = queryStructure;
                IAtomContainer target = targetStructure;

                // obtain only the mappings where the first atom in the query is
                // mapped to the first atom in the target
                Mappings mappings = Pattern.FindSubstructure(query)
                    .MatchAll(target)
                    .Filter(input =&gt; input[0] == 0);
</code>
            </example>
            <param name="predicate">a predicate</param>
            <returns>fluent-api reference</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.Mappings.GetMapping``1(System.Func{System.Int32[],``0})">
            <summary>
            Enumerate the mappings to another type. Each mapping is transformed using the
            provided function.
            </summary>
            <example>
            <code>                IAtomContainer query = queryStructure;
                IAtomContainer target = targetStructure;

                // obtain only the mappings where the first atom in the query is
                // mapped to the first atom in the target
                Mappings mappings = Pattern.FindSubstructure(query)
                    .MatchAll(target)
                    .Filter(input =&gt; input[0] == 0);
</code>
            </example>
            <typeparam name="T" />
            <param name="f">function to transform a mapping</param>
            <returns>The transformed types</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.Mappings.Limit(System.Int32)">
            <summary>
            Limit the number of mappings - only this number of mappings will be
            generate.
            </summary>
            <param name="limit">the number of mappings</param>
            <returns>fluent-api instance</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.Mappings.GetStereochemistry">
            <summary>
            Filter the mappings for those which preserve stereochemistry specified in
            the query.
            </summary>
            <returns>fluent-api instance</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.Mappings.GetUniqueAtoms">
            <summary>
            Filter the mappings for those which cover a unique set of atoms in the
            target. The unique atom mappings are a subset of the unique bond
            matches.
            </summary>
            <returns>fluent-api instance</returns>
            <seealso cref="M:NCDK.Isomorphisms.Mappings.GetUniqueBonds"/>
        </member>
        <member name="M:NCDK.Isomorphisms.Mappings.GetUniqueBonds">
            <summary>
            Filter the mappings for those which cover a unique set of bonds in the
            target.
            </summary>
            <returns>fluent-api instance</returns>
            <seealso cref="M:NCDK.Isomorphisms.Mappings.GetUniqueAtoms"/>
        </member>
        <member name="M:NCDK.Isomorphisms.Mappings.ToArray">
            <summary>
            Mappings are lazily generated and best used in a loop. However if all
            mappings are required this method can provide a fixed size array of
            mappings.
            </summary>
            <example>
            <code>                IAtomContainer query = queryStructure;
                IAtomContainer target = targetStructure;

                Pattern pat = Pattern.FindSubstructure(query);

                // lazily iterator
                foreach (int[] mapping in pat.MatchAll(target))
                {
                    // logic...
                }

                int[][] mappings = pat.MatchAll(target).ToArray();

                // same as lazy iterator but we now can refer to and parse 'mappings'
                // to other methods without regenerating the graph match
                foreach (int[] mapping in mappings)
                {
                    // logic...
                }
</code>
            The method can be used in combination with other modifiers.
            <code>                IAtomContainer query = queryStructure;
                IAtomContainer target = targetStructure;

                Pattern pat = Pattern.FindSubstructure(query);

                // array of the first 5 unique atom mappings
                int[][] mappings = pat.MatchAll(target)
                                      .GetUniqueAtoms()
                                      .Limit(5)
                                      .ToArray();
</code>
            </example>
            <returns>array of mappings</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.Mappings.ToAtomMap">
            <summary>
            Convert the permutations to a atom-atom map.
            </summary>
            <example>
            <code>                foreach (IDictionary&lt;IAtom, IAtom&gt; map in mappings.ToAtomMap())
                {
                    foreach (KeyValuePair&lt;IAtom, IAtom&gt; e in map)
                    {
                        IAtom queryAtom = e.Key;
                        IAtom targetAtom = e.Value;
                    }
                }
</code>
            </example>
            <returns>iterable of atom-atom mappings</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.Mappings.ToBondMap">
            <summary>
            Convert the permutations to a bond-bond map.
            </summary>
            <example>
            <code>                foreach (IDictionary&lt;IBond, IBond&gt; map in mappings.ToBondMap())
                {
                    foreach (KeyValuePair&lt;IBond, IBond&gt; e in map)
                    {
                        IBond queryBond = e.Key;
                        IBond targetBond = e.Value;
                    }
                }
</code>
            </example>
            <returns>iterable of bond-bond mappings</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.Mappings.ToAtomBondMap">
            <summary>
            Convert the permutations to an atom-atom bond-bond map.
            </summary>
            <example>
            <code>                foreach (var map in mappings.ToAtomBondMap())
                {
                    foreach (var e in map)
                    {
                        IChemObject queryObj = e.Key;
                        IChemObject targetObj = e.Value;
                    }
                    IAtom matchedAtom = (IAtom)map[query.Atoms[i]];
                    IBond matchedBond = (IBond)map[query.Bonds[i]];
                }
</code>
            </example>
            <returns>iterable of atom-atom and bond-bond mappings</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.Mappings.ToChemObjects">
            <summary>
            Obtain the chem objects (atoms and bonds) that have 'hit' in the target molecule.
            </summary>
            <example>
            <code>                foreach (var obj in mappings.ToChemObjects())
                {
                    if (obj is IAtom)
                    {
                        // this atom was 'hit' by the pattern
                    }
                }
</code>
            </example>
            <returns>lazy iterable of chem objects</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.Mappings.ToSubstructures">
            <summary>
            Obtain the mapped substructures (atoms/bonds) of the target compound. The atoms
            and bonds are the same as in the target molecule but there may be less of them.
            </summary>
            <example>
            <code>                IAtomContainer target = targetStructure;
                Mappings mappings = someMappings;
                foreach (var mol in mappings.ToSubstructures())
                {
                    foreach (var atom in mol.Atoms)
                        target.Contains(atom); // always true
                    foreach (var atom in target.Atoms)
                        mol.Contains(atom); // not always true
                }
</code>
            </example>
            <returns>lazy iterable of molecules</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.Mappings.AtLeast(System.Int32)">
            <summary>
            Efficiently determine if there are at least 'n' matches
            </summary>
            <example>
            <code>                Mappings mappings = someMappings;

                if (mappings.AtLeast(5))
                {
                    // set bit flag etc.
                }

                // are the at least 5 unique matches?
                if (mappings.GetUniqueAtoms().AtLeast(5))
                {
                    // set bit etc.
                }
</code>
            </example>
            <param name="n">number of matches</param>
            <returns>there are at least 'n' matches</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.Mappings.First">
            <summary>
            Obtain the first match - if there is no first match an empty array is
            returned.
            </summary>
            <returns>first match</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.Mappings.Count">
            <summary>
            Convenience method to count the number mappings. Note mappings are lazily
            generated and checking the count and then iterating over the mappings
            currently performs two searches. If the mappings are also needed, it is
            more efficient to check the mappings and count manually.
            </summary>
            <returns>number of matches</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.Mappings.CountUnique">
             <summary>
             Convenience method to count the number of unique atom mappings. Note
             mappings are lazily generated and checking the count and then iterating
             over the mappings currently performs two searches. If the mappings are
             also needed, it is more efficient to check the mappings and count
             manually.
            
             The method is simply invokes <c>mappings.GetUniqueAtoms().Count()</c>.
             </summary>
             <returns>number of matches</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.Mappings.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Isomorphisms.Mappings.AtomMaper">
            <summary>Utility to transform a permutation into the atom-atom map.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Mappings.AtomMaper.query">
            <summary>Query/target containers from the graph matching.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Mappings.AtomMaper.target">
            <summary>Query/target containers from the graph matching.</summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Mappings.AtomMaper.#ctor(NCDK.IAtomContainer,NCDK.IAtomContainer)">
            <summary>
            Use the provided query and target to obtain the atom instances.
            </summary>
            <param name="query">the structure to be found</param>
            <param name="target">the structure being searched</param>
        </member>
        <member name="M:NCDK.Isomorphisms.Mappings.AtomMaper.Apply(System.Int32[])">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Isomorphisms.Mappings.BondMaper">
            <summary>Utility to transform a permutation into the bond-bond map.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Mappings.BondMaper.g1">
            <summary>The query graph - indicates a presence of edges.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Mappings.BondMaper.bonds1">
            <summary>Bond look ups for the query and target.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Mappings.BondMaper.bonds2">
            <summary>Bond look ups for the query and target.</summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Mappings.BondMaper.#ctor(NCDK.IAtomContainer,NCDK.IAtomContainer)">
            <summary>
            Use the provided query and target to obtain the bond instances.
            </summary>
            <param name="query">the structure to be found</param>
            <param name="target">the structure being searched</param>
        </member>
        <member name="M:NCDK.Isomorphisms.Mappings.BondMaper.Apply(System.Int32[])">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Isomorphisms.Mappings.AtomBondMaper">
            <summary>Utility to transform a permutation into an atom-atom and bond-bond map.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Mappings.AtomBondMaper.g1">
            <summary>The query graph - indicates a presence of edges.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Mappings.AtomBondMaper.bonds1">
            <summary>Bond look ups for the query and target.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Mappings.AtomBondMaper.bonds2">
            <summary>Bond look ups for the query and target.</summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Mappings.AtomBondMaper.#ctor(NCDK.IAtomContainer,NCDK.IAtomContainer)">
            <summary>
            Use the provided query and target to obtain the bond instances.
            </summary>
            <param name="query">the structure to be found</param>
            <param name="target">the structure being searched</param>
        </member>
        <member name="M:NCDK.Isomorphisms.Mappings.AtomBondMaper.Apply(System.Int32[])">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Isomorphisms.MCSS.RGraph">
            <summary>
            This class implements the Resolution Graph (RGraph).
            The RGraph is a graph based representation of the search problem.
            An RGraph is constructed from the two compared graphs (G1 and G2).
            Each vertex (node) in the RGraph represents a possible association
            from an edge in G1 with an edge in G2. Thus two compatible bonds
            in two molecular graphs are represented by a vertex in the RGraph.
            Each edge in the RGraph corresponds to a common adjacency relationship
            between the 2 couple of compatible edges associated to the 2 RGraph nodes
            forming this edge.
            </summary>
            <remarks>
            <para>
            Example:
            <pre>
               G1 : C-C=O  and G2 : C-C-C=0
                    1 2 3           1 2 3 4
            </pre>
            </para>
            <para>
            The resulting RGraph(G1,G2) will contain 3 nodes:
            <list type="bullet">
               <item>Node A : association between bond C-C :  1-2 in G1 and 1-2 in G2</item>
               <item>Node B : association between bond C-C :  1-2 in G1 and 2-3 in G2</item>
               <item>Node C : association between bond C=0 :  2-3 in G1 and 3-4 in G2</item>
            </list> 
            </para>
            <para>
            The RGraph will also contain one edge representing the
            adjacency between node B and C  that is : bonds 1-2 and 2-3 in G1
            and bonds 2-3 and 3-4 in G2.
            </para>
            <para>
            Once the RGraph has been built from the two compared graphs
            it becomes a very interesting tool to perform all kinds of
            structural search (isomorphism, substructure search, maximal common
            substructure,....).
            </para>
            <para>
            The  search may be constrained by mandatory elements (e.g. bonds that
            have to be present in the mapped common substructures).
            </para>
            <para>
            Performing a query on an RGraph requires simply to set the constrains
            (if any) and to invoke the parsing method (Parse())
            </para>
            <para>
             The RGraph has been designed to be a generic tool. It may be constructed
             from any kind of source graphs, thus it is not restricted to a chemical
             context.
            </para>
            <para>
             The RGraph model is independent from the CDK model and the link between
             both model is performed by the RTools class. In this way the RGraph
             class may be reused in other graph context (conceptual graphs,....)
            </para>
            <note type="important">
            This implementation of the algorithm has not been
                                 optimized for speed at this stage. It has been
                                 written with the goal to clearly retrace the
                                 principle of the underlined search method. There is
                                 room for optimization in many ways including the
                                 the algorithm itself.
            </note>
            <para>
            This algorithm derives from the algorithm described in
             <token>cdk-cite-HAN90</token> and modified in the thesis of T. Hanser <token>cdk-cite-HAN93</token>.
            </para>
            </remarks>
        </member>
        <member name="P:NCDK.Isomorphisms.MCSS.RGraph.FirstGraphSize">
            <summary>
            The size of the first of the two compared graphs
            </summary>
        </member>
        <member name="F:NCDK.Isomorphisms.MCSS.RGraph.SecondGraphSize">
            <summary>
            The size of the second of the two compared graphs
            </summary>
        </member>
        <member name="P:NCDK.Isomorphisms.MCSS.RGraph.Timeout">
            <summary>
            The time in milliseconds until the substructure search will be breaked. 
            Time in milliseconds. -1 to ignore the timeout.
            </summary>
        </member>
        <member name="P:NCDK.Isomorphisms.MCSS.RGraph.Start">
            <summary>
            The start time in milliseconds.
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.MCSS.RGraph.#ctor">
            <summary>
            Constructor for the RGraph object and creates an empty RGraph.
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.MCSS.RGraph.Clear">
            <summary>
             Reinitialisation of the TGraph.
            </summary>
        </member>
        <member name="P:NCDK.Isomorphisms.MCSS.RGraph.Graph">
            <summary>
             Returns the graph object of this RGraph.
            </summary>
            <returns>The graph object, a list</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.MCSS.RGraph.AddNode(NCDK.Isomorphisms.MCSS.RNode)">
            <summary>
             Adds a new node to the RGraph.
            </summary>
            <param name="newNode">The node to add to the graph</param>
        </member>
        <member name="M:NCDK.Isomorphisms.MCSS.RGraph.Parse(System.Collections.BitArray,System.Collections.BitArray,System.Boolean,System.Boolean)">
            <summary>
             Parsing of the RGraph. This is the main method
             to perform a query. Given the constrains c1 and c2
             defining mandatory elements in G1 and G2 and given
             the search options, this method builds an initial set
             of starting nodes (B) and parses recursively the
             RGraph to find a list of solution according to
             these parameters.
            </summary>
            <param name="c1">constrain on the graph G1</param>
            <param name="c2">constrain on the graph G2</param>
            <param name="findAllStructure">true if we want all results to be generated</param>
            <param name="findAllMap">true is we want all possible 'mappings'</param>
        </member>
        <member name="M:NCDK.Isomorphisms.MCSS.RGraph.ParseRec(System.Collections.BitArray,System.Collections.BitArray,System.Collections.BitArray)">
            <summary>
             Parsing of the RGraph. This is the recursive method
             to perform a query. The method will recursively
             parse the RGraph thru connected nodes and visiting the
             RGraph using allowed adjacency relationship.
            </summary>
            <param name="traversed">node already parsed</param>
            <param name="extension">possible extension node (allowed neighbors)</param>
            <param name="forbidden">node forbidden (set of node incompatible with the current solution)</param>
        </member>
        <member name="M:NCDK.Isomorphisms.MCSS.RGraph.Solution(System.Collections.BitArray)">
            <summary>
            Checks if a potential solution is a real one
            (not included in a previous solution)
             and add this solution to the solution list
            in case of success.
            </summary>
            <param name="traversed">new potential solution</param>
        </member>
        <member name="M:NCDK.Isomorphisms.MCSS.RGraph.MustContinue(System.Collections.BitArray)">
            <summary>
             Determine if there are potential solution remaining.
            </summary>
            <param name="potentialNode">set of remaining potential nodes</param>
            <returns>true if it is worse to continue the search</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.MCSS.RGraph.BuildB(System.Collections.BitArray,System.Collections.BitArray)">
            <summary>
             Builds the initial extension set. This is the
             set of node that may be used as seed for the
             RGraph parsing. This set depends on the constrains
             defined by the user.
            </summary>
            <param name="c1">constraint in the graph G1</param>
            <param name="c2">constraint in the graph G2</param>
            <returns>the new extension set</returns>
        </member>
        <member name="P:NCDK.Isomorphisms.MCSS.RGraph.Solutions">
            <summary>
             Returns the list of solutions.
            </summary>
            <returns>The solution list</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.MCSS.RGraph.BitSetToRMap(System.Collections.BitArray)">
            <summary>
             Converts a RGraph bitset (set of RNode)
            to a list of RMap that represents the
            mapping between to substructures in G1 and G2
            (the projection of the RGraph bitset on G1
            and G2).
            </summary>
            <param name="set">the BitArray</param>
            <returns>the RMap list</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.MCSS.RGraph.SetAllStructure(System.Boolean)">
            <summary>
             Sets the 'AllStructres' option. If true
            all possible solutions will be generated. If false
            the search will stop as soon as a solution is found.
            (e.g. when we just want to know if a G2 is
             a substructure of G1 or not).
            </summary>
            <param name="findAllStructure"></param>
        </member>
        <member name="M:NCDK.Isomorphisms.MCSS.RGraph.SetAllMap(System.Boolean)">
            <summary>
             Sets the 'finAllMap' option. If true
            all possible 'mappings' will be generated. If false
            the search will keep only one 'mapping' per structure
            association.
            </summary>
            <param name="findAllMap"></param>
        </member>
        <member name="M:NCDK.Isomorphisms.MCSS.RGraph.SetMaxIteration(System.Int32)">
            <summary>
            Sets the maxIteration for the RGraph parsing. If set to -1,
            then no iteration maximum is taken into account.
            </summary>
            <param name="it">The new maxIteration value</param>
        </member>
        <member name="M:NCDK.Isomorphisms.MCSS.RGraph.ToString">
            <summary>
             Returns a string representation of the RGraph.
            </summary>
            <returns>the string representation of the RGraph</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.MCSS.RGraph.ProjectG1(System.Collections.BitArray)">
            <summary>
             Projects a RGraph bitset on the source graph G1.
            </summary>
            <param name="set">RGraph BitArray to project</param>
            <returns>The associate BitArray in G1</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.MCSS.RGraph.ProjectG2(System.Collections.BitArray)">
            <summary>
             Projects a RGraph bitset on the source graph G2.
            </summary>
            <param name="set">RGraph BitArray to project</param>
            <returns>The associate BitArray in G2</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.MCSS.RGraph.IsContainedIn(System.Collections.BitArray,System.Collections.BitArray)">
            <summary>
             Test if set A is contained in  set B.
            </summary>
            <param name="A">a bitSet</param>
            <param name="B">a bitSet</param>
            <returns>true if  A is contained in  B</returns>
        </member>
        <member name="T:NCDK.Isomorphisms.MCSS.RMap">
            <summary>
             An RMap implements the association between an edge (bond) in G1 and an edge
             (bond) in G2, G1 and G2 being the compared graphs in a RGraph context.
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.MCSS.RMap.#ctor(System.Int32,System.Int32)">
            <summary>
             Constructor for the RMap.
            </summary>
            <param name="id1">number of the edge (bond) in the graph 1</param>
            <param name="id2">number of the edge (bond) in the graph 2</param>
        </member>
        <member name="M:NCDK.Isomorphisms.MCSS.RMap.Equals(System.Object)">
            <summary>
             The equals method.
            </summary>
            <param name="o">The object to compare.</param>
            <returns>true=if both ids equal, else false.</returns>
        </member>
        <member name="T:NCDK.Isomorphisms.MCSS.RNode">
            <summary>
             Node of the resolution graph (RGraph) An RNode represents an association
             between two edges of the source graphs G1 and G2 that are compared. Two
             edges may be associated if they have at least one common feature. The
             association is defined outside this class. The node keeps tracks of the ID
             of the mapped edges (in an RMap), of its neighbours in the RGraph it belongs
             to and of the set of incompatible nodes (nodes that may not be along with
             this node in the same solution)
            </summary>
        </member>
        <member name="P:NCDK.Isomorphisms.MCSS.RNode.RMap">
            <summary>
            The rMap attribute of the RNode object.
            </summary>
        </member>
        <member name="P:NCDK.Isomorphisms.MCSS.RNode.Extension">
            <summary>
            The extension attribute of the RNode object.
            </summary>
        </member>
        <member name="P:NCDK.Isomorphisms.MCSS.RNode.Forbidden">
            <summary>
            The extension attribute of the RNode object.
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.MCSS.RNode.#ctor(System.Int32,System.Int32)">
            <summary>
             Constructor for the RNode object.
            </summary>
            <param name="id1">number of the bond in the graph 1</param>
            <param name="id2">number of the bond in the graph 2</param>
        </member>
        <member name="M:NCDK.Isomorphisms.MCSS.RNode.ToString">
            <summary>
             Returns a string representation of the RNode.
            </summary>
            <returns>the string representation of the RNode</returns>
        </member>
        <member name="T:NCDK.Isomorphisms.Pattern">
            <summary>
            A structural pattern for finding an exact matching in a target compound.
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Pattern.Match(NCDK.IAtomContainer)">
            <summary>
            Find a matching of this pattern in the <paramref name="target" />. If no such order
            exist an empty mapping is returned. Depending on the implementation
            stereochemistry may be checked (recommended).
            </summary>
            <example>
            <code>                Pattern pattern = createPattern; // create pattern
                foreach (var m in ms)
                {
                    int[] mapping = pattern.Match(m);
                    if (mapping.Length &gt; 0)
                    {
                        // found mapping!
                    }
                }
</code>
            </example>
            <param name="target">the container to search for the pattern in</param>
            <returns>the mapping from the pattern to the target or an empty array</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.Pattern.Matches(NCDK.IAtomContainer)">
            <summary>
            Determine if there is a mapping of this pattern in the <paramref name="target" />.
            Depending on the implementation stereochemistry may be checked
            (recommended).
            </summary>
            <example>
            <code>                Pattern pattern = createPattern; // create pattern
                foreach (var m in ms)
                {
                    if (pattern.Matches(m))
                    {
                        // found mapping!
                    }
                }
</code>
            </example>
            <param name="target">the container to search for the pattern in</param>
            <returns>the mapping from the pattern to the target</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.Pattern.Matches(NCDK.IReaction)">
            <summary>
            Determine if there is a mapping of this pattern in the <code>target</code>
            reaction.
            
            <blockquote><pre>
            Pattern        pattern = ...; // create pattern
            for (IReaction r : rs) {
                if (pattern.matches(r)) {
                    // found mapping!
                }
            }
            </pre></blockquote>
            </summary>
            <param name="target">the reaction to search for the pattern in</param>
            <returns>the mapping from the pattern to the target</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.Pattern.MatchAll(NCDK.IAtomContainer)">
            <summary>
            Find all mappings of this pattern in the <paramref name="target" />. Stereochemistry
            should not be checked to allow filtering with <see cref="M:NCDK.Isomorphisms.Mappings.GetStereochemistry" />. 
            </summary>
            <example>
            <code>                Pattern pattern = Pattern.FindSubstructure(query);
                foreach (var m in ms)
                {
                    foreach (int[] mapping in pattern.MatchAll(m))
                    {
                        // found mapping
                    }
                }
</code>
            Using the fluent interface (see <see cref="T:NCDK.Isomorphisms.Mappings" />) we can search and
            manipulate the mappings. Here's an example of finding the first 5
            mappings and creating an array. If the mapper is lazy other states are
            simply not explored.
            <code>                // find only the first 5 mappings and store them in an array
                Pattern pattern = Pattern.FindSubstructure(query);
                int[][] mappings = pattern.MatchAll(target)
                                          .Limit(5)
                                          .ToArray();
</code>
            </example>
            <param name="target">the container to search for the pattern in</param>
            <returns>the mapping from the pattern to the target</returns>
            <seealso cref="T:NCDK.Isomorphisms.Mappings" />
        </member>
        <member name="M:NCDK.Isomorphisms.Pattern.MatchAll(NCDK.IReaction)">
            <summary>
            Find all mappings of this pattern in the <code>target</code> reaction.
            
            <blockquote><pre>
            Pattern pattern = Pattern.findSubstructure(query);
            for (IReaction r : rs) {
                for (int[] mapping : pattern.matchAll(r)) {
                    // found mapping
                }
            }
            </pre></blockquote>
            
            The reaction is inlined into a molecule and vs mapped id's correspond
            to the absolute atom index in the reaction when considered as reactants, agents,
            products <see cref="M:NCDK.Tools.Manipulator.ReactionManipulator.ToMolecule(NCDK.IReaction)"/>.
            </summary>
            <param name="target">the reaction to search for the pattern in</param>
            <returns>the mapping from the pattern to the target</returns>
            <seealso cref="T:NCDK.Isomorphisms.Mappings"/>
            <seealso cref="M:NCDK.Tools.Manipulator.ReactionManipulator.ToMolecule(NCDK.IReaction)"/>
        </member>
        <member name="M:NCDK.Isomorphisms.Pattern.FindSubstructure(NCDK.IAtomContainer)">
            <summary>
            Create a pattern which can be used to find molecules which contain the
            <paramref name="query"/> structure. The default structure search implementation is
            <see cref="T:NCDK.Isomorphisms.VentoFoggia"/>.
            </summary>
            <param name="query">the substructure to find</param>
            <returns>a pattern for finding the <paramref name="query"/></returns>
            <seealso cref="T:NCDK.Isomorphisms.VentoFoggia"/>
        </member>
        <member name="M:NCDK.Isomorphisms.Pattern.FindIdentical(NCDK.IAtomContainer)">
            <summary>
            Create a pattern which can be used to find molecules which are the same
            as the <paramref name="query"/> structure. The default structure search
            implementation is <see cref="T:NCDK.Isomorphisms.VentoFoggia"/>.
            </summary>
            <param name="query">the substructure to find</param>
            <returns>a pattern for finding the <paramref name="query"/></returns>
            <seealso cref="T:NCDK.Isomorphisms.VentoFoggia"/>
        </member>
        <member name="T:NCDK.Isomorphisms.State">
            <summary>
            Defines a state for matching (subgraph-)isomorphism from a query graph
            (<i>G1</i>) to a target graph (<i>G2</i>). The mutable state allows
            generation and adding and removal of mappings. A mapping {n, m} indicates a
            query vertex (from <i>G1</i>), n, is paired (mapped) with the target vertex,
            m (from <i>G2</i>). Candidate pairs are generated using <see cref="M:NCDK.Isomorphisms.State.NextN(System.Int32)"/> 
            and <see cref="M:NCDK.Isomorphisms.State.NextM(System.Int32,System.Int32)"/>. Each candidate pair {n, m} is then <see cref="M:NCDK.Isomorphisms.State.Add(System.Int32,System.Int32)"/>ed if
            the mapping was feasible.
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.State.NextN(System.Int32)">
            <summary>
            Given the previous candidate generate the next query candidate. The first
            candidate passed is always -1.
            </summary>
            <param name="n">the previous candidate</param>
            <returns>next candidate</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.State.NextM(System.Int32,System.Int32)">
            <summary>
            Given the previous candidate generate the next target candidate. The
            first candidate passed is always -1.
            </summary>
            <param name="n">the current n vertex</param>
            <param name="m">the previous candidate</param>
            <returns>next candidate</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.State.NMax">
            <summary>
            The max query candidate (number of vertices in the query).
            </summary>
            <returns><i>|V| ‚àà G1</i></returns>
        </member>
        <member name="M:NCDK.Isomorphisms.State.MMax">
            <summary>
            The max target candidate (number of vertices in the target).
            </summary>
            <returns><i>|V| ‚àà G2</i></returns>
        </member>
        <member name="M:NCDK.Isomorphisms.State.Add(System.Int32,System.Int32)">
            <summary>
            Add a mapping between n (a vertex G1) and m (a vertex in G2). If the
            mapping was not feasible the mapping is not added.
            </summary>
            <param name="n">a vertex in G1</param>
            <param name="m">a vertex in G2</param>
            <returns>the mapping was added</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.State.Remove(System.Int32,System.Int32)">
            <summary>
            Remove a mapping (backtrack) between n (a vertex G1) and m (a vertex in
            G2).
            </summary>
            <param name="n">a vertex in G1</param>
            <param name="m">a vertex in G2</param>
        </member>
        <member name="M:NCDK.Isomorphisms.State.Mapping">
            <summary>
            Access a copy of the current mapping.
            </summary>
            <returns>mapping of vertices from <i>G1</i> to <i>G2</i></returns>
        </member>
        <member name="P:NCDK.Isomorphisms.State.Count">
            <summary>
            Current size of the state. If <i>size</i> is the current number of mapped
            candidates.
            </summary>
            <returns>the size of the state</returns>
        </member>
        <member name="T:NCDK.Isomorphisms.StateStream">
            <summary>
            Given a (subgraph-)isomorphism state this class can lazily iterate over the
            mappings in a non-recursive manner.
            </summary>
        </member>
        <member name="F:NCDK.Isomorphisms.StateStream.state">
            <summary>A mapping state.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.StateStream.stack">
            <summary>The stack replaces the call-stack in a recursive matcher.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.StateStream.n">
            <summary>Current candidates.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.StateStream.m">
            <summary>Current candidates.</summary>
        </member>
        <member name="M:NCDK.Isomorphisms.StateStream.#ctor(NCDK.Isomorphisms.State)">
            <summary>
            Create a stream for the provided state.
            </summary>
            <param name="state">the state to stream over</param>
        </member>
        <member name="M:NCDK.Isomorphisms.StateStream.FindNext">
            <summary>
            Finds the next mapping from the current state.
            </summary>
            <returns>the next state (or null if none)</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.StateStream.Map">
            <summary>
            Progress the state-machine - the function return false when a mapping is
            found on the mapping is done.
            </summary>
            <returns>the state is partial</returns>
        </member>
        <member name="T:NCDK.Isomorphisms.StateStream.CandidateStack">
            <summary>
            A fixed size stack to keep track of which vertices are mapped. This stack
            allows us to turn the recursive algorithms it to lazy iterating mappers.
            A reclusive call is usually implemented as call-stack which stores the
            variable in each subroutine invocation. For the mapping we actually only
            need store the candidates.
            </summary>
        </member>
        <member name="F:NCDK.Isomorphisms.StateStream.CandidateStack.ns">
            <summary>Candidate storage.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.StateStream.CandidateStack.ms">
            <summary>Candidate storage.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.StateStream.CandidateStack.nSize">
            <summary>Size of each stack.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.StateStream.CandidateStack.mSize">
            <summary>Size of each stack.</summary>
        </member>
        <member name="M:NCDK.Isomorphisms.StateStream.CandidateStack.Push(System.Int32,System.Int32)">
            <summary>
            Push a candidate mapping on to the stack.
            </summary>
            <param name="n">query candidate</param>
            <param name="m">target candidate</param>
        </member>
        <member name="M:NCDK.Isomorphisms.StateStream.CandidateStack.PopN">
            <summary>
            Pops the G1 candidate.
            </summary>
            <returns>the previous 'n' candidate</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.StateStream.CandidateStack.PopM">
            <summary>
            Pops the G2 candidate.
            </summary>
            <returns>the previous 'm' candidate</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.StateStream.CandidateStack.IsEmpty">
            <summary>
            Is the stack empty - if so no candidates can be popped.
            </summary>
            <returns></returns>
        </member>
        <member name="T:NCDK.Isomorphisms.StereoMatch">
            <summary>
            Filters out (sub)graph-isomorphism matches that have invalid stereochemistry
            configuration. The class is not currently set up to handle partial mappings
            (MCS) but could easily be extended to handle such cases. <p/> The class
            implements the Guava predicate and can be used easily filter the mappings.
            </summary>
            <example><code>
            var f = new StereoMatch(query, target);
            var mappings = ...; // from subgraph isomorphism etc.
            var stereoMappings = Iterables.Filter(mappings, f);
            </code></example>
        </member>
        <member name="F:NCDK.Isomorphisms.StereoMatch.query">
            <summary>Query and target contains.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.StereoMatch.target">
            <summary>Query and target contains.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.StereoMatch.queryMap">
            <summary>Atom to atom index lookup.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.StereoMatch.targetMap">
            <summary>Atom to atom index lookup.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.StereoMatch.queryElements">
            <summary>Indexed array of stereo elements.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.StereoMatch.targetElements">
            <summary>Indexed array of stereo elements.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.StereoMatch.queryTypes">
            <summary>Indexed array of stereo element types.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.StereoMatch.targetTypes">
            <summary>Indexed array of stereo element types.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.StereoMatch.queryStereoIndices">
            <summary>Indices of focus atoms of stereo elements.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.StereoMatch.targetStereoIndices">
            <summary>Indices of focus atoms of stereo elements.</summary>
        </member>
        <member name="M:NCDK.Isomorphisms.StereoMatch.#ctor(NCDK.IAtomContainer,NCDK.IAtomContainer)">
            <summary>
            Create a predicate for checking mappings between a provided
            <paramref name="query"/> and <paramref name="target"/>.
            </summary>
            <param name="query">query container</param>
            <param name="target">target container</param>
        </member>
        <member name="M:NCDK.Isomorphisms.StereoMatch.Apply(System.Int32[])">
            <summary>
            Is the <paramref name="mapping"/> of the stereochemistry in the query preserved in
            the target.
            </summary>
            <param name="mapping">permutation of the query vertices</param>
            <returns>the stereo chemistry is value</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.StereoMatch.CheckTetrahedral(System.Int32,System.Int32[])">
            <summary>
            Verify the tetrahedral stereochemistry (clockwise/anticlockwise) of atom
            <paramref name="u"/> is preserved in the target when the <paramref name="mapping"/> is used.
            </summary>
            <param name="u">tetrahedral index in the target</param>
            <param name="mapping">mapping of vertices</param>
            <returns>the tetrahedral configuration is preserved</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.StereoMatch.Map(System.Int32,System.Int32,System.Int32[],System.Int32[])">
            <summary>
            Transforms the neighbors <paramref name="us"/> adjacent to <paramref name="u"/> into the target
            indices using the mapping <paramref name="mapping"/>. The transformation accounts
            for an implicit hydrogen in the query being an explicit hydrogen in the
            target.
            </summary>
            <param name="u">central atom of tetrahedral element</param>
            <param name="v">mapped central atom of the tetrahedral element</param>
            <param name="us">neighboring vertices of u (u plural)</param>
            <param name="mapping">mapping from the query to the target</param>
            <returns>the neighbors us, transformed into the neighbors around v</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.StereoMatch.CheckGeometric(System.Int32,System.Int32,System.Int32[])">
            <summary>
            Verify the geometric stereochemistry (cis/trans) of the double bond
            <c>u1=u2</c> is preserved in the target when the <paramref name="mapping"/> is
            used.
            </summary>
            <param name="u1">one index of the double bond</param>
            <param name="u2">other index of the double bond</param>
            <param name="mapping">mapping of vertices</param>
            <returns>the geometric configuration is preserved</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.StereoMatch.Neighbors(NCDK.ITetrahedralChirality,System.Collections.Generic.IDictionary{NCDK.IAtom,System.Int32})">
            <summary>
            Access the neighbors of <paramref name="element"/> as their indices.
            </summary>
            <param name="element">tetrahedral element</param>
            <param name="map">atom index lookup</param>
            <returns>the neighbors</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.StereoMatch.FindHydrogen(System.Collections.Generic.IEnumerable{NCDK.IAtom})">
            <summary>
            Given an array of atoms, find the first hydrogen atom.
            </summary>
            <param name="atoms">array of non-null atoms.</param>
            <returns>a hydrogen atom</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.StereoMatch.PermutationParity(System.Int32[])">
            <summary>
            Compute the permutation parity of the values <paramref name="vs"/>. The parity is
            whether we need to do an odd or even number of swaps to put the values in
            sorted order.
            </summary>
            <param name="vs">values</param>
            <returns>parity of the permutation (odd = -1, even = +1)</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.StereoMatch.OtherIndex(System.Int32)">
            <summary>
            Given an index of an atom in the query get the index of the other atom in
            the double bond.
            </summary>
            <param name="i">query atom index</param>
            <returns>the other atom index involved in a double bond</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.StereoMatch.IndexAtoms(NCDK.IAtomContainer)">
            <summary>
            Create an index of atoms for the provided <paramref name="container"/>.
            </summary>
            <param name="container">the container to index the atoms of</param>
            <returns>the index/lookup of atoms to the index they appear</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.StereoMatch.IndexElements(System.Collections.Generic.IDictionary{NCDK.IAtom,System.Int32},NCDK.IStereoElement[],NCDK.Isomorphisms.StereoMatch.Types[],NCDK.IAtomContainer)">
            <summary>
            Index the stereo elements of the <paramref name="container"/> into the the 
            <paramref name="elements"/> and <paramref name="types"/> arrays. The <paramref name="map"/> is used for looking
            up the index of atoms.
            </summary>
            <param name="map">index of atoms</param>
            <param name="elements">array to fill with stereo elements</param>
            <param name="types">type of stereo element indexed</param>
            <param name="container">the container to index the elements of</param>
            <returns>indices of atoms involved in stereo configurations</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.StereoMatch.Parity(NCDK.TetrahedralStereo)">
            <summary>
            Get the parity (-1,+1) of the tetrahedral configuration.
            </summary>
            <param name="stereo">configuration</param>
            <returns>the parity</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.StereoMatch.Parity(NCDK.DoubleBondConformation)">
            <summary>
            Get the parity (-1,+1) of the geometric (double bond) configuration.
            </summary>
            <param name="conformation">configuration</param>
            <returns>the parity</returns>
        </member>
        <member name="T:NCDK.Isomorphisms.SmartsStereoMatch">
            <summary>
            Filters SMARTS matches for those that have valid stereochemistry
            configuration.
            </summary>
            <remarks>
            <note type="note">
            This class is internal and will be private in future.
            </note>
            </remarks>
        </member>
        <member name="F:NCDK.Isomorphisms.SmartsStereoMatch.query">
            <summary>Query and target contains.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.SmartsStereoMatch.target">
            <summary>Query and target contains.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.SmartsStereoMatch.queryMap">
            <summary>Atom to atom index lookup.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.SmartsStereoMatch.targetMap">
            <summary>Atom to atom index lookup.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.SmartsStereoMatch.queryElements">
            <summary>Indexed array of stereo elements.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.SmartsStereoMatch.targetElements">
            <summary>Indexed array of stereo elements.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.SmartsStereoMatch.queryTypes">
            <summary>Indexed array of stereo element types.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.SmartsStereoMatch.targetTypes">
            <summary>Indexed array of stereo element types.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.SmartsStereoMatch.queryStereoIndices">
            <summary>Indices of focus atoms of stereo elements.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.SmartsStereoMatch.targetStereoIndices">
            <summary>Indices of focus atoms of stereo elements.</summary>
        </member>
        <member name="M:NCDK.Isomorphisms.SmartsStereoMatch.#ctor(NCDK.IAtomContainer,NCDK.IAtomContainer)">
            <summary>
            Create a predicate for checking mappings between a provided
            <paramref name="query"/> and <paramref name="target"/>.
            </summary>
            <param name="query">query container</param>
            <param name="target">target container</param>
        </member>
        <member name="M:NCDK.Isomorphisms.SmartsStereoMatch.Apply(System.Int32[])">
            <summary>
            Is the <paramref name="mapping"/> of the stereochemistry in the query preserved in
            the target.
            </summary>
            <param name="mapping">permutation of the query vertices</param>
            <returns>the stereo chemistry is value</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.SmartsStereoMatch.CheckTetrahedral(System.Int32,System.Int32[])">
            <summary>
            Verify the tetrahedral stereochemistry (clockwise/anticlockwise) of atom
            <paramref name="u"/> is preserved in the target when the <paramref name="mapping"/> is used.
            </summary>
            <param name="u">tetrahedral index in the target</param>
            <param name="mapping">mapping of vertices</param>
            <returns>the tetrahedral configuration is preserved</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.SmartsStereoMatch.Map(System.Int32,System.Int32,System.Int32[],System.Int32[])">
            <summary>
            Transforms the neighbors <paramref name="us"/> adjacent to <paramref name="u"/> into the target
            indices using the mapping <paramref name="mapping"/>. The transformation accounts
            for an implicit hydrogen in the query being an explicit hydrogen in the
            target.
            </summary>
            <param name="u">central atom of tetrahedral element</param>
            <param name="v">mapped central atom of the tetrahedral element</param>
            <param name="us">neighboring vertices of <paramref name="u"/> (<paramref name="u"/> plural)</param>
            <param name="mapping">mapping from the query to the target</param>
            <returns>the neighbors us, transformed into the neighbors around v</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.SmartsStereoMatch.CheckGeometric(System.Int32,System.Int32,System.Int32[])">
            <summary>
            Verify the geometric stereochemistry (cis/trans) of the double bond
            <c>u1=u2</c> is preserved in the target when the <paramref name="mapping"/> is
            used.
            </summary>
            <param name="u1">one index of the double bond</param>
            <param name="u2">other index of the double bond</param>
            <param name="mapping">mapping of vertices</param>
            <returns>the geometric configuration is preserved</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.SmartsStereoMatch.Neighbors(NCDK.ITetrahedralChirality,System.Collections.Generic.IDictionary{NCDK.IAtom,System.Int32})">
            <summary>
            Access the neighbors of <paramref name="element"/> as their indices.
            </summary>
            <param name="element">tetrahedral element</param>
            <param name="map">atom index lookup</param>
            <returns>the neighbors</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.SmartsStereoMatch.PermutationParity(System.Int32[])">
            <summary>
            Compute the permutation parity of the values <paramref name="vs"/>. The parity is
            whether we need to do an odd or even number of swaps to put the values in
            sorted order.
            </summary>
            <param name="vs">values</param>
            <returns>parity of the permutation (odd = -1, even = +1)</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.SmartsStereoMatch.OtherIndex(System.Int32)">
            <summary>
            Given an index of an atom in the query get the index of the other atom in
            the double bond.
            </summary>
            <param name="i">query atom index</param>
            <returns>the other atom index involved in a double bond</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.SmartsStereoMatch.IndexAtoms(NCDK.IAtomContainer)">
            <summary>
            Create an index of atoms for the provided <paramref name="container"/>.
            </summary>
            <param name="container">the container to index the atoms of</param>
            <returns>the index/lookup of atoms to the index they appear</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.SmartsStereoMatch.IndexElements(System.Collections.Generic.IDictionary{NCDK.IAtom,System.Int32},NCDK.IStereoElement[],NCDK.Isomorphisms.SmartsStereoMatch.StereoType[],NCDK.IAtomContainer)">
            <summary>
            Index the stereo elements of the <paramref name="container"/> into the the 
            <paramref name="elements"/> and <paramref name="types"/> arrays. The <paramref name="map"/> is used for looking
            up the index of atoms.
            </summary>
            <param name="map">index of atoms</param>
            <param name="elements">array to fill with stereo elements</param>
            <param name="types">type of stereo element indexed</param>
            <param name="container">the container to index the elements of</param>
            <returns>indices of atoms involved in stereo configurations</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.SmartsStereoMatch.Parity(NCDK.TetrahedralStereo)">
            <summary>
            Get the parity (-1,+1) of the tetrahedral configuration.
            </summary>
            <param name="stereo">configuration</param>
            <returns>the parity</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.SmartsStereoMatch.Parity(NCDK.DoubleBondConformation)">
            <summary>
            Get the parity (-1,+1) of the geometric (double bond) configuration.
            </summary>
            <param name="conformation">configuration</param>
            <returns>the parity</returns>
        </member>
        <member name="T:NCDK.Isomorphisms.Ullmann">
            <summary>
            A structure pattern which utilises the Ullmann algorithm <token>cdk-cite-Ullmann76</token>.
            </summary>
            <example>
            Find and count the number molecules which contain the query substructure.
            <code>                IAtomContainer query = queryStructure;
                Pattern pattern = Ullmann.FindSubstructure(query);

                int hits = 0;
                foreach (var m in ms)
                    if (pattern.Matches(m))
                        hits++;
</code>
            Finding the matching to molecules which contain the query substructure. It is
            more efficient to obtain the <see cref="M:NCDK.Isomorphisms.Ullmann.Match(NCDK.IAtomContainer)" /> and check it's size rather than
            test if it <see cref="M:NCDK.Isomorphisms.Ullmann.MatchAll(NCDK.IAtomContainer)" /> first. These methods automatically verify
            stereochemistry.
            <code>                IAtomContainer query = queryStructure;
                Pattern pattern = Ullmann.FindSubstructure(query);

                int hits = 0;
                foreach (var m in ms)
                {
                    int[] match = pattern.Match(m);
                    if (match.Length &gt; 0)
                        hits++;
                }
</code>
            </example>
        </member>
        <member name="F:NCDK.Isomorphisms.Ullmann.query">
            <summary>The query structure.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Ullmann.g1">
            <summary>The query structure adjacency list.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Ullmann.bonds1">
            <summary>The bonds of the query structure.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Ullmann.atomMatcher">
            <summary>The atom matcher to determine atom feasibility.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Ullmann.bondMatcher">
            <summary>The bond matcher to determine atom feasibility.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Ullmann.queryMatching">
            <summary>Is the query matching query atoms/bonds etc?</summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Ullmann.#ctor(NCDK.IAtomContainer,NCDK.Isomorphisms.AtomMatcher,NCDK.Isomorphisms.BondMatcher)">
            <summary>
            Non-public constructor for-now the atom/bond semantics are fixed.
            </summary>
            <param name="query">the query structure</param>
            <param name="atomMatcher">how atoms should be matched</param>
            <param name="bondMatcher">how bonds should be matched</param>
        </member>
        <member name="M:NCDK.Isomorphisms.Ullmann.FindSubstructure(NCDK.IAtomContainer)">
            <summary>
            Create a pattern which can be used to find molecules which contain the
            <paramref name="query"/> structure.
            </summary>
            <param name="query">the substructure to find</param>
            <returns>a pattern for finding the <paramref name="query"/></returns>
        </member>
        <member name="T:NCDK.Isomorphisms.Ullmann.UllmannIterable">
            <summary>Iterable matcher for Ullmann.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Ullmann.UllmannIterable.container1">
            <summary>Query and target containers.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Ullmann.UllmannIterable.container2">
            <summary>Query and target containers.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Ullmann.UllmannIterable.g1">
            <summary>Query and target adjacency lists.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Ullmann.UllmannIterable.g2">
            <summary>Query and target adjacency lists.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Ullmann.UllmannIterable.bonds1">
            <summary>Query and target bond lookup.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Ullmann.UllmannIterable.bonds2">
            <summary>Query and target bond lookup.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Ullmann.UllmannIterable.atomMatcher">
            <summary>How are atoms are matched.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Ullmann.UllmannIterable.bondMatcher">
            <summary>How are bonds are match.</summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Ullmann.UllmannIterable.#ctor(NCDK.IAtomContainer,NCDK.IAtomContainer,System.Int32[][],System.Int32[][],NCDK.Graphs.GraphUtil.EdgeToBondMap,NCDK.Graphs.GraphUtil.EdgeToBondMap,NCDK.Isomorphisms.AtomMatcher,NCDK.Isomorphisms.BondMatcher)">
            <summary>
            Create a match for the following parameters.
            </summary>
            <param name="container1">query structure</param>
            <param name="container2">target structure</param>
            <param name="g1">query adjacency list</param>
            <param name="g2">target adjacency list</param>
            <param name="bonds1">query bond map</param>
            <param name="bonds2">target bond map</param>
            <param name="atomMatcher">how atoms are matched</param>
            <param name="bondMatcher">how bonds are matched</param>
        </member>
        <member name="M:NCDK.Isomorphisms.Ullmann.UllmannIterable.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Isomorphisms.UllmannState">
            <summary>
            A mutable state for matching graphs using the Ullmann algorithm <token>cdk-cite-Ullmann76</token>.
            There are a couple of modifications in this implementation.
            Firstly the mappings are stored in two vectors m1 and m2 and simply allows us
            to return <see cref="M:NCDK.Isomorphisms.UllmannState.Mapping"/>  without searching the compatibility matrix.
            Secondly the compatibility matrix is non-binary and instead of removing
            entries they are <i>marked</i>. The backtracking then resets these entries
            rather and avoids storing/copying the matrix between states.
            </summary>
        </member>
        <member name="F:NCDK.Isomorphisms.UllmannState.g1">
            <summary>Adjacency list representations.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.UllmannState.g2">
            <summary>Adjacency list representations.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.UllmannState.bond1">
            <summary>Query and target bond maps.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.UllmannState.bonds2">
            <summary>Query and target bond maps.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.UllmannState.matrix">
            <summary>The compatibility matrix.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.UllmannState.m1">
            <summary>Current mapped values.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.UllmannState.m2">
            <summary>Current mapped values.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.UllmannState.size">
            <summary>Size of the current mapping.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.UllmannState.bondMatcher">
            <summary>How bond semantics are matched.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.UllmannState.UNMAPPED">
            <summary>Indicates a vertex is unmapped.</summary>
        </member>
        <member name="M:NCDK.Isomorphisms.UllmannState.#ctor(NCDK.IAtomContainer,NCDK.IAtomContainer,System.Int32[][],System.Int32[][],NCDK.Graphs.GraphUtil.EdgeToBondMap,NCDK.Graphs.GraphUtil.EdgeToBondMap,NCDK.Isomorphisms.AtomMatcher,NCDK.Isomorphisms.BondMatcher)">
            <summary>
            Create a state for matching subgraphs using the Ullmann refinement
            procedure.
            </summary>
            <param name="container1">query container</param>
            <param name="container2">target container</param>
            <param name="g1">query container adjacency list</param>
            <param name="g2">target container adjacency list</param>
            <param name="bonds1">query container bond map</param>
            <param name="bonds2">target container bond map</param>
            <param name="atomMatcher">method of matching atom semantics</param>
            <param name="bondMatcher">method of matching bond semantics</param>
        </member>
        <member name="M:NCDK.Isomorphisms.UllmannState.NextN(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Isomorphisms.UllmannState.NextM(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Isomorphisms.UllmannState.NMax">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Isomorphisms.UllmannState.MMax">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Isomorphisms.UllmannState.Add(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Isomorphisms.UllmannState.Remove(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Isomorphisms.UllmannState.Refine(System.Int32)">
            <summary>
            Refines the compatibility removing any mappings which have now become
            invalid (since the last mapping). The matrix is refined from the row
            after the current <paramref name="row"/> - all previous rows are fixed. If when
            refined we find a query vertex has no more candidates left in the target
            we can never reach a feasible matching and refinement is aborted (false
            is returned).
            </summary>
            <param name="row">refine from here</param>
            <returns>match is still feasible</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.UllmannState.Verify(System.Int32,System.Int32)">
            <summary>
            Verify that for every vertex adjacent to n, there should be at least one
            feasible candidate adjacent which can be mapped. If no such candidate
            exists the mapping of n -> m is not longer valid.
            </summary>
            <param name="n">query vertex</param>
            <param name="m">target vertex</param>
            <returns>mapping is still valid</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.UllmannState.HasCandidate(System.Int32)">
            <summary>
            Check if there are any feasible mappings left for the query vertex n. We
            scan the compatibility matrix to see if any value is > 0.
            </summary>
            <param name="n">query vertex</param>
            <returns>a candidate is present</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.UllmannState.Mapping">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.Isomorphisms.UllmannState.Count">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Isomorphisms.UniqueAtomMatches">
             <summary>
             A predicate for filtering atom-mapping results. This class is intended for
             use with <see cref="T:NCDK.Isomorphisms.Pattern"/>.
             </summary>
            
             <example><code>
                 Pattern     pattern = Ullmann.FindSubstructure(query);
                 var unique  = FluentIterable.Of(patter.MatchAll(target))
                                                     .Filter(new UniqueAtomMatches())
                                                     .ToList();
             </code></example>
        </member>
        <member name="F:NCDK.Isomorphisms.UniqueAtomMatches.unique">
            <summary>Which mappings have we seen already.</summary>
        </member>
        <member name="M:NCDK.Isomorphisms.UniqueAtomMatches.#ctor(System.Int32)">
            <summary>
            Create filter for the expected number of unique matches. The number
            of matches can grow if required.
            </summary>
            <param name="expectedHits">expected number of unique matches</param>
        </member>
        <member name="M:NCDK.Isomorphisms.UniqueAtomMatches.#ctor">
            <summary>
            Create filter for unique matches.
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.UniqueAtomMatches.Apply(System.Int32[])">
            <inheritdoc/> 
        </member>
        <member name="M:NCDK.Isomorphisms.UniqueAtomMatches.ToBitArray(System.Int32[])">
            <summary>
            Convert a mapping to a bitset.
            </summary>
            <param name="mapping">an atom mapping</param>
            <returns>a bit set of the mapped vertices (values in array)</returns>
        </member>
        <member name="T:NCDK.Isomorphisms.UniqueBondMatches">
            <summary>
            A predicate for filtering atom-mapping results for those which cover unique
            edges. This class is intended for use with <see cref="T:NCDK.Isomorphisms.Pattern"/>.
            </summary>
            <example><code>
                Pattern     pattern = Ullmann.FindSubstructure(query);
                var unique  = FluentIterable.Of(patter.MatchAll(target))
                                                    .Filter(new UniqueBondMatches())
                                                    .ToList();
            </code></example>
        </member>
        <member name="F:NCDK.Isomorphisms.UniqueBondMatches.unique">
            <summary>Which mappings have we seen already.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.UniqueBondMatches.g">
            <summary>The query graph.</summary>
        </member>
        <member name="M:NCDK.Isomorphisms.UniqueBondMatches.#ctor(System.Int32[][],System.Int32)">
            <summary>
            Create filter for the expected number of unique matches. The number of
            matches can grow if required.
            </summary>
            <param name="g"></param>
            <param name="expectedHits">expected number of unique matches</param>
        </member>
        <member name="M:NCDK.Isomorphisms.UniqueBondMatches.#ctor(System.Int32[][])">
            <summary>Create filter for unique matches.</summary>
        </member>
        <member name="M:NCDK.Isomorphisms.UniqueBondMatches.Apply(System.Int32[])">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Isomorphisms.UniqueBondMatches.ToEdgeSet(System.Int32[])">
            <summary>
            Convert a mapping to a bitset.
            </summary>
            <param name="mapping">an atom mapping</param>
            <returns>a bit set of the mapped vertices (values in array)</returns>
        </member>
        <member name="T:NCDK.Isomorphisms.UniqueBondMatches.Tuple">
            <summary>Immutable helper class holds two vertices id's.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.UniqueBondMatches.Tuple.u">
            <summary>Endpoints.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.UniqueBondMatches.Tuple.v">
            <summary>Endpoints.</summary>
        </member>
        <member name="M:NCDK.Isomorphisms.UniqueBondMatches.Tuple.#ctor(System.Int32,System.Int32)">
            <summary>
            Create the tuple
            </summary>
            <param name="u">an endpoint</param>
            <param name="v">another endpoint</param>
        </member>
        <member name="T:NCDK.Isomorphisms.UniversalIsomorphismTester">
            <summary>
             This class implements a multipurpose structure comparison tool.
             It allows to find maximal common substructure, find the
             mapping of a substructure in another structure, and the mapping of
             two isomorphic structures.
            </summary>
            <remarks>
             Structure comparison may be associated to bond constraints
             (mandatory bonds, e.g. scaffolds, reaction cores,...) on each source graph.
             The constraint flexibility allows a number of interesting queries.
             The substructure analysis relies on the RGraph generic class (see: RGraph)
             This class implements the link between the RGraph model and the
             the CDK model in this way the <see cref="T:NCDK.Isomorphisms.MCSS.RGraph" /> remains independent and may be used
             in other contexts.
             <para>
             This algorithm derives from the algorithm described in
             <token>cdk-cite-HAN90</token> and modified in the thesis of T. Hanser <token>cdk-cite-HAN93</token>.
             </para>
            <note type="warning">
               As a result of the adjacency perception used in this algorithm
               there is a single limitation: cyclopropane and isobutane are seen as isomorph.
               This is due to the fact that these two compounds are the only ones where
               each bond is connected two each other bond (bonds are fully connected)
               with the same number of bonds and still they have different structures
               The algorithm could be easily enhanced with a simple atom mapping manager
               to provide an atom level overlap definition that would reveal this case.
               We decided not to penalize the whole procedure because of one single
               exception query. Furthermore isomorphism may be discarded since  the number of atoms are
               not the same (3 != 4) and in most case this will be already
               screened out by a fingerprint based filtering.
               It is possible to add a special treatment for this special query.
               Be reminded that this algorithm matches bonds only.
            </note>
            <para>
            <note type="note">
            While most isomorphism queries involve a multi-atom query structure
            there may be cases in which the query atom is a single atom. In such a case
            a mapping of target bonds to query bonds is not feasible. In such a case, the RMap objects
            correspond to atom indices rather than bond indices. In general, this will not affect user
            code and the same sequence of method calls for matching multi-atom query structures will
            work for single atom query structures as well.
            </note>
            </para>
            </remarks>
            <example>
             With the <see cref="M:NCDK.Isomorphisms.UniversalIsomorphismTester.IsSubgraph(NCDK.IAtomContainer,NCDK.IAtomContainer)" /> method,
             the second, and only the second argument <b>may</b> be a <see cref="T:NCDK.Isomorphisms.Matchers.IQueryAtomContainer" />,
             which allows one to do SMARTS or MQL like queries.
             The first <see cref="T:NCDK.IAtomContainer" /> must never be an <see cref="T:NCDK.Isomorphisms.Matchers.IQueryAtomContainer" />.
             An example:
            <code>            SmilesParser sp = new SmilesParser(Default.ChemObjectBuilder.Instance);
            IAtomContainer atomContainer = sp.ParseSmiles("CC(=O)OC(=O)C"); // acetic acid anhydride
            IAtomContainer SMILESquery = sp.ParseSmiles("CC"); // ethylene
            IQueryAtomContainer query = QueryAtomContainerCreator.CreateBasicQueryContainer(SMILESquery);
            bool isSubstructure = universalIsomorphismTester.IsSubgraph(atomContainer, query);
</code>
            </example>
        </member>
        <member name="P:NCDK.Isomorphisms.UniversalIsomorphismTester.Timeout">
            <summary>
            Sets the time in milliseconds until the substructure search will be breaked.
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.UniversalIsomorphismTester.IsIsomorph(NCDK.IAtomContainer,NCDK.IAtomContainer)">
            <summary>
            Tests if g1 and g2 are isomorph.
            </summary>
            <param name="g1">first molecule. Must not be an <see cref="T:NCDK.Isomorphisms.Matchers.IQueryAtomContainer"/>.</param>
            <param name="g2">second molecule. May be an <see cref="T:NCDK.Isomorphisms.Matchers.IQueryAtomContainer"/>.</param>
            <returns>true if the 2 molecule are isomorph</returns>
            <exception cref="T:NCDK.CDKException">if the first molecule is an instance of IQueryAtomContainer</exception>
        </member>
        <member name="M:NCDK.Isomorphisms.UniversalIsomorphismTester.GetIsomorphMap(NCDK.IAtomContainer,NCDK.IAtomContainer)">
            <summary>
            Returns the first isomorph mapping found or null.
            </summary>
            <param name="g1">first molecule. Must not be an <see cref="T:NCDK.Isomorphisms.Matchers.IQueryAtomContainer"/>.</param>
            <param name="g2">second molecule. May be an <see cref="T:NCDK.Isomorphisms.Matchers.IQueryAtomContainer"/>.</param>
            <returns>the first isomorph mapping found projected of g1. This is a List of RMap objects containing Ids of matching bonds.</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.UniversalIsomorphismTester.GetIsomorphAtomsMap(NCDK.IAtomContainer,NCDK.IAtomContainer)">
            <summary>
            Returns the first isomorph 'atom mapping' found for g2 in g1.
            </summary>
            <param name="g1">first molecule. Must not be an <see cref="T:NCDK.Isomorphisms.Matchers.IQueryAtomContainer"/>.</param>
            <param name="g2">second molecule. May be an <see cref="T:NCDK.Isomorphisms.Matchers.IQueryAtomContainer"/>.</param>
            <returns>the first isomorph atom mapping found projected on g1. This is a List of RMap objects containing Ids of matching atoms.</returns>
            <exception cref="T:NCDK.CDKException">if the first molecules is not an instance of <see cref="T:NCDK.Isomorphisms.Matchers.IQueryAtomContainer"/></exception>
        </member>
        <member name="M:NCDK.Isomorphisms.UniversalIsomorphismTester.GetIsomorphMaps(NCDK.IAtomContainer,NCDK.IAtomContainer)">
            <summary>
            Returns all the isomorph 'mappings' found between two
            atom containers.
            </summary>
            <param name="g1">first molecule. Must not be an <see cref="T:NCDK.Isomorphisms.Matchers.IQueryAtomContainer"/>.</param>
            <param name="g2">second molecule. May be an <see cref="T:NCDK.Isomorphisms.Matchers.IQueryAtomContainer"/>.</param>
            <returns>the list of all the 'mappings'</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.UniversalIsomorphismTester.GetSubgraphMaps(NCDK.IAtomContainer,NCDK.IAtomContainer)">
            <summary>
            Returns all the subgraph 'bond mappings' found for g2 in g1.
            This is an <see cref="T:System.Collections.Generic.IList`1"/> of <see cref="T:System.Collections.Generic.IList`1"/>s of <see cref="T:NCDK.Isomorphisms.MCSS.RMap"/> objects.
            </summary>
            <remarks>
            Note that if the query molecule is a single atom, then bond mappings
            cannot be defined. In such a case, the <see cref="T:NCDK.Isomorphisms.MCSS.RMap"/> object refers directly to
            atom - atom mappings. Thus RMap.id1 is the index of the target atom
            and RMap.id2 is the index of the matching query atom (in this case,
            it will always be 0). Note that in such a case, there is no need
            to call <see cref="M:NCDK.Isomorphisms.UniversalIsomorphismTester.MakeAtomsMapOfBondsMap(System.Collections.Generic.IList{NCDK.Isomorphisms.MCSS.RMap},NCDK.IAtomContainer,NCDK.IAtomContainer)"/> ,
            though if it is called, then the
            return value is simply the same as the return value of this method.
            </remarks>
            <param name="g1">first molecule. Must not be an <see cref="T:NCDK.Isomorphisms.Matchers.IQueryAtomContainer"/>.</param>
            <param name="g2">second molecule. May be an <see cref="T:NCDK.Isomorphisms.Matchers.IQueryAtomContainer"/>.</param>
            <returns>the list of all the 'mappings' found projected of g1</returns>
            <seealso cref="M:NCDK.Isomorphisms.UniversalIsomorphismTester.MakeAtomsMapsOfBondsMaps(System.Collections.Generic.IList{System.Collections.Generic.IList{NCDK.Isomorphisms.MCSS.RMap}},NCDK.IAtomContainer,NCDK.IAtomContainer)"/>
        </member>
        <member name="M:NCDK.Isomorphisms.UniversalIsomorphismTester.GetSubgraphMap(NCDK.IAtomContainer,NCDK.IAtomContainer)">
            <summary>
            Returns the first subgraph 'bond mapping' found for g2 in g1.
            </summary>
            <param name="g1">first molecule. Must not be an <see cref="T:NCDK.Isomorphisms.Matchers.IQueryAtomContainer"/>.</param>
            <param name="g2">second molecule. May be an <see cref="T:NCDK.Isomorphisms.Matchers.IQueryAtomContainer"/>.</param>
            <returns>the first subgraph bond mapping found projected on g1. This is a <see cref="T:System.Collections.Generic.IList`1"/> of <see cref="T:NCDK.Isomorphisms.MCSS.RMap"/> objects containing Ids of matching bonds.</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.UniversalIsomorphismTester.GetSubgraphAtomsMaps(NCDK.IAtomContainer,NCDK.IAtomContainer)">
            <summary>
            Returns all subgraph 'atom mappings' found for g2 in g1, where g2 must be a substructure
            of g1. If it is not a substructure, null will be returned.
            This is an <see cref="T:System.Collections.Generic.IList`1"/> of <see cref="T:System.Collections.Generic.IList`1"/>s of <see cref="T:NCDK.Isomorphisms.MCSS.RMap"/> objects.
            </summary>
            <param name="g1">first molecule. Must not be an <see cref="T:NCDK.Isomorphisms.Matchers.IQueryAtomContainer"/>.</param>
            <param name="g2">substructure to be mapped. May be an <see cref="T:NCDK.Isomorphisms.Matchers.IQueryAtomContainer"/>.</param>
            <returns>all subgraph atom mappings found projected on g1. This is a <see cref="T:System.Collections.Generic.IList`1"/> of <see cref="T:NCDK.Isomorphisms.MCSS.RMap"/> objects containing Ids of matching atoms.</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.UniversalIsomorphismTester.GetSubgraphAtomsMap(NCDK.IAtomContainer,NCDK.IAtomContainer)">
            <summary>
            Returns the first subgraph 'atom mapping' found for g2 in g1, where g2 must be a substructure
            of g1. If it is not a substructure, null will be returned.
            </summary>
            <param name="g1">first molecule. Must not be an <see cref="T:NCDK.Isomorphisms.Matchers.IQueryAtomContainer"/>.</param>
            <param name="g2">substructure to be mapped. May be an <see cref="T:NCDK.Isomorphisms.Matchers.IQueryAtomContainer"/>.</param>
            <returns>the first subgraph atom mapping found projected on g1. This is a <see cref="T:System.Collections.Generic.IList`1"/> of <see cref="T:NCDK.Isomorphisms.MCSS.RMap"/> objects containing Ids of matching atoms.</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.UniversalIsomorphismTester.IsSubgraph(NCDK.IAtomContainer,NCDK.IAtomContainer)">
            <summary>
            Tests if g2 a subgraph of g1.
            </summary>
            <param name="g1">first molecule. Must not be an <see cref="T:NCDK.Isomorphisms.Matchers.IQueryAtomContainer"/>.</param>
            <param name="g2">second molecule. May be an <see cref="T:NCDK.Isomorphisms.Matchers.IQueryAtomContainer"/>.</param>
            <returns>true if g2 a subgraph on g1</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.UniversalIsomorphismTester.GetOverlaps(NCDK.IAtomContainer,NCDK.IAtomContainer)">
            <summary>
            Returns all the maximal common substructure between two atom containers.
            </summary>
            <param name="g1">first molecule. Must not be an <see cref="T:NCDK.Isomorphisms.Matchers.IQueryAtomContainer"/>.</param>
            <param name="g2">second molecule. May be an <see cref="T:NCDK.Isomorphisms.Matchers.IQueryAtomContainer"/>.</param>
            <returns>the list of all the maximal common substructure found projected of g1 (list of <see cref="T:NCDK.IAtomContainer"/>)</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.UniversalIsomorphismTester.GetBitSet(NCDK.IAtomContainer)">
            <summary>
            Transforms an AtomContainer into a <see cref="T:System.Collections.BitArray"/> (which's size = number of bond
            in the atomContainer, all the bit are set to true).
            </summary>
            <param name="ac"><see cref="T:NCDK.IAtomContainer"/> to transform</param>
            <returns>The bitSet</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.UniversalIsomorphismTester.BuildRGraph(NCDK.IAtomContainer,NCDK.IAtomContainer)">
            <summary>
            Builds the <see cref="T:NCDK.Isomorphisms.MCSS.RGraph"/> ( resolution graph ), from two atomContainer
            (description of the two molecules to compare)
            This is the interface point between the CDK model and
            the generic MCSS algorithm based on the RGRaph.
            </summary>
            <param name="g1">Description of the first molecule</param>
            <param name="g2">Description of the second molecule</param>
            <returns>the rGraph</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.UniversalIsomorphismTester.Search(NCDK.IAtomContainer,NCDK.IAtomContainer,System.Collections.BitArray,System.Collections.BitArray,System.Boolean,System.Boolean)">
            <summary>
            General <see cref="T:NCDK.Isomorphisms.MCSS.RGraph"/> parsing method (usually not used directly)
            This method is the entry point for the recursive search
            adapted to the atom container input.
            </summary>
            <param name="g1">first molecule. Must not be an <see cref="T:NCDK.Isomorphisms.Matchers.IQueryAtomContainer"/>.</param>
            <param name="g2">second molecule. May be an <see cref="T:NCDK.Isomorphisms.Matchers.IQueryAtomContainer"/>.</param>
            <param name="c1">initial condition ( bonds from g1 that must be contains in the solution )</param>
            <param name="c2">initial condition ( bonds from g2 that must be contains in the solution )</param>
            <param name="findAllStructure">if false stop at the first structure found</param>
            <param name="findAllMap">if true search all the 'mappings' for one same structure</param>
            <returns>a List of Lists of <see cref="T:NCDK.Isomorphisms.MCSS.RMap"/> objects that represent the search solutions</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.UniversalIsomorphismTester.CheckQueryAtoms(System.Collections.Generic.IList{NCDK.Isomorphisms.MCSS.RMap},NCDK.IAtomContainer,NCDK.IAtomContainer)">
            <summary>
            Checks that <see cref="T:NCDK.Isomorphisms.Matchers.IQueryAtom"/>'s correctly match consistently.
            </summary>
            <param name="bondmap">bond mapping</param>
            <param name="g1">target graph</param>
            <param name="g2">query graph</param>
            <returns>the atom matches are consistent</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.UniversalIsomorphismTester.Project(System.Collections.Generic.IList{NCDK.Isomorphisms.MCSS.RMap},NCDK.IAtomContainer,System.Int32)">
            <summary>
            Projects a list of <see cref="T:NCDK.Isomorphisms.MCSS.RMap"/> on a molecule.
            </summary>
            <param name="rMapList">the list to project</param>
            <param name="g">the molecule on which project</param>
            <param name="id">the id in the <see cref="T:NCDK.Isomorphisms.MCSS.RMap"/> of the molecule g</param>
            <returns>an AtomContainer</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.UniversalIsomorphismTester.ProjectList(System.Collections.Generic.IList{System.Collections.Generic.IList{NCDK.Isomorphisms.MCSS.RMap}},NCDK.IAtomContainer,System.Int32)">
            <summary>
            Projects a list of RMapsList on a molecule.
            </summary>
            <param name="rMapsList">list of RMapsList to project</param>
            <param name="g">the molecule on which project</param>
            <param name="id">the id in the RMap of the molecule g</param>
            <returns>a list of AtomContainer</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.UniversalIsomorphismTester.GetMaximum(System.Collections.Generic.IList{NCDK.IAtomContainer})">
            <summary>
            Removes all redundant solution.
            </summary>
            <param name="graphList">the list of structure to clean</param>
            <returns>the list cleaned</returns>
            <exception cref="T:NCDK.CDKException">if there is a problem in obtaining subgraphs</exception>
        </member>
        <member name="M:NCDK.Isomorphisms.UniversalIsomorphismTester.CheckSingleAtomCases(NCDK.IAtomContainer,NCDK.IAtomContainer)">
            <summary>
             Checks for single atom cases before doing subgraph/isomorphism search.
            </summary>
            <param name="g1">AtomContainer to match on. Must not be an <see cref="T:NCDK.Isomorphisms.Matchers.IQueryAtomContainer"/>.</param>
            <param name="g2">AtomContainer as query. May be an <see cref="T:NCDK.Isomorphisms.Matchers.IQueryAtomContainer"/>.</param>
            <returns><see cref="T:System.Collections.Generic.IList`1"/> of <see cref="T:System.Collections.Generic.IList`1"/> of <see cref="T:NCDK.Isomorphisms.MCSS.RMap"/> objects for the Atoms (not Bonds!), null if no single atom case</returns>
            <exception cref="T:NCDK.CDKException">if the first molecule is an instance of IQueryAtomContainer</exception>
        </member>
        <member name="M:NCDK.Isomorphisms.UniversalIsomorphismTester.MakeAtomsMapsOfBondsMaps(System.Collections.Generic.IList{System.Collections.Generic.IList{NCDK.Isomorphisms.MCSS.RMap}},NCDK.IAtomContainer,NCDK.IAtomContainer)">
            <summary>
             This makes maps of matching atoms out of a maps of matching bonds as produced by the
             Get(Subgraph|Ismorphism)Maps methods.
            </summary>
            <param name="l">The list produced by the getMap method.</param>
            <param name="g1">The first atom container. Must not be a <see cref="T:NCDK.Isomorphisms.Matchers.IQueryAtomContainer"/>.</param>
            <param name="g2">The second one (first and second as in getMap). May be an <see cref="T:NCDK.Isomorphisms.Matchers.IQueryAtomContainer"/>.</param>
            <returns>A List of <see cref="T:System.Collections.Generic.IList`1"/>s of <see cref="T:NCDK.Isomorphisms.MCSS.RMap"/> objects of matching Atoms.</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.UniversalIsomorphismTester.MakeAtomsMapOfBondsMap(System.Collections.Generic.IList{NCDK.Isomorphisms.MCSS.RMap},NCDK.IAtomContainer,NCDK.IAtomContainer)">
            <summary>
            This makes a map of matching atoms out of a map of matching bonds as produced by the
            <see cref="M:NCDK.Isomorphisms.UniversalIsomorphismTester.GetSubgraphMap(NCDK.IAtomContainer,NCDK.IAtomContainer)"/>/<see cref="M:NCDK.Isomorphisms.UniversalIsomorphismTester.GetIsomorphMap(NCDK.IAtomContainer,NCDK.IAtomContainer)"/> methods.
            </summary>
            <param name="l">The list produced by the getMap method.</param>
            <param name="g1">first molecule. Must not be an <see cref="T:NCDK.Isomorphisms.Matchers.IQueryAtomContainer"/>.</param>
            <param name="g2">second molecule. May be an <see cref="T:NCDK.Isomorphisms.Matchers.IQueryAtomContainer"/>.</param>
            <returns>The mapping found projected on g1. This is a <see cref="T:System.Collections.Generic.List`1"/> of <see cref="T:NCDK.Isomorphisms.MCSS.RMap"/> objects containing Ids of matching atoms.</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.UniversalIsomorphismTester.NodeConstructor(NCDK.Isomorphisms.MCSS.RGraph,NCDK.IAtomContainer,NCDK.IAtomContainer)">
            <summary>
             Builds  the nodes of the <see cref="T:NCDK.Isomorphisms.MCSS.RGraph"/> ( resolution graph ), from
             two atom containers (description of the two molecules to compare)
            </summary>
            <param name="gr">the target RGraph</param>
            <param name="ac1">first molecule. Must not be an <see cref="T:NCDK.Isomorphisms.Matchers.IQueryAtomContainer"/>.</param>
            <param name="ac2">second molecule. May be an <see cref="T:NCDK.Isomorphisms.Matchers.IQueryAtomContainer"/>.</param>
            <exception cref="T:NCDK.CDKException">if it takes too long to identify overlaps</exception>
        </member>
        <member name="M:NCDK.Isomorphisms.UniversalIsomorphismTester.ArcConstructor(NCDK.Isomorphisms.MCSS.RGraph,NCDK.IAtomContainer,NCDK.IAtomContainer)">
            <summary>
             Build edges of the <see cref="T:NCDK.Isomorphisms.MCSS.RGraph"/>s.
             This method create the edge of the RGraph and
             calculates the incompatibility and neighborhood
             relationships between RGraph nodes.
            </summary>
            <param name="gr">the rGraph</param>
            <param name="ac1">first molecule. Must not be an <see cref="T:NCDK.Isomorphisms.Matchers.IQueryAtomContainer"/>.</param>
            <param name="ac2">second molecule. May be an <see cref="T:NCDK.Isomorphisms.Matchers.IQueryAtomContainer"/>.</param>
            <exception cref="T:NCDK.CDKException">if it takes too long to identify overlaps</exception>
        </member>
        <member name="M:NCDK.Isomorphisms.UniversalIsomorphismTester.HasCommonAtom(NCDK.IBond,NCDK.IBond)">
            <summary>
            Determines if two bonds have at least one atom in common.
            </summary>
            <param name="a">first bond</param>
            <param name="b">second bond</param>
            <returns> the symbol of the common atom or "" if the 2 bonds have no common atom</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.UniversalIsomorphismTester.GetCommonSymbol(NCDK.IBond,NCDK.IBond)">
            <summary>
            Determines if 2 bond have 1 atom in common and returns the common symbol.
            </summary>
            <param name="a">first bond</param>
            <param name="b">second bond</param>
            <returns>the symbol of the common atom or "" if the 2 bonds have no common atom</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.UniversalIsomorphismTester.QueryAdjacency(NCDK.IBond,NCDK.IBond,NCDK.IBond,NCDK.IBond)">
            <summary>
            Determines if 2 bond have 1 atom in common if second is a query AtomContainer.
            </summary>
            <param name="a1">first bond</param>
            <param name="b1">second bond</param>
            <param name="a2">first bond</param>
            <param name="b2">second bond</param>
            <returns>the symbol of the common atom or "" if the 2 bonds have no common atom</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.UniversalIsomorphismTester.QueryAdjacencyAndOrder(NCDK.IBond,NCDK.IBond,NCDK.IBond,NCDK.IBond)">
            <summary>
             Determines if 2 bond have 1 atom in common if second is a query AtomContainer
             and whether the order of the atoms is correct (atoms match).
            </summary>
            <param name="bond1">first bond</param>
            <param name="bond2">second bond</param>
            <param name="queryBond1">first query bond</param>
            <param name="queryBond2">second query bond</param>
            <returns>the symbol of the common atom or "" if the 2 bonds have no common atom</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.UniversalIsomorphismTester.TestSubgraphHeuristics(NCDK.IAtomContainer,NCDK.IAtomContainer)">
            <summary>
             Checks some simple heuristics for whether the subgraph query can
             realistically be a subgraph of the supergraph. If, for example, the
             number of nitrogen atoms in the query is larger than that of the supergraph
             it cannot be part of it.
            </summary>
            <param name="ac1">the supergraph to be checked. Must not be an <see cref="T:NCDK.Isomorphisms.Matchers.IQueryAtomContainer"/>.</param>
            <param name="ac2">the subgraph to be tested for. May be an <see cref="T:NCDK.Isomorphisms.Matchers.IQueryAtomContainer"/>.</param>
            <returns>true if the subgraph ac2 has a chance to be a subgraph of ac1</returns>
            <exception cref="T:NCDK.CDKException">if the first molecule is an instance of <see cref="T:NCDK.Isomorphisms.Matchers.IQueryAtomContainer"/></exception>
        </member>
        <member name="T:NCDK.Isomorphisms.VentoFoggia">
            <summary>
            A structure pattern which utilises the Vento-Foggia (VF) algorithm <token>cdk-cite-Cordella04</token>.
            </summary>
            <example>
            Find and count the number molecules which contain the query substructure.
            <code>                IAtomContainer query = queryStructure;
                Pattern pattern = VentoFoggia.FindSubstructure(query);

                int hits = 0;
                foreach (var m in ms)
                    if (pattern.Matches(m))
                        hits++;
</code>
            Finding the matching to molecules which contain the query substructure. It is
            more efficient to obtain the <see cref="M:NCDK.Isomorphisms.VentoFoggia.Match(NCDK.IAtomContainer)" /> and check it's size rather than
            test if it <see cref="M:NCDK.Isomorphisms.VentoFoggia.MatchAll(NCDK.IAtomContainer)" />. These methods automatically verify
            stereochemistry.
            <code>                IAtomContainer query = queryStructure;
                Pattern pattern = VentoFoggia.FindSubstructure(query);

                int hits = 0;
                foreach (var m in ms)
                {
                    int[] match = pattern.Match(m);
                    if (match.Length &gt; 0)
                        hits++;
                }
</code>
            </example>
        </member>
        <member name="F:NCDK.Isomorphisms.VentoFoggia.query">
            <summary>The query structure.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.VentoFoggia.g1">
            <summary>The query structure adjacency list.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.VentoFoggia.bonds1">
            <summary>The bonds of the query structure.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.VentoFoggia.atomMatcher">
            <summary>The atom matcher to determine atom feasibility.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.VentoFoggia.bondMatcher">
            <summary>The bond matcher to determine atom feasibility.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.VentoFoggia.subgraph">
            <summary>Search for a subgraph.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.VentoFoggia.queryMatching">
            <summary>Is the query matching query atoms/bonds etc?</summary>
        </member>
        <member name="M:NCDK.Isomorphisms.VentoFoggia.#ctor(NCDK.IAtomContainer,NCDK.Isomorphisms.AtomMatcher,NCDK.Isomorphisms.BondMatcher,System.Boolean)">
            <summary>
            Non-public constructor for-now the atom/bond semantics are fixed.
            </summary>
            <param name="query">the query structure</param>
            <param name="atomMatcher">how atoms should be matched</param>
            <param name="bondMatcher">how bonds should be matched</param>
            <param name="substructure">substructure search</param>
        </member>
        <member name="M:NCDK.Isomorphisms.VentoFoggia.Match(NCDK.IAtomContainer)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Isomorphisms.VentoFoggia.MatchAll(NCDK.IAtomContainer)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Isomorphisms.VentoFoggia.FindSubstructure(NCDK.IAtomContainer)">
            <summary>
            Create a pattern which can be used to find molecules which contain the
            <paramref name="query"/> structure.
            </summary>
            <param name="query">the substructure to find</param>
            <returns>a pattern for finding the <paramref name="query"/></returns>
        </member>
        <member name="M:NCDK.Isomorphisms.VentoFoggia.FindIdentical(NCDK.IAtomContainer)">
            <summary>
            Create a pattern which can be used to find molecules which are the same
            as the <paramref name="query"/> structure.
            </summary>
            <param name="query">the substructure to find</param>
            <returns>a pattern for finding the <paramref name="query"/></returns>
        </member>
        <member name="M:NCDK.Isomorphisms.VentoFoggia.FindSubstructure(NCDK.IAtomContainer,NCDK.Isomorphisms.AtomMatcher,NCDK.Isomorphisms.BondMatcher)">
            <summary>
            Create a pattern which can be used to find molecules which contain the
            <paramref name="query"/> structure.
            </summary>
            <param name="query">the substructure to find</param>
            <param name="atomMatcher">how atoms are matched</param>
            <param name="bondMatcher">how bonds are matched</param>
            <returns>a pattern for finding the <paramref name="query"/></returns>
        </member>
        <member name="M:NCDK.Isomorphisms.VentoFoggia.FindIdentical(NCDK.IAtomContainer,NCDK.Isomorphisms.AtomMatcher,NCDK.Isomorphisms.BondMatcher)">
            <summary>
            Create a pattern which can be used to find molecules which are the same
            as the <paramref name="query"/> structure.
            </summary>
            <param name="query">the substructure to find</param>
            <param name="atomMatcher">how atoms are matched</param>
            <param name="bondMatcher">how bonds are matched</param>
            <returns>a pattern for finding the <paramref name="query"/></returns>
        </member>
        <member name="F:NCDK.Isomorphisms.VentoFoggia.VFIterable.container1">
            <summary>Query and target containers.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.VentoFoggia.VFIterable.container2">
            <summary>Query and target containers.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.VentoFoggia.VFIterable.g1">
            <summary>Query and target adjacency lists.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.VentoFoggia.VFIterable.g2">
            <summary>Query and target adjacency lists.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.VentoFoggia.VFIterable.bonds1">
            <summary>Query and target bond lookup.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.VentoFoggia.VFIterable.bonds2">
            <summary>Query and target bond lookup.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.VentoFoggia.VFIterable.atomMatcher">
            <summary>How are atoms are matched.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.VentoFoggia.VFIterable.bondMatcher">
            <summary>How are bonds are match.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.VentoFoggia.VFIterable.subgraph">
            <summary>The query is a subgraph.</summary>
        </member>
        <member name="M:NCDK.Isomorphisms.VentoFoggia.VFIterable.#ctor(NCDK.IAtomContainer,NCDK.IAtomContainer,System.Int32[][],System.Int32[][],NCDK.Graphs.GraphUtil.EdgeToBondMap,NCDK.Graphs.GraphUtil.EdgeToBondMap,NCDK.Isomorphisms.AtomMatcher,NCDK.Isomorphisms.BondMatcher,System.Boolean)">
            <summary>
            Create a match for the following parameters.
            </summary>
            <param name="container1">query structure</param>
            <param name="container2">target structure</param>
            <param name="g1">query adjacency list</param>
            <param name="g2">target adjacency list</param>
            <param name="bonds1">query bond map</param>
            <param name="bonds2">target bond map</param>
            <param name="atomMatcher">how atoms are matched</param>
            <param name="bondMatcher">how bonds are matched</param>
            <param name="subgraph">perform subgraph search</param>
        </member>
        <member name="M:NCDK.Isomorphisms.VentoFoggia.VFIterable.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Isomorphisms.VFState">
            <summary>
            Vento-Foggia (VF) state for matching isomorphisms (identity) <token>cdk-cite-Cordella04</token>.</summary>
            <remarks>
            <note type="note">
            No heuristics or sorting are performed as all and
            should be checked externally</note>
            </remarks>
        </member>
        <member name="F:NCDK.Isomorphisms.VFState.container1">
            <summary>
            The query (container1) and target (container2) of the isomorphism
            matching.
            </summary>
        </member>
        <member name="F:NCDK.Isomorphisms.VFState.container2">
            <summary>
            The query (container1) and target (container2) of the isomorphism
            matching.
            </summary>
        </member>
        <member name="F:NCDK.Isomorphisms.VFState.bonds1">
            <summary>
            Lookup for the query bonds (bonds1) and target bonds (bonds2) of the
            isomorphism matching.
            </summary>
        </member>
        <member name="F:NCDK.Isomorphisms.VFState.bonds2">
            <summary>
            Lookup for the query bonds (bonds1) and target bonds (bonds2) of the
            isomorphism matching.
            </summary>
        </member>
        <member name="F:NCDK.Isomorphisms.VFState.atomMatcher">
            <summary>Defines how atoms are matched.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.VFState.bondMatcher">
            <summary>Defines how bonds are matched.</summary>
        </member>
        <member name="M:NCDK.Isomorphisms.VFState.#ctor(NCDK.IAtomContainer,NCDK.IAtomContainer,System.Int32[][],System.Int32[][],NCDK.Graphs.GraphUtil.EdgeToBondMap,NCDK.Graphs.GraphUtil.EdgeToBondMap,NCDK.Isomorphisms.AtomMatcher,NCDK.Isomorphisms.BondMatcher)">
            <summary>
            Create a VF state for matching isomorphisms. The query is passed first
            and should read as, find container1 in container2.
            </summary>
            <param name="container1">the molecule to search for (query)</param>
            <param name="container2">the molecule to search in (target)</param>
            <param name="g1">adjacency list of the query</param>
            <param name="g2">adjacency list of the target</param>
            <param name="bonds1">bond lookup of the query</param>
            <param name="bonds2">bond lookup of the target</param>
            <param name="atomMatcher">what semantic attributes (symbol, charge, query) determines atoms to be compatible</param>
            <param name="bondMatcher">what semantic attributes (order/aromatic, query) determines bonds to be compatible</param>
        </member>
        <member name="M:NCDK.Isomorphisms.VFState.Feasible(System.Int32,System.Int32)">
            <summary>
            Check the feasibility of the candidate pair {n, m}. A candidate pair is
            syntactically feasible iff all k-look-ahead rules hold. These look ahead
            rules check adjacency relation of the mapping. If an edge is mapped in g1
            it should also be mapped in g2 and vise-versa (0-look-ahead). If an edge
            in g1 is unmapped but the edge is adjacent to an another mapped vertex
            (terminal) then the number of such edges should be equal in g1 compared
            to g2 (1-look-ahead). If the edge is unmapped and non-terminal then the
            number of such edges should be equal in g1 compared to g2 (2-look-ahead).
            </summary>
            <param name="n">a candidate vertex from g1</param>
            <param name="m">a candidate vertex from g2</param>
            <returns>the mapping is feasible</returns>
        </member>
        <member name="T:NCDK.Isomorphisms.VFSubState">
            <summary>
            Vento-Foggia (VF) state for matching subgraph-monomorphisms. The original
            algorithm <token>cdk-cite-Cordella04</token> is for matching vertex-induced
            subgraph-isomorphisms. A matching is vertex-induced if adjacency relation of
            mapped vertices is isomorphic. Under such a procedure propane (<c>CCC</c>)
            is not considered a substructure of cyclopropane (<c>C1CC1</c>). The term
            subgraph-isomorphism is often conflated and it is really
            subgraph-monomorphism that is required for substructure matching.
            </summary>
            <remarks>
            Note: no heuristics or sorting are performed at all and should be checked
            externally
            </remarks>
        </member>
        <member name="F:NCDK.Isomorphisms.VFSubState.container1">
            <summary>The query (container1) and target (container2) of the subgraph matching.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.VFSubState.container2">
            <summary>The query (container1) and target (container2) of the subgraph matching.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.VFSubState.bonds1">
            <summary>
            Lookup for the query bonds (bonds1) and target bonds (bonds2) of the
            subgraph matching.
            </summary>
        </member>
        <member name="F:NCDK.Isomorphisms.VFSubState.bonds2">
            <summary>
            Lookup for the query bonds (bonds1) and target bonds (bonds2) of the
            subgraph matching.
            </summary>
        </member>
        <member name="F:NCDK.Isomorphisms.VFSubState.atomMatcher">
            <summary>Defines how atoms are matched.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.VFSubState.bondMatcher">
            <summary>Defines how bonds are matched.</summary>
        </member>
        <member name="M:NCDK.Isomorphisms.VFSubState.#ctor(NCDK.IAtomContainer,NCDK.IAtomContainer,System.Int32[][],System.Int32[][],NCDK.Graphs.GraphUtil.EdgeToBondMap,NCDK.Graphs.GraphUtil.EdgeToBondMap,NCDK.Isomorphisms.AtomMatcher,NCDK.Isomorphisms.BondMatcher)">
            <summary>
            Create a VF state for matching subgraph-monomorphism. The query is passed
            first and should read as, find container1 in container2.
            </summary>
            <param name="container1">the molecule to search for (query)</param>
            <param name="container2">the molecule to search in (target)</param>
            <param name="g1">adjacency list of the query</param>
            <param name="g2">adjacency list of the target</param>
            <param name="bonds1">bond lookup of the query</param>
            <param name="bonds2">bond lookup of the target</param>
            <param name="atomMatcher">what semantic attributes (symbol, charge, query) determines atoms to be compatible</param>
            <param name="bondMatcher">what semantic attributes (order/aromatic, query) determines bonds to be compatible</param>
        </member>
        <member name="M:NCDK.Isomorphisms.VFSubState.Feasible(System.Int32,System.Int32)">
            <summary>
            Check the feasibility of the candidate pair {n, m}. 
            </summary>
            <remarks>
            <para>
            A candidate pair is
            syntactically feasible iff all k-look-ahead rules hold. These look ahead
            rules check adjacency relation of the mapping. If an edge is mapped in g1
            it should also be mapped in g2 and vise-versa (0-look-ahead). If an edge
            in g1 is unmapped but the edge is adjacent to an another mapped vertex
            (terminal) then the number of such edges should be less or equal in g1
            compared to g2 (1-look-ahead). If the edge is unmapped and non-terminal
            then the number of such edges should be less or equal in g1 compared to
            g2 (2-look-ahead).
            </para>
            <para>
            The above feasibility rules are for
            subgraph-isomorphism and have been adapted for subgraph-monomorphism. For
            a monomorphism a mapped edge in g2 does not have to be present in g1. The
            2-look-ahead also requires summing the terminal and remaining counts (or
            sorting the vertices). 
            </para>
            <para>
            The semantic feasibility verifies that the
            labels the label n, m are compatabile and that the label on each matched
            edge is compatabile.
            </para>
            </remarks>
            <param name="n">a candidate vertex from g1</param>
            <param name="m">a candidate vertex from g2</param>
            <returns>the mapping is feasible</returns>
        </member>
        <member name="M:NCDK.LibIO.CML.CMLAtomArray.Sort(NCDK.LibIO.CML.CMLFormula.Sorts)">
            <summary>
            sorts atomArray. 
            currently only works for array type syntax.
            </summary>
            <param name="sort"></param>
        </member>
        <member name="M:NCDK.LibIO.CML.CMLAtomArray.GenerateConcise(System.Int32)">
            <summary>
            generates concise representation. corresponds to concise attribute in
            schema. only works if atomArray has elementType and count in array format
            </summary>
            <param name="formalCharge">(maybe omit this)</param>
            <returns>concise string</returns>
            <exception cref="T:System.ApplicationException">if atomArray of wrong sort</exception>
        </member>
        <member name="T:NCDK.LibIO.CML.CMLFormula">
            <summary>
            user-modifiable class supporting formula. * The semantics of formula have
            been updated (2005-10) and the relationship between concise attribute and
            atomArray children is explicit. This class supports the parsing of a number
            of current inline structures but does not guarantee correctness as there are
            no agreed community syntax/semantics. This is a particular problem for
            charges which could be "2+", "++", "+2", etc. For robust inline interchange
            ONLY the concise representation is supported.
            </summary>
            <remarks>
            NOTE: The atomArray child, in array format, together with the formalCharge
            attribute is the primary means of holding the formula. There is now no lazy
            evaluation. The concise attribute can be autogenerated from the atomArray and
            formalCharge. If a formula is input with only concise then the atomArray is
            automatically generated from it.
            </remarks>
        </member>
        <member name="T:NCDK.LibIO.CML.CMLFormula.HydrogenStrategies">
            <summary>
            type of hydrogen counting
            </summary>
        </member>
        <member name="F:NCDK.LibIO.CML.CMLFormula.HydrogenStrategies.HYDROGEN_COUNT">
            <summary>use hydrogen count attribute</summary>
        </member>
        <member name="F:NCDK.LibIO.CML.CMLFormula.HydrogenStrategies.EXPLICIT_HYDROGENS">
            <summary>use explicit hydrogens</summary>
        </member>
        <member name="M:NCDK.LibIO.CML.CMLFormula.CheckAtomArrayFormat(NCDK.LibIO.CML.CMLAtomArray)">
            <summary>
            checks that atomArray is in array format with unduplicated valid
            elements. must have elementType and count attributes of equal lengths.
            </summary>
            <param name="atomArray">to check (not modified)</param>
            <exception cref="T:System.ApplicationException">if invalid</exception>
        </member>
        <member name="P:NCDK.LibIO.CML.CMLFormula.Concise">
            <summary>
            set concise attribute. if atomArray is absent will automatically compute
            atomArray and formalCharge, so use with care if atomArray is present will
            throw CMLRuntime this logic may need to be revised
            </summary>
            <param name="value">concise value</param>
            <exception cref="T:System.ApplicationException">attribute wrong value/type</exception>
        </member>
        <member name="P:NCDK.LibIO.CML.CMLFormula.AtomArrayElements">
            <summary>
            An inline representation of the object.
            No description
            </summary>
        </member>
        <member name="M:NCDK.LibIO.CML.CMLFormula.Add(System.String,System.Double)">
            <summary>
            Adds element and count to formula. If element is already known,
            increments the count.
            </summary>
            <param name="elementType">the element atomicSymbol</param>
            <param name="count">the element multiplier</param>
        </member>
        <member name="M:NCDK.LibIO.CML.CMLFormula.GetCounts">
            <summary>
            Count for corresponding element.
            No defaults.
            </summary>
            <returns>double[] array of element counts; or null for none.</returns>
        </member>
        <member name="M:NCDK.LibIO.CML.CMLFormula.GetTotalAtomCount">
            <summary>
            get atom count
            </summary>
            <returns>count</returns>
        </member>
        <member name="M:NCDK.LibIO.CML.CMLFormula.GetElementTypes">
            <summary>
            Count for corresponding element.
            No defaults.
            </summary>
            <returns>double[] array of element counts; or null for none.</returns>
        </member>
        <member name="T:NCDK.LibIO.CML.CMLFormula.Types.O">
            <summary>
            The <see cref="P:NCDK.LibIO.CML.CMLFormula.Types.Ordinal"/> values of <see cref="T:NCDK.LibIO.CML.CMLFormula.Types"/>.
            </summary>
            <seealso cref="T:NCDK.LibIO.CML.CMLFormula.Types"/>
        </member>
        <member name="P:NCDK.LibIO.CML.CMLFormula.Types.Ordinal">
            <summary>
            The ordinal of this enumeration constant. The list is in <see cref="T:NCDK.LibIO.CML.CMLFormula.Types.O"/>.
            </summary>
            <seealso cref="T:NCDK.LibIO.CML.CMLFormula.Types.O"/>
        </member>
        <member name="M:NCDK.LibIO.CML.CMLFormula.Types.ToString">
            <inheritdoc/>
        </member>
        <member name="F:NCDK.LibIO.CML.CMLFormula.Types.NOPUNCTUATION">
            <summary>
            the simplest representation. an input-only format. parsing is possible but fragile. The charge semantics are not defined. Not recommended for output.
            </summary>
        </member>
        <member name="F:NCDK.LibIO.CML.CMLFormula.Types.ELEMENT_COUNT_WHITESPACE">
            <summary>
            another simple representation. an input-only format. parsing is also fragile as charge sematics are not defined. Not recommended for output.
            </summary>
        </member>
        <member name="F:NCDK.LibIO.CML.CMLFormula.Types.ELEMENT_WHITESPACE_COUNT">
            <summary>
            Yet another simple representation. an input-only format. Element counts of 1 should always be given. Fragile as charge field is likely to be undefined. Not recommended for output.
            </summary>
        </member>
        <member name="F:NCDK.LibIO.CML.CMLFormula.Types.CONCISE">
            <summary>
            the format used in concise. recommended as the main output form. Element counts of 1 should always be given. the charge shoudl always be included. See concise.xsd and formulaType.xsd for syntax.
            </summary>
        </member>
        <member name="F:NCDK.LibIO.CML.CMLFormula.Types.MULTIPLIED_ELEMENT_COUNT_WHITESPACE">
            <summary>
            multipliers for moieties. an input only format. JUMBO will try to parse this correctly but no guarantee is given.
            </summary>
        </member>
        <member name="F:NCDK.LibIO.CML.CMLFormula.Types.NESTEDBRACKETS">
            <summary>
            hierarchical formula. an input-only format. JUMBO will try to parse this correctly but no guarantee is given.
            </summary>
        </member>
        <member name="F:NCDK.LibIO.CML.CMLFormula.Types.IUPAC">
            <summary>
            an input only format. JUMBO will not yet parse this correctly. comments from IUCr
            </summary>
        </member>
        <member name="F:NCDK.LibIO.CML.CMLFormula.Types.MOIETY">
            <summary>
            Moiety, used by IUCr. an input-only format. moieties assumed to be comma separated then ELEMENT_COUNT_WHITESPACE, with optional brackets and post or pre-multipliers
            </summary>
        </member>
        <member name="F:NCDK.LibIO.CML.CMLFormula.Types.SUBMOIETY">
            <summary>
            SubMoiety, used by IUCr. the part of a moiety within the brackets assumed to b ELEMENT_OPTIONALCOUNT followed by optional FORMULA
            </summary>
        </member>
        <member name="F:NCDK.LibIO.CML.CMLFormula.Types.STRUCTURAL">
            <summary>
            Structural, used by IUCr. not currently implemented, I think. probably the same as nested brackets
            </summary>
        </member>
        <member name="F:NCDK.LibIO.CML.CMLFormula.Types.ANY">
            <summary>
            any of the above. input-only.
            </summary>
        </member>
        <member name="M:NCDK.LibIO.CML.CMLFormula.Types.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.LibIO.CML.CMLFormula.Types.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.LibIO.CML.CMLFormula.Types.CompareTo(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.LibIO.CML.CMLFormula.Types.CompareTo(NCDK.LibIO.CML.CMLFormula.Types)">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.LibIO.CML.CMLFormula.Sorts.O">
            <summary>
            The <see cref="P:NCDK.LibIO.CML.CMLFormula.Sorts.Ordinal"/> values of <see cref="T:NCDK.LibIO.CML.CMLFormula.Sorts"/>.
            </summary>
            <seealso cref="T:NCDK.LibIO.CML.CMLFormula.Sorts"/>
        </member>
        <member name="P:NCDK.LibIO.CML.CMLFormula.Sorts.Ordinal">
            <summary>
            The ordinal of this enumeration constant. The list is in <see cref="T:NCDK.LibIO.CML.CMLFormula.Sorts.O"/>.
            </summary>
            <seealso cref="T:NCDK.LibIO.CML.CMLFormula.Sorts.O"/>
        </member>
        <member name="M:NCDK.LibIO.CML.CMLFormula.Sorts.ToString">
            <inheritdoc/>
        </member>
        <member name="F:NCDK.LibIO.CML.CMLFormula.Sorts.ALPHABETIC_ELEMENTS">
            <summary>
            sort alphabetically. output only. Not sure where this is
            </summary>
        </member>
        <member name="F:NCDK.LibIO.CML.CMLFormula.Sorts.CHFIRST">
            <summary>
            C H and then alphabetically. (output only)
            </summary>
        </member>
        <member name="M:NCDK.LibIO.CML.CMLFormula.Sorts.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.LibIO.CML.CMLFormula.Sorts.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.LibIO.CML.CMLFormula.Sorts.CompareTo(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.LibIO.CML.CMLFormula.Sorts.CompareTo(NCDK.LibIO.CML.CMLFormula.Sorts)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.LibIO.CML.CMLScalar.SetValue(System.Int32)">
            <summary>
            sets value to int.. updates dataType.
            </summary>
            <param name="scalar"></param>
        </member>
        <member name="F:NCDK.LibIO.CML.CMLCrystal.CRYSTAL_DICT_REFS">
            <summary>
            dictRef ids for 6 scalar children of crystal.
            </summary>
        </member>
        <member name="F:NCDK.LibIO.CML.CMLCrystal.CRYSTAL_DICT_UNITS">
            <summary>
             unit refs for 6 scalar children of crystal.
            </summary>
        </member>
        <member name="M:NCDK.LibIO.CML.Convertor.#ctor(System.Boolean,System.String)">
            <summary>
            Constructs a CML convertor.
            </summary>
            <param name="useCMLIDs">Uses object IDs like 'a1' instead of 'a&lt;hash&gt;'.</param>
            <param name="prefix">Namespace prefix to use. If null, then no prefix is used;</param>
        </member>
        <member name="T:NCDK.LibIO.CML.MDMoleculeCustomizer">
            <summary>
            Customize persistence of MDMolecule by adding support for residues and charge groups.
            </summary>
        </member>
        <member name="M:NCDK.LibIO.CML.MDMoleculeCustomizer.Customize(NCDK.IBond,System.Object)">
            <summary>
            No customization for bonds.
            </summary>
            <param name="bond"></param>
            <param name="nodeToAdd"></param>
        </member>
        <member name="M:NCDK.LibIO.CML.MDMoleculeCustomizer.Customize(NCDK.IAtom,System.Object)">
            <summary>
            Customize Atom.
            </summary>
            <param name="atom"></param>
            <param name="nodeToAdd"></param>
        </member>
        <member name="M:NCDK.LibIO.CML.MDMoleculeCustomizer.Customize(NCDK.IAtomContainer,System.Object)">
            <summary>
            Customize Molecule.
            </summary>
            <param name="molecule"></param>
            <param name="nodeToAdd"></param>
        </member>
        <member name="T:NCDK.LibIO.CML.PDBAtomCustomizer">
            <summary>
            <see cref="T:NCDK.LibIO.CML.ICMLCustomizer"/> for the libio-cml <see cref="T:NCDK.LibIO.CML.Convertor"/> to be able to export details for <see cref="T:NCDK.IPDBAtom"/>'s.
            </summary>
        </member>
        <member name="T:NCDK.LibIO.MD.ChargeGroup">
            <summary>
            A ChargeGroup (CG) is a numbered collection of atoms in an MDMolecule.
            
            A CG is a small set of atoms with total zero or Integer charge.
            </summary>
        </member>
        <member name="M:NCDK.LibIO.MD.ChargeGroup.#ctor">
            <summary>
            Empty constructor.
            </summary>
        </member>
        <member name="M:NCDK.LibIO.MD.ChargeGroup.#ctor(NCDK.IAtomContainer,System.Int32,NCDK.LibIO.MD.MDMolecule)">
            <summary>
            Constructor to create a ChargeGroup based on an AC, a number, and a MDMolecule.
            </summary>
            <param name="container"></param>
            <param name="number"></param>
            <param name="parentMolecule"></param>
        </member>
        <member name="M:NCDK.LibIO.MD.MDMolecule.AddResidue(NCDK.LibIO.MD.Residue)">
            <summary>
            Add a Residue to the MDMolecule if not already present.
            </summary>
            <param name="residue">Residue to add</param>
        </member>
        <member name="M:NCDK.LibIO.MD.MDMolecule.AddChargeGroup(NCDK.LibIO.MD.ChargeGroup)">
            <summary>
            Add a ChargeGroup to the MDMolecule if not already present.
            </summary>
            <param name="chargeGroup"><see cref="T:NCDK.LibIO.MD.ChargeGroup"/> to add</param>
        </member>
        <member name="T:NCDK.LibIO.MD.Residue">
            <summary>
            A residue is a named, numbered collection of atoms in an MDMolecule.
            
            Residues are used to partition molecules in distinct pieces.
            </summary>
        </member>
        <member name="M:NCDK.LibIO.MD.Residue.#ctor">
            <summary>
            Empty constructor
            </summary>
        </member>
        <member name="M:NCDK.LibIO.MD.Residue.#ctor(NCDK.IAtomContainer,System.Int32,NCDK.LibIO.MD.MDMolecule)">
            <summary>
            Constructor to create a Residue based on an AC, a number, and a MDMolecule.
            </summary>
        </member>
        <member name="T:NCDK.Maths.MersenneTwister">
            <summary>
            This class implements a powerful pseudo-random number generator
            developed by Makoto Matsumoto and Takuji Nishimura during
            1996-1997.
            </summary>
            <remarks>
            <para>This generator features an extremely long period
            (2<sup>19937</sup>-1) and 623-dimensional equidistribution up to 32
            bits accuracy. The home page for this generator is located at 
            <see href="http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html">http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html</see>.
            </para>
            <para>
            This generator is described in a paper by Makoto Matsumoto and
            Takuji Nishimura in 1998: <see href="http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/ARTICLES/mt.pdf">Mersenne Twister: A 623-Dimensionally Equidistributed Uniform Pseudo-Random Number Generator</see>, 
            ACM Transactions on Modeling and Computer
            Simulation, Vol. 8, No. 1, January 1998, pp 3--30
            </para>
            <para>
            This class is mainly a Java port of the 2002-01-26 version of
            the generator written in C by Makoto Matsumoto and Takuji
            Nishimura. Here is their original copyright:
            </para>
            <list type="table">
            <item>
            <term>Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura, All rights reserved.</term>
            </item>
            <item>
            <term>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
            <list type="bullet">
              <item>Redistributions of source code must retain the above copyright
                  notice, this list of conditions and the following disclaimer.</item>
              <item>Redistributions in binary form must reproduce the above copyright
                  notice, this list of conditions and the following disclaimer in the
                  documentation and/or other materials provided with the distribution.</item>
              <item>The names of its contributors may not be used to endorse or promote
                  products derived from this software without specific prior written
                  permission.</item>
            </list>
            </term>
            <item><strong>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
            CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
            INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
            MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
            DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
            BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
            OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
            PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
            PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
            OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
            (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
            USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
            DAMAGE.</strong></item></item>
            </list> 
            </remarks>
        </member>
        <member name="F:NCDK.Maths.MersenneTwister.N">
            <summary>Size of the bytes pool. </summary>
        </member>
        <member name="F:NCDK.Maths.MersenneTwister.M">
            <summary>Period second parameter. </summary>
        </member>
        <member name="F:NCDK.Maths.MersenneTwister.MAG01">
            <summary>X * MATRIX_A for X = {0, 1}. </summary>
        </member>
        <member name="F:NCDK.Maths.MersenneTwister.mt">
            <summary>Bytes pool. </summary>
        </member>
        <member name="F:NCDK.Maths.MersenneTwister.mti">
            <summary>Current index in the bytes pool. </summary>
        </member>
        <member name="M:NCDK.Maths.MersenneTwister.#ctor">
            <summary>
            Creates a new random number generator.
            <para>The instance is initialized using the current time plus the system identity hash code of this instance as the seed.</para>
            </summary>
        </member>
        <member name="M:NCDK.Maths.MersenneTwister.#ctor(System.Int32)">
            <summary>
            Creates a new random number generator using a single int seed.
            </summary>
            <param name="seed">the initial seed (32 bits integer)</param>
        </member>
        <member name="M:NCDK.Maths.MersenneTwister.#ctor(System.Int32[])">
            <summary>
            Creates a new random number generator using an int array seed.
            </summary>
            <param name="seed">the initial seed (32 bits integers array), if null the seed of the generator will be related to the current time</param>
        </member>
        <member name="M:NCDK.Maths.MersenneTwister.#ctor(System.Int64)">
            <summary>
            Creates a new random number generator using a single long seed.
            </summary>
            <param name="seed">the initial seed (64 bits integer)</param>
        </member>
        <member name="M:NCDK.Maths.MersenneTwister.SetSeed(System.Int32)">
            <summary>
            Reinitialize the generator as if just built with the given int seed
            <para>The state of the generator is exactly the same as a new generator built with the same seed.</para>
            </summary>
            <param name="seed">the initial seed (32 bits integer)</param>
        </member>
        <member name="M:NCDK.Maths.MersenneTwister.SetSeed(System.Int32[])">
            <summary>
            Reinitialize the generator as if just built with the given int array seed.
            <para>The state of the generator is exactly the same as a new
            generator built with the same seed.</para>
            </summary>
            <param name="seed"> the initial seed (32 bits integers array), if null the seed of the generator will be the current system time plus the system identity hash code of this instance</param>
        </member>
        <member name="M:NCDK.Maths.MersenneTwister.SetSeed(System.Int64)">
            <summary>
            Reinitialize the generator as if just built with the given long seed.
            <para>The state of the generator is exactly the same as a new generator built with the same seed.</para>
            </summary>
            <param name="seed">seed the initial seed (64 bits integer)</param>
        </member>
        <member name="M:NCDK.Maths.MersenneTwister.Next(System.Int32)">
            <summary>
            Generate next pseudorandom number.
            </summary>
            <param name="bits">number of random bits to produce</param>
            <returns>random bits generated</returns>
        </member>
        <member name="T:NCDK.Maths.FortranFormat">
            <summary>
            Converts a string representation of a Fortran double to a double.
            </summary>
            <remarks>
            A modified version of the <c>atof</c> method provided in the Core Java
            books by Cay S. Horstmann &amp; Gary Cornell.  The main difference
            here is that we scan for Fortran double precision characters
            ('D' and 'd') which often cause the C versions of atof to
            barf.
            </remarks>
        </member>
        <member name="M:NCDK.Maths.FortranFormat.Atof(System.String)">
            <summary>
            Converts a string of digits to an double.
            </summary>
            <param name="s">a string denoting a double</param>
        </member>
        <member name="T:NCDK.Maths.Primes">
            <summary>
            </summary>
        </member>
        <member name="M:NCDK.Maths.Primes.GetPrimeAt(System.Int32)">
            <summary>
            Returns the i-th prime number in the sequence of
            all prime numbers below 19700. The first in the sequence
            (n=0) is the prime number 2.
            </summary>
        </member>
        <member name="T:NCDK.Maths.RandomNumbersTool">
            <summary>
            Class supplying useful methods to generate random numbers.
            This class isn't supposed to be instantiated. You should use it by calling
            its static methods.
            </summary>
        </member>
        <member name="P:NCDK.Maths.RandomNumbersTool.Random">
            <summary>
            The instance of Random used by this class.
            </summary>
        </member>
        <member name="P:NCDK.Maths.RandomNumbersTool.RandomSeed">
            <summary>
            The seed being used by this random number generator.
            </summary>
        </member>
        <member name="M:NCDK.Maths.RandomNumbersTool.RandomInt">
            <summary>
             Generates a random integer between '0' and '1'.
            </summary>
            <returns> a random integer between '0' and '1'.</returns>
        </member>
        <member name="M:NCDK.Maths.RandomNumbersTool.RandomInt(System.Int32,System.Int32)">
            <summary>
            Generates a random integer between the specified values.
            </summary>
            <param name="lo">the lower bound for the generated integer.</param>
            <param name="hi">the upper bound for the generated integer.</param>
            <returns>a random integer between <paramref name="lo"/> and <paramref name="hi"/>.</returns>
        </member>
        <member name="M:NCDK.Maths.RandomNumbersTool.RandomLong">
            <summary>
            Generates a random long between '0' and '1'.
            </summary>
            <returns>a random long between '0' and '1'.</returns>
        </member>
        <member name="M:NCDK.Maths.RandomNumbersTool.RandomLong(System.Int64,System.Int64)">
            <summary>
            Generates a random long between the specified values.
            </summary>
            <param name="lo">the lower bound for the generated long.</param>
            <param name="hi">the upper bound for the generated long.</param>
            <returns>a random long between <paramref name="lo"/> and <paramref name="hi"/>.</returns>
        </member>
        <member name="M:NCDK.Maths.RandomNumbersTool.NextLong(NCDK.Maths.BitsStreamGenerator,System.Int64)">
            <summary>
            Access the next long random number between 0 and n.
            </summary>
            <param name="rng">random number generator</param>
            <param name="n">max value</param>
            <returns>a long random number between 0 and n</returns>
            <seealso href="http://stackoverflow.com/questions/2546078/java-random-long-number-in-0-x-n-range">Random Long Number in range, Stack Overflow</seealso >
        </member>
        <member name="M:NCDK.Maths.RandomNumbersTool.RandomFloat">
            <summary>
            Generates a random float between '0' and '1'.
            </summary>
            <returns>a random float between '0' and '1'.</returns>
        </member>
        <member name="M:NCDK.Maths.RandomNumbersTool.RandomFloat(System.Single,System.Single)">
            <summary>
            Generates a random float between the specified values.
            </summary>
            <param name="lo">the lower bound for the generated float.</param>
            <param name="hi">the upper bound for the generated float.</param>
            <returns>a random float between <paramref name="lo"/> and <paramref name="hi"/>.</returns>
        </member>
        <member name="M:NCDK.Maths.RandomNumbersTool.RandomDouble">
            <summary>
            Generates a random double between '0' and '1'.
            </summary>
            <returns>a random double between '0' and '1'.</returns>
        </member>
        <member name="M:NCDK.Maths.RandomNumbersTool.RandomDouble(System.Double,System.Double)">
            <summary>
            Generates a random double between the specified values.
            </summary>
            <param name="lo">the lower bound for the generated double.</param>
            <param name="hi">the upper bound for the generated double.</param>
            <returns>a random double between <paramref name="lo"/> and <paramref name="hi"/>.</returns>
        </member>
        <member name="M:NCDK.Maths.RandomNumbersTool.RandomBoolean">
            <summary>
            Generates a random bool.
            </summary>
            <returns>a random bool.</returns>
        </member>
        <member name="M:NCDK.Maths.RandomNumbersTool.RandomBit">
            <summary>
            Generates a random bit: either '0' or '1'.
            </summary>
            <returns>a random bit.</returns>
        </member>
        <member name="M:NCDK.Maths.RandomNumbersTool.FlipCoin(System.Double)">
            <summary>
            Returns a bool value based on a biased coin toss.
            </summary>
            <param name="p">the probability of success.</param>
            <returns><see langword="true"/> if a success was found; <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:NCDK.Maths.RandomNumbersTool.GaussianFloat(System.Single)">
            <summary>
            Generates a random float from a Gaussian distribution with the specified deviation.
            </summary>
            <param name="dev">the desired deviation.</param>
            <returns>a random float from a Gaussian distribution with deviation <paramref name="dev"/>.</returns>
        </member>
        <member name="M:NCDK.Maths.RandomNumbersTool.GaussianDouble(System.Double)">
            <summary>
            Generates a random double from a Gaussian distribution with the specified deviation.
            </summary>
            <param name="dev">the desired deviation.</param>
            <returns>a random float from a Gaussian distribution with deviation <paramref name="dev"/>.</returns>
        </member>
        <member name="M:NCDK.Maths.RandomNumbersTool.ExponentialDouble(System.Double)">
            <summary>
            Generates a random double from an Exponential distribution with the specified
            mean value.
            </summary>
            <param name="mean">the desired mean value.</param>
            <returns>a random double from an Exponential distribution with mean value <paramref name="mean"/>.</returns>
        </member>
        <member name="T:NCDK.Maths.BitsStreamGenerator">
            <summary>
            Base class for random number generators that generates bits streams.
            </summary>
        </member>
        <member name="F:NCDK.Maths.BitsStreamGenerator.nextGaussian">
            <summary>Next gaussian.</summary>
        </member>
        <member name="M:NCDK.Maths.BitsStreamGenerator.#ctor">
            <summary>Creates a new random number generator.</summary>
        </member>
        <member name="M:NCDK.Maths.BitsStreamGenerator.SetSeed(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Maths.BitsStreamGenerator.SetSeed(System.Int32[])">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Maths.BitsStreamGenerator.SetSeed(System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Maths.BitsStreamGenerator.Next(System.Int32)">
            <summary> 
            Generate next pseudorandom number.
            <para>
            This method is the core generation algorithm. It is used by all the
            public generation methods for the various primitive types 
            <see cref="M:NCDK.Maths.BitsStreamGenerator.NextBool"/>,
            <see cref="M:NCDK.Maths.BitsStreamGenerator.NextBytes(System.Byte[])"/>, 
            <see cref="M:NCDK.Maths.BitsStreamGenerator.NextDouble"/>,
            <see cref="M:NCDK.Maths.BitsStreamGenerator.NextFloat"/>,
            <see cref="M:NCDK.Maths.BitsStreamGenerator.NextGaussian"/>,
            <see cref="M:NCDK.Maths.BitsStreamGenerator.Next"/>,
            <see cref="M:NCDK.Maths.BitsStreamGenerator.NextInt(System.Int32)"/>,
            <see cref="M:NCDK.Maths.BitsStreamGenerator.NextLong"/>
            </para>
            </summary>
            <param name="bits">number of random bits to produce</param>
            <returns>random bits generated</returns>
        </member>
        <member name="M:NCDK.Maths.BitsStreamGenerator.NextBool">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Maths.BitsStreamGenerator.NextBytes(System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Maths.BitsStreamGenerator.NextDouble">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Maths.BitsStreamGenerator.NextFloat">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Maths.BitsStreamGenerator.NextGaussian">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Maths.BitsStreamGenerator.Next">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Maths.BitsStreamGenerator.NextInt(System.Int32)">
            <summary>
            This default implementation is copied from Apache Harmony java.util.Random (r929253).
            </summary>
            <remarks>
            Implementation notes: 
            <list type="bullet">
            <item>If n is a power of 2, this method returns <c>(int) ((n * (long) Next(31)) >> 31)</c>.</item>
            <item>If n is not a power of 2, what is returned is <c>Next(31) % n</c>
            with <c>Next(31)</c> values rejected (i.e. regenerated) until a
            value that is larger than the remainder of <c>int.MaxValue / n</c>
            is generated. Rejection of this initial segment is necessary to ensure
            a uniform distribution.</item>
            </list>
            </remarks>
        </member>
        <member name="M:NCDK.Maths.BitsStreamGenerator.NextLong">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Maths.BitsStreamGenerator.Clear">
            <summary>
            Clears the cache used by the default implementation of <see cref="M:NCDK.Maths.BitsStreamGenerator.NextGaussian"/> 
            </summary>
        </member>
        <member name="T:NCDK.FaulonSignatures.AbstractGraphBuilder">
            <summary>
            Class to reconstruct a graph from a signature string (or a colored tree).
            </summary>
        </member>
        <member name="M:NCDK.FaulonSignatures.AbstractGraphBuilder.MakeGraph">
            <summary>
            Make the initial, empty, graph to be filled. It is up to the
            implementing class to store the graph instance.
            </summary>
        </member>
        <member name="M:NCDK.FaulonSignatures.AbstractGraphBuilder.MakeVertex(System.String)">
            <summary>
            Make a vertex in the graph with label <paramref name="label"/>.
            </summary>
            <param name="label">the string label to use</param>
        </member>
        <member name="M:NCDK.FaulonSignatures.AbstractGraphBuilder.MakeEdge(System.Int32,System.Int32,System.String,System.String,System.String)">
            <summary>
            Make an edge between the two vertices indexed by 
            <paramref name="vertexIndex1"/> and <paramref name="vertexIndex2"/>.
            </summary>
            <param name="vertexIndex1">the index of the first vertex in the graph</param>
            <param name="vertexIndex2">the index of the second vertex in the graph</param>
            <param name="vertexSymbol1"></param>
            <param name="vertexSymbol2"></param>
            <param name="edgeLabel"></param>
        </member>
        <member name="T:NCDK.FaulonSignatures.AbstractGraphSignature">
            <summary>
            A signature for an entire graph.
            </summary>
        </member>
        <member name="F:NCDK.FaulonSignatures.AbstractGraphSignature.separator">
            <summary>
            The separator is printed between vertex signature strings
            </summary>
        </member>
        <member name="F:NCDK.FaulonSignatures.AbstractGraphSignature.height">
            <summary>
            This is the height the signature is created with, which cannot be exceeded.
            </summary>
        </member>
        <member name="M:NCDK.FaulonSignatures.AbstractGraphSignature.#ctor">
            <summary>
            Create a graph signature with a default separator.
            </summary>
        </member>
        <member name="M:NCDK.FaulonSignatures.AbstractGraphSignature.#ctor(System.String)">
            <summary>
            Create a graph signature with the given separator.
            </summary>
            <param name="separator">the separator to use</param>
        </member>
        <member name="M:NCDK.FaulonSignatures.AbstractGraphSignature.#ctor(System.Int32)">
            <summary>
            Create a graph signature with a default separator and the given height.
            </summary>
            <param name="height">the height of the vertex signatures made from this graph.</param>
        </member>
        <member name="M:NCDK.FaulonSignatures.AbstractGraphSignature.#ctor(System.String,System.Int32)">
            <summary>
            Create a graph signature with the given separator and height.
            </summary>
            <param name="separator">the separator to use</param>
            <param name="height">the height of the vertex signatures made from this graph.</param>
        </member>
        <member name="P:NCDK.FaulonSignatures.AbstractGraphSignature.Height">
            <summary>
            The height that the graph signature was created with.
            </summary>
        </member>
        <member name="M:NCDK.FaulonSignatures.AbstractGraphSignature.GetVertexCount">
            <summary>
            Get the vertex count of the graph that this is the signature of.
            </summary>
            <returns>the vertex count</returns>
        </member>
        <member name="M:NCDK.FaulonSignatures.AbstractGraphSignature.SignatureStringForVertex(System.Int32)">
            <summary>
            Return the canonical signature string for the vertex at index 
            <paramref name="vertexIndex"/> in the graph.
            </summary>
            <param name="vertexIndex">the vertex index</param>
            <returns>the canonical signature string for this vertex</returns>
        </member>
        <member name="M:NCDK.FaulonSignatures.AbstractGraphSignature.SignatureStringForVertex(System.Int32,System.Int32)">
            <summary>
            Return the canonical signature string for the vertex at index 
            <paramref name="vertexIndex"/> in the graph with a height of 
            <paramref name="height"/>.
            </summary>
            <param name="vertexIndex">the vertex index</param>
            <param name="height">the maximum height of the signature</param>
            <returns>the signature at the given height for a vertex </returns>
        </member>
        <member name="M:NCDK.FaulonSignatures.AbstractGraphSignature.SignatureForVertex(System.Int32)">
            <summary>
            Generate and return an AbstractVertexSignature rooted at the vertex with index <paramref name="vertexIndex"/>.
            </summary>
            <param name="vertexIndex">the vertex to use</param>
            <returns>an AbstractSignature object</returns>
        </member>
        <member name="M:NCDK.FaulonSignatures.AbstractGraphSignature.ToCanonicalString">
            <summary>
            Run through the vertices of the graph, generating a signature string for
            each vertex, and return the one that is lexicographically minimal.
            </summary>
            <returns>the lexicographically minimal vertex string</returns>
        </member>
        <member name="M:NCDK.FaulonSignatures.AbstractGraphSignature.GetSymmetryClasses">
            <summary>
            For all the vertices in the graph, get the signature string and group the
            resulting list of strings into symmetry classes. All vertices in one
            symmetry class will have the same signature string, and therefore the
            same environment.
            </summary>
            <returns>a list of symmetry classes</returns>
        </member>
        <member name="M:NCDK.FaulonSignatures.AbstractGraphSignature.ToFullString">
            <summary>
            Generate signature strings for each vertex of the graph, and count up
            how many of each there are, printing out a final string concatenated
            together with the separator.
            </summary>
            <returns>a full signature string for this graph</returns>
        </member>
        <member name="M:NCDK.FaulonSignatures.AbstractGraphSignature.GetGraphSignature">
            <summary>
            Use the lexicographically largest (or smallest) as the graph signature
            </summary>
        </member>
        <member name="M:NCDK.FaulonSignatures.AbstractGraphSignature.GetVertexSignatureStrings">
            <summary>
            Create the canonical signature strings for each vertex. They are 
            unsorted, so will be in the same order as the vertices.
            </summary>
            <returns>a list of canonical signature strings</returns>
        </member>
        <member name="M:NCDK.FaulonSignatures.AbstractGraphSignature.GetVertexSignatures">
            <summary>
            Create a list of vertex signatures, one for each vertex.They are 
            unsorted, so will be in the same order as the vertices.
            </summary>
            <returns>a list of vertex signatures</returns>
        </member>
        <member name="M:NCDK.FaulonSignatures.AbstractGraphSignature.IsCanonicallyLabelled">
            <summary>
            Test the the vertices in the graph, to see if the order they are in
            (confusingly called the 'labelling' of the graph) is canonical. The 
            order that is canonical according to this method may not be the same as
            the canonical order from another method.
            </summary>
            <returns>true if the vertices are in a canonical order</returns>
        </member>
        <member name="T:NCDK.FaulonSignatures.AbstractQuotientGraph">
            <summary>
            A quotient graph Q is derived from a simple graph G (or molecule graph) by 
            determining the signature for each vertex in G, and making a vertex in Q
            for each signature. These vertices in Q are then connected to each other -
            or <b>themselves</b> - if vertices in G with those signatures are connected.
            
            Therefore, the quotient graph is a summary of the original graph.
            </summary>
        </member>
        <member name="T:NCDK.FaulonSignatures.AbstractVertexSignature">
            <summary>
            The base class for signatures that are created from a vertex of a graph. A
            concrete derived class will implement the methods (getConnected, 
            GetVertexCount() etc.) that communicate between the graph and the signature.
            </summary>
        </member>
        <member name="F:NCDK.FaulonSignatures.AbstractVertexSignature.height">
            <summary>
            If the signature is considered as a tree, the height is the maximum 
            distance from the root to the leaves. A height of -1 is taken to mean
            the same as the maximum possible height, which is the graph diameter
            </summary>
        </member>
        <member name="F:NCDK.FaulonSignatures.AbstractVertexSignature.vertexCount">
            <summary>
            The number of vertices from the graph that were visited to make the
            signature. This is either the number of vertices in the graph - if the
            height is equal to the graph diameter - or the number of vertices seen up
            to that height
            </summary>
        </member>
        <member name="F:NCDK.FaulonSignatures.AbstractVertexSignature.vertexMapping">
            <summary>
            Mapping between the vertex indices in the original graph and the vertex   
            indices stored in the Nodes. This is necessary for signatures with a
            height less than the graph diameter. It is also the order in which the
            vertices were visited to make the DAG.
            </summary>
        </member>
        <member name="M:NCDK.FaulonSignatures.AbstractVertexSignature.#ctor">
            <summary>
            Create an abstract vertex signature.
            </summary>
        </member>
        <member name="M:NCDK.FaulonSignatures.AbstractVertexSignature.#ctor(NCDK.FaulonSignatures.AbstractVertexSignature.InvariantTypes)">
            <summary>
            Create an abstract vertex signature that uses the given invariant type
            for the initial invariants. 
            </summary>
            <param name="invariantType"></param>
        </member>
        <member name="P:NCDK.FaulonSignatures.AbstractVertexSignature.Height">
            <summary>
            The height of the signature.
            </summary>
        </member>
        <member name="M:NCDK.FaulonSignatures.AbstractVertexSignature.GetOriginalVertexIndex(System.Int32)">
            <summary>
            Look up the original graph vertex that <paramref name="vertexIndex"/> maps to.  
            </summary>
            <param name="vertexIndex">the internal vertex index that </param>
            <returns>the vertex index in the original graph</returns>
        </member>
        <member name="M:NCDK.FaulonSignatures.AbstractVertexSignature.CreateMaximumHeight(System.Int32,System.Int32)">
            <summary>
            This is a kind of constructor that builds the internal representation of
            the signature given the index of the vertex to use as a root.
            </summary>
            <param name="rootVertexIndex">the index in the graph of the root for this signature</param>
            <param name="graphVertexCount">the number of vertices in the graph</param>
        </member>
        <member name="M:NCDK.FaulonSignatures.AbstractVertexSignature.Create(System.Int32,System.Int32,System.Int32)">
            <summary>
            This is a kind of constructor that builds the internal representation of
            the signature given the index of the vertex to use as a root. It also
            takes a maximum height, which limits how many vertices will be visited.
            </summary>
            <param name="rootVertexIndex">the index in the graph of the root for this signature</param>
            <param name="graphVertexCount">the number of vertices in the graph</param>
            <param name="height">the maximum height of the signature</param>
        </member>
        <member name="M:NCDK.FaulonSignatures.AbstractVertexSignature.ToCanonicalString">
            <summary>
            Convert this signature into a canonical signature string.
            </summary>
            <returns>the canonical string form</returns>
        </member>
        <member name="M:NCDK.FaulonSignatures.AbstractVertexSignature.Canonize(System.Int32,System.Text.StringBuilder)">
            <summary>
            Find the minimal signature string by trying all colors.
            </summary>
            <param name="color">the current color to use</param>
            <param name="canonicalVertexSignature">the buffer to fill</param>
        </member>
        <member name="M:NCDK.FaulonSignatures.AbstractVertexSignature.GetCanonicalLabelling(System.Int32)">
            <summary>
            Get a canonical labelling for this signature. Note that a signature that
            does not cover the graph (has a height &lt; graph diameter) will not have
            labels for every vertex. Unlabelled vertices will have a value of -1. To
            handle all cases, the total number of vertices must be passed to the 
            method.
            </summary>
            <param name="totalVertexCount">the number of vertices in the graph</param>
            <returns>the permutation necessary to transform the graph into a canonical form</returns>
        </member>
        <member name="M:NCDK.FaulonSignatures.AbstractVertexSignature.GetVertexCount">
            <summary>
            Get the number of vertices.
            </summary>
            <returns>the number of vertices seen when making the signature, which may
                    be less than the number in the full graph, depending on the height</returns>
        </member>
        <member name="M:NCDK.FaulonSignatures.AbstractVertexSignature.ConvertEdgeLabelToColor(System.String)">
            <summary>
            Convert the edge label (if any) to an integer color, for example the bond
            order in a chemistry implementation.
            </summary>
            <param name="label">the label for an edge</param>
            <returns>an int color</returns>
        </member>
        <member name="M:NCDK.FaulonSignatures.AbstractVertexSignature.GetIntLabel(System.Int32)">
            <summary>
            Get the integer label for a vertex - in chemistry implementations this
            will be the element mass.
            </summary>
            <param name="vertexIndex">the index of the vertex in the input graph</param>
            <returns>an integer label</returns>
        </member>
        <member name="M:NCDK.FaulonSignatures.AbstractVertexSignature.GetVertexSymbol(System.Int32)">
            <summary>
            Get the symbol to use in the output signature string for this vertex of 
            the input graph.
            </summary>
            <param name="vertexIndex">the index of the vertex in the input graph</param>
            <returns>a string symbol</returns>
        </member>
        <member name="M:NCDK.FaulonSignatures.AbstractVertexSignature.GetConnected(System.Int32)">
            <summary>
            Get a list of the indices of the vertices connected to the vertex with 
            the supplied index.
            </summary>
            <param name="vertexIndex">the index of the vertex to use</param>
            <returns>the indices of connected vertices in the input graph</returns>
        </member>
        <member name="M:NCDK.FaulonSignatures.AbstractVertexSignature.GetEdgeLabel(System.Int32,System.Int32)">
            <summary>
            Get the symbol (if any) for the edge between the vertices with these two indices.
            </summary>
            <param name="vertexIndex">the index of one of the vertices in the edge</param>
            <param name="otherVertexIndex">the index of the other vertex in the edge </param>
            <returns>a string symbol for this edge</returns>
        </member>
        <member name="M:NCDK.FaulonSignatures.AbstractVertexSignature.Print(System.Text.StringBuilder,NCDK.FaulonSignatures.DAG.Node,NCDK.FaulonSignatures.DAG.Node,System.Collections.Generic.List{NCDK.FaulonSignatures.DAG.Arc})">
            <summary>
            Recursively print the signature into the buffer.
            </summary>
            <param name="buffer">the string buffer to print into</param>
            <param name="node">the current node of the signature</param>
            <param name="parent">the parent node, or null</param>
            <param name="arcs">the list of already visited arcs</param>
        </member>
        <member name="M:NCDK.FaulonSignatures.AbstractVertexSignature.ToString">
            <summary>
            Convert this vertex signature into a signature string.
            </summary>
        </member>
        <member name="T:NCDK.FaulonSignatures.Chemistry.AtomPermutor">
            <summary>
            Utility class for permuting the atoms of a molecule - mainly for testing.
            </summary>
        </member>
        <member name="M:NCDK.FaulonSignatures.Chemistry.AtomPermutor.#ctor(NCDK.FaulonSignatures.Chemistry.Molecule)">
            <summary>
            Make a permutor for the specified molecule.
            
            <param name="molecule">the molecule to permute</param>
            </summary>
        </member>
        <member name="T:NCDK.FaulonSignatures.Chemistry.Molecule">
            <summary>
            A trivial test molecule class, to show how to implement signatures for chemistry libraries.
            </summary>
        </member>
        <member name="M:NCDK.FaulonSignatures.Chemistry.MoleculeReader.ReadSDFFile(System.String)">
            <summary>
            Read a list of Molecule from SDFile
            </summary>
            <param name="filename">path to SDFile</param>
            <returns>List of Molecules</returns>
        </member>
        <member name="M:NCDK.FaulonSignatures.Chemistry.MoleculeReader.ReadSDFfromStream(System.IO.Stream)">
            <summary>
            Read a list of Molecule from an InputStream, providing SDFile contents
            </summary>
            <param name="stream">InputStream to read from</param>
            <returns>List of Molecules</returns>
        </member>
        <member name="T:NCDK.FaulonSignatures.ColoredTree">
            <summary>
            A signature string is read back in as a colored tree, not a DAG since some 
            of the information in the DAG is lost when printing out. A colored tree can
            be reconstructed into a graph.
            </summary>
        </member>
        <member name="T:NCDK.FaulonSignatures.DAG">
            <summary>
            A directed acyclic graph that is the core data structure of a signature. It
            is the DAG that is canonized by sorting its layers of nodes.
            </summary>
        </member>
        <member name="T:NCDK.FaulonSignatures.DAG.Direction">
            <summary>
            The direction up and down the DAG. UP is from leaves to root.
            </summary>
        </member>
        <member name="T:NCDK.FaulonSignatures.DAG.Node">
            <summary>
            A node of the directed acyclic graph
            </summary>
        </member>
        <member name="F:NCDK.FaulonSignatures.DAG.Node.vertexIndex">
            <summary>
            The index of the vertex in the graph. Note that for signatures that
            cover only part of the graph (with a height less than the diameter)
            this index may have to be mapped to the original index 
            </summary>
        </member>
        <member name="F:NCDK.FaulonSignatures.DAG.Node.parents">
            <summary>
            The parent nodes in the DAG
            </summary>
        </member>
        <member name="F:NCDK.FaulonSignatures.DAG.Node.children">
            <summary>
            The child nodes in the DAG
            </summary>
        </member>
        <member name="F:NCDK.FaulonSignatures.DAG.Node.layer">
            <summary>
            What layer this node is in
            </summary>
        </member>
        <member name="F:NCDK.FaulonSignatures.DAG.Node.edgeColors">
            <summary>
            Labels for the edges between this node and the parent nodes
            </summary>
        </member>
        <member name="F:NCDK.FaulonSignatures.DAG.Node.invariant">
            <summary>
            The final computed invariant, used for sorting children when printing
            </summary>
        </member>
        <member name="M:NCDK.FaulonSignatures.DAG.Node.#ctor(System.Int32,System.Int32)">
            <summary>
            Make a Node that refers to a vertex, in a layer, and with a label.
            </summary>
            <param name="vertexIndex">the graph vertex index</param>
            <param name="layer">the layer of this Node</param>
        </member>
        <member name="T:NCDK.FaulonSignatures.DAG.Arc">
            <summary>
            An arc of the directed acyclic graph.
            </summary>
        </member>
        <member name="T:NCDK.FaulonSignatures.DAG.NodeStringLabelComparator">
            <summary>
            Comparator for nodes based on string labels.
            </summary>
        </member>
        <member name="F:NCDK.FaulonSignatures.DAG.NodeStringLabelComparator.vertexLabels">
            <summary>
            The labels for vertices.
            </summary>
        </member>
        <member name="T:NCDK.FaulonSignatures.DAG.NodeIntegerLabelComparator">
            <summary>
            Comparator for nodes based on int labels.
            </summary>
        </member>
        <member name="F:NCDK.FaulonSignatures.DAG.NodeIntegerLabelComparator.vertexLabels">
            <summary>
            The labels for vertices.
            </summary>
        </member>
        <member name="F:NCDK.FaulonSignatures.DAG.nodeComparator">
            <summary>
            Used to sort nodes, it is public so that the AbstractVertexSignature
            can use it 
            </summary>
        </member>
        <member name="F:NCDK.FaulonSignatures.DAG.layers">
            <summary>
            The layers of the DAG
            </summary>
        </member>
        <member name="F:NCDK.FaulonSignatures.DAG.parentCounts">
            <summary>
            The counts of parents for vertices  
            </summary>
        </member>
        <member name="F:NCDK.FaulonSignatures.DAG.childCounts">
            <summary>
            The counts of children for vertices  
            </summary>
        </member>
        <member name="F:NCDK.FaulonSignatures.DAG.nodes">
            <summary>
            Convenience reference to the nodes of the DAG
            </summary>
        </member>
        <member name="F:NCDK.FaulonSignatures.DAG.vertexCount">
            <summary>
            A convenience record of the number of vertices
            </summary>
        </member>
        <member name="M:NCDK.FaulonSignatures.DAG.#ctor(System.Int32,System.Int32)">
            <summary>
            Create a DAG from a graph, starting at the root vertex.
            </summary>
            <param name="rootVertexIndex">the vertex to start from</param>
            <param name="graphVertexCount">the number of vertices in the original graph</param>
        </member>
        <member name="M:NCDK.FaulonSignatures.DAG.InitializeWithStringLabels(System.String[])">
            <summary>
            Initialize the invariants, assuming that the vertex count for the
            signature is the same as the length of the label array.
            </summary>
        </member>
        <member name="M:NCDK.FaulonSignatures.DAG.MakeNode(System.Int32,System.Int32)">
            <summary>
            Create and return a DAG.Node, while setting some internal references to
            the same data. Does not add the node to a layer.
            </summary>
            <param name="vertexIndex">the index of the vertex in the original graph</param>
            <param name="layer">the index of the layer</param>
            <returns>the new node </returns>
        </member>
        <member name="M:NCDK.FaulonSignatures.DAG.MakeNodeInLayer(System.Int32,System.Int32)">
            <summary>
            Create and return a DAG.Node, while setting some internal references to
            the same data. Note: also adds the node to a layer, creating it if 
            necessary.
            </summary>
            <param name="vertexIndex">the index of the vertex in the original graph</param>
            <param name="layer">the index of the layer</param>
            <returns>the new node</returns>
        </member>
        <member name="M:NCDK.FaulonSignatures.DAG.GetOccurrences">
            <summary>
            Count the occurrences of each vertex index in the final signature string.
            Since duplicate DAG edges are removed, this count will not be the same as
            the simple count of occurrences in the DAG before printing.
            </summary>
            <returns></returns>
        </member>
        <member name="T:NCDK.FaulonSignatures.EdgeColored.EdgeColoredGraph">
            <summary>
            A very simple graph class - the equivalent of a client library class.
            </summary>
        </member>
        <member name="T:NCDK.FaulonSignatures.EdgeColored.EdgeColoredGraphSignature">
            <summary>
            A test implementation of signatures for <see cref="T:NCDK.FaulonSignatures.EdgeColored.EdgeColoredGraph"/>s.
            </summary>
        </member>
        <member name="F:NCDK.FaulonSignatures.Invariants.colors">
            <summary>
            The colors assigned to vertices of the input graph
            </summary>
        </member>
        <member name="F:NCDK.FaulonSignatures.Invariants.nodeInvariants">
            <summary>
            The invariants of the nodes of the DAG
            </summary>
        </member>
        <member name="F:NCDK.FaulonSignatures.Invariants.vertexInvariants">
            <summary>
            The invariants of the vertices of the input graph
            </summary>
        </member>
        <member name="T:NCDK.FaulonSignatures.Permutor">
            <summary>
            General permutation generator, that uses orderly generation by ranking and
            unranking. The basic idea is that all permutations of length N can be ordered
            (lexicographically) like:
            <pre>
            0 [0, 1, 2]
            1 [0, 2, 1]
            2 [1, 0, 2]
            ...
            </pre>
            where the number to the left of each permutation is the <i>rank</i> - really
            just the index in this ordered list. The list is created on demand, by a
            process called <i>unranking</i> where the rank is converted to the 
            permutation that appears at that point in the list.
            
            <para>The algorithms used are from the book "Combinatorial Generation : 
            Algorithms, Generation, and Search" (or C.A.G.E.S.) by D.L. Kreher and D.R.
            Stinson</para>
            </summary>
        </member>
        <member name="F:NCDK.FaulonSignatures.Permutor.currentRank">
            <summary>
            The current rank of the permutation to use 
            </summary>
        </member>
        <member name="F:NCDK.FaulonSignatures.Permutor.maxRank">
            <summary>
            The maximum rank possible, given the size
            </summary>
        </member>
        <member name="F:NCDK.FaulonSignatures.Permutor.size">
            <summary>
            The number of objects to permute
            </summary>
        </member>
        <member name="F:NCDK.FaulonSignatures.Permutor.random">
            <summary>
            For accessing part of the permutation space
            </summary>
        </member>
        <member name="M:NCDK.FaulonSignatures.Permutor.#ctor(System.Int32)">
            <summary>
            Create a permutor that will generate permutations of numbers up to <paramref name="size"/>.
            </summary>
            <param name="size">the size of the permutations to generate</param>
        </member>
        <member name="M:NCDK.FaulonSignatures.Permutor.SetRank(System.Int32)">
            <summary>
            Set the permutation to use, given its rank.
            </summary>
            <param name="rank">the order of the permutation in the list</param>
        </member>
        <member name="M:NCDK.FaulonSignatures.Permutor.SetPermutation(System.Int32[])">
            <summary>
            Set the currently used permutation.
            </summary>
            <param name="permutation">the permutation to use, as an int array</param>
        </member>
        <member name="M:NCDK.FaulonSignatures.Permutor.GetRandomNextPermutation">
            <summary>
            Randomly skip ahead in the list of permutations.
            </summary>
            <returns>a permutation in the range (current, N!)</returns>
        </member>
        <member name="M:NCDK.FaulonSignatures.Permutor.GetNextPermutation">
            <summary>
            Get the next permutation in the list.
            </summary>
            <returns>the next permutation</returns>
        </member>
        <member name="M:NCDK.FaulonSignatures.Permutor.GetCurrentPermutation">
            <summary>
            Get the permutation that is currently being used.
            </summary>
            <returns>the permutation as an int array</returns>
        </member>
        <member name="M:NCDK.FaulonSignatures.Permutor.CalculateMaxRank">
            <summary>
            Calculate the max possible rank for permutations of N numbers.
            </summary>
            <returns>the maximum number of permutations</returns>
        </member>
        <member name="M:NCDK.FaulonSignatures.Permutor.RankPermutationLexicographically(System.Int32[])">
            <summary>
            Convert a permutation (in the form of an int array) into a 'rank' - which
            is just a single number that is the order of the permutation in a lexico-
            graphically ordered list.
            </summary>
            <param name="permutation">the permutation to use</param>
            <returns>the rank as a number</returns>
        </member>
        <member name="M:NCDK.FaulonSignatures.Permutor.UnrankPermutationLexicographically(System.Int32,System.Int32)">
            <summary>
            Performs the opposite to the rank method, producing the permutation that
            has the order <paramref name="rank"/> in the lexicographically ordered list.
            
            As an implementation note, the algorithm assumes that the permutation is
            in the form [1,...N] not the more usual [0,...N-1] for a list of size N.
            This is why there is the final step of 'shifting' the permutation. The
            shift also reduces the numbers by one to make them array indices.
            </summary>
            <param name="rank">the order of the permutation to generate</param>
            <param name="size">the length/size of the permutation</param>
            <returns>a permutation as an int array</returns>
        </member>
        <member name="T:NCDK.FaulonSignatures.Simple.SimpleGraph">
            <summary>
            A very simple graph class - the equivalent of a client library class.
            </summary>
        </member>
        <member name="T:NCDK.FaulonSignatures.Simple.SimpleGraphSignature">
            <summary>
            A test implementation of signatures for <see cref="T:NCDK.FaulonSignatures.Simple.SimpleGraph"/>s.
            </summary>
        </member>
        <member name="T:NCDK.FaulonSignatures.SymmetryClass">
            <summary>
            A collection of vertex indices with the same canonical signature string.
            </summary>
        </member>
        <member name="F:NCDK.FaulonSignatures.SymmetryClass.signatureString">
            <summary>
            The signature string that the vertices all share
            </summary>
        </member>
        <member name="F:NCDK.FaulonSignatures.SymmetryClass.vertexIndices">
            <summary>
            The set of vertex indices that have this signature string
            </summary>
        </member>
        <member name="M:NCDK.FaulonSignatures.SymmetryClass.#ctor(System.String)">
            <summary>
            Make a symmetry class for the signature string <paramref name="signatureString"/>.
            </summary>
            <param name="signatureString">the signature string for this symmetry class</param>
        </member>
        <member name="M:NCDK.FaulonSignatures.SymmetryClass.HasSignature(System.String)">
            <summary>
            Check that the symmetry class' string is the same as the supplied string.
            </summary>
            <param name="otherSignatureString">the string to check</param>
            <returns>true if the strings are equal</returns>
        </member>
        <member name="M:NCDK.FaulonSignatures.SymmetryClass.AddIndex(System.Int32)">
            <summary>
            Add a vertex index to the list.
            </summary>
            <param name="vertexIndex">the vertex index to add</param>
        </member>
        <member name="M:NCDK.FaulonSignatures.SymmetryClass.GetMinimal(System.Int32,System.Collections.Generic.List{System.Int32})">
            <summary>
            If the vertex indexed by <paramref name="vertexIndex"/> is in the symmetry 
            class then return the smaller of it and the lowest element. If it is not
            in the symmetry class, return -1.
            </summary>
            <param name="vertexIndex"></param>
            <param name="used"></param>
            <returns></returns>
        </member>
        <member name="M:NCDK.FaulonSignatures.SymmetryClass.CompareTo(NCDK.FaulonSignatures.SymmetryClass)">
            <seealso cref="M:System.IComparable.CompareTo(System.Object)"/>
        </member>
        <member name="T:NCDK.FaulonSignatures.VirtualGraphBuilder">
            <summary>
            Only intended for use in creating 'virtual' graphs for checking canonicity.
            </summary>
        </member>
        <member name="T:NCDK.Hash.BasicAtomEncoder">
            <summary>
            Enumeration of atom encoders for seeding atomic hash codes. Generally these
            encoders return the direct value or a prime number if that value is null.
            These encoders are considered <i>basic</i> as the values generated are all in
            the same range. Better encoding can be achieved by assigning discrete values
            a section of the prime number table. However, In practice using a
            pseudorandom number generator to distribute the encoded values provides a
            good distribution.
            </summary>
            <seealso href="http://www.bigprimes.net/archive/prime/">Prime numbers archive</seealso>
            <seealso cref="T:NCDK.Hash.ConjugatedAtomEncoder"/>
        </member>
        <member name="T:NCDK.Hash.BasicAtomEncoder.O">
            <summary>
            The <see cref="P:NCDK.Hash.BasicAtomEncoder.Ordinal"/> values of <see cref="T:NCDK.Hash.BasicAtomEncoder"/>.
            </summary>
            <seealso cref="T:NCDK.Hash.BasicAtomEncoder"/>
        </member>
        <member name="P:NCDK.Hash.BasicAtomEncoder.Ordinal">
            <summary>
            The ordinal of this enumeration constant. The list is in <see cref="T:NCDK.Hash.BasicAtomEncoder.O"/>.
            </summary>
            <seealso cref="T:NCDK.Hash.BasicAtomEncoder.O"/>
        </member>
        <member name="M:NCDK.Hash.BasicAtomEncoder.ToString">
            <inheritdoc/>
        </member>
        <member name="F:NCDK.Hash.BasicAtomEncoder.AtomicNumber">
            <summary>
            Encode the atomic number of an atom.
            </summary>
        </member>
        <member name="F:NCDK.Hash.BasicAtomEncoder.MassNumber">
            <summary>
            Encode the mass number of an atom, allowing distinction of isotopes.
            </summary>
        </member>
        <member name="F:NCDK.Hash.BasicAtomEncoder.FormalCharge">
            <summary>
            Encode the formal charge of an atom, allowing distinction of different protonation states.
            </summary>
        </member>
        <member name="F:NCDK.Hash.BasicAtomEncoder.NConnectedAtoms">
            <summary>
            Encode the number of explicitly connected atoms (degree).
            </summary>
        </member>
        <member name="F:NCDK.Hash.BasicAtomEncoder.BondOrderSum">
            <summary>
            Encode the explicit bond order sum of an atom.
            </summary>
        </member>
        <member name="F:NCDK.Hash.BasicAtomEncoder.OrbitalHybridization">
            <summary>
            Encode the orbital hybridization of an atom.
            </summary>
        </member>
        <member name="M:NCDK.Hash.BasicAtomEncoder.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Hash.BasicAtomEncoder.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Hash.BasicAtomEncoder.CompareTo(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Hash.BasicAtomEncoder.CompareTo(NCDK.Hash.BasicAtomEncoder)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Hash.IAtomHashGenerator.Generate(NCDK.IAtomContainer)">
            <summary>
            Generate invariant 64-bit hash codes for the atoms of the molecule.
            </summary>
            <param name="container">a molecule</param>
            <returns>atomic hash codes</returns>
        </member>
        <member name="T:NCDK.Hash.AbstractAtomHashGenerator">
            <summary>
            Defines an internal super-class for AtomHashGenerators. The single required
            method allows atom hash generators to either ignore 'suppressed' atoms or use
            the information.
            </summary>
        </member>
        <member name="F:NCDK.Hash.AbstractAtomHashGenerator.EmptyBitSet">
            <summary>
            Empty BitArray for use when the 'suppressed' atoms are ignored.
            </summary>
        </member>
        <member name="M:NCDK.Hash.AbstractAtomHashGenerator.Generate(System.Int64[],NCDK.Hash.Stereo.IStereoEncoder,System.Int32[][],NCDK.Hash.Suppressed)">
            <summary>
            Internal method invoked by 'molecule' hash generators.
            </summary>
            <param name="current">the current invariants</param>
            <param name="encoder">encoder used for encoding stereo-chemistry</param>
            <param name="graph">adjacency list representation of the molecule</param>
            <param name="suppressed">bit set marks vertices which are 'suppressed' (may be ignored)</param>
            <returns>the atom hash values</returns>
        </member>
        <member name="T:NCDK.Hash.AbstractHashGenerator">
            <summary>
            An abstract hash function providing several utility methods to be used by
            other hashing functions.
            </summary>
        </member>
        <member name="M:NCDK.Hash.AbstractHashGenerator.#ctor(NCDK.Hash.Pseudorandom)">
            <summary>
            Construct an abstract hash function providing the pseudorandom number
            generator.
            </summary>
            <param name="pseudorandom">a pseudorandom number generator</param>
            <exception cref="T:System.ArgumentNullException">the pseudorandom number generator was null</exception>
        </member>
        <member name="M:NCDK.Hash.AbstractHashGenerator.Copy(System.Int64[])">
            <summary>
            Create a copy of the array of long values.
            </summary>
            <param name="src">original values</param>
            <returns>copy of the original values</returns>
            <seealso cref="M:System.Array.Copy(System.Array,System.Array,System.Int32)"/>
        </member>
        <member name="M:NCDK.Hash.AbstractHashGenerator.Copy(System.Int64[],System.Int64[])">
            <summary>
            Copy the values from the source (src) array to the destination (dest).
            </summary>
            <param name="src">source values</param>
            <param name="dest">destination of the source copy</param>
            <seealso cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)"/>
        </member>
        <member name="M:NCDK.Hash.AbstractHashGenerator.Rotate(System.Int64)">
            <summary>
            Generate the next random number.
            </summary>
            <param name="seed">a <see cref="T:System.Int64"/> value to seed a pseudorandom number generator</param>
            <returns>next pseudorandom number</returns>
        </member>
        <member name="M:NCDK.Hash.AbstractHashGenerator.Rotate(System.Int64,System.Int32)">
            <summary>
            Rotate a <paramref name="value"/>, <paramref name="n"/> times. The rotation uses a pseudorandom
            number generator to sequentially generate values seed on the previous
            value.
            </summary>
            <param name="value">the <see cref="T:System.Int64"/> value to rotate</param>
            <param name="n">the number of times to rotate the value</param>
            <returns>the <see cref="T:System.Int64"/> value rotated the specified number of times</returns>
        </member>
        <member name="M:NCDK.Hash.AbstractHashGenerator.LowestThreeBits(System.Int64)">
            <summary>
            Returns the value of the lowest three bits. This value is between 0 and 7
            inclusive.
            </summary>
            <param name="value">a <see cref="T:System.Int64"/> value</param>
            <returns>the <see cref="T:System.Int32"/> value of the lowest three bits.</returns>
        </member>
        <member name="M:NCDK.Hash.AbstractHashGenerator.Distribute(System.Int64)">
            <summary>
            Distribute the provided value across the set of <see cref="T:System.Int64"/> values.
            </summary>
            <param name="value">a <see cref="T:System.Int64"/> value to distribute</param>
            <returns>the <see cref="T:System.Int64"/> value distributed a set amount</returns>
        </member>
        <member name="M:NCDK.Hash.AbstractHashGenerator.ToAdjList(NCDK.IAtomContainer)">
            <summary>
            Convert an IAtomContainer to an adjacency list.
            </summary>
            <param name="container">the container to convert</param>
            <returns>adjacency list representation</returns>
        </member>
        <member name="T:NCDK.Hash.AllEquivalentCyclicSet">
            <summary>
            Finds the set of equivalent values are members of a ring. This class is
            intended to drive the systematic perturbation of the <see cref="T:NCDK.Hash.PerturbedAtomHashGenerator"/> 
            . This <see cref="T:NCDK.Hash.EquivalentSetFinder"/> provides the highest probability of avoid collisions due
            to uniform atom environments but is much more demanding then the simpler
            <see cref="T:NCDK.Hash.MinimumEquivalentCyclicSet"/>.
            </summary>
            <example>
            The easiest way to use this class is with the <see cref="T:NCDK.Hash.HashGeneratorMaker"/>.
            <code>
            MoleculeHashGenerator generator =
              new HashGeneratorMaker().Depth(6)
                                      .Elemental()
                                      .PerturbWith(new AllEquivalentCyclicSet())
                                      .Molecular();
            </code></example>
            <seealso cref="T:NCDK.Hash.MinimumEquivalentCyclicSet"/>
            <seealso cref="T:NCDK.Hash.MinimumEquivalentCyclicSetUnion"/>
        </member>
        <member name="T:NCDK.Hash.AtomSuppression">
            <summary>
            Defines a method of suppressing certain atoms from an <see cref="T:NCDK.IAtomContainer"/>
            when computing the hash codes for the molecule or its atoms.
            </summary>
        </member>
        <member name="M:NCDK.Hash.AtomSuppression.Suppress(NCDK.IAtomContainer)">
            <summary>
            Returns a new instance indicating which atoms are suppressed for this
            suppression method.
            </summary>
            <param name="container">molecule with 0 or more atoms</param>
            <returns>the vertices (atom index) which should be suppressed</returns>
        </member>
        <member name="T:NCDK.Hash.AtomSuppression.UnsuppressedAtomSuppression">
            <summary>Default implementation - don't suppress anything.</summary>
        </member>
        <member name="T:NCDK.Hash.AtomSuppression.AnyHydrogensAtomSuppression">
            <summary>
            Suppresses any explicit hydrogen regardless of whether the atom is a
            hydrogen ion or isotope.
            </summary>
        </member>
        <member name="T:NCDK.Hash.AtomSuppression.AnyPseudosAtomSuppression">
            <summary>Suppresses any pseudo atom.</summary>
        </member>
        <member name="P:NCDK.Hash.AtomSuppression.Unsuppressed">
            <summary>
            A suppression which wont' suppress anything.
            Do not suppress any atoms.
            </summary>
        </member>
        <member name="P:NCDK.Hash.AtomSuppression.AnyHydrogens">
            <summary>
            A a suppression which will mark 'all' explicit hydrogens.
            Suppress all hydrogens even if they are charged or an isotope.
            </summary>
        </member>
        <member name="F:NCDK.Hash.AtomSuppression.AnyPseudos">
            <summary>
            A suppression which will mark 'all' pseudo atoms.
            Suppress all pseudo atoms regardless of what their label is.
            </summary>
        </member>
        <member name="T:NCDK.Hash.BasicAtomHashGenerator">
             <summary>
             A generator for basic atom hash codes. This implementation is based on the description by <token>cdk-cite-Ihlenfeldt93</token>.
             The hash codes use an initial combined over a series of cycles up to a specified depth. At each cycle the
             hash values of adjacent invariants are incorporated.
             </summary>
             <remarks>
             Which depth should I use?
             <para>The <i>depth</i> determines the number of
             cycles and thus how <i>deep</i> the hashing is, larger values discriminate
             more molecules but can take longer to compute. The original publication
             recommends a depth of 32 however values as low as 6 can yield good results.
             The actual depth required is related to the <i>diameter</i> of the chemical
             graph. The <i>diameter</i> is the longest shortest path, that is, the
             furthest distance one must travel between any two vertex. Unfortunately the
             time complexity of finding the longest shortest path in an undirected graph
             is O(n<sup>2</sup>) which is larger then the time required for this hash
             function. Depending on the types of molecules in your data set the depth
             should be adjusted accordingly. For example, a library of large-lipids would
             require deeper hashing to discriminate differences in chain length.
             </para> 
             </remarks>
             <example>
             Usage
             <code>
             SeedGenerator     seeding   = ...
             AtomHashGenerator generator = new BasicAtomHashGenerator(seeding, new Xorshift(), 32);
            
             IAtomContainer benzene = MoleculeFactory.Benzene();
             long[]         hashes  = generator.Generate(benzene);
             </code>
             </example>
             <seealso href="http://mathworld.wolfram.com/GraphDiameter.html">Graph Diameter</seealso>
             <seealso href="http://onlinelibrary.wiley.com/doi/10.1002/jcc.540150802/abstract">Wolf Dietrich Ihlenfeldt, Johann Gasteiger</seealso>
             <seealso cref="T:NCDK.Hash.SeedGenerator"/>
        </member>
        <member name="M:NCDK.Hash.BasicAtomHashGenerator.#ctor(NCDK.Hash.IAtomHashGenerator,NCDK.Hash.Pseudorandom,NCDK.Hash.Stereo.IStereoEncoderFactory,System.Int32)">
            <summary>
            Create a basic hash generator using the provided seed generator to
            initialise atom invariants and using the provided stereo factory.
            </summary>
            <param name="seedGenerator">generator to seed the initial values of atoms</param>
            <param name="pseudorandom">pseudorandom number generator used to randomise hash distribution</param>
            <param name="factory">a stereo encoder factory</param>
            <param name="depth">depth of the hashing function, larger values take longer</param>
            <exception cref="T:System.ArgumentException">depth was less then 0</exception>
            <exception cref="T:System.ArgumentNullException">    seed generator or pseudo random was null</exception>
            <seealso cref="T:NCDK.Hash.SeedGenerator"/>
        </member>
        <member name="M:NCDK.Hash.BasicAtomHashGenerator.#ctor(NCDK.Hash.IAtomHashGenerator,NCDK.Hash.Pseudorandom,System.Int32)">
            <summary>
            Create a basic hash generator using the provided seed generator to
            initialise atom invariants and no stereo configuration.
            </summary>
            <param name="seedGenerator">generator to seed the initial values of atoms</param>
            <param name="pseudorandom">pseudorandom number generator used to randomise hash distribution</param>
            <param name="depth">depth of the hashing function, larger values take longer</param>
            <exception cref="T:System.ArgumentException">depth was less then 0</exception>
            <exception cref="T:System.ArgumentNullException">    seed generator or pseudo random was null</exception>
            <seealso cref="T:NCDK.Hash.SeedGenerator"/>
        </member>
        <member name="M:NCDK.Hash.BasicAtomHashGenerator.Generate(System.Int64[],NCDK.Hash.Stereo.IStereoEncoder,System.Int32[][],NCDK.Hash.Suppressed)">
            <summary>
            Package-private method for generating the hash for the given molecule.
            The initial invariants are passed as to the method along with an
            adjacency list representation of the graph.
            </summary>
            <param name="current">initial invariants</param>
            <param name="encoder"></param>
            <param name="graph">adjacency list representation</param>
            <param name="suppressed"></param>
            <returns>hash codes for atoms</returns>
        </member>
        <member name="M:NCDK.Hash.BasicAtomHashGenerator.Next(System.Int32[][],System.Int32,System.Int64[],System.Int64[],System.Int64[])">
            <summary>
            Determine the next value of the atom at index <paramref name="v"/>. The value is
            calculated by combining the current values of adjacent atoms. When a
            duplicate value is found it can not be directly included and is
            <i>rotated</i> the number of times it has previously been seen.
            </summary>
            <param name="graph">adjacency list representation of connected atoms</param>
            <param name="v">the atom to calculate the next value for</param>
            <param name="current">the current values</param>
            <param name="unique">buffer for working out which adjacent values are unique</param>
            <param name="included">buffer for storing the rotated <paramref name="unique"/> value, this value is <i>rotated</i> each time the same value is found.</param>
            <returns>the next value for <paramref name="v"/></returns>
        </member>
        <member name="T:NCDK.Hash.BasicMoleculeHashGenerator">
             <summary>
             A generator for basic molecule hash codes <token>cdk-cite-Ihlenfeldt93</token>. The
             provided <see cref="T:NCDK.Hash.IAtomHashGenerator"/> is used to produce individual atom hash
             codes. These are then combined together in an order independent manner to
             generate a single hash code for the molecule.
             </summary>
             <example><code>
             AtomHashGenerator     atomGenerator = ...;
             MoleculeHashGenerator generator     = new BasicMoleculeHashGenerator(atomGenerator)
            
             IAtomContainer benzene  = MoleculeFactory.MakeBenzene();
             long           hashCode = generator.Generate(benzene);
             </code></example>
             <seealso cref="T:NCDK.Hash.IAtomHashGenerator"/>
             <seealso cref="T:NCDK.Hash.BasicAtomHashGenerator"/>
        </member>
        <member name="M:NCDK.Hash.BasicMoleculeHashGenerator.#ctor(NCDK.Hash.IAtomHashGenerator)">
            <summary>
            Create a new molecule hash using the provided atom hash generator.
            </summary>
            <param name="generator">a generator for atom hash codes</param>
            <exception cref="T:System.ArgumentNullException">no generator provided</exception>
        </member>
        <member name="M:NCDK.Hash.BasicMoleculeHashGenerator.#ctor(NCDK.Hash.IAtomHashGenerator,NCDK.Hash.Pseudorandom)">
            <summary>
            Create a new molecule hash using the provided atom hash generator and
            pseudorandom number generator.
            </summary>
            <param name="generator">a generator for atom hash codes</param>
            <param name="pseudorandom">pseudorandom number generator</param>
            <exception cref="T:System.ArgumentNullException">no atom hash generator or pseudorandom number generator provided</exception>
        </member>
        <member name="T:NCDK.Hash.ConjugatedAtomEncoder">
             <summary>
             An atom encoder which takes several atom encodes and combines the encodings
             into a single encoder. The order of the encoders matter and for persistent
             results should be ordered before construction.
             </summary>
             <example><code>
             // import org.openscience.cdk.hash.seed.BasicAtomEncoder.*
             AtomEncoder encoder = new ConjugatedAtomEncoder(Arrays.asList(ATOMIC_NUMBER, FORMAL_CHARGE));
            
             // convenience constructor using var-args
             AtomEncoder encoder = ConjugatedAtomEncoder.Create(ATOMIC_NUMBER, FORMAL_CHARGE);
            
             // specifying a custom encoder
             AtomEncoder encoder =
               ConjugatedAtomEncoder.Create(ATOMIC_NUMBER, FORMAL_CHARGE,
                                            new AtomEncoder(){
                                              public int Encode(IAtom a, IAtomContainer c){
                                                return a.Symbol.HashCode();
                                              }
                                            });
             </code></example>
        </member>
        <member name="M:NCDK.Hash.ConjugatedAtomEncoder.#ctor(System.Collections.Generic.IList{NCDK.Hash.IAtomEncoder})">
            <summary>
            Create a new conjugated encoder for the specified list of atom encoders.
            The encoders are combined in an order dependant manner.
            </summary>
            <param name="encoders">non-empty list of encoders</param>
            <exception cref="T:System.ArgumentNullException">the list of encoders was null</exception>
            <exception cref="T:System.ArgumentException">the list of encoders was empty</exception>
        </member>
        <member name="M:NCDK.Hash.ConjugatedAtomEncoder.Create(NCDK.Hash.IAtomEncoder,NCDK.Hash.IAtomEncoder[])">
            <summary>
            Convenience method for creating a conjugated encoder from one or more
            <see cref="T:NCDK.Hash.IAtomEncoder"/>s.
            </summary>
            <example><code>
            // import org.openscience.cdk.hash.seed.BasicAtomEncoder.*
            AtomEncoder encoder = ConjugatedAtomEncoder.Create(ATOMIC_NUMBER, FORMAL_CHARGE);
            </code></example>
            <param name="encoder">the first encoder</param>
            <param name="encoders">the other encoders</param>
            <returns>a new conjugated encoder</returns>
            <exception cref="T:System.ArgumentNullException">either argument was null</exception>
        </member>
        <member name="T:NCDK.Hash.EquivalentSetFinder">
            <summary>
            Describes a function which identifies a set of equivalent atoms base on the
            provided invariants. Given some other pre-conditions this set is filtered
            down and an array of length 0 to n is returned. It is important to note that
            the atoms may not actually be equivalent and are only equivalent by the
            provided invariants. An example of a pre-condition could be that we only
            return the vertices which are present in rings (cyclic). This condition
            removes all terminal atoms which although equivalent are not relevant.
            </summary>
        </member>
        <member name="M:NCDK.Hash.EquivalentSetFinder.Find(System.Int64[],NCDK.IAtomContainer,System.Int32[][])">
            <summary>
            Find a set of equivalent vertices (atoms) and return this set as an array of indices.
            </summary>
            <param name="invariants">the values for each vertex</param>
            <param name="container">the molecule which which the graph is based on</param>
            <param name="graph">adjacency list representation of the graph</param>
            <returns>set of equivalent vertices</returns>
        </member>
        <member name="T:NCDK.Hash.HashGeneratorMaker">
            <summary>
            Fluent API for creating hash generators. The maker is first configured with
            one or more attributes. Once fully configured the generator is made by
            invoking <see cref="M:NCDK.Hash.HashGeneratorMaker.Atomic" />, <see cref="M:NCDK.Hash.HashGeneratorMaker.Molecular" /> or <see cref="M:NCDK.Hash.HashGeneratorMaker.Ensemble" />. The
            order of the built-in configuration methods does not matter however when
            specifying custom encoders with <see cref="M:NCDK.Hash.HashGeneratorMaker.Encode(NCDK.Hash.IAtomEncoder)" />  the order they
            are added is the order they will be used. Therefore one can expect different
            hash codes if there is a change in the order they are specified.
            </summary>
            <example>
            <code>            // simple
            IMoleculeHashGenerator generator0 = new HashGeneratorMaker().Depth(16)
                                                                       .Elemental()
                                                                       .Molecular();

            // fast
            IMoleculeHashGenerator generator1 = new HashGeneratorMaker().Depth(8)
                                                                       .Elemental()
                                                                       .Isotopic()
                                                                       .Charged()
                                                                       .Orbital()
                                                                       .Molecular();
            // comprehensive
            IMoleculeHashGenerator generator2 = new HashGeneratorMaker().Depth(32)
                                                                       .Elemental()
                                                                       .Isotopic()
                                                                       .Charged()
                                                                       .Chiral()
                                                                       .Perturbed()
                                                                       .Molecular();
</code>
            </example>
        </member>
        <member name="M:NCDK.Hash.HashGeneratorMaker.Depth(System.Int32)">
            <summary>
            Specify the depth of the hash generator. Larger values discriminate more
            molecules.
            </summary>
            <param name="depth">how deep should the generator hash</param>
            <returns>reference for fluent API</returns>
            <exception cref="T:System.ArgumentException">if the depth was less then zero</exception>
        </member>
        <member name="M:NCDK.Hash.HashGeneratorMaker.Elemental">
             <summary>
             Discriminate elements.
            
             <returns>fluent API reference (self)</returns>
             <seealso cref="F:NCDK.Hash.BasicAtomEncoder.AtomicNumber"/>
             </summary>
        </member>
        <member name="M:NCDK.Hash.HashGeneratorMaker.Isotopic">
             <summary>
             Discriminate isotopes.
            
             <returns>fluent API reference (self)</returns>
             <seealso cref="F:NCDK.Hash.BasicAtomEncoder.MassNumber"/>
             </summary>
        </member>
        <member name="M:NCDK.Hash.HashGeneratorMaker.Charged">
            <summary>
            Discriminate protonation states.
            </summary>
            <returns>fluent API reference (self)</returns>
            <seealso cref="F:NCDK.Hash.BasicAtomEncoder.FormalCharge"/>
        </member>
        <member name="M:NCDK.Hash.HashGeneratorMaker.Orbital">
            <summary>
            Discriminate atomic orbitals.
            </summary>
            <returns>fluent API reference (self)</returns>
            <seealso cref="F:NCDK.Hash.BasicAtomEncoder.OrbitalHybridization"/>
        </member>
        <member name="M:NCDK.Hash.HashGeneratorMaker.Radical">
            <summary>
            Discriminate free radicals.
            </summary>
            <returns>fluent API reference (self)</returns>
            <seealso cref="F:NCDK.Hash.BasicAtomEncoder.FreeRadicals"/>
        </member>
        <member name="M:NCDK.Hash.HashGeneratorMaker.Chiral">
            <summary>
            Generate different hash codes for stereoisomers. The currently supported
            geometries are:
            <list type="bullet">
                <item>Tetrahedral</item>
                <item>Double Bond</item>
                <item>Cumulative Double Bonds</item>
            </list> 
            </summary>
            <returns>fluent API reference (self)</returns>
        </member>
        <member name="M:NCDK.Hash.HashGeneratorMaker.SuppressHydrogens">
            <summary>
            Suppress any explicit hydrogens in the encoding of hash values. The
            generation of hashes acts as though the hydrogens are not present and as
            such preserves stereo-encoding.
            </summary>
            <returns>fluent API reference (self)</returns>
        </member>
        <member name="M:NCDK.Hash.HashGeneratorMaker.Perturbed">
            <summary>
            Discriminate atoms experiencing uniform environments. This method uses
            <see cref="T:NCDK.Hash.MinimumEquivalentCyclicSet"/>  to break symmetry but depending on
            application one may need a more comprehensive method. Please refer to
            <see cref="M:NCDK.Hash.HashGeneratorMaker.PerturbWith(NCDK.Hash.EquivalentSetFinder)"/> for further configuration
            details.
            </summary>
            <returns>fluent API reference (self)</returns>
            <seealso cref="T:NCDK.Hash.MinimumEquivalentCyclicSet"/>
            <seealso cref="M:NCDK.Hash.HashGeneratorMaker.PerturbWith(NCDK.Hash.EquivalentSetFinder)"/>
        </member>
        <member name="M:NCDK.Hash.HashGeneratorMaker.PerturbWith(NCDK.Hash.EquivalentSetFinder)">
             <summary>
             Discriminate atoms experiencing uniform environments using the provided
             method. Depending on the level of identity required one can choose how
             the atoms a perturbed in an attempt to break symmetry.  As with all
             hashing there is always a probability of collision but some of these
             collisions may be due to an insufficiency in the algorithm opposed to a
             random chance of collision. Currently there are three strategies but one
             should choose either to use the fast, but good, heuristic <see cref="T:NCDK.Hash.MinimumEquivalentCyclicSet"/> 
             or the exact <see cref="T:NCDK.Hash.AllEquivalentCyclicSet"/>.
             In practice <see cref="T:NCDK.Hash.MinimumEquivalentCyclicSet"/> is good enough for most
             applications but it is important to understand the potential trade off.
             The <see cref="T:NCDK.Hash.MinimumEquivalentCyclicSetUnion"/> is provided for demonstration
             only, and as such, is deprecated.
            
             <list type="bullet">
             <item>MinimumEquivalentCyclicSet - fastest, attempt to break symmetry
             by changing a single smallest set of the equivalent atoms which occur in
             a ring</item> 
             <item><strike>MinimumEquivalentCyclicSetUnion</strike>
             (deprecated) - distinguishes more molecules by changing all smallest sets
             of the equivalent atoms which occur in a ring. This method is provided
             from example only</item> 
             <item>AllEquivalentCyclicSet - slowest,
             systematically perturb all equivalent atoms that occur in a ring</item>
             </list>
            
             At the time of writing (Feb, 2013) the number of known false possibles
             found in PubChem-Compound (aprx. 46,000,000 structures) are as follows:
             <list type="bullet">
             <item>MinimumEquivalentCyclicSet - 128 molecules, 64 false positives (128/2)</item>
             <item>MinimumEquivalentCyclicSetUnion - 8 molecules, 4 false positives (8/2)</item>
             <item>AllEquivalentCyclicSet - 0 molecules</item>
             </list>
             </summary>
             <param name="equivSetFinder">equivalent set finder, used to determine which atoms will be perturbed to try and break symmetry.</param>
             <returns>fluent API reference (self)</returns>
             <seealso cref="T:NCDK.Hash.AllEquivalentCyclicSet"/>
             <seealso cref="T:NCDK.Hash.MinimumEquivalentCyclicSet"/>
             <seealso cref="T:NCDK.Hash.MinimumEquivalentCyclicSetUnion"/>
        </member>
        <member name="M:NCDK.Hash.HashGeneratorMaker.Encode(NCDK.Hash.IAtomEncoder)">
            <summary>
            Add a custom encoder to the hash generator which will be built. Although
            not enforced, the encoder should be stateless and should not modify any
            passed inputs.
            </summary>
            <param name="encoder">an atom encoder</param>
            <returns>fluent API reference (self)</returns>
            <exception cref="T:System.NullReferenceException">no encoder provided</exception>
        </member>
        <member name="M:NCDK.Hash.HashGeneratorMaker.MakeStereoEncoderFactory">
            <summary>
            Combines the separate stereo encoder factories into a single factory.
            </summary>
            <returns>a single stereo encoder factory</returns>
        </member>
        <member name="M:NCDK.Hash.HashGeneratorMaker.Ensemble">
            <summary>
            Given the current configuration create an <see cref="T:NCDK.Hash.EnsembleHashGenerator"/>.
            </summary>
            <returns>instance of the generator</returns>
            <exception cref="T:System.ArgumentException">no depth or encoders were configured</exception>
        </member>
        <member name="M:NCDK.Hash.HashGeneratorMaker.Molecular">
            <summary>
            Given the current configuration create an <see cref="T:NCDK.Hash.IMoleculeHashGenerator"/>.
            </summary>
            <returns>instance of the generator</returns>
            <exception cref="T:System.ArgumentException">no depth or encoders were configured</exception>
        </member>
        <member name="M:NCDK.Hash.HashGeneratorMaker.Atomic">
            <summary>
            Given the current configuration create an <see cref="T:NCDK.Hash.IAtomHashGenerator"/>.
            </summary>
            <returns>instance of the generator</returns>
            <exception cref="T:System.ArgumentException">no depth or encoders were configured</exception>
        </member>
        <member name="T:NCDK.Hash.HashGeneratorMaker.ConjugatedEncoderFactory">
            <summary>
            Help class to combined two stereo encoder factories
            </summary>
        </member>
        <member name="M:NCDK.Hash.HashGeneratorMaker.ConjugatedEncoderFactory.#ctor(NCDK.Hash.Stereo.IStereoEncoderFactory,NCDK.Hash.Stereo.IStereoEncoderFactory)">
             <summary>
             Create a new conjugated encoder factory from the left and right
             factories.
            
             <param name="left">encoder factory</param>
             <param name="right">encoder factory</param>
             </summary>
        </member>
        <member name="T:NCDK.Hash.HashGeneratorMaker.ConjugatedEncoder">
            <summary>
            Help class to combined two stereo encoders
            </summary>
        </member>
        <member name="M:NCDK.Hash.HashGeneratorMaker.ConjugatedEncoder.#ctor(NCDK.Hash.Stereo.IStereoEncoder,NCDK.Hash.Stereo.IStereoEncoder)">
             <summary>
             Create a new conjugated encoder from a left and right encoder.
            
             <param name="left">encoder</param>
             <param name="right">encoder</param>
             </summary>
        </member>
        <member name="M:NCDK.Hash.HashGeneratorMaker.ConjugatedEncoder.Encode(System.Int64[],System.Int64[])">
            <summary>
            Encodes using the left and then the right encoder.
            </summary>
            <param name="current">current invariants</param>
            <param name="next">next invariants</param>
            <returns>whether either encoder modified any values</returns>
        </member>
        <member name="M:NCDK.Hash.HashGeneratorMaker.ConjugatedEncoder.Reset">
            <summary>
            reset the left and right encoders
            </summary>
        </member>
        <member name="T:NCDK.Hash.MinimumEquivalentCyclicSet">
             <summary>
             Finds the smallest set of equivalent values are members of a ring. If there
             are multiple smallest sets then the set with the lowest invariant value is
             returned. This class is intended to drive the systematic perturbation of the
             <see cref="T:NCDK.Hash.PerturbedAtomHashGenerator"/>.
             <para>
             This method will not distinguish all possible molecules but represents a good
             enough approximation to quickly narrow down an identity search. At the time
             of writing (Feb, 2013) there are only 128 molecules (64 false positives) in
             PubChem-Compound (46E6 molecules) which are not separated. In many data sets
             this method will suffice however the exact <see cref="T:NCDK.Hash.AllEquivalentCyclicSet"/> is
             provided.</para>
             <para>
             This method is currently the default used by the <see cref="T:NCDK.Hash.HashGeneratorMaker"/> but can also be explicitly specified. 
             </para>
             </summary>
             <example>
             <code>
             MoleculeHashGenerator generator =
               new HashGeneratorMaker().Depth(6)
                                       .Elemental()
                                       .Perturbed() // use this class by default
                                       .Molecular();
            
             // explicitly specify the method
             MoleculeHashGenerator generator =
               new HashGeneratorMaker().Depth(6)
                                       .Elemental()
                                       .PerturbWith(new MinimumEquivalentCyclicSet())
                                       .Molecular();
             </code>
             </example>
             <seealso cref="T:NCDK.Hash.PerturbedAtomHashGenerator"/>
             <seealso cref="T:NCDK.Hash.MinimumEquivalentCyclicSetUnion"/>
             <seealso cref="T:NCDK.Hash.AllEquivalentCyclicSet"/>
             <seealso cref="T:NCDK.Hash.HashGeneratorMaker"/>
        </member>
        <member name="T:NCDK.Hash.MinimumEquivalentCyclicSetUnion">
            <summary>
            The union of all the smallest set of equivalent values are members of a ring.
            This class is intended to drive the systematic perturbation of the <see cref="T:NCDK.Hash.PerturbedAtomHashGenerator"/>. 
            The method is more comprehensive then a single <see cref="T:NCDK.Hash.MinimumEquivalentCyclicSet"/> and not as
            computationally demanding as <see cref="T:NCDK.Hash.AllEquivalentCyclicSet"/>. In reality one
            should choose either use the fast (but good) heuristic <see cref="T:NCDK.Hash.MinimumEquivalentCyclicSet"/> 
            or the exact <see cref="T:NCDK.Hash.AllEquivalentCyclicSet"/>. This method is provided for demonstration only.
            </summary>
            <remarks>
            As with the <see cref="T:NCDK.Hash.MinimumEquivalentCyclicSet"/> perturbation, this method does
            not guarantee that all molecules will be distinguished. At the time of
            writing (Feb 2013) there are only 8 structure in PubChem-Compound which need
            the more comprehensive perturbation method (<see cref="T:NCDK.Hash.AllEquivalentCyclicSet"/>),
            these are listed below.
            <list type="bullet">
            <item>CID <see href="http://pubchem.ncbi.nlm.nih.gov/summary/summary.cgi?cid=144432">144432</see>
            and CID <see href="http://pubchem.ncbi.nlm.nih.gov/summary/summary.cgi?cid=15584856">15584856</see></item>
            <item>CID <see href="http://pubchem.ncbi.nlm.nih.gov/summary/summary.cgi?cid=138898">138898</see>
            and CID <see href="http://pubchem.ncbi.nlm.nih.gov/summary/summary.cgi?cid=241107">241107</see></item>
            <item>CID <see href="http://pubchem.ncbi.nlm.nih.gov/summary/summary.cgi?cid=9990759">9990759</see>
            and CID <see href="http://pubchem.ncbi.nlm.nih.gov/summary/summary.cgi?cid=10899923">10899923</see></item>
            <item>CID <see href="http://pubchem.ncbi.nlm.nih.gov/summary/summary.cgi?cid=5460768">5460768</see>
            and CID <see href="http://pubchem.ncbi.nlm.nih.gov/summary/summary.cgi?cid=20673269">20673269</see></item>
            </list> 
            </remarks>
            <example>
            The easiest way to use this class is with the <see cref="T:NCDK.Hash.HashGeneratorMaker"/>.
            <code>
            MoleculeHashGenerator generator =
              new HashGeneratorMaker().Depth(6)
                                      .Elemental()
                                      .PerturbWith(new MinimumEquivalentCyclicSetUnion())
                                      .Molecular();
            </code>
            </example>
            <seealso cref="T:NCDK.Hash.PerturbedAtomHashGenerator"/>
            <seealso cref="T:NCDK.Hash.MinimumEquivalentCyclicSet"/>
            <seealso cref="T:NCDK.Hash.AllEquivalentCyclicSet"/>
        </member>
        <member name="T:NCDK.Hash.PerturbedAtomHashGenerator">
            <summary>
            A perturbed hash generator <token>cdk-cite-Ihlenfeldt93</token> which differentiates
            molecules with uniform atom environments and symmetry. The generator first
            calculates the basic hash codes (<see cref="T:NCDK.Hash.BasicAtomHashGenerator"/>) and then
            checks for duplicate values (uniform environments). These duplicate values
            are then filtered down (<see cref="T:NCDK.Hash.EquivalentSetFinder"/>) to a set (<i>S</i>)
            which can introduce systematic differences with. We then combine the
            |<i>S</i>| different invariant values with the original value to produce a
            unique value of each atom. There may still be duplicate values but providing
            the depth is appropriate then the atoms are truly equivalent.
            </summary>
            <example>
            The class requires a lot of configuration however it can be easily built with
            the <see cref="T:NCDK.Hash.HashGeneratorMaker"/>.
            <code>
            MoleculeHashGenerator generator = new HashGeneratorMaker().Depth(8)
                                                                      .Elemental()
                                                                      .Perturbed()
                                                                      .Molecular();
            IAtomContainer molecule = ...;
            long hash = generator.Generate(molecule);
            </code>
            </example>
            <seealso href="http://onlinelibrary.wiley.com/doi/10.1002/jcc.540150802/abstract">Wolf Dietrich Ihlenfeldt, Johann Gasteiger</seealso>  
            <seealso cref="T:NCDK.Hash.HashGeneratorMaker"/>
        </member>
        <member name="M:NCDK.Hash.PerturbedAtomHashGenerator.#ctor(NCDK.Hash.SeedGenerator,NCDK.Hash.AbstractAtomHashGenerator,NCDK.Hash.Pseudorandom,NCDK.Hash.Stereo.IStereoEncoderFactory,NCDK.Hash.EquivalentSetFinder,NCDK.Hash.AtomSuppression)">
            <summary>
            Create a perturbed hash generator using the provided seed generator to
            initialise atom invariants and using the provided stereo factory.
            </summary>
            <param name="seeds"></param>
            <param name="simple">generator to encode the initial values of atoms</param>
            <param name="pseudorandom">pseudorandom number generator used to randomise hash distribution</param>
            <param name="factory">a stereo encoder factory</param>
            <param name="finder">equivalent set finder for driving the systematic perturbation</param>
            <param name="suppression">suppression of atoms (these atoms are 'ignored' in the hash generation)</param>
            <exception cref="T:System.ArgumentException">depth was less then 0</exception>
            <exception cref="T:System.ArgumentNullException">    seed generator or pseudo random was null</exception>
            <seealso cref="T:NCDK.Hash.SeedGenerator"/>
        </member>
        <member name="M:NCDK.Hash.PerturbedAtomHashGenerator.Combine(System.Int64[][])">
            <summary>
            Combines the values in an n x m matrix into a single array of size n.
            This process scans the rows and xors all unique values in the row
            together. If a duplicate value is found it is rotated using a
            pseudorandom number generator.
            </summary>
            <param name="perturbed">n x m, matrix</param>
            <returns>the combined values of each row</returns>
        </member>
        <member name="T:NCDK.Hash.Pseudorandom">
            <summary>
            A pseudorandom number generator.
            </summary>
        </member>
        <member name="M:NCDK.Hash.Pseudorandom.Next(System.Int64)">
            <summary>
            Generate a pseudorandom number for the given seed.
            </summary>
            <param name="seed">seeding value for the random number generator</param>
            <returns>next pseudorandom number</returns>
        </member>
        <member name="T:NCDK.Hash.SeedGenerator">
             <summary>
             Generate a seed value for each atom of a molecule. The provided <see cref="T:NCDK.Hash.IAtomEncoder"/> 
             is used to encode invariant attributes of the atoms. This value
             is then modified by the size of the molecule and pseudorandomly distributed.
             The seed values should be used with another <see cref="T:NCDK.Hash.IAtomHashGenerator"/> which
             will differentiate atoms experiencing different environments, such as, <see cref="T:NCDK.Hash.BasicAtomHashGenerator"/>.
             </summary>
             <example><code>
             // create a new seed generator
             AtomEncoder       encoder   = ConjugatedAtomEncoder.Create(ATOMIC_NUMBER, MASS_NUMBER);
             AtomHashGenerator generator = new SeedGenerator(encoder);
            
             // generate six hash codes for each atom of benzene
             IAtomContainer benzene   = MoleculeFactory.MakeBenzene();
             long[]         hashCodes = generator.Generate(benzene);
             </code></example>
             <seealso cref="T:NCDK.Hash.BasicAtomHashGenerator"/>
             <seealso cref="T:NCDK.Hash.ConjugatedAtomEncoder"/>
        </member>
        <member name="F:NCDK.Hash.SeedGenerator.suppression">
            <summary>Optional suppression of atoms.</summary>
        </member>
        <member name="M:NCDK.Hash.SeedGenerator.#ctor(NCDK.Hash.IAtomEncoder)">
            <summary>
            Create a new seed generator using the provided <see cref="T:NCDK.Hash.IAtomEncoder"/>.
            </summary>
            <param name="encoder">a method for encoding atom invariant properties</param>
            <exception cref="T:System.ArgumentNullException">encoder was null</exception>
            <seealso cref="T:NCDK.Hash.ConjugatedAtomEncoder"/>
        </member>
        <member name="M:NCDK.Hash.SeedGenerator.#ctor(NCDK.Hash.IAtomEncoder,NCDK.Hash.AtomSuppression)">
            <summary>
            Create a new seed generator using the provided <see cref="T:NCDK.Hash.IAtomEncoder"/>.
            </summary>
            <param name="encoder">a method for encoding atom invariant properties</param>
            <param name="suppression"></param>
            <exception cref="T:System.ArgumentNullException">encoder was null</exception>
            <seealso cref="T:NCDK.Hash.ConjugatedAtomEncoder"/>
        </member>
        <member name="M:NCDK.Hash.SeedGenerator.#ctor(NCDK.Hash.IAtomEncoder,NCDK.Hash.Pseudorandom,NCDK.Hash.AtomSuppression)">
            <summary>
            Create a new seed generator using the provided <see cref="T:NCDK.Hash.IAtomEncoder"/> and
            pseudorandom number generator.
            </summary>
            <param name="encoder">a method for encoding atom invariant properties</param>
            <param name="pseudorandom">number generator to randomise initial invariants</param>
            <param name="suppression">indicates which vertices should be suppressed</param>
            <exception cref="T:System.ArgumentNullException">encoder or pseudorandom number generator was null</exception>
        </member>
        <member name="T:NCDK.Hash.Stereo.BasicPermutationParity">
            <summary>
            A basic implementation suitable for determining the parity of the indicates a
            provided sub-array.
            </summary>
        </member>
        <member name="M:NCDK.Hash.Stereo.BasicPermutationParity.#ctor(System.Int32[])">
            <summary>
            Create a permutation parity for the provided indices.
            </summary>
            <param name="indices">sub-array of indices</param>
            <exception cref="T:System.ArgumentNullException">the provided indices were null</exception>
            <exception cref="T:System.ArgumentException">less then two indices provided</exception>
        </member>
        <member name="M:NCDK.Hash.Stereo.BasicPermutationParity.Parity(System.Int64[])">
            <summary>
            The number values to check is typically small (&lt;5) and thus
            we use brute-force to count the number of inversions.
            </summary>
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Hash.Stereo.CombinedPermutationParity">
            <summary>
            Combine two permutation parities into one.
            </summary>
        </member>
        <member name="M:NCDK.Hash.Stereo.CombinedPermutationParity.#ctor(NCDK.Hash.Stereo.PermutationParity,NCDK.Hash.Stereo.PermutationParity)">
            <summary>
            Combines the left and right parity into a single parity. This parity is
            the product of the two separate parities.
            </summary>
            <param name="left">either parity</param>
            <param name="right">other parity</param>
        </member>
        <member name="T:NCDK.Hash.Stereo.DoubleBond2DParity">
            <summary>
            Calculate the geometric configuration of a double bond. The configuration is
            provided as a parity (+1,0,-1) where +1 indicates the substituents are on
            <i>opposite</i> sides (E or trans) and -1 indicates they are <i>together</i>
            on the same side (Z or cis). If one of the substituents is parallel to the
            double bond then the configuration is unspecified and 0 is returned.
            </summary>
        </member>
        <member name="F:NCDK.Hash.Stereo.DoubleBond2DParity.Threshold">
            <summary>
            the area below which we return unspecified parity
            </summary>
        </member>
        <member name="M:NCDK.Hash.Stereo.DoubleBond2DParity.#ctor(NCDK.Numerics.Vector2,NCDK.Numerics.Vector2,NCDK.Numerics.Vector2,NCDK.Numerics.Vector2)">
            <summary>
            Create a new double bond parity for the 2D coordinates of the atoms.
            </summary>
            <param name="left">one atom of the double bond</param>
            <param name="right">the other atom of a double bond</param>
            <param name="leftSubstituent">the substituent atom connected to the left atom</param>
            <param name="rightSubstituent">the substituent atom connected to the right atom</param>
        </member>
        <member name="M:NCDK.Hash.Stereo.DoubleBond2DParity.#ctor(NCDK.Numerics.Vector2,NCDK.Numerics.Vector2,NCDK.Numerics.Vector2,NCDK.Numerics.Vector2,NCDK.Numerics.Vector2,NCDK.Numerics.Vector2)">
             <summary>
             Create a new double bond parity for the 2D coordinates of the atoms. This
             method is required for cases where both substituents may lie on the same
             side of a bond. If one of the sides has two substituents and the other
             side has two then you can pass left/right atom of the double bond as
             the second substituent.
             </summary>
             <example>
              l1      r1
               \     /
                l = r
               /
              l2
            
              should be passed as:
             <code>
                  new DoubleBond2DParity(l, r, l1, l2, r1, r);
             </code>
             </example>
             <param name="left">one atom of the double bond</param>
             <param name="right">the other atom of a double bond</param>
             <param name="leftSubstituent1">first substituent atom connected to the left atom</param>
             <param name="leftSubstituent2">second substituent atom connected to the left atom</param>
             <param name="rightSubstituent1">first substituent atom connected to the right atom</param>
             <param name="rightSubstituent2">second substituent atom connected to the right atom</param>
        </member>
        <member name="P:NCDK.Hash.Stereo.DoubleBond2DParity.Parity">
            <summary>
            Calculate the configuration of the double bond as a parity.
            </summary>
            <returns>opposite (+1), together (-1) or unspecified (0)</returns>
        </member>
        <member name="M:NCDK.Hash.Stereo.DoubleBond2DParity.GetParity(NCDK.Numerics.Vector2,NCDK.Numerics.Vector2,NCDK.Numerics.Vector2)">
            <summary>
            Determine the rotation parity of one side of the double bond. This parity
            is the sign of the area of a triangle.
            <pre>
            a
             \
              b = c
            </pre>
            </summary>
            <param name="a">coordinates of the substituent atom</param>
            <param name="b">coordinates of the atom next to the substituent</param>
            <param name="c">coordinates of the atom double bonds to <i>b</i></param>
            <returns>clockwise (+1), anti-clockwise (-1) or unspecified (0)</returns>
        </member>
        <member name="T:NCDK.Hash.Stereo.DoubleBond3DParity">
            <summary>
            Calculate the geometric configuration of a double bond. The configuration is
            provided as a parity (+1,-1) where +1 indicates the substituents are on
            <i>opposite</i> sides (E or trans) and -1 indicates they are <i>together</i>
            on the same side (Z or cis).
            </summary>
        </member>
        <member name="M:NCDK.Hash.Stereo.DoubleBond3DParity.#ctor(NCDK.Numerics.Vector3,NCDK.Numerics.Vector3,NCDK.Numerics.Vector3,NCDK.Numerics.Vector3)">
            <summary>
            Create a new double bond parity for the 2D coordinates of the atoms.
            </summary>
            <param name="left">one atom of the double bond</param>
            <param name="right">the other atom of a double bond</param>
            <param name="leftSubstituent">the substituent atom connected to the left atom</param>
            <param name="rightSubstituent">the substituent atom connected to the right atom</param>
        </member>
        <member name="P:NCDK.Hash.Stereo.DoubleBond3DParity.Parity">
            <summary>
            Calculate the configuration of the double bond as a parity.
            </summary>
            <returns>opposite (+1), together (-1)</returns>
        </member>
        <member name="M:NCDK.Hash.Stereo.DoubleBond3DParity.ToVector(NCDK.Numerics.Vector3,NCDK.Numerics.Vector3)">
            <summary>
            Create a vector by specifying the source and destination coordinates.
            </summary>
            <param name="src">start point of the vector</param>
            <param name="dest">end point of the vector</param>
            <returns>a new vector</returns>
        </member>
        <member name="M:NCDK.Hash.Stereo.DoubleBond3DParity.Dot(System.Double[],System.Double[])">
            <summary>
            Dot product of two 3D coordinates
            </summary>
            <param name="u">either 3D coordinates</param>
            <param name="v">other 3D coordinates</param>
            <returns>the dot-product</returns>
        </member>
        <member name="M:NCDK.Hash.Stereo.DoubleBond3DParity.CrossProduct(System.Double[],System.Double[])">
            <summary>
            Cross product of two 3D coordinates
            </summary>
            <param name="u">either 3D coordinates</param>
            <param name="v">other 3D coordinates</param>
            <returns>the cross-product</returns>
        </member>
        <member name="T:NCDK.Hash.Stereo.DoubleBondElementEncoderFactory">
            <summary>
            Defines a stereo encoder factory for the hash code. The factory allows the
            generation of stereo hash codes for molecules with predefined <see cref="T:NCDK.IDoubleBondStereochemistry"/> stereo elements. 
            </summary>
        </member>
        <member name="M:NCDK.Hash.Stereo.DoubleBondElementEncoderFactory.GetEncoder(NCDK.IDoubleBondStereochemistry,System.Collections.Generic.IDictionary{NCDK.IAtom,System.Int32},System.Int32[][])">
            <summary>
            Create an encoder for the <see cref="T:NCDK.IDoubleBondStereochemistry"/> element.
            </summary>
            <param name="dbs">stereo element from an atom container</param>
            <param name="atomToIndex">map of atoms to indices</param>
            <param name="graph">adjacency list of connected vertices</param>
            <returns>a new geometry encoder</returns>
        </member>
        <member name="M:NCDK.Hash.Stereo.DoubleBondElementEncoderFactory.FindOther(System.Int32[],System.Int32,System.Int32)">
            <summary>
            Finds a vertex in <paramref name="vs"/> which is not <paramref name="u"/> or <paramref name="x"/>.
            </summary>
            <param name="vs">fixed size array of 3 elements</param>
            <param name="u">a vertex in <paramref name="vs"/></param>
            <param name="x">another vertex in <paramref name="vs"/></param>
            <returns>the other vertex</returns>
        </member>
        <member name="M:NCDK.Hash.Stereo.DoubleBondElementEncoderFactory.IndexMap(System.Collections.Generic.IDictionary{NCDK.IAtom,System.Int32},NCDK.IAtomContainer)">
            <summary>
            Lazy creation of an atom index map.
            </summary>
            <param name="map">existing map (possibly null)</param>
            <param name="container">the container we want the map for</param>
            <returns>a usable atom to index map for the given container</returns>
        </member>
        <member name="T:NCDK.Hash.Stereo.GeometricCumulativeDoubleBondFactory">
            <summary>
            Stereo encoder factory for 2D and 3D cumulative double bonds.
            </summary>
        </member>
        <member name="M:NCDK.Hash.Stereo.GeometricCumulativeDoubleBondFactory.Create(NCDK.IAtomContainer,System.Int32[][])">
            <summary>
            Create a stereo encoder for cumulative double bonds.
            </summary>
            <param name="container">the container</param>
            <param name="graph">adjacency list representation of the container</param>
            <returns>a stereo encoder</returns>
        </member>
        <member name="M:NCDK.Hash.Stereo.GeometricCumulativeDoubleBondFactory.AxialEncoder(NCDK.IAtomContainer,NCDK.IAtom,NCDK.IAtom)">
            <summary>
            Create an encoder for axial 2D stereochemistry for the given start and
            end atoms.
            </summary>
            <param name="container">the molecule</param>
            <param name="start">start of the cumulated system</param>
            <param name="end">end of the cumulated system</param>
            <returns>an encoder or null if there are no coordinated</returns>
        </member>
        <member name="M:NCDK.Hash.Stereo.GeometricCumulativeDoubleBondFactory.Axial2DEncoder(NCDK.IAtomContainer,NCDK.IAtom,System.Collections.Generic.IEnumerable{NCDK.IBond},NCDK.IAtom,System.Collections.Generic.IEnumerable{NCDK.IBond})">
            <summary>
            Create an encoder for axial 2D stereochemistry for the given start and
            end atoms.
            </summary>
            <param name="container">the molecule</param>
            <param name="start">start of the cumulated system</param>
            <param name="startBonds">bonds connected to the start</param>
            <param name="end">end of the cumulated system</param>
            <param name="endBonds">bonds connected to the end</param>
            <returns>an encoder</returns>
        </member>
        <member name="M:NCDK.Hash.Stereo.GeometricCumulativeDoubleBondFactory.Axial3DEncoder(NCDK.IAtomContainer,NCDK.IAtom,System.Collections.Generic.IEnumerable{NCDK.IBond},NCDK.IAtom,System.Collections.Generic.IEnumerable{NCDK.IBond})">
            <summary>
            Create an encoder for axial 3D stereochemistry for the given start and end atoms.
            </summary>
            <param name="container">the molecule</param>
            <param name="start">start of the cumulated system</param>
            <param name="startBonds">bonds connected to the start</param>
            <param name="end">end of the cumulated system</param>
            <param name="endBonds">bonds connected to the end</param>
            <returns>an encoder</returns>
        </member>
        <member name="M:NCDK.Hash.Stereo.GeometricCumulativeDoubleBondFactory.Fill2DCoordinates(NCDK.IAtomContainer,NCDK.IAtom,System.Collections.Generic.IEnumerable{NCDK.IBond},NCDK.Numerics.Vector2[],System.Int32[],System.Int32)">
            <summary>
            Fill the <paramref name="coordinates"/> and <paramref name="elevations"/> from the given
            offset index. If there is only one connection then the second entry (from
            the offset) will use the coordinates of <paramref name="a"/>. The permutation parity
            is also built and returned.
            </summary>
            <param name="container">atom container</param>
            <param name="a">the central atom</param>
            <param name="connected">bonds connected to the central atom</param>
            <param name="coordinates">the coordinates array to fill</param>
            <param name="elevations">the elevations of the connected atoms</param>
            <param name="offset">current location in the offset array</param>
            <returns>the permutation parity</returns>
        </member>
        <member name="M:NCDK.Hash.Stereo.GeometricCumulativeDoubleBondFactory.Fill3DCoordinates(NCDK.IAtomContainer,NCDK.IAtom,System.Collections.Generic.IEnumerable{NCDK.IBond},NCDK.Numerics.Vector3[],System.Int32)">
            <summary>
            Fill the <paramref name="coordinates"/> from the given offset index. If there is
            only one connection then the second entry (from the offset) will use the
            coordinates of <paramref name="a"/>. The permutation parity is also built and
            returned.
            </summary>
            <param name="container">atom container</param>
            <param name="a">the central atom</param>
            <param name="connected">bonds connected to the central atom</param>
            <param name="coordinates">the coordinates array to fill</param>
            <param name="offset">current location in the offset array</param>
            <returns>the permutation parity</returns>
        </member>
        <member name="M:NCDK.Hash.Stereo.GeometricCumulativeDoubleBondFactory.Has2DCoordinates(System.Collections.Generic.IEnumerable{NCDK.IBond})">
            <summary>
            Check if all atoms in the bond list have 2D coordinates. There is some
            redundant checking but the list will typically be short.
            </summary>
            <param name="bonds">the bonds to check</param>
            <returns>whether all atoms have 2D coordinates</returns>
        </member>
        <member name="M:NCDK.Hash.Stereo.GeometricCumulativeDoubleBondFactory.Has3DCoordinates(System.Collections.Generic.IEnumerable{NCDK.IBond})">
            <summary>
            Check if all atoms in the bond list have 3D coordinates. There is some
            redundant checking but the list will typically be short.
            </summary>
            <param name="bonds">the bonds to check</param>
            <returns>whether all atoms have 2D coordinates</returns>
        </member>
        <member name="M:NCDK.Hash.Stereo.GeometricCumulativeDoubleBondFactory.Elevation(NCDK.IBond,NCDK.IAtom)">
            <summary>
            Access the elevation of a bond relative to the given source atom. With a
            wedge bond if the atom <i>a</i> is the <i>point</i> end then the bond
            comes off the paper <i>above</i> the plane. If <i>a</i> is the <i>fat</i>
            end then the bond from <i>a</i> goes <i>below</i> the plane.
            </summary>
            <param name="bond">a bond</param>
            <param name="a">an atom</param>
            <returns>elevation of bond</returns>
        </member>
        <member name="M:NCDK.Hash.Stereo.GeometricCumulativeDoubleBondFactory.Elevation(NCDK.IBond)">
            <summary>
            Access the elevation of a bond.
            </summary>
            <param name="bond">the bond</param>
            <returns>+1 above the plane, 0 in the plane (default) or -1 below the plane</returns>
        </member>
        <member name="M:NCDK.Hash.Stereo.GeometricCumulativeDoubleBondFactory.IsOdd(System.Int32)">
            <summary>
            Is the value <paramref name="x"/> odd?
            </summary>
            <param name="x">an int value</param>
            <returns>whether x is odd</returns>
        </member>
        <member name="M:NCDK.Hash.Stereo.GeometricCumulativeDoubleBondFactory.IsDoubleBond(NCDK.IBond)">
            <summary>
            Determine whether the bond order is 'double'.
            </summary>
            <param name="bond">a bond</param>
            <returns>the bond is a double bond.</returns>
        </member>
        <member name="T:NCDK.Hash.Stereo.GeometricCumulativeDoubleBondFactory.BondMap">
            <summary>
            Helper class for storing a lookup of atoms and their connected double
            bonds.
            </summary>
        </member>
        <member name="M:NCDK.Hash.Stereo.GeometricCumulativeDoubleBondFactory.BondMap.#ctor(System.Int32)">
            <summary>
            Create new bond map for the specified number of atoms.
            </summary>
            <param name="n">atom count</param>
        </member>
        <member name="M:NCDK.Hash.Stereo.GeometricCumulativeDoubleBondFactory.BondMap.GetBonds(NCDK.IAtom)">
            <summary>
            List of bonds involving the atom.
            </summary>
            <param name="a">atom</param>
            <returns>list of bonds, empty if none stored</returns>
        </member>
        <member name="M:NCDK.Hash.Stereo.GeometricCumulativeDoubleBondFactory.BondMap.Cumulated(NCDK.IAtom)">
            <summary>
            Check whether the the atom is cumulated - two consecutive double bonds.
            </summary>
            <param name="a">an atom</param>
            <returns>whether the atom is cumulated</returns>
        </member>
        <member name="M:NCDK.Hash.Stereo.GeometricCumulativeDoubleBondFactory.BondMap.Add(NCDK.IBond)">
            <summary>
            Add a bond to the map.
            </summary>
            <param name="bond">the bond to add</param>
        </member>
        <member name="M:NCDK.Hash.Stereo.GeometricCumulativeDoubleBondFactory.BondMap.Add(NCDK.IAtom,NCDK.IBond)">
            <summary>
            Add the bond for the provided atom.
            </summary>
            <param name="a">an atom of the bond</param>
            <param name="b">the bond</param>
        </member>
        <member name="P:NCDK.Hash.Stereo.GeometricCumulativeDoubleBondFactory.BondMap.Atoms">
            <summary>
            Set of atoms which have double bonds.
            </summary>
            <returns>iterable set of atoms</returns>
        </member>
        <member name="T:NCDK.Hash.Stereo.GeometricDoubleBondEncoderFactory">
            <summary>
            A stereo encoder factory encoding double bond configurations by 2D and 3D
            coordinates. This factory will attempt to encode all double bonds that meet
            the following conditions. Are not <c>-N=N-</c> bonds, non-cumulated,
            non-query and have each double bonded atom has at least one substituent. In
            future the encoding rules may be more strict or even configurable but
            currently they may be over zealous when encoding configurations with 3D
            coordinates.
            <para>This class is intended to be used with a the hash
            encoding classes and is easier used via the <see cref="T:NCDK.Hash.HashGeneratorMaker"/>.</para>
            </summary>
        </member>
        <member name="M:NCDK.Hash.Stereo.GeometricDoubleBondEncoderFactory.Create(NCDK.IAtomContainer,System.Int32[][])">
            <summary>
            Create a stereo encoder for all potential 2D and 3D double bond stereo
            configurations.
            </summary>
            <param name="container">an atom container</param>
            <param name="graph">adjacency list representation of the container</param>
            <returns>a new encoder for tetrahedral elements</returns>
        </member>
        <member name="M:NCDK.Hash.Stereo.GeometricDoubleBondEncoderFactory.NewEncoder(NCDK.IAtomContainer,NCDK.IAtom,NCDK.IAtom,NCDK.IAtom,NCDK.IAtom,System.Int32[][])">
            <summary>
            Create a new encoder for the specified left and right atoms. The parent
            is the atom which is connected by a double bond to the left and right
            atom. For simple double bonds the parent of each is the other atom, in
            cumulenes the parents are not the same.
            </summary>
            <param name="container">the molecule</param>
            <param name="left">the left atom</param>
            <param name="leftParent">the left atoms parent (usually <paramref name="right"/>)</param>
            <param name="right">the right atom</param>
            <param name="rightParent">the right atoms parent (usually <paramref name="left"/>)</param>
            <param name="graph">adjacency list representation of the molecule</param>
            <returns>a stereo encoder (or null)</returns>
        </member>
        <member name="M:NCDK.Hash.Stereo.GeometricDoubleBondEncoderFactory.Geometric(NCDK.IAtomContainer,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Generate a new geometric parity (2D or 3D) for the given molecule and
            atom indices. This method ensure that 2D and 3D coordinates are available
            on the specified atoms and returns null if the 2D or 3D coordinates are
            not fully available.
            </summary>
            <param name="mol">a molecule</param>
            <param name="l">left double bonded atom</param>
            <param name="r">right double bonded atom</param>
            <param name="l1">first substituent atom of <i>l</i></param>
            <param name="l2">second substituent atom of <i>l</i> or <i>l</i> if there is none</param>
            <param name="r1">first substituent atom of <paramref name="r"/></param>
            <param name="r2">second substituent atom of <paramref name="r"/> or <paramref name="r"/> if there is none</param>
            <returns>geometric parity or null</returns>
        </member>
        <member name="M:NCDK.Hash.Stereo.GeometricDoubleBondEncoderFactory.Permutation(System.Int32[])">
             <summary>
             Create a permutation parity for the given neighbors. The neighbor list
             should include the other double bonded atom but in the last index.
            
             <pre>
             c3
              \
               c2 = c1  = [c3,c4,c1]
              /
             c4
             </pre>
             </summary>
             <param name="neighbors">neighbors of a double bonded atom specified by index</param>
             <returns>a new permutation parity</returns>
        </member>
        <member name="M:NCDK.Hash.Stereo.GeometricDoubleBondEncoderFactory.MoveToBack(System.Int32[],System.Int32)">
            <summary>
            Utility method for shifting a specified value in an index to the back
            (see <see cref="M:NCDK.Hash.Stereo.GeometricDoubleBondEncoderFactory.Permutation(System.Int32[])"/> ).
            </summary>
            <param name="neighbors">list of neighbors</param>
            <param name="v">the value to shift to the back</param>
            <returns><i>neighbors</i> array</returns>
        </member>
        <member name="M:NCDK.Hash.Stereo.GeometricDoubleBondEncoderFactory.Accept(NCDK.IAtom,System.Collections.Generic.IEnumerable{NCDK.IBond})">
            <summary>
            Test whether we accept atom and it's connected bonds for inclusion in a
            double bond configuration. This method checks for query bonds (up/down)
            as well as double bond counts. If there is more then one double bond in
            the connect bonds then it cannot have Z/E configuration.
            </summary>
            <param name="atom">a double bonded atom</param>
            <param name="bonds">all bonds connected to the atom</param>
            <returns>whether the atom is accepted for configuration</returns>
        </member>
        <member name="T:NCDK.Hash.Stereo.GeometricParity">
            <summary>
            Describes the geometric parity of a stereo configuration.
            </summary>
        </member>
        <member name="P:NCDK.Hash.Stereo.GeometricParity.Parity">
            <summary>
            Calculate the geometric parity.
            </summary>
            <returns>-1 odd, +1 even and 0 none</returns>
        </member>
        <member name="T:NCDK.Hash.Stereo.GeometricParity.Predefined">
            <summary>
            Simple implementation allows us to wrap a predefined parity up for access
            later. See <see cref="T:NCDK.Hash.Stereo.TetrahedralElementEncoderFactory"/> for usage example.
            </summary>
        </member>
        <member name="M:NCDK.Hash.Stereo.GeometricParity.Predefined.#ctor(System.Int32)">
            <summary>
            Create a new predefined geometric parity.
            </summary>
            <param name="parity">value of the parity</param>
        </member>
        <member name="M:NCDK.Hash.Stereo.GeometricParity.ValueOf(System.Int32)">
            <summary>
            Create a geometric parity from a pre-stored value (-1, 0, +1).
            </summary>
            <param name="parity">existing parity</param>
            <returns>instance which when invoked will return the value</returns>
        </member>
        <member name="T:NCDK.Hash.Stereo.GeometricTetrahedralEncoderFactory">
            <summary>
            A stereo encoder factory for tetrahedral centres. This factory generates
            <see cref="T:NCDK.Hash.Stereo.StereoEncoder"/>s for centres with specified by 2D and 3D coordinates.
            The required preconditions are the central atom must have 3/4 neighboring
            atoms, Sp3 hybridization and no query bonds (e.g. wiggly). If there is at
            least one up/down bond and all required atoms have coordinates a new 2D
            encoder is created. If the there are no stereo bonds (up/down) and all
            required atoms have 3D coordinates then a new 3D encoder is created.
            </summary>
        </member>
        <member name="M:NCDK.Hash.Stereo.GeometricTetrahedralEncoderFactory.Create(NCDK.IAtomContainer,System.Int32[][])">
            <summary>
            Create a stereo encoder for all potential 2D and 3D tetrahedral
            elements.
            </summary>
            <param name="container">an atom container</param>
            <param name="graph">adjacency list representation of the container</param>
            <returns>a new encoder for tetrahedral elements</returns>
        </member>
        <member name="M:NCDK.Hash.Stereo.GeometricTetrahedralEncoderFactory.Geometric(System.Collections.Generic.IDictionary{NCDK.IAtom,System.Int32},System.Collections.Generic.IEnumerable{NCDK.IBond},System.Int32,System.Int32[],NCDK.IAtomContainer)">
            <summary>
            Create the geometric part of an encoder
            </summary>
            <param name="elevationMap">temporary map to store the bond elevations (2D)</param>
            <param name="bonds">list of bonds connected to the atom at i</param>
            <param name="i">the central atom (index)</param>
            <param name="adjacent">adjacent atoms (indices)</param>
            <param name="container">container</param>
            <returns>geometric parity encoder (or null)</returns>
        </member>
        <member name="M:NCDK.Hash.Stereo.GeometricTetrahedralEncoderFactory.Geometric2D(System.Collections.Generic.IDictionary{NCDK.IAtom,System.Int32},System.Collections.Generic.IEnumerable{NCDK.IBond},System.Int32,System.Int32[],NCDK.IAtomContainer)">
            <summary>
            Create the geometric part of an encoder of 2D configurations
            </summary>
            <param name="elevationMap">temporary map to store the bond elevations (2D)</param>
            <param name="bonds">list of bonds connected to the atom at i</param>
            <param name="i">the central atom (index)</param>
            <param name="adjacent">adjacent atoms (indices)</param>
            <param name="container">container</param>
            <returns>geometric parity encoder (or null)</returns>
        </member>
        <member name="M:NCDK.Hash.Stereo.GeometricTetrahedralEncoderFactory.Geometric3D(System.Int32,System.Int32[],NCDK.IAtomContainer)">
            <summary>
            Create the geometric part of an encoder of 3D configurations
            </summary>
            <param name="i">the central atom (index)</param>
            <param name="adjacent">adjacent atoms (indices)</param>
            <param name="container">container</param>
            <returns>geometric parity encoder (or null)</returns>
        </member>
        <member name="M:NCDK.Hash.Stereo.GeometricTetrahedralEncoderFactory.Sp3(NCDK.IAtom)">
            <summary>
            check whether the atom is Sp3 hybridization
            </summary>
            <param name="atom">an atom</param>
            <returns>whether the atom is Sp3</returns>
        </member>
        <member name="M:NCDK.Hash.Stereo.GeometricTetrahedralEncoderFactory.GetNumPfStereoBonds(System.Collections.Generic.IEnumerable{NCDK.IBond})">
            <summary>
            access the number of stereo bonds in the provided bond list.
            </summary>
            <param name="bonds">input list</param>
            <returns>number of Up/Down bonds in the list, -1 if a query bond was found</returns>
        </member>
        <member name="M:NCDK.Hash.Stereo.GeometricTetrahedralEncoderFactory.MakeElevationMap(NCDK.IAtom,System.Collections.Generic.IEnumerable{NCDK.IBond},System.Collections.Generic.IDictionary{NCDK.IAtom,System.Int32})">
            <summary>
            Maps the input bonds to a map of Atom->Elevation where the elevation is
            whether the bond is off the plane with respect to the central atom.
            </summary>
            <param name="atom">central atom</param>
            <param name="bonds">bonds connected to the central atom</param>
            <param name="map">map to load with elevation values (can be reused)</param>
        </member>
        <member name="T:NCDK.Hash.Stereo.GeometryEncoder">
            <summary>
            Given a geometric parity and a permutation parity encode the parity of the
            combination at the specified stereo centre indices.
            </summary>
        </member>
        <member name="M:NCDK.Hash.Stereo.GeometryEncoder.#ctor(System.Int32[],NCDK.Hash.Stereo.PermutationParity,NCDK.Hash.Stereo.GeometricParity)">
            <summary>
            Create a new encoder for multiple stereo centres (specified as an array).
            </summary>
            <param name="centres">the stereo centres which will be configured</param>
            <param name="permutation">calculator for permutation parity</param>
            <param name="geometric">geometric calculator</param>
            <exception cref="T:System.ArgumentException">if the centres[] were empty</exception>
        </member>
        <member name="M:NCDK.Hash.Stereo.GeometryEncoder.#ctor(System.Int32,NCDK.Hash.Stereo.PermutationParity,NCDK.Hash.Stereo.GeometricParity)">
            <summary>
            Convenience method to create a new encoder for a single stereo centre.
            </summary>
            <param name="centre">a stereo centre which will be configured</param>
            <param name="permutation">calculator for permutation parity</param>
            <param name="geometric">geometric calculator</param>
            <exception cref="T:System.ArgumentException">if the centres[] were empty</exception>
        </member>
        <member name="M:NCDK.Hash.Stereo.GeometryEncoder.Encode(System.Int64[],System.Int64[])">
            <summary>
            Encodes the <see cref="F:NCDK.Hash.Stereo.GeometryEncoder.centres"/> specified in the constructor as either
            clockwise/anticlockwise or none. If there is a permutation parity but no
            geometric parity then we can not encode the configuration and 'true' is
            returned to indicate the perception is done. If there is no permutation
            parity this may changed with the next <paramref name="current"/>[] values and so
            <see langword="false"/> is returned.
            </summary>
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Hash.Stereo.MultiStereoEncoder">
            <summary>
            A multiple stereo encoder. Given a list of other encoders this class wraps
            them up into a single method call. Once each encoder has been configured it
            is marked and will not be visited again unless the encoder is <see cref="M:NCDK.Hash.Stereo.MultiStereoEncoder.Reset"/>. 
            </summary>
        </member>
        <member name="M:NCDK.Hash.Stereo.MultiStereoEncoder.#ctor(System.Collections.Generic.IList{NCDK.Hash.Stereo.IStereoEncoder})">
            <summary>
            Create a new multiple stereo encoder from a single list of encoders
            </summary>
        </member>
        <member name="T:NCDK.Hash.Stereo.PermutationParity">
            <summary>
            Calculate the permutation parity on a given array of current values.
            </summary>
            <seealso href="http://en.wikipedia.org/wiki/Parity_of_a_permutation">Parity of a Permutation, Wikipedia</seealso>
        </member>
        <member name="F:NCDK.Hash.Stereo.PermutationParity.Identity">
            <summary>
            Identity parity which always returns 1 (even). This is useful for
            configurations which do not require ordering, such as, double bonds with
            implicit hydrogens.
            </summary>
        </member>
        <member name="M:NCDK.Hash.Stereo.PermutationParity.Parity(System.Int64[])">
            <summary>
            Calculate the permutation parity of a permutation on the current values.
            The inversion parity counts whether we need to do an odd or even number
            of swaps to put the values in sorted order. If the values contain
            duplicates then the parity is returned as 0.
            </summary>
            <param name="current">current values of invariants</param>
            <returns>-1, odd number of swaps, +1, even number of swaps, 0, contains duplicates</returns>
        </member>
        <member name="T:NCDK.Hash.Stereo.IStereoEncoder">
            <summary>
            An encoder for stereo chemistry. The stereo configuration is encoded by
            checking the <c>current[]</c> invariant values. If there is a configuration
            then the appropriate value is the <c>next[]</c> is modified.
            </summary>
        </member>
        <member name="M:NCDK.Hash.Stereo.IStereoEncoder.Encode(System.Int64[],System.Int64[])">
            <summary>
            Encode one or more stereo elements based on the current invariants. If
            any stereo element are uncovered then the corresponding value in the
            <paramref name="next"/>[] array is modified.
            </summary>
            <param name="current">current invariants</param>
            <param name="next">next invariants</param>
            <returns>whether any stereo configurations were encoded</returns>
        </member>
        <member name="M:NCDK.Hash.Stereo.IStereoEncoder.Reset">
            <summary>
            Reset the stereo-encoders, any currently perceived configurations will be
            re-activated.
            </summary>
        </member>
        <member name="F:NCDK.Hash.Stereo.StereoEncoder.Empty">
            <summary>
            empty stereo encoder when no stereo can be perceived
            </summary>
        </member>
        <member name="T:NCDK.Hash.Stereo.IStereoEncoderFactory">
            <summary>
            Describes a factory for stereo elements. The factory create encoders for
            specific stereo elements.
            </summary>
        </member>
        <member name="M:NCDK.Hash.Stereo.IStereoEncoderFactory.Create(NCDK.IAtomContainer,System.Int32[][])">
            <summary>
            Create a stereo-encoder for possible stereo-chemical configurations.
            </summary>
            <param name="container">the container</param>
            <param name="graph">adjacency list representation of the container</param>
            <returns>a new stereo encoder</returns>
        </member>
        <member name="F:NCDK.Hash.Stereo.StereoEncoderFactory.Empty">
            <summary>
            Empty factory for when stereo encoding is not required
            </summary>
        </member>
        <member name="T:NCDK.Hash.Stereo.Tetrahedral2DParity">
            <summary>
            Geometric parity for 2D tetrahedral geometry. This class requires four 2D
            coordinates and their elevations. The 2D coordinates correspond to the four
            ligands of a tetrahedral atom and the elevation as to whether they are
            attached via a wedge/hatch bonds. Wedge bonds come out of the plane (+ve) and
            hatch bonds go into the plane (-ve), these elevations are specified with a
            (+1) and (-1) respectively. If a tetrahedral atom has an implicit hydrogen
            (only 3 ligands) the forth coordinate should be that of the atom at the
            centre with no elevation <token>cdk-cite-Cieplak2001</token>.
            </summary>
            <seealso href="http://www.mdpi.org/molecules/papers/61100915/61100915.htm">Cieplak, T and Wisniewski, J.L. 2001</seealso>
        </member>
        <member name="M:NCDK.Hash.Stereo.Tetrahedral2DParity.#ctor(NCDK.Numerics.Vector2[],System.Int32[])">
            <summary>
            Create a new geometric parity for 2D tetrahedral geometry by specifying
            the coordinates and the elevations.
            </summary>
            <param name="coordinates">non-null, 4 2D coordinates</param>
            <param name="elevations">non-null, 4 elevations (-1,0,+1)</param>
            <exception cref="T:System.ArgumentException">if the number of coordinates/elevations was not exactly 4</exception>
        </member>
        <member name="T:NCDK.Hash.Stereo.Tetrahedral3DParity">
            <summary>
            Geometric parity for 3D tetrahedral geometry. This class requires four 3D
            coordinates. The 3D coordinates correspond to the four ligands of a
            tetrahedral atom. If a tetrahedral atom has an implicit hydrogen (only 3
            ligands) the forth coordinate should be that of the atom at the centre
            <see href="http://www.mdpi.org/molecules/papers/61100915/61100915.htm">Cieplak, T and Wisniewski, J.L. 2001</see>.
            </summary>
        </member>
        <member name="M:NCDK.Hash.Stereo.Tetrahedral3DParity.#ctor(NCDK.Numerics.Vector3[])">
            <summary>
            Create a new geometric parity for 3D tetrahedral geometry by specifying
            the coordinates.
            </summary>
            <param name="coordinates">non-null, 4 3D coordinates</param>
            <exception cref="T:System.ArgumentException">if the number of coordinates was not 4</exception>
        </member>
        <member name="T:NCDK.Hash.Stereo.TetrahedralElementEncoderFactory">
            <summary>
            Defines a stereo encoder factory for the hash code. The factory allows the
            generation of stereo hash codes for molecules with predefined
            <see cref="T:NCDK.ITetrahedralChirality"/> stereo elements.
            </summary>
        </member>
        <member name="M:NCDK.Hash.Stereo.TetrahedralElementEncoderFactory.Encoder(NCDK.ITetrahedralChirality,System.Collections.Generic.IDictionary{NCDK.IAtom,System.Int32})">
            <summary>
            Create an encoder for the <see cref="T:NCDK.ITetrahedralChirality"/> element.
            </summary>
            <param name="tc">stereo element from an atom container</param>
            <param name="atomToIndex">map of atoms to indices</param>
            <returns>a new geometry encoder</returns>
        </member>
        <member name="M:NCDK.Hash.Stereo.TetrahedralElementEncoderFactory.IndexMap(System.Collections.Generic.IDictionary{NCDK.IAtom,System.Int32},NCDK.IAtomContainer)">
            <summary>
            Lazy creation of an atom index map.
            </summary>
            <param name="map">existing map (possibly null)</param>
            <param name="container">the container we want the map for</param>
            <returns>a usable atom to index map for the given container</returns>
        </member>
        <member name="T:NCDK.Hash.Suppressed">
            <summary>
            Defines a structure which indicates whether a vertex (int id) is suppressed
            when computing an atomic/molecular hash code.
            </summary>
        </member>
        <member name="M:NCDK.Hash.Suppressed.Contains(System.Int32)">
            <summary>
            Is the vertex <paramref name="i"/> contained in the vertices which should be suppressed.
            </summary>
            <param name="i">vertex index</param>
            <returns>the vertex is supressed</returns>
        </member>
        <member name="P:NCDK.Hash.Suppressed.Count">
            <summary>
            The total number of suppressed vertices.
            </summary>
            <returns>number of suppressed vertices 0 .. |V|</returns>
        </member>
        <member name="M:NCDK.Hash.Suppressed.ToArray">
            <summary>
            Access which vertices are suppressed as a fixed-size array.
            </summary>
            <returns>the suppressed vertices</returns>
        </member>
        <member name="T:NCDK.Hash.Suppressed.Empty">
            <summary>Default 'empty' implementation always returns false.</summary>
        </member>
        <member name="T:NCDK.Hash.Suppressed.SuppressedBitSet">
            <summary>
            Implementation where the suppressed vertices are indicated with a BitArray.
            </summary>
        </member>
        <member name="F:NCDK.Hash.Suppressed.SuppressedBitSet.set">
            <summary>Bits indicate suppressed vertices.</summary>
        </member>
        <member name="M:NCDK.Hash.Suppressed.SuppressedBitSet.#ctor(System.Collections.BitArray)">
            <summary>
            Create a new suppressed instance with the specified vertices
            suppressed.
            </summary>
            <param name="set">bits indicates suppressed</param>
        </member>
        <member name="F:NCDK.Hash.Suppressed.empty">
            <summary>default implementation.</summary>
        </member>
        <member name="F:NCDK.Hash.Suppressed.None">
            <summary>
            Access a suppressed implementation where no vertices are suppressed.
            </summary>
            <returns>implementation where all vertices are unsuppressed</returns>
        </member>
        <member name="M:NCDK.Hash.Suppressed.FromBitSet(System.Collections.BitArray)">
            <summary>
            Create a suppressed implementation for the provided BitArray.
            </summary>
            <param name="set">bits indicated suppressed vertices</param>
            <returns>implementation using the BitArray to lookup suppressed vertices</returns>
        </member>
        <member name="T:NCDK.Hash.SuppressedAtomHashGenerator">
             <summary>
             A generator for atom hash codes where atoms maybe be <i>suppressed</i>. A
             common usage would be compute the hash code for a molecule with explicit
             hydrogens but ignore any values for the explicit hydrogens. This particularly
             useful for stereo-centres where by removing explicit hydrogens could affect
             the configuration.
            
             The suppress atom hashes are returned as '0'.
             </summary>
             <seealso cref="T:NCDK.Hash.SeedGenerator"/>
        </member>
        <member name="F:NCDK.Hash.SuppressedAtomHashGenerator.suppression">
            <summary>
            Function used to indicate which atoms should be suppressed. One can think
            of this as 'masking' out a value.
            </summary>
        </member>
        <member name="M:NCDK.Hash.SuppressedAtomHashGenerator.#ctor(NCDK.Hash.IAtomHashGenerator,NCDK.Hash.Pseudorandom,NCDK.Hash.Stereo.IStereoEncoderFactory,NCDK.Hash.AtomSuppression,System.Int32)">
            <summary>
            Create a basic hash generator using the provided seed generator to
            initialise atom invariants and using the provided stereo factory.
            </summary>
            <param name="seedGenerator">generator to seed the initial values of atoms</param>
            <param name="pseudorandom">pseudorandom number generator used to randomise hash distribution</param>
            <param name="factory">a stereo encoder factory</param>
            <param name="suppression">defines which atoms are suppressed - that is masked from the hash</param>
            <param name="depth">depth of the hashing function, larger values take longer</param>
            <exception cref="T:System.ArgumentException">depth was less then 0</exception>
            <exception cref="T:System.ArgumentNullException">    seed generator or pseudo random was null</exception>
            <seealso cref="T:NCDK.Hash.SeedGenerator"/>
        </member>
        <member name="M:NCDK.Hash.SuppressedAtomHashGenerator.#ctor(NCDK.Hash.IAtomHashGenerator,NCDK.Hash.Pseudorandom,NCDK.Hash.AtomSuppression,System.Int32)">
            <summary>
            Create a basic hash generator using the provided seed generator to
            initialise atom invariants and no stereo configuration.
            </summary>
            <param name="seedGenerator">generator to seed the initial values of atoms</param>
            <param name="pseudorandom">pseudorandom number generator used to randomise hash distribution</param>
            <param name="suppression">defines which atoms are suppressed (i.e. masked) from the hash code</param>
            <param name="depth">depth of the hashing function, larger values take longer</param>
            <exception cref="T:System.ArgumentException">depth was less then 0</exception>
            <exception cref="T:System.ArgumentNullException">seed generator or pseudo random was null</exception>
            <seealso cref="T:NCDK.Hash.SeedGenerator"/>
        </member>
        <member name="M:NCDK.Hash.SuppressedAtomHashGenerator.Generate(System.Int64[],NCDK.Hash.Stereo.IStereoEncoder,System.Int32[][],NCDK.Hash.Suppressed)">
            <summary>
            Package-private method for generating the hash for the given molecule.
            The initial invariants are passed as to the method along with an
            adjacency list representation of the graph.
            </summary>
            <param name="current">initial invariants</param>
            <param name="encoder"></param>
            <param name="graph">adjacency list representation</param>
            <param name="suppressed"></param>
            <returns>hash codes for atoms</returns>
        </member>
        <member name="M:NCDK.Hash.SuppressedAtomHashGenerator.Next(System.Int32[][],System.Int32,System.Int64[],System.Int64[],System.Int64[],NCDK.Hash.Suppressed)">
            <summary>
            Determine the next value of the atom at index <paramref name="v"/>. The value is
            calculated by combining the current values of adjacent atoms. When a
            duplicate value is found it can not be directly included and is
            <i>rotated</i> the number of times it has previously been seen.
            </summary>
            <param name="graph">adjacency list representation of connected atoms</param>
            <param name="v">the atom to calculate the next value for</param>
            <param name="current">the current values</param>
            <param name="unique">buffer for working out which adjacent values are unique</param>
            <param name="included">buffer for storing the rotated <i>unique</i> value, this value is <i>rotated</i> each time the same value is found.</param>
            <param name="suppressed">bit set indicates which atoms are 'suppressed'</param>
            <returns>the next value for <paramref name="v"/></returns>
        </member>
        <member name="T:NCDK.Hash.Xorshift">
            <summary>
            A fast pseudorandom number generator based on feedback shift registers.
            </summary>
            <seealso href="http://en.wikipedia.org/wiki/Xorshift">Xorshift</seealso>
            <seealso href="http://www.javamex.com/tutorials/random_numbers/xorshift.shtml">Xorshift random number generators</seealso>
        </member>
        <member name="M:NCDK.Hash.Xorshift.Next(System.Int64)">
            <summary>
            Generate the next pseudorandom number for the provided <paramref name="seed"/>.
            </summary>
            <param name="seed">random number seed</param>
            <returns>the next pseudorandom number</returns>
        </member>
        <member name="T:NCDK.Hybridization">
            <summary>
            Hybridization states.
            </summary>
        </member>
        <member name="T:NCDK.Hybridization.O">
            <summary>
            The <see cref="P:NCDK.Hybridization.Ordinal"/> values of <see cref="T:NCDK.Hybridization"/>.
            </summary>
            <seealso cref="T:NCDK.Hybridization"/>
        </member>
        <member name="P:NCDK.Hybridization.Ordinal">
            <summary>
            The ordinal of this enumeration constant. The list is in <see cref="T:NCDK.Hybridization.O"/>.
            </summary>
            <seealso cref="T:NCDK.Hybridization.O"/>
        </member>
        <member name="M:NCDK.Hybridization.ToString">
            <inheritdoc/>
        </member>
        <member name="F:NCDK.Hybridization.Unset">
            <summary>
            A undefined hybridization.
            </summary>
        </member>
        <member name="F:NCDK.Hybridization.SP1">
            <summary>
            A geometry of neighboring atoms when an s orbital is hybridized with one p orbital.
            </summary>
        </member>
        <member name="F:NCDK.Hybridization.SP2">
            <summary>
            A geometry of neighboring atoms when an s orbital is hybridized with two p orbitals.
            </summary>
        </member>
        <member name="F:NCDK.Hybridization.SP3">
            <summary>
            A geometry of neighboring atoms when an s orbital is hybridized with three p orbitals.
            </summary>
        </member>
        <member name="F:NCDK.Hybridization.Planar3">
            <summary>
            trigonal planar (lone pair in pz)
            </summary>
        </member>
        <member name="F:NCDK.Hybridization.SP3D1">
            <summary>
            A geometry of neighboring atoms when an s orbital is hybridized with three p orbitals with one d orbital.
            </summary>
        </member>
        <member name="F:NCDK.Hybridization.SP3D2">
            <summary>
            A geometry of neighboring atoms when an s orbital is hybridized with three p orbitals with two d orbitals.
            </summary>
        </member>
        <member name="F:NCDK.Hybridization.SP3D3">
            <summary>
            A geometry of neighboring atoms when an s orbital is hybridized with three p orbitals with three d orbitals.
            </summary>
        </member>
        <member name="F:NCDK.Hybridization.SP3D4">
            <summary>
            A geometry of neighboring atoms when an s orbital is hybridized with three p orbitals with four d orbitals.
            </summary>
        </member>
        <member name="F:NCDK.Hybridization.SP3D5">
            <summary>
            A geometry of neighboring atoms when an s orbital is hybridized with three p orbitals with five d orbitals.
            </summary>
        </member>
        <member name="M:NCDK.Hybridization.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Hybridization.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Hybridization.CompareTo(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Hybridization.CompareTo(NCDK.Hybridization)">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.DoubleBondConformation">
            <summary>
            Enumeration that defines the two possible values for this stereochemistry type.
            </summary>
        </member>
        <member name="T:NCDK.DoubleBondConformation.O">
            <summary>
            The <see cref="P:NCDK.DoubleBondConformation.Ordinal"/> values of <see cref="T:NCDK.DoubleBondConformation"/>.
            </summary>
            <seealso cref="T:NCDK.DoubleBondConformation"/>
        </member>
        <member name="P:NCDK.DoubleBondConformation.Ordinal">
            <summary>
            The ordinal of this enumeration constant. The list is in <see cref="T:NCDK.DoubleBondConformation.O"/>.
            </summary>
            <seealso cref="T:NCDK.DoubleBondConformation.O"/>
        </member>
        <member name="M:NCDK.DoubleBondConformation.ToString">
            <inheritdoc/>
        </member>
        <member name="F:NCDK.DoubleBondConformation.Together">
            <summary>
            Z-form
            </summary>
        </member>
        <member name="F:NCDK.DoubleBondConformation.Opposite">
            <summary>
            E-form
            </summary>
        </member>
        <member name="M:NCDK.DoubleBondConformation.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.DoubleBondConformation.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.DoubleBondConformation.CompareTo(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.DoubleBondConformation.CompareTo(NCDK.DoubleBondConformation)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.DoubleBondConformation.Invert">
            <summary>
            Invert this conformation, Together.Invert() = Opposite, Opposite.Invert() = Together.
            </summary>
            <returns>the inverse conformation</returns>
        </member>
        <member name="T:NCDK.Events.ICDKChangeListener">
            <summary>
            A ChangeListener for the CDK, to be independent from the Swing package.
            </summary>
        </member>
        <member name="M:NCDK.Events.ICDKChangeListener.StateChanged(NCDK.ChemObjectChangeEventArgs)">
            <summary>
            Invoked when the target of the listener has changed its state.
            </summary>The EventObject
            <param name="evt"></param>
        </member>
        <member name="T:NCDK.Events.ICDKSelectionChangeListener">
            <summary>
            A ChangeListener for the CDK, to be independent from the Swing package.
            </summary>
        </member>
        <member name="M:NCDK.Events.ICDKSelectionChangeListener.StateChanged(System.EventArgs)">
            <summary>
            Invoked when the target of the listener has changed its state.
            </summary>
            <param name="evt">The EventObject</param>
        </member>
        <member name="T:NCDK.SGroups.SgroupType">
            <summary>
            Enumeration of Ctab Sgroup types.
            </summary>
            <remarks>
            <b>Display shortcuts</b>
            <list type="bullet">
            <item>SUP, abbreviation Sgroup (formerly called superatom)</item>
            <item>MUL, multiple group</item>
            <item>GEN, generic</item>
            </list>
            <b>Polymers</b>
            <list type="bullet">
            <item>SRU, SRU type</item>
            <item>MON, monomer</item>
            <item>MER, Mer type</item>
            <item>COP, copolymer</item>
            <item>CRO, crosslink</item>
            <item>MOD, modification</item>
            <item>GRA, graft</item>
            <item>ANY, any polymer</item> 
            </list>
            <b>Components, Mixtures, and formulations</b>
            <list type="bullet">
            <item>COM, component</item>
            <item>MIX, mixture</item>
            <item>FOR, formulation</item>
            </list>
            <b>Non-chemical</b>
            <list type="bullet">
            <item>DAT, data Sgroup</item>
            </list>
            </remarks>
        </member>
        <member name="T:NCDK.SGroups.SgroupType.O">
            <summary>
            The <see cref="P:NCDK.SGroups.SgroupType.Ordinal"/> values of <see cref="T:NCDK.SGroups.SgroupType"/>.
            </summary>
            <seealso cref="T:NCDK.SGroups.SgroupType"/>
        </member>
        <member name="P:NCDK.SGroups.SgroupType.Ordinal">
            <summary>
            The ordinal of this enumeration constant. The list is in <see cref="T:NCDK.SGroups.SgroupType.O"/>.
            </summary>
            <seealso cref="T:NCDK.SGroups.SgroupType.O"/>
        </member>
        <member name="M:NCDK.SGroups.SgroupType.ToString">
            <inheritdoc/>
        </member>
        <member name="F:NCDK.SGroups.SgroupType.CtabAbbreviation">
            <summary>
            SUP, abbreviation Sgroup (formerly called superatom)
            </summary>
        </member>
        <member name="F:NCDK.SGroups.SgroupType.CtabMultipleGroup">
            <summary>
            MUL, multiple group
            </summary>
        </member>
        <member name="F:NCDK.SGroups.SgroupType.CtabStructureRepeatUnit">
            <summary>
            GEN, generic
            </summary>
        </member>
        <member name="F:NCDK.SGroups.SgroupType.CtabMonomer">
            <summary>
            SRU, SRU type
            </summary>
        </member>
        <member name="F:NCDK.SGroups.SgroupType.CtabModified">
            <summary>
            MON, monomer
            </summary>
        </member>
        <member name="F:NCDK.SGroups.SgroupType.CtabCopolymer">
            <summary>
            MER, Mer type
            </summary>
        </member>
        <member name="F:NCDK.SGroups.SgroupType.CtabMer">
            <summary>
            COP, copolymer
            </summary>
        </member>
        <member name="F:NCDK.SGroups.SgroupType.CtabCrossLink">
            <summary>
            CRO, crosslink
            </summary>
        </member>
        <member name="F:NCDK.SGroups.SgroupType.CtabGraft">
            <summary>
            MOD, modification
            </summary>
        </member>
        <member name="F:NCDK.SGroups.SgroupType.CtabAnyPolymer">
            <summary>
            GRA, graft
            </summary>
        </member>
        <member name="F:NCDK.SGroups.SgroupType.CtabComponent">
            <summary>
            ANY, any polymer
            </summary>
        </member>
        <member name="F:NCDK.SGroups.SgroupType.CtabMixture">
            <summary>
            COM, component
            </summary>
        </member>
        <member name="F:NCDK.SGroups.SgroupType.CtabFormulation">
            <summary>
            MIX, mixture
            </summary>
        </member>
        <member name="F:NCDK.SGroups.SgroupType.CtabData">
            <summary>
            FOR, formulation
            </summary>
        </member>
        <member name="F:NCDK.SGroups.SgroupType.CtabGeneric">
            <summary>
            DAT, data Sgroup
            </summary>
        </member>
        <member name="M:NCDK.SGroups.SgroupType.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.SGroups.SgroupType.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.SGroups.SgroupType.CompareTo(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.SGroups.SgroupType.CompareTo(NCDK.SGroups.SgroupType)">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.SGroups.Sgroup">
            <summary>
            Generic CTab Sgroup (substructure group) that stores all other types of group. This representation
            is allows reading from CTfiles (e.g. Molfile, SDfile).
            </summary>
            <remarks>
            The class uses a key-value store for Sgroup attributes simplifying both input and output.
            </remarks>
        </member>
        <member name="P:NCDK.SGroups.Sgroup.Atoms">
            <summary>
            the atoms of this substructure group.
            </summary>
        </member>
        <member name="P:NCDK.SGroups.Sgroup.Bonds">
            <summary>
            Access the bonds that belong to this substructure group.
            For data Sgroups, the bonds are the containment bonds,
            for all other <see cref="T:NCDK.SGroups.Sgroup"/> types, they are crossing bonds.
            </summary>
        </member>
        <member name="P:NCDK.SGroups.Sgroup.Parents">
            <summary>
            the parents of this Sgroup.
            </summary>
        </member>
        <member name="M:NCDK.SGroups.Sgroup.#ctor">
            <summary>
            Create a new generic Sgroup.
            </summary>
        </member>
        <member name="M:NCDK.SGroups.Sgroup.#ctor(NCDK.SGroups.Sgroup)">
            <summary>
            Copy constructor.
            </summary>
            <param name="org">original Sgroup instance</param>
        </member>
        <member name="P:NCDK.SGroups.Sgroup.AttributeKeys">
            <summary>
            Access all the attribute keys of this Sgroup.
            </summary>
            <returns>attribute keys</returns>
        </member>
        <member name="P:NCDK.SGroups.Sgroup.Type">
            <summary>
            The type of the Sgroup.
            </summary>
        </member>
        <member name="M:NCDK.SGroups.Sgroup.Add(NCDK.IAtom)">
            <summary>
            Add a bond to this Sgroup.
            </summary>
            <param name="atom">the atom</param>
        </member>
        <member name="M:NCDK.SGroups.Sgroup.Add(NCDK.IBond)">
            <summary>
            Add a bond to this Sgroup. The bond list
            </summary>
            <param name="bond">bond to add</param>
        </member>
        <member name="M:NCDK.SGroups.Sgroup.AddParent(NCDK.SGroups.Sgroup)">
            <summary>
            Add a parent Sgroup.
            </summary>
            <param name="parent">parent sgroup</param>
        </member>
        <member name="M:NCDK.SGroups.Sgroup.RemoveParents(System.Collections.Generic.IEnumerable{NCDK.SGroups.Sgroup})">
            <summary>
            Remove the specified parent associations from this Sgroup.
            </summary>
            <param name="parents">parent associations</param>
        </member>
        <member name="M:NCDK.SGroups.Sgroup.PutValue(NCDK.SGroups.SgroupKeys,System.Object)">
            <summary>
            Store an attribute for the Sgroup.
            </summary>
            <param name="key">attribute key</param>
            <param name="val">attribute value</param>
        </member>
        <member name="M:NCDK.SGroups.Sgroup.GetValue(NCDK.SGroups.SgroupKeys)">
            <summary>
            Access an attribute for the Sgroup.
            </summary>
            <param name="key">attribute key</param>
        </member>
        <member name="P:NCDK.SGroups.Sgroup.Subscript">
            <summary>
            Access the subscript value.
            </summary>
            <returns>subscript value (or null if not present)</returns>
        </member>
        <member name="M:NCDK.SGroups.Sgroup.AddBracket(NCDK.SGroups.SgroupBracket)">
            <summary>
            Add a bracket for this Sgroup.
            </summary>
            <param name="bracket">sgroup bracket</param>
        </member>
        <member name="M:NCDK.SGroups.Sgroup.Downcast``1">
            <summary>
            Downcast this, maybe generic, Sgroup to a specific concrete implementation. This
            method should be called on load by a reader once all data has been added to the sgroup.
            </summary>
            <typeparam name="T">return type</typeparam>
            <returns>downcast instance</returns>
        </member>
        <member name="T:NCDK.SGroups.SgroupBracket">
            <summary>
            Representation of an Sgroup bracket.
            </summary>
        </member>
        <member name="M:NCDK.SGroups.SgroupBracket.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Create an Sgroup bracket.
            </summary>
            <param name="x1">first x coord</param>
            <param name="y1">first y coord</param>
            <param name="x2">second x coord</param>
            <param name="y2">second y coord</param>
        </member>
        <member name="P:NCDK.SGroups.SgroupBracket.FirstPoint">
            <summary>
            First point of the bracket (x1,y1).
            </summary>
            <returns>first point</returns>
        </member>
        <member name="P:NCDK.SGroups.SgroupBracket.SecondPoint">
            <summary>
            Second point of the bracket (x2,y2).
            </summary>
            <returns>second point</returns>
        </member>
        <member name="T:NCDK.SGroups.SgroupKeys">
            <summary>
            Keys for indexing common Sgroup attributes. 
            </summary>
        </member>
        <member name="F:NCDK.SGroups.SgroupKeys.CtabLabel">
            <summary>
            Not to be confused with the subscript key
            this is Sgroup label not the bracket label (e.g. 'n').
            </summary>
        </member>
        <member name="T:NCDK.Smiles.CxSmilesState">
            <summary>
            Light-weight intermediate data-structure for transferring information CDK to/from
            CXSMILES.
            </summary>
        </member>
        <member name="T:NCDK.Smiles.CxSmilesState.Radical.O">
            <summary>
            The <see cref="P:NCDK.Smiles.CxSmilesState.Radical.Ordinal"/> values of <see cref="T:NCDK.Smiles.CxSmilesState.Radical"/>.
            </summary>
            <seealso cref="T:NCDK.Smiles.CxSmilesState.Radical"/>
        </member>
        <member name="P:NCDK.Smiles.CxSmilesState.Radical.Ordinal">
            <summary>
            The ordinal of this enumeration constant. The list is in <see cref="T:NCDK.Smiles.CxSmilesState.Radical.O"/>.
            </summary>
            <seealso cref="T:NCDK.Smiles.CxSmilesState.Radical.O"/>
        </member>
        <member name="M:NCDK.Smiles.CxSmilesState.Radical.ToString">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Smiles.CxSmilesState.Radical.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Smiles.CxSmilesState.Radical.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Smiles.CxSmilesState.Radical.CompareTo(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Smiles.CxSmilesState.Radical.CompareTo(NCDK.Smiles.CxSmilesState.Radical)">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Smiles.SMARTS.Parser.ParseException">
            <summary>
            This exception is thrown when parse errors are encountered.
            You can explicitly create objects of this exception type by
            calling the method generateParseException in the generated
            parser.
            </summary>
            <remarks>
            You can modify this class to customize your error reporting
            mechanisms so long as you retain the public fields.
            </remarks>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ParseException.#ctor(NCDK.Smiles.SMARTS.Parser.Token,System.Int32[][],System.String[])">
            <summary>
            This constructor is used by the method "generateParseException"
            in the generated parser.  Calling this constructor generates
            a new object of this type with the fields "currentToken",
            "expectedTokenSequences", and "tokenImage" set.
            </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ParseException.#ctor">
            <summary>
            The following constructors are for use by you for whatever
            purpose you can think of.  Constructing the exception in this
            manner makes the exception behave in the normal way - i.e., as
            documented in the class "Throwable".  The fields "errorToken",
            "expectedTokenSequences", and "tokenImage" do not contain
            relevant information.  The JavaCC generated code does not use
            these constructors.
            </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ParseException.#ctor(System.String)">
            <summary>Constructor with message.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.ParseException.currentToken">
            <summary>
            This is the last token that has been consumed successfully.  If
            this object has been created due to a parse error, the token
            followng this token will (therefore) be the first error token.
            </summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.ParseException.expectedTokenSequences">
            <summary>
            Each entry in this array is an array of integers.  Each array
            of integers represents a sequence of tokens (by their ordinal
            values) that is expected at this point of the parse.
            </summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.ParseException.tokenImage">
            <summary>
            This is a reference to the "tokenImage" array of the generated
            parser within which the parse error occurred.  This array is
            defined in the generated ...Constants interface.
            </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ParseException.Initialise(NCDK.Smiles.SMARTS.Parser.Token,System.Int32[][],System.String[])">
            <summary>
            It uses "currentToken" and "expectedTokenSequences" to generate a parse
            error message and returns it.  If this object has been created
            due to a parse error, and you do not catch it (it gets thrown
            from the parser) the correct error message
            gets displayed.
            </summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.ParseException.eol">
            <summary>
            The end of line string for this machine.
            </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ParseException.Add_escapes(System.String)">
            <summary>
            Used to convert raw characters to their escaped version
            when these raw version cannot be used as part of an ASCII
            string literal.
            </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ASTAliphatic.JJTAccept(NCDK.Smiles.SMARTS.Parser.SMARTSParserVisitor,System.Object)">
            <summary>Accept the visitor. </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ASTAnyAtom.JJTAccept(NCDK.Smiles.SMARTS.Parser.SMARTSParserVisitor,System.Object)">
            <summary>Accept the visitor. </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ASTAromatic.JJTAccept(NCDK.Smiles.SMARTS.Parser.SMARTSParserVisitor,System.Object)">
            <summary>Accept the visitor. </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ASTAtom.JJTAccept(NCDK.Smiles.SMARTS.Parser.SMARTSParserVisitor,System.Object)">
            <summary>Accept the visitor. </summary>
        </member>
        <member name="P:NCDK.Smiles.SMARTS.Parser.ASTAtomicMass.Mass">
            <summary>
            The mass value.
            </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ASTAtomicMass.JJTAccept(NCDK.Smiles.SMARTS.Parser.SMARTSParserVisitor,System.Object)">
            <summary>Accept the visitor. </summary>
        </member>
        <member name="P:NCDK.Smiles.SMARTS.Parser.ASTAtomicNumber.Number">
            <summary>
            the atomic number.
            </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ASTAtomicNumber.JJTAccept(NCDK.Smiles.SMARTS.Parser.SMARTSParserVisitor,System.Object)">
            <summary>Accept the visitor. </summary>
        </member>
        <member name="P:NCDK.Smiles.SMARTS.Parser.ASTCharge.Charge">
            <summary>
            The charge value.
            </summary>
        </member>
        <member name="P:NCDK.Smiles.SMARTS.Parser.ASTCharge.IsPositive">
            <summary>
            true if charge is positive.
            </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ASTCharge.JJTAccept(NCDK.Smiles.SMARTS.Parser.SMARTSParserVisitor,System.Object)">
            <summary>Accept the visitor. </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ASTChirality.JJTAccept(NCDK.Smiles.SMARTS.Parser.SMARTSParserVisitor,System.Object)">
            <summary>Accept the visitor. </summary>
        </member>
        <member name="P:NCDK.Smiles.SMARTS.Parser.ASTElement.Symbol">
            <summary>
            the element symbol.
            </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ASTElement.JJTAccept(NCDK.Smiles.SMARTS.Parser.SMARTSParserVisitor,System.Object)">
            <summary>Accept the visitor. </summary>
        </member>
        <member name="P:NCDK.Smiles.SMARTS.Parser.ASTExplicitAtom.Symbol">
            <summary>
            The element symbol.
            </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ASTExplicitAtom.JJTAccept(NCDK.Smiles.SMARTS.Parser.SMARTSParserVisitor,System.Object)">
            <summary>Accept the visitor. </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ASTExplicitConnectivity.JJTAccept(NCDK.Smiles.SMARTS.Parser.SMARTSParserVisitor,System.Object)">
            <summary>Accept the visitor. </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ASTExplicitHighAndBond.JJTAccept(NCDK.Smiles.SMARTS.Parser.SMARTSParserVisitor,System.Object)">
            <summary>Accept the visitor. </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ASTExplicitHighAndExpression.JJTAccept(NCDK.Smiles.SMARTS.Parser.SMARTSParserVisitor,System.Object)">
            <summary>Accept the visitor. </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ASTGroup.JJTAccept(NCDK.Smiles.SMARTS.Parser.SMARTSParserVisitor,System.Object)">
            <summary>Accept the visitor. </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ASTHybrdizationNumber.JJTAccept(NCDK.Smiles.SMARTS.Parser.SMARTSParserVisitor,System.Object)">
            <summary>Accept the visitor. </summary>
        </member>
        <member name="P:NCDK.Smiles.SMARTS.Parser.ASTImplicitHCount.Count">
            <summary>
            Implicit H count.
            </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ASTImplicitHCount.JJTAccept(NCDK.Smiles.SMARTS.Parser.SMARTSParserVisitor,System.Object)">
            <summary>Accept the visitor. </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ASTImplicitHighAndBond.JJTAccept(NCDK.Smiles.SMARTS.Parser.SMARTSParserVisitor,System.Object)">
            <summary>Accept the visitor. </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ASTImplicitHighAndExpression.JJTAccept(NCDK.Smiles.SMARTS.Parser.SMARTSParserVisitor,System.Object)">
            <summary>Accept the visitor. </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ASTLowAndBond.JJTAccept(NCDK.Smiles.SMARTS.Parser.SMARTSParserVisitor,System.Object)">
            <summary>Accept the visitor. </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ASTLowAndExpression.JJTAccept(NCDK.Smiles.SMARTS.Parser.SMARTSParserVisitor,System.Object)">
            <summary>Accept the visitor. </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ASTNonCHHeavyAtom.JJTAccept(NCDK.Smiles.SMARTS.Parser.SMARTSParserVisitor,System.Object)">
            <summary>Accept the visitor. </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ASTNotBond.JJTAccept(NCDK.Smiles.SMARTS.Parser.SMARTSParserVisitor,System.Object)">
            <summary>Accept the visitor. </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ASTNotExpression.JJTAccept(NCDK.Smiles.SMARTS.Parser.SMARTSParserVisitor,System.Object)">
            <summary>Accept the visitor. </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ASTOrBond.JJTAccept(NCDK.Smiles.SMARTS.Parser.SMARTSParserVisitor,System.Object)">
            <summary>Accept the visitor. </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ASTOrExpression.JJTAccept(NCDK.Smiles.SMARTS.Parser.SMARTSParserVisitor,System.Object)">
            <summary>Accept the visitor. </summary>
        </member>
        <member name="P:NCDK.Smiles.SMARTS.Parser.ASTPeriodicGroupNumber.GroupNumber">
            <summary>
            The periodic table group number for this element.
            </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ASTPeriodicGroupNumber.JJTAccept(NCDK.Smiles.SMARTS.Parser.SMARTSParserVisitor,System.Object)">
            <summary>Accept the visitor. </summary>
        </member>
        <member name="T:NCDK.Smiles.SMARTS.Parser.ASTPrimitiveAtomExpression">
            <summary>
            An AST node. It represents one type of atomic primitive notation in smarts.
            </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ASTPrimitiveAtomExpression.#ctor(System.Int32)">
            <summary>
            Creates a new instance.
            </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ASTPrimitiveAtomExpression.#ctor(NCDK.Smiles.SMARTS.Parser.SMARTSParser,System.Int32)">
            <summary>
            Creates a new instance.
            </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ASTReaction.JJTAccept(NCDK.Smiles.SMARTS.Parser.SMARTSParserVisitor,System.Object)">
            <summary>Accept the visitor. </summary>
        </member>
        <member name="P:NCDK.Smiles.SMARTS.Parser.ASTRingConnectivity.NumOfConnection">
            <summary>
            The number of ring connections.
            </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ASTRingConnectivity.JJTAccept(NCDK.Smiles.SMARTS.Parser.SMARTSParserVisitor,System.Object)">
            <summary>Accept the visitor. </summary>
        </member>
        <member name="P:NCDK.Smiles.SMARTS.Parser.ASTRingIdentifier.RingId">
            <summary>
            The ring identifier.
            </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ASTRingIdentifier.JJTAccept(NCDK.Smiles.SMARTS.Parser.SMARTSParserVisitor,System.Object)">
            <summary>Accept the visitor. </summary>
        </member>
        <member name="P:NCDK.Smiles.SMARTS.Parser.ASTRingMembership.NumOfMembership">
            <summary>
            The number of SSSR rings this atom is in.
            </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ASTRingMembership.JJTAccept(NCDK.Smiles.SMARTS.Parser.SMARTSParserVisitor,System.Object)">
            <summary>Accept the visitor. </summary>
        </member>
        <member name="P:NCDK.Smiles.SMARTS.Parser.ASTSimpleBond.BondType">
            <summary>
            Type of bond.
            </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ASTSimpleBond.JJTAccept(NCDK.Smiles.SMARTS.Parser.SMARTSParserVisitor,System.Object)">
            <summary>Accept the visitor. </summary>
        </member>
        <member name="P:NCDK.Smiles.SMARTS.Parser.ASTSmallestRingSize.Size">
            <summary>
            The smallest SSSR size.
            </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ASTSmallestRingSize.JJTAccept(NCDK.Smiles.SMARTS.Parser.SMARTSParserVisitor,System.Object)">
            <summary>Accept the visitor. </summary>
        </member>
        <member name="P:NCDK.Smiles.SMARTS.Parser.ASTSmarts.ComponentId">
            <summary>
            Indicate that component-level grouping should applied and this expression
            belongs to the specified component.
            </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ASTSmarts.JJTAccept(NCDK.Smiles.SMARTS.Parser.SMARTSParserVisitor,System.Object)">
            <summary>Accept the visitor. </summary>
        </member>
        <member name="P:NCDK.Smiles.SMARTS.Parser.ASTTotalConnectivity.NumOfConnection">
            <summary>
            The number of total connections.
            </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ASTTotalConnectivity.JJTAccept(NCDK.Smiles.SMARTS.Parser.SMARTSParserVisitor,System.Object)">
            <summary>Accept the visitor. </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ASTTotalHCount.JJTAccept(NCDK.Smiles.SMARTS.Parser.SMARTSParserVisitor,System.Object)">
            <summary>Accept the visitor. </summary>
        </member>
        <member name="P:NCDK.Smiles.SMARTS.Parser.ASTValence.Order">
            <summary>
            valence order.
            </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ASTValence.JJTAccept(NCDK.Smiles.SMARTS.Parser.SMARTSParserVisitor,System.Object)">
            <summary>Accept the visitor. </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.Node.JJTOpen">
            <summary> This method is called after the node has been made the current node.  It indicates that child nodes can now be added to it.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.Node.JJTClose">
            <summary> This method is called after all the child nodes have been added.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.Node.JJTSetParent(NCDK.Smiles.SMARTS.Parser.Node)">
            <summary> This pair of methods are used to inform the node of its parent.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.Node.JJTAddChild(NCDK.Smiles.SMARTS.Parser.Node,System.Int32)">
            <summary> This method tells the node to add its argument to the node's list of children. </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.Node.JJTGetChild(System.Int32)">
            <summary> This method returns a child node.  The children are numbered from zero, left to right.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.Node.JJTGetNumChildren">
            <summary>Return the number of children the node has.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.Node.JJTAccept(NCDK.Smiles.SMARTS.Parser.SMARTSParserVisitor,System.Object)">
            <summary>Accept the visitor. </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.Node.JJTRemoveChild(System.Int32)">
            <summary>
            Removes a child from this node
            </summary>
            <param name="i"></param>
        </member>
        <member name="T:NCDK.Smiles.SMARTS.Parser.SimpleCharStream">
            <summary>
            An implementation of interface CharStream, where the stream is assumed to
            contain only ASCII characters (without unicode processing).
            </summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SimpleCharStream.staticFlag">
            <summary>Whether parser is static.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SimpleCharStream.bufpos">
            <summary>Position in buffer.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SimpleCharStream.BeginToken">
            <summary>Start.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SimpleCharStream.ReadChar">
            <summary>Read a character.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SimpleCharStream.GetEndColumn">
            <summary>Get token end column number.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SimpleCharStream.GetEndLine">
            <summary>Get token end line number.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SimpleCharStream.GetBeginColumn">
            <summary>Get token beginning column number.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SimpleCharStream.GetBeginLine">
            <summary>Get token beginning line number.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SimpleCharStream.Backup(System.Int32)">
            <summary>Backup a number of characters.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SimpleCharStream.#ctor(System.IO.TextReader,System.Int32,System.Int32,System.Int32)">
            <summary>Constructor.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SimpleCharStream.#ctor(System.IO.TextReader,System.Int32,System.Int32)">
            <summary>Constructor.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SimpleCharStream.#ctor(System.IO.TextReader)">
            <summary>Constructor.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SimpleCharStream.ReInit(System.IO.TextReader,System.Int32,System.Int32,System.Int32)">
            <summary>Reinitialise.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SimpleCharStream.ReInit(System.IO.TextReader,System.Int32,System.Int32)">
            <summary>Reinitialise.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SimpleCharStream.ReInit(System.IO.TextReader)">
            <summary>Reinitialise.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SimpleCharStream.#ctor(System.IO.Stream,System.String,System.Int32,System.Int32,System.Int32)">
            <summary>Constructor.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SimpleCharStream.#ctor(System.IO.Stream,System.Int32,System.Int32,System.Int32)">
            <summary>Constructor.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SimpleCharStream.#ctor(System.IO.Stream,System.String,System.Int32,System.Int32)">
            <summary>Constructor.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SimpleCharStream.#ctor(System.IO.Stream,System.Int32,System.Int32)">
            <summary>Constructor.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SimpleCharStream.#ctor(System.IO.Stream,System.String)">
            <summary>Constructor.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SimpleCharStream.#ctor(System.IO.Stream)">
            <summary>Constructor.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SimpleCharStream.ReInit(System.IO.Stream,System.String,System.Int32,System.Int32,System.Int32)">
            <summary>Reinitialise.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SimpleCharStream.ReInit(System.IO.Stream,System.Int32,System.Int32,System.Int32)">
            <summary>Reinitialise.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SimpleCharStream.ReInit(System.IO.Stream,System.String)">
            <summary>Reinitialise.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SimpleCharStream.ReInit(System.IO.Stream)">
            <summary>Reinitialise.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SimpleCharStream.ReInit(System.IO.Stream,System.String,System.Int32,System.Int32)">
            <summary>Reinitialise.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SimpleCharStream.ReInit(System.IO.Stream,System.Int32,System.Int32)">
            <summary>Reinitialise.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SimpleCharStream.GetImage">
            <summary>Get token literal value.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SimpleCharStream.GetSuffix(System.Int32)">
            <summary>Get the suffix.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SimpleCharStream.Done">
            <summary>Reset buffer when finished.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SimpleCharStream.AdjustBeginLineColumn(System.Int32,System.Int32)">
            <summary>
            Method to adjust line and column numbers for the start of a token.
            </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SimpleNode.JJTAccept(NCDK.Smiles.SMARTS.Parser.SMARTSParserVisitor,System.Object)">
            <summary>Accept the visitor. </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SimpleNode.childrenAccept(NCDK.Smiles.SMARTS.Parser.SMARTSParserVisitor,System.Object)">
            <summary>Accept the visitor. </summary>
        </member>
        <member name="T:NCDK.Smiles.SMARTS.Parser.Smarts2MQLVisitor">
            <summary>
            An AST tree visitor. It is a prototype that translate Smarts to MQL.
            It is far from fully functioning.
            </summary>
        </member>
        <member name="T:NCDK.Smiles.SMARTS.Parser.SmartsDumpVisitor">
            <summary>
            An AST Tree visitor. It dumps the whole AST tree into console
            </summary>
        </member>
        <member name="T:NCDK.Smiles.SMARTS.Parser.SMARTSParser">
            <summary>
            This parser implements a nearly complete subset of the SMARTS syntax as defined on
            <see href="http://www.daylight.com/dayhtml/doc/theory/theory.smarts.html">the Daylight website</see>. 
            </summary>
            <example>
            <para>
            Example code using SMARTS substructure search looks like:
            <code>            SmilesParser sp = new SmilesParser(Silent.ChemObjectBuilder.Instance);
             IAtomContainer atomContainer = sp.ParseSmiles("CC(=O)OC(=O)C");
             QueryAtomContainer query = SMARTSParser.Parse("C*C", Silent.ChemObjectBuilder.Instance);
             bool queryMatch = universalIsomorphismTester.IsSubgraph(atomContainer, query);
</code>
            </para>
            <para>See the <see cref="!:NCDK.Smiles.SMARTS.Parser.ParserTest" /> for examples of the implemented
            subset.
            </para>
            </example>
            <remarks>
            This parser is based on JJTree and it generates an AST (Abstract Syntax Tree)
            <para>To get the AST, the code looks like:
            <code>             SMARTSParser parser = new SMARTSParser(new StringReader("C*C"));
             ASTStart start = parser.Start();
</code>
            </para>
            </remarks>
            <seealso cref="T:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtom" />
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SMARTSParser.Parse(System.String,NCDK.IChemObjectBuilder)">
            <summary>
            This method parses a Smarts String and returns an instance of <see cref="T:NCDK.Isomorphisms.Matchers.QueryAtomContainer"/>.
            </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SMARTSParser.Start">
            <summary>
            <![CDATA[
                                Start ::= <ReactionExpression> <#_WS>
                   ReactionExpression ::= <GroupExpression>? (">" <GroupExpression>? ">" <GroupExpression>?)?
                      GroupExpression ::= ["("] <SmartsExpresion> [")"] ( "." ["("] <SmartsExpression> [")"] )*
                     SmartsExpression ::= <AtomExpression> (
            ( [ <LowAndBond> ] ( <Digit> | <AtomExpression> ) ) |
            ( "(" [ <LowAndBond> ] <SmartsExpression> ")" ) )*
            AtomExpression ::= ( "[" [ <AtomicMass> ] <LowAndExpression> [:<Digit>+] "]" ) | <ExplicitAtomExpression>
                           LowAndBond ::= <OrBond> [ ";" <AndBond> ]
                               OrBond ::= <ExplicitHighAndBond> [ "," <OrBond> ]
                  ExplicitHighAndBond ::= <ImplicitHighAndBond> [ "&" <ExplicitHighAndBond> ]
                  ImplicitHighAndBond ::= <NotBond> [ <ImplicitHighAndBond> ]
                              NotBond ::= [ "!" ] <SimpleBond>
                           SimpleBond ::= "/" | "\\" | "/?" | "\\?" | "=" | "#" | "~" | "@"
               ExplicitAtomExpression ::= [ "B" | "C" | "N" | "O" | "P" | "S" | "F" | "CL" | "BR" | "I"
                                          | "c" | "o" | "n" | "*" | "A" | "a" | "p" | "as" | "se" ]
                     LowAndExpression ::= <OrExpression> ( ";" <LowAndExpression> )?
                         OrExpression ::= <ExplicitHighAndExpression> ( "," <OrExpression> ) ?
            ExplicitHighAndExpression ::= <ImplicitHighAndExpression> ( "&" <ExplicitHighAndExpression> )?
            ImplicitHighAndExpression ::= <NotExpression> ( <ImplicitHighAndExpression> ) ?
                        NotExpression ::= "!" ( <PrimitiveAtomExpression> | <RecursiveSmartsExpression> )
            RecursiveSmartsExpression ::= "$" "(" <SmartsExpression> ")"
              PrimitiveAtomExpression ::= <NonHydrogenElement> | "*" | "A" | "a" | "D" (<Digits>)? | "H" (<Digits>)? | "h" (<Digits>)?
                                          | "R" (<Digit>+)? | "r" (<Digit>+)? | "v" (<Digit>+)? | "#X" | "G" (<DIGIT>+)
                                          | "X" (<Digit>+)? | "x" (<Digit>+)? | "^" (<DIGIT>)
                                          | ("+" | "-") (<Digit>+)? | "#" (<Digit>+) | "@" | "@@" | <Digit>+
                                Digit ::= ( "0" - "9")
                   NonHydrogenElement ::= [ "HE" | "LI" | "BE" | "NE" | "NA" | "MG" | "AL" | "SI" | "AR" | "CA" | "SC" |
                                          "TI" | "CR" | "MN" | "FE" | "CO" | "NI" | "CU" | "ZN" | "GA" | "GE" | "AS" |
                                          "SE" | "BR" | "KR" | "RB" | "SR" | "ZR" | "NB" | "MO" | "TC" | "RU" | "RH" |
                                          "PD" | "AG" | "CD" | "IN" | "SN" | "SB" | "TE" | "XE" | "CS" | "BA" | "LA" |
                                          "HF" | "TA" | "RE" | "OS" | "IR" | "PT" | "AU" | "HG" | "TL" | "PB" | "BI" |
                                          "PO" | "AT" | "RN" | "FR" | "RA" | "AC" | "TH" | "PA" |
                                          "B" | "C" | "N" | "O" | "F" | "P" | "S" | "K" | "V" | "Y" | "I" | "U" |
                                          "c" | "o" | "n" | "p" | "as" | "se" ]
            ]]>                               
            </summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParser.token_source">
            <summary>Generated Token Manager.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParser.token">
            <summary>Current token.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParser.jj_nt">
            <summary>Next token.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SMARTSParser.#ctor(System.IO.Stream)">
            <summary>Constructor with InputStream.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SMARTSParser.#ctor(System.IO.Stream,System.String)">
            <summary>Constructor with InputStream and supplied encoding</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SMARTSParser.ReInit(System.IO.Stream)">
            <summary>Reinitialise.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SMARTSParser.ReInit(System.IO.Stream,System.String)">
            <summary>Reinitialise.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SMARTSParser.#ctor(System.IO.TextReader)">
            <summary>Constructor.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SMARTSParser.ReInit(System.IO.TextReader)">
            <summary>Reinitialise.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SMARTSParser.#ctor(NCDK.Smiles.SMARTS.Parser.SMARTSParserTokenManager)">
            <summary>Constructor with generated Token Manager.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SMARTSParser.ReInit(NCDK.Smiles.SMARTS.Parser.SMARTSParserTokenManager)">
            <summary>Reinitialise.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SMARTSParser.GetNextToken">
            <summary>Get the next Token.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SMARTSParser.GetToken(System.Int32)">
            <summary>Get the specific Token.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SMARTSParser.GenerateParseException">
            <summary>Generate ParseException.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SMARTSParser.Enable_tracing">
            <summary>Enable tracing.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SMARTSParser.Disable_tracing">
            <summary>Disable tracing.</summary>
        </member>
        <member name="T:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants">
            <summary>
            Token literal values and constants.
            Generated by org.javacc.parser.OtherFilesGen#Start()
            </summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.EOF">
            <summary>End of File.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.WS">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.L_AND">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.H_AND">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.OR">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.NOT">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.S_BOND">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.UP_S_BOND">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.DN_S_BOND">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.UP_OR_UNSPECIFIED_S_BOND">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.DN_OR_UNSPECIFIED_S_BOND">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.D_BOND">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.T_BOND">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.AR_BOND">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.ANY_BOND">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.R_BOND">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.c">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.n">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.o">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.s">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.p">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.as_">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.se">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.B">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.C">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.N">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.O">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.F">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.P">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.S">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.CL">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.BR">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.I">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.WILDCARD">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.a">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.A">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.CARET">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.Q_MARK">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.DIGIT">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.L_BRACKET">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.L_PAREN">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.R_PAREN">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.R_BRACKET">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.DOLLAR">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.PLUS">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.h">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.D">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.R">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.r">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.v">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.X">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.x">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.G">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.HX">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.H">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.HE">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.LI">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.BE">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.NE">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.NA">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.MG">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.AL">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.SI">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.AR">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.K">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.CA">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.TI">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.V">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.CR">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.MN">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.FE">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.CO">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.NI">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.CU">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.ZN">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.GA">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.GE">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.AS">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.SE">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.KR">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.RB">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.SR">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.Y">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.ZR">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.NB">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.MO">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.TC">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.RU">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.RH">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.PD">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.AG">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.CD">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.IN">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.SN">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.SB">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.TE">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.XE">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.CS">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.BA">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.LA">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.HF">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.TA">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.W">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.RE">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.OS">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.IR">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.PT">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.AU">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.HG">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.TL">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.PB">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.BI">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.PO">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.AT">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.RN">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.FR">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.RA">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.AC">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.TH">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.PA">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.U">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.PU">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.AM">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.CM">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.BK">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.CF">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.ES">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.FM">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.MD">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.NO">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.LR">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.NP">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.CE">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.ND">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.PM">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.SM">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.EU">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.GD">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.TB">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.DY">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.HO">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.ER">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.TM">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.YB">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.LU">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.PR">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.SC">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.ATOM_EXPRESSION">
            <summary>Lexical state.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.Default">
            <summary>Lexical state.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.tokenImage">
            <summary>Literal token values.</summary>
        </member>
        <member name="T:NCDK.Smiles.SMARTS.Parser.SMARTSParserTokenManager">
            <summary>Token Manager.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserTokenManager.debugStream">
            <summary>Debug output.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SMARTSParserTokenManager.SetDebugStream(System.IO.Stream)">
            <summary>Set debug output.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserTokenManager.jjstrLiteralImages">
            <summary>Token literal values.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserTokenManager.lexStateNames">
            <summary>Lexer state names.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserTokenManager.jjnewLexState">
            <summary>Lex State array.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SMARTSParserTokenManager.#ctor(NCDK.Smiles.SMARTS.Parser.SimpleCharStream)">
            <summary>Constructor.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SMARTSParserTokenManager.#ctor(NCDK.Smiles.SMARTS.Parser.SimpleCharStream,System.Int32)">
            <summary>Constructor.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SMARTSParserTokenManager.ReInit(NCDK.Smiles.SMARTS.Parser.SimpleCharStream)">
            <summary>Reinitialise parser.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SMARTSParserTokenManager.ReInit(NCDK.Smiles.SMARTS.Parser.SimpleCharStream,System.Int32)">
            <summary>Reinitialise parser.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SMARTSParserTokenManager.SwitchTo(System.Int32)">
            <summary>Switch to specified lex state.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SMARTSParserTokenManager.GetNextToken">
            <summary>Get the next Token.</summary>
        </member>
        <member name="T:NCDK.Smiles.SMARTS.Parser.SmartsQueryVisitor">
            <summary>
            An AST tree visitor. It builds an instance of <see cref="T:NCDK.Isomorphisms.Matchers.QueryAtomContainer" /> 
            from the AST tree.
            </summary>
            <example>
            To use this visitor:
            <code>             SMARTSParser parser = new SMARTSParser(new StringReader("C*C"));
             ASTStart ast = parser.Start();
             SmartsQueryVisitor visitor = new SmartsQueryVisitor(Silent.ChemObjectBuilder.Instance);
            QueryAtomContainer query = (QueryAtomContainer)visitor.Visit(ast, null);
</code>
            </example>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SmartsQueryVisitor.neighbors">
            <summary>
            Maintain order of neighboring atoms - required for atom-based
            stereochemistry.
            </summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SmartsQueryVisitor.tetrahedral">
            <summary>
            Lookup of atom indices.
            </summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SmartsQueryVisitor.stereoBonds">
            <summary>
            Stores the directional '/' or '\' bonds. Speeds up looking for double
            bond configurations.
            </summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SmartsQueryVisitor.doubleBonds">
            <summary>
            Stores the double bonds in the query.
            </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SmartsQueryVisitor.FindStereoBond(NCDK.IAtom)">
            <summary>
            Locate a stereo bond adjacent to the <paramref name="atom"/>.
            </summary>
            <param name="atom">an atom</param>
            <returns>a stereo bond or null if non found</returns>
        </member>
        <member name="T:NCDK.Smiles.SMARTS.Parser.Token">
            <summary>
            Describes the input token stream.
            </summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.Token.kind">
            <summary>
            An integer that describes the kind of this token.  This numbering
            system is determined by JavaCCParser, and a table of these numbers is
            stored in the file ...Constants.java.
            </summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.Token.beginLine">
            <summary>The line number of the first character of this Token.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.Token.beginColumn">
            <summary>The column number of the first character of this Token.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.Token.endLine">
            <summary>The line number of the last character of this Token.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.Token.endColumn">
            <summary>The column number of the last character of this Token.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.Token.image">
            <summary>
            The string image of the token.
            </summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.Token.next">
            <summary>
            A reference to the next regular (non-special) token from the input
            stream.  If this is the last token from the input stream, or if the
            token manager has not read tokens beyond this one, this field is
            set to null.  This is true only if this token is also a regular
            token.  Otherwise, see below for a description of the contents of
            this field.
            </summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.Token.specialToken">
            <summary>
            This field is used to access special tokens that occur prior to this
            token, but after the immediately preceding regular (non-special) token.
            If there are no such special tokens, this field is set to null.
            When there are more than one such special token, this field refers
            to the last of these special tokens, which in turn refers to the next
            previous special token through its specialToken field, and so on
            until the first special token (whose specialToken field is null).
            The next fields of special tokens refer to other special tokens that
            immediately follow it (without an intervening regular token).  If there
            is no such token, this field is null.
            </summary>
        </member>
        <member name="P:NCDK.Smiles.SMARTS.Parser.Token.Value">
            <summary>
            An optional attribute value of the Token.
            Tokens which are not used as syntactic sugar will often contain
            meaningful values that will be used later on by the compiler or
            interpreter. This attribute value is often different from the image.
            Any subclass of Token that actually wants to return a non-null value can
            override this method as appropriate.
            </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.Token.#ctor">
            <summary>
            No-argument constructor
            </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.Token.#ctor(System.Int32)">
            <summary>
            Constructs a new token for the specified Image.
            </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.Token.#ctor(System.Int32,System.String)">
            <summary>
            Constructs a new token for the specified Image and Kind.
            </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.Token.ToString">
            <summary>
            Returns the image.
            </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.Token.NewToken(System.Int32,System.String)">
             <summary>
             Returns a new Token object, by default. However, if you want, you
             can create and return subclass objects based on the value of ofKind.
             Simply add the cases to the switch for all those special cases.
             For example, if you have a subclass of Token called IDToken that
             you want to create if ofKind is ID, simply add something like :
            
                case MyParserConstants.ID : return new IDToken(ofKind, image);
            
             to the following switch statement. Then you can cast matchedToken
             variable to the appropriate type and use sit in your lexical actions.
             </summary>
        </member>
        <member name="T:NCDK.Smiles.SMARTS.Parser.TokenMgrError">
            <summary>Token Manager Error.</summary>
        </member>
        <member name="T:NCDK.Smiles.SMARTS.Parser.TokenMgrError.ErrorCodes">
            <summary>
            Ordinals for various reasons why an Error of this type can be thrown.
            </summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.TokenMgrError.ErrorCodes.LexicalError">
            <summary>
            Lexical error occurred.
            </summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.TokenMgrError.ErrorCodes.StaticLexicalError">
            <summary>
            An attempt was made to create a second instance of a static token manager.
            </summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.TokenMgrError.ErrorCodes.InvalidLexicalState">
            <summary>
            Tried to change to an invalid lexical state.
            </summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.TokenMgrError.ErrorCodes.LoopDetected">
            <summary>
            Detected (and bailed out of) an infinite loop in the token manager.
            </summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.TokenMgrError.errorCode">
            <summary>
            Indicates the reason why the exception is thrown. It will have
            one of the above 4 values.
            </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.TokenMgrError.AddEscapes(System.String)">
            <summary>
            Replaces unprintable characters by their escaped (or unicode escaped)
            equivalents in the given string
            </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.TokenMgrError.LexicalError(System.Boolean,System.Int32,System.Int32,System.Int32,System.String,System.Char)">
            <summary>
            Returns a detailed message for the Error when it is thrown by the
            token manager to indicate a lexical error.
            </summary>
            <remarks>
            Parameters :
            <list type="bullet">
            <item><term></term><description></description></item>
            <item><term></term><description></description></item>
            <item><term>EOFSeen</term><description>indicates if EOF caused the lexical error</description></item>
            <item><term>curLexState</term><description>lexical state in which this error occurred</description></item>
            <item><term>errorLine</term><description>line number when the error occurred</description></item>
            <item><term>errorColumn</term><description>column number when the error occurred</description></item>
            <item><term>errorAfter</term><description>prefix that was seen before this error occurred</description></item>
            <item><term>curchar</term><description>the offending character</description></item>
            </list>
            <note type="note">
            You can customize the lexical error message by modifying this method.
            </note>
            </remarks>
        </member>
        <member name="P:NCDK.Smiles.SMARTS.Parser.TokenMgrError.Message">
            <summary>
            You can also modify the body of this method to customize your error messages.
            </summary>
            <remarks>
            For example, cases like <see cref="F:NCDK.Smiles.SMARTS.Parser.TokenMgrError.ErrorCodes.LoopDetected"/> and <see cref="F:NCDK.Smiles.SMARTS.Parser.TokenMgrError.ErrorCodes.InvalidLexicalState"/> are not
            of end-users concern, so you can return something like :
            <para>
            <pre>
                "Internal Error : Please file a bug report .... "
            </pre>     
            </para>
            from this method for such cases in the release version of your parser.
            </remarks>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.TokenMgrError.#ctor">
            <summary>No arg constructor.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.TokenMgrError.#ctor(System.String,NCDK.Smiles.SMARTS.Parser.TokenMgrError.ErrorCodes)">
            <summary>Constructor with message and reason.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.TokenMgrError.#ctor(System.Boolean,System.Int32,System.Int32,System.Int32,System.String,System.Char,NCDK.Smiles.SMARTS.Parser.TokenMgrError.ErrorCodes)">
            <summary>Full Constructor.</summary>
        </member>
        <member name="T:NCDK.Smiles.SMARTS.SmartsAtomAtomMapFilter">
            <summary>
            A filter for substructure matches implementing the logic for Atom-Atom Mapping matching. The following
            table from the Daylight theory manual summarises the expected functionality:
            </summary>
            <pre>
            C>>C                 CC>>CC    4 hits                        No maps, normal match.
            C>>C                 [CH3:7][CH3:8]>>[CH3:7][CH3:8] 4 hits   No maps in query, maps in target are ignored.
            [C:1]>>C             [CH3:7][CH3:8]>>[CH3:7][CH3:8] 4 hits   Unpaired map in query ignored.
            [C:1]>>[C:1]         CC>>CC  0 hits                          No maps in target, hence no matches.
            [C:?1]>>[C:?1]       CC>>CC  4 hits                          Query says mapped as shown or not present.
            [C:1]>>[C:1]         [CH3:7][CH3:8]>>[CH3:7][CH3:8] 2 hits   Matches for target 7,7 and 8,8 atom pairs.
            [C:1]>>[C:2]         [CH3:7][CH3:8]>>[CH3:7][CH3:8] 4 hits   When a query class is not found on both sides of the
                                                                         query, it is ignored; this query does NOT say that the
                                                                         atoms are in different classes.
            [C:1][C:1]>>[C:1]    [CH3:7][CH3:7]>>[CH3:7][CH3:7] 4 hits   Atom maps match with "or" logic. All atoms  get bound to
                                                                         class 7.
            [C:1][C:1]>>[C:1]    [CH3:7][CH3:8]>>[CH3:7][CH3:8] 4 hits   The reactant atoms are bound to classes 7 and 8. Note that
                                                                         having the first query atom bound to class 7 does not
                                                                         preclude binding the second atom. Next, the product
                                                                         atom can bind to classes 7 or 8.
            [C:1][C:1]>>[C:1]    [CH3:7][CH3:7]>>[CH3:7][CH3:8] 2 hits   The reactants are bound to class 7. The product atom can
                                                                         bind to class 7 only.
            </pre>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.SmartsAtomAtomMapFilter.Mapidx(NCDK.IAtom)">
            <summary>
            Safely access the mapidx of an atom, returns 0 if null.
            </summary>
            <param name="atom">atom</param>
            <returns>mapidx, 0 if undefined</returns>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.SmartsAtomAtomMapFilter.Role(NCDK.IAtom)">
            <summary>
            Safely access the reaction role of an atom, returns <see cref="F:NCDK.ReactionRoles.None"/> if null.
            </summary>
            <param name="atom">atom</param>
            <returns>mapidx, None if undefined</returns>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.SmartsAtomAtomMapFilter.Apply(System.Int32[])">
            <summary>
            Filters a structure match (described as an index permutation query -> target) for
            those where the atom-atom maps are acceptable.
            </summary>
            <param name="perm">permuation</param>
            <returns>whether the match should be accepted</returns>
        </member>
        <member name="T:NCDK.Smiles.SMARTS.SmartsAtomAtomMapFilter.MappedPairs">
            <summary>
            Helper class list all reactant atom indices (rIdxs) and product
            atom indices (pIdxs) that are in the same Atom-Atom-Mapping class.
            </summary>
        </member>
        <member name="T:NCDK.Smiles.SMARTS.SmartsPattern">
            <summary>
            A <see cref="T:NCDK.Isomorphisms.Pattern" /> for matching a single SMARTS query against multiple target
            compounds. The class should <b>not</b> be used for matching many queries
            against a single target as in substructure keyed fingerprints. The <see cref="T:NCDK.Smiles.SMARTS.SMARTSQueryTool" /> 
            is currently a better option as less target initialistion is performed.
            </summary>
            <example>
            Simple usage:
            <code>                Pattern ptrn = SmartsPattern.Create("O[C@?H](C)CC", Default.ChemObjectBuilder.Instance);

                foreach (var ac in acs)
                {
                    if (ptrn.Matches(ac))
                    {
                        // 'ac' contains the pattern
                    }
                }
</code>
            Obtaining a <see cref="T:NCDK.Isomorphisms.Mappings" /> instance and determine the number of unique
            matches.
            <code>                Pattern ptrn = SmartsPattern.Create("O[C@?H](C)CC", Default.ChemObjectBuilder.Instance);

                foreach (var ac in acs)
                {
                    nUniqueHits += ptrn.MatchAll(ac).CountUnique();
                }
</code>
            </example>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.SmartsPattern.query">
            <summary>Parsed query.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.SmartsPattern.pattern">
            <summary>Subgraph mapping.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.SmartsPattern.ringInfo">
            <summary>Include invariants about ring size / number.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.SmartsPattern.hasStereo">
            <summary>Include invariants about ring size / number.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.SmartsPattern.hasCompGrp">
            <summary>Include invariants about ring size / number.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.SmartsPattern.hasRxnMap">
            <summary>Include invariants about ring size / number.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.SmartsPattern.arom">
            <summary>Aromaticity model.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.SmartsPattern.#ctor(System.String,NCDK.IChemObjectBuilder)">
            <summary>
            Internal constructor.
            </summary>
            <param name="smarts">pattern</param>
            <param name="builder">the builder</param>
            <exception cref="T:System.IO.IOException">the pattern could not be parsed</exception>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.SmartsPattern.Match(NCDK.IAtomContainer)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.SmartsPattern.MatchAll(NCDK.IAtomContainer)">
            <summary>
            Obtain the mappings of the query pattern against the target compound. Any
            initializations required for the SMARTS match are automatically
            performed. The Daylight aromaticity model is applied clearing existing
            aromaticity. <b>Do not use this for matching multiple SMARTS against the
            same container</b>.
            </summary>
            <example>
            <code>                 Pattern ptrn = SmartsPattern.Create("O[C@?H](C)CC", Default.ChemObjectBuilder.Instance);
                 int nUniqueHits = 0;
                
                 foreach (var ac in acs) {
                   nUniqueHits += ptrn.MatchAll(ac).CountUnique();
                 }
</code>
            See <see cref="T:NCDK.Isomorphisms.Mappings" /> for available methods.
            </example>
            <param name="target">the target compound in which we want to match the pattern</param>
            <returns>mappings of the query to the target compound</returns>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.SmartsPattern.Create(System.String,NCDK.IChemObjectBuilder)">
            <summary>
            Create a <see cref="T:NCDK.Isomorphisms.Pattern"/> that will match the given <paramref name="smarts"/> query.
            </summary>
            <param name="smarts">SMARTS pattern string</param>
            <param name="builder">chem object builder used to create objects</param>
            <returns>a new pattern</returns>
            <exception cref="T:System.IO.IOException">the smarts could not be parsed</exception> 
        </member>
        <member name="M:NCDK.Smiles.SMARTS.SmartsPattern.Create(System.String)">
            <summary>
            Default SMARTS pattern constructor, passes in a null chem object builder.
            </summary>
            <param name="smarts">SMARTS pattern string</param>
            <returns>a SMARTS pattern</returns>
            <exception cref="T:System.IO.IOException">problem with SMARTS string syntax/semantics</exception>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.SmartsPattern.RingSizeOrNumber(System.String)">
            <summary>
            Checks a smarts string for !R, R&lt;num&gt; or r&lt;num&gt;. If found then the more
            expensive ring info needs to be initlised before querying.
            </summary>
            <param name="smarts">pattern string</param>
            <returns>the pattern has a ring size or number query</returns>
        </member>
        <member name="T:NCDK.Smiles.SMARTS.SMARTSQueryTool">
            <summary>
            This class provides a easy to use wrapper around SMARTS matching functionality. 
            <para>
            User code that wants to do
            SMARTS matching should use this rather than using SMARTSParser (and UniversalIsomorphismTester) directly.
            </para>
            </summary>
            <remarks>
            <list type="bullet">
            <listheader><description>Unsupported Features</description></listheader>
            <item><description>Component level grouping</description></item>
            <item><description>Stereochemistry</description></item>
            <item><description>Reaction support</description></item>
            </list>
            <h3>SMARTS Extensions</h3>
            <para>
            Currently the CDK supports the following SMARTS symbols, that are not described in the Daylight specification.
            However they are supported by other packages and are noted as such.
            </para>
            <list type="table">
            <listheader>
            <term>Symbol</term>
            <term>Meaning</term>
            <term>Default</term>
            <term>Notes</term>
            </listheader>
            <item>
            <term>Gx</term>
            <term>Periodic group number</term>
            <term>None</term>
            <term>x must be specified and must be a number between 1 and 18. This symbol is supported by the MOE SMARTS implementation</term>
            </item>
            <item>
            <term>#X</term>
            <term>Any non-carbon heavy element</term>
            <term>None</term>
            <term>This symbol is supported by the MOE SMARTS implementation</term>
            </item>
            <item>
            <term>^x</term>
            <term>Any atom with the a specified hybridization state</term>
            <term>None</term>
            <term>x must be specified and should be between 1 and 8 (inclusive), corresponding to SP1, SP2, SP3, SP3D1, SP3D2 SP3D3, SP3D4 and SP3D5. Supported by the OpenEye SMARTS implementation</term>
            </item>
            </list>
            <note type="note">
            <list type="bullet">
            <item>
            <term>
            As <see href="http://sourceforge.net/mailarchive/message.php?msg_name=4964F605.1070502%40emolecules.com">described</see>
            by Craig James the <pre>h&lt;n&gt;</pre> SMARTS pattern should not be used. It was included in the Daylight spec
            for backwards compatibility. To match hydrogens, use the <pre>H&lt;n&gt;</pre> pattern.
            </term>
            <term>
            The wild card pattern (<pre>*</pre>) will not match hydrogens (explicit or implicit) unless an isotope is specified. In other
            words, <pre>*</pre> gives two hits against <pre>C[2H]</pre> but 1 hit against <pre>C[H]</pre>. This also means
            that it gives no hits against <pre>[H][H]</pre>. This is contrary to what is shown by Daylights 
            <see href="http://www.daylight.com/daycgi_tutorials/depictmatch.cgi">depictmatch</see> service, but is based on this 
            <see href="https://sourceforge.net/mailarchive/message.php?msg_name=4964FF9D.3040004%40emolecules.com">discussion</see>. A
            work around to get <pre>*</pre> to match <pre>[H][H]</pre> is to write it in the form <pre>[1H][1H]</pre>.
            <para>
            It's not entirely clear what the behavior of * should be with respect to hydrogens. it is possible that the code will
            be updated so that <pre>*</pre> will not match <i>any</i> hydrogen in the future.</para>
            </term>
            <term>
            The CDKHueckelAromaticityDetector only considers single rings and two fused non-spiro
            rings. As a result, it does not properly detect aromaticity in polycyclic systems such as
            <pre>[O-]C(=O)c1ccccc1c2c3ccc([O-])cc3oc4cc(=O)ccc24</pre>. Thus SMARTS patterns that depend on proper aromaticity
            detection may not work correctly in such polycyclic systems
            </term>
            </item>
            </list>
            </note>
            </remarks>
            <example>
            <code>                SmilesParser sp = new SmilesParser(Default.ChemObjectBuilder.Instance);
                IAtomContainer atomContainer = sp.ParseSmiles("CC(=O)OC(=O)C");
                SMARTSQueryTool querytool = new SMARTSQueryTool("O=CO", Silent.ChemObjectBuilder.Instance);
                bool status = querytool.Matches(atomContainer);
                if (status)
                {
                    int nmatch = querytool.MatchesCount;
                    IList&lt;IList&lt;int&gt;&gt; mappings = querytool.GetMatchingAtoms();
                    for (int i = 0; i &lt; nmatch; i++)
                    {
                        IList&lt;int&gt; atomIndices = mappings[i];
                    }
                }
</code>
            </example>
        </member>
        <member name="T:NCDK.Smiles.SMARTS.SMARTSQueryTool.RingSet">
            <summary>
            Defines which set of rings to define rings in the target.
            </summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.SMARTSQueryTool.RingSet.SmallestSetOfSmallestRings">
            <summary>
            Smallest Set of Smallest Rings (or Minimum Cycle Basis - but not
            strictly the same). Defines what is typically thought of as a 'ring'
            however the non-uniqueness leads to ambiguous matching.
            </summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.SMARTSQueryTool.RingSet.EssentialRings">
            <summary>
            Intersect of all Minimum Cycle Bases (or SSSR) and thus is a subset.
            The set is unique but may excludes rings (e.g. from bridged systems).
            </summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.SMARTSQueryTool.RingSet.RelevantRings">
            <summary>
            Union of all Minimum Cycle Bases (or SSSR) and thus is a superset.
            The set is unique but may include more rings then is necessary.
            </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.SMARTSQueryTool.RingSet.ComputeRingSet(NCDK.IAtomContainer)">
            <summary>
            Compute a ring set for a molecule.
            </summary>
            <param name="m">molecule</param>
            <returns>the ring set for the molecule</returns>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.SMARTSQueryTool.ringSet">
            <summary>Which short cyclic set should be used.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.SMARTSQueryTool.aromaticity">
            <summary>
            Aromaticity perception - dealing with SMARTS we should use the Daylight
            model. This can be set to a different model using <see cref="M:NCDK.Smiles.SMARTS.SMARTSQueryTool.SetAromaticity(NCDK.Aromaticities.Aromaticity)"/>.
            </summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.SMARTSQueryTool.skipAromaticity">
            <summary>
            Logical flag indicates whether the aromaticity model should be skipped.
            Generally this should be left as false to ensure the structures being
            matched are all treated the same. The flag can however be turned off if
            the molecules being tests are known to all have the same aromaticity
            model.
            </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.SMARTSQueryTool.#ctor(System.String,NCDK.IChemObjectBuilder)">
            <summary>
            Create a new SMARTS query tool for the specified SMARTS string. Query
            objects will contain a reference to the specified <see cref="T:NCDK.IChemObjectBuilder"/>.
            </summary>
            <param name="smarts">SMARTS query string</param>
            <exception cref="T:System.ArgumentException">if the SMARTS string can not be handled</exception>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.SMARTSQueryTool.SetQueryCacheSize(System.Int32)">
            <summary>
            Set the maximum size of the query cache.
            </summary>
            <param name="maxEntries">The maximum number of entries</param>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.SMARTSQueryTool.UseSmallestSetOfSmallestRings">
            <summary>
            Indicates that ring properties should use the Smallest Set of Smallest
            Rings. The set is not unique and may lead to ambiguous matches.
            </summary>
            <seealso cref="M:NCDK.Smiles.SMARTS.SMARTSQueryTool.UseEssentialRings"/>
            <seealso cref="M:NCDK.Smiles.SMARTS.SMARTSQueryTool.UseRelevantRings"/>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.SMARTSQueryTool.UseRelevantRings">
            <summary>
            Indicates that ring properties should use the Relevant Rings. The set is
            unique and includes all of the SSSR but may be exponential in size.
            </summary>
            <seealso cref="M:NCDK.Smiles.SMARTS.SMARTSQueryTool.UseSmallestSetOfSmallestRings"/>
            <seealso cref="M:NCDK.Smiles.SMARTS.SMARTSQueryTool.UseEssentialRings"/>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.SMARTSQueryTool.UseEssentialRings">
            <summary>
            Indicates that ring properties should use the Essential Rings (default).
            The set is unique but only includes a subset of the SSSR.
            </summary>
            <seealso cref="M:NCDK.Smiles.SMARTS.SMARTSQueryTool.UseSmallestSetOfSmallestRings"/>
            <seealso cref="M:NCDK.Smiles.SMARTS.SMARTSQueryTool.UseEssentialRings"/>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.SMARTSQueryTool.SetAromaticity(NCDK.Aromaticities.Aromaticity)">
            <summary>
            Set the aromaticity perception to use. Different aromaticity models
            may required certain attributes to be set (e.g. atom typing). These
            will not be automatically configured and should be preset before matching.
            </summary>
            <example>
            <code>                SMARTSQueryTool sqt = new SMARTSQueryTool(someSmartsPattern, Default.ChemObjectBuilder.Instance);
                sqt.SetAromaticity(new Aromaticity(ElectronDonation.CDKModel, Cycles.CDKAromaticSetFinder));
                foreach (var molecule in molecules)
                {
                    // CDK Aromatic model needs atom types
                    AtomContainerManipulator.PercieveAtomTypesAndConfigureAtoms(molecule);
                    sqt.Matches(molecule);
                }
</code>
            </example>
            <param name="aromaticity">the new aromaticity perception</param>
            <seealso cref="T:NCDK.Aromaticities.ElectronDonation" />
            <seealso cref="T:NCDK.Graphs.Cycles" />
        </member>
        <member name="P:NCDK.Smiles.SMARTS.SMARTSQueryTool.Smarts">
            <summary>
            The current SMARTS pattern being used.
            </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.SMARTSQueryTool.Matches(NCDK.IAtomContainer)">
            <summary>
            Perform a SMARTS match and check whether the query is present in the target molecule. 
            <para>
            This function simply
            checks whether the query pattern matches the specified molecule. However the function will also, internally, save
            the mapping of query atoms to the target molecule</para>
            </summary>
            <remarks>
            <b>Note</b>: This method performs a simple caching scheme, by comparing the current molecule to the previous
            molecule by reference. If you repeatedly match different SMARTS on the same molecule, this method will avoid
            initializing ( ring perception, aromaticity etc.) the molecule each time. If however, you modify the molecule
            between such multiple matchings you should use the other form of this method to force initialization.
            </remarks>
            <param name="atomContainer">The target moleculoe</param>
            <returns>true if the pattern is found in the target molecule, false otherwise</returns>
            <exception cref="T:NCDK.CDKException">if there is an error in ring, aromaticity or isomorphism perception</exception>
            <seealso cref="M:NCDK.Smiles.SMARTS.SMARTSQueryTool.GetMatchingAtoms"/>
            <seealso cref="P:NCDK.Smiles.SMARTS.SMARTSQueryTool.MatchesCount"/>
            <see cref="M:NCDK.Smiles.SMARTS.SMARTSQueryTool.Matches(NCDK.IAtomContainer,System.Boolean)"/>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.SMARTSQueryTool.Matches(NCDK.IAtomContainer,System.Boolean)">
            <summary>
            Perform a SMARTS match and check whether the query is present in the target molecule. 
            <para>This function simply
            checks whether the query pattern matches the specified molecule. However the function will also, internally, save
            the mapping of query atoms to the target molecule</para>
            </summary>
            <param name="atomContainer">The target moleculoe</param>
            <param name="forceInitialization">If true, then the molecule is initialized (ring perception, aromaticity etc). If
                                       false, the molecule is only initialized if it is different (in terms of object
                                       reference) than one supplied in a previous call to this method.</param>
            <returns>true if the pattern is found in the target molecule, false otherwise</returns>
            <exception cref="T:NCDK.CDKException">if there is an error in ring, aromaticity or isomorphism perception</exception>
            <seealso cref="M:NCDK.Smiles.SMARTS.SMARTSQueryTool.GetMatchingAtoms"/>
            <seealso cref="P:NCDK.Smiles.SMARTS.SMARTSQueryTool.MatchesCount"/>
            <seealso cref="M:NCDK.Smiles.SMARTS.SMARTSQueryTool.Matches(NCDK.IAtomContainer)"/>
        </member>
        <member name="P:NCDK.Smiles.SMARTS.SMARTSQueryTool.MatchesCount">
            <summary>
            Returns the number of times the pattern was found in the target molecule. 
            <para>This function should be called
            after <see cref="M:NCDK.Smiles.SMARTS.SMARTSQueryTool.Matches(NCDK.IAtomContainer)"/>. If not, the results may be undefined.</para>
            </summary>
            <returns>The number of times the pattern was found in the target molecule</returns>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.SMARTSQueryTool.GetMatchingAtoms">
            <summary>
            Get the atoms in the target molecule that match the query pattern. 
            <para>Since there may be multiple matches, the
            return value is a List of List objects. Each List object contains the indices of the atoms in the target
            molecule, that match the query pattern</para>
            </summary>
            <returns>A List of List of atom indices in the target molecule</returns>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.SMARTSQueryTool.GetUniqueMatchingAtoms">
            <summary>
            Get the atoms in the target molecule that match the query pattern. 
            <para>
            Since there may be multiple matches, the
            return value is a List of List objects. Each List object contains the unique set of indices of the atoms in the
            target molecule, that match the query pattern
            </para>
            </summary>
            <returns>A List of List of atom indices in the target molecule</returns>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.SMARTSQueryTool.InitializeMolecule">
            <summary>
            Prepare the target molecule for analysis. 
            <para>
            We perform ring perception and aromaticity detection and set up
            the appropriate properties. Right now, this function is called each time we need to do a query and this is
            inefficient.</para>
            </summary>
            <exception cref="T:NCDK.CDKException">if there is a problem in ring perception or aromaticity detection, which is usually related to a timeout in the ring finding code.</exception>
        </member>
        <member name="T:NCDK.Smiles.SmiFlavor">
            <summary>
            Flags for customising SMILES generation.
            </summary>
        </member>
        <member name="F:NCDK.Smiles.SmiFlavor.Canonical">
            <summary>
            Output SMILES in a canonical order. The order is not guaranteed to be
            equivalent between releases.
            </summary>
        </member>
        <member name="F:NCDK.Smiles.SmiFlavor.InChILabelling">
            <summary>
            Output SMILES in a canonical order using the InChI labelling algorithm.
            </summary>
            <seealso cref="F:NCDK.Smiles.SmiFlavor.UniversalSmiles"/>
        </member>
        <member name="F:NCDK.Smiles.SmiFlavor.AtomAtomMap">
            <summary>
            Output atom-atom mapping for reactions and atom classes for molecules. The
            map index is set on an atom with property <see cref="F:NCDK.CDKPropertyName.AtomAtomMapping"/>
            using <see cref="M:NCDK.IChemObject.SetProperty(System.Object,System.Object)"/>.
            </summary>
        </member>
        <member name="F:NCDK.Smiles.SmiFlavor.AtomicMass">
            <summary>
            Output atomic mass on atoms. For historical reasons the atomic mass is
            often set on all atoms in a CDK molecule. Therefore to avoid SMILES like
            <code>[12CH3][12CH2][16OH]</code> major isotopes are not generated. If you
            wish to generate SMILES with the major isotopes please use the flag
            <see cref="F:NCDK.Smiles.SmiFlavor.AtomicMassStrict"/> this will output all mass numbers and only be
            omitted when the mass is unset (null).
            </summary>
        </member>
        <member name="F:NCDK.Smiles.SmiFlavor.UseAromaticSymbols">
            <summary>
            Writes aromatic atoms as lower case letters. For portability
            this option is not recommended.
            </summary>
        </member>
        <member name="F:NCDK.Smiles.SmiFlavor.StereoTetrahedral">
            <summary>
            Output tetrahedral stereochemistry on atoms as <code>@</code> and <code>@@</code>.
            </summary>
            <seealso cref="F:NCDK.Smiles.SmiFlavor.Stereo"/>
        </member>
        <member name="F:NCDK.Smiles.SmiFlavor.StereoCisTrans">
            <summary>
            Output <i>cis</i>-<i>trans</i> stereochemistry specified by directional <code>\</code>
            of <code>/</code> bonds.
            </summary>
            <seealso cref="F:NCDK.Smiles.SmiFlavor.Stereo"/>
        </member>
        <member name="F:NCDK.Smiles.SmiFlavor.StereoExTetrahedral">
            <summary>
            Output extended tetrahedral stereochemistry on atoms as <pre>@</pre> and
            <pre>@@</pre>. Extended tetrahedral captures rotations around a cumulated
            carbon: <pre>CC=[C@]=CC</pre>.
            </summary>
            <seealso cref="F:NCDK.Smiles.SmiFlavor.Stereo"/>
        </member>
        <member name="F:NCDK.Smiles.SmiFlavor.AtomicMassStrict">
            <summary>
            Generate SMILES with the major isotopes, only omit mass numbers when it
            is unset.
            </summary>
        </member>
        <member name="F:NCDK.Smiles.SmiFlavor.Stereo">
            <summary>
            Output supported stereochemistry types.
            </summary>
            <seealso cref="F:NCDK.Smiles.SmiFlavor.StereoTetrahedral"/>
            <seealso cref="F:NCDK.Smiles.SmiFlavor.StereoCisTrans"/>
            <seealso cref="F:NCDK.Smiles.SmiFlavor.StereoExTetrahedral"/>
        </member>
        <member name="F:NCDK.Smiles.SmiFlavor.Cx2dCoordinates">
            <summary>
            Output 2D coordinates.
            </summary>
        </member>
        <member name="F:NCDK.Smiles.SmiFlavor.Cx3dCoordinates">
            <summary>
            Output 3D coordinates.
            </summary>
        </member>
        <member name="F:NCDK.Smiles.SmiFlavor.CxCoordinates">
            <summary>
            Output either 2D/3D coordinates.
            </summary>
        </member>
        <member name="F:NCDK.Smiles.SmiFlavor.CxAtomLabel">
            <summary>
            Output atom labels, atom labels are specified by <see cref="P:NCDK.IPseudoAtom.Label"/>.
            </summary>
        </member>
        <member name="F:NCDK.Smiles.SmiFlavor.CxAtomValue">
            <summary>
            Output atom values, atom values are specified by <see cref="P:NCDK.IPseudoAtom.Label"/>.
            </summary>
        </member>
        <member name="F:NCDK.Smiles.SmiFlavor.CxRadical">
            <summary>
            Output radicals, radicals are specified by <see cref="M:NCDK.IAtomContainer.GetConnectedSingleElectrons(NCDK.IAtom)"/>
            </summary>
        </member>
        <member name="F:NCDK.Smiles.SmiFlavor.CxMulticenter">
            <summary>
            Output multi-center bonds, positional variation is specified with <see cref="T:NCDK.SGroups.Sgroup"/>s
            of the type <see cref="F:NCDK.SGroups.SgroupType.ExtMulticenter"/>.
            </summary>
        </member>
        <member name="F:NCDK.Smiles.SmiFlavor.CxPolymer">
            <summary>
            Output polymer repeat units is specified with <see cref="T:NCDK.SGroups.Sgroup"/>s.
            </summary>
        </member>
        <member name="F:NCDK.Smiles.SmiFlavor.CxFragmentGroup">
            <summary>
            Output fragment grouping for reactions.
            </summary>
        </member>
        <member name="F:NCDK.Smiles.SmiFlavor.CxSmiles">
            <summary>
            Output CXSMILES layers.
            </summary>
        </member>
        <member name="F:NCDK.Smiles.SmiFlavor.CxSmilesWithCoords">
            <summary>
            Output CXSMILES layers and coordinates.
            </summary>
        </member>
        <member name="F:NCDK.Smiles.SmiFlavor.Generic">
            <summary>
            Output non-canonical SMILES without stereochemistry, atomic masses.
            </summary>
        </member>
        <member name="F:NCDK.Smiles.SmiFlavor.Unique">
            <summary>
            Output canonical SMILES without stereochemistry, atomic masses.
            </summary>
        </member>
        <member name="F:NCDK.Smiles.SmiFlavor.Isomeric">
            <summary>
            Output non-canonical SMILES with stereochemistry, atomic masses.
            </summary>
        </member>
        <member name="F:NCDK.Smiles.SmiFlavor.Absolute">
            <summary>
            Output canonical SMILES with stereochemistry, atomic masses.
            </summary>
        </member>
        <member name="F:NCDK.Smiles.SmiFlavor.Default">
            <summary>
            Default SMILES output write Stereochemistry, Atomic Mass, and CXSMILES layers. The
            ordering is not canonical.
            </summary>
        </member>
        <member name="F:NCDK.Smiles.SmiFlavor.UniversalSmiles">
            <summary>
            Output canonical SMILES with stereochemistry and atomic masses, This output uses the
            InChI labelling algorithm to generate a 'Universal SMILES' <token>cdk-cite-OBoyle12</token>.
            </summary>
            <remarks>
            Unfortunately there are several issues and general use is not recommended:
            <ul>
             <li>MAJOR: Molecules with delocalised charges are generally non-canonical, e.g.
                        <code>C(\C=C\N1CCCC1)=C/c2[n+](c3c(n2CC)nc4ccccc4n3)CC</code> will generate two different
                        SMILES depending on input order</li>
             <li>MINOR: Double bond '/' '\' assignment is different from the original paper (O'Boyle) and
                        will not match universal SMILES generated by Open Babel</li>
             <li>MINOR: SMILES with '*' atoms can not be canonicalised by default, to avoid this we use
                        the 'Rf' atom as a substitute. Structures with an 'Rf' atom can still be generated
                        providing there are no '*' atoms.</li>
             <li>MINOR: The InChI library (v1.03) is not thread safe</li>
            </ul>
            </remarks>
        </member>
        <member name="T:NCDK.Smiles.BeamToCDK">
             <summary>
             Convert the Beam toolkit object model to the CDK. Currently the aromatic
             bonds from SMILES are loaded as singly bonded <see cref="T:NCDK.IBond"/>s with the 
             <see cref="P:NCDK.IMolecularEntity.IsAromatic"/> flag set.
             </summary>
             <example><code>
             IChemObjectBuilder builder = Silent.ChemObjectBuilder.Instance;
             ChemicalGraph      g       = ChemicalGraph.FromSmiles("CCO");
            
             BeamToCDK          g2c     = new BeamToCDK(builder);
            
             // make sure the Beam notation is expanded - this converts organic
             // subset atoms with inferred hydrogen counts to atoms with a
             // set implicit hydrogen property
             IAtomContainer    ac       = g2c.ToAtomContainer(Functions.Expand(g));
             </code></example>
             <seealso href="http://johnmay.github.io/beam">Beam SMILES Toolkit</seealso >
        </member>
        <member name="F:NCDK.Smiles.BeamToCDK.builder">
            <summary>The builder used to create the CDK objects.</summary>
        </member>
        <member name="F:NCDK.Smiles.BeamToCDK.templateAtom">
            <summary> Base atom objects for cloning - SMILES is very efficient and noticeable
             lag is seen using the IChemObjectBuilders.
             </summary>
        </member>
        <member name="F:NCDK.Smiles.BeamToCDK.templateBond">
            <summary> Base atom objects for cloning - SMILES is very efficient and noticeable
             lag is seen using the IChemObjectBuilders.
             </summary>
        </member>
        <member name="F:NCDK.Smiles.BeamToCDK.emptyContainer">
            <summary>
            Base atom container for cloning - SMILES is very efficient and noticeable
            lag is seen using the IChemObjectBuilders.
            </summary>
        </member>
        <member name="M:NCDK.Smiles.BeamToCDK.#ctor(NCDK.IChemObjectBuilder)">
            <summary>
            Create a new converter for the Beam SMILES toolkit. The converter needs
            an <see cref="T:NCDK.IChemObjectBuilder"/>. Currently the 'cdk-silent' builder will
            give the best performance.
            </summary>
            <param name="builder">chem object builder</param>
        </member>
        <member name="M:NCDK.Smiles.BeamToCDK.ToAtomContainer(NCDK.Beam.Graph,System.Boolean)">
            <summary>
            Convert a Beam ChemicalGraph to a CDK IAtomContainer.
            </summary>
            <param name="g">Beam graph instance</param>
            <param name="kekule">the input has been kekulzied</param>
            <returns>the CDK <see cref="T:NCDK.IAtomContainer"/> for the input</returns>
            <exception cref="T:System.ArgumentException">the Beam graph was not 'expanded' - and
            contained organic subset atoms. If this happens use the Beam <see cref="M:NCDK.Beam.Functions.Expand(NCDK.Beam.Graph)"/> to
            </exception>
        </member>
        <member name="M:NCDK.Smiles.BeamToCDK.AddDoubleBondStereochemistry(NCDK.Beam.Graph,NCDK.IAtomContainer)">
            <summary>
            Adds double-bond conformations (<see cref="T:NCDK.Stereo.DoubleBondStereochemistry"/>) to the
            atom-container.
            </summary>
            <param name="g">Beam graph object (for directional bonds)</param>
            <param name="ac">The atom-container built from the Beam graph</param>
        </member>
        <member name="M:NCDK.Smiles.BeamToCDK.FindDirectionalEdge(NCDK.Beam.Graph,System.Int32)">
            <summary>
            Utility for find the first directional edge incident to a vertex. If
            there are no directional labels then null is returned.
            </summary>
            <param name="g">graph from Beam</param>
            <param name="u">the vertex for which to find</param>
            <returns>first directional edge (or <see langword="null"/> if none)</returns>
        </member>
        <member name="M:NCDK.Smiles.BeamToCDK.NewTetrahedral(System.Int32,System.Int32[],NCDK.IAtom[],NCDK.Beam.Configuration)">
            <summary>
            Creates a tetrahedral element for the given configuration. Currently only
            tetrahedral centres with 4 explicit atoms are handled.
            </summary>
            <param name="u">central atom</param>
            <param name="vs">neighboring atom indices (in order)</param>
            <param name="atoms">array of the CDK atoms (pre-converted)</param>
            <param name="c">the configuration of the neighbors (vs) for the order they are given</param>
            <returns>tetrahedral stereo element for addition to an atom container</returns>
        </member>
        <member name="M:NCDK.Smiles.BeamToCDK.Insert(System.Int32,System.Int32[])">
            <summary>
            Insert the vertex <paramref name="v"/> into sorted position in the array <paramref name="vs"/>.
            </summary>
            <param name="v">a vertex (int id)</param>
            <param name="vs">array of vertices (int ids)</param>
            <returns>array with 'u' inserted in sorted order</returns>
        </member>
        <member name="M:NCDK.Smiles.BeamToCDK.ToCDKAtom(NCDK.Beam.Atom,System.Int32)">
            <summary>
            Create a new CDK <see cref="T:NCDK.IAtom"/> from the Beam Atom.
            </summary>
            <param name="beamAtom">an Atom from the Beam ChemicalGraph</param>
            <param name="hCount">hydrogen count for the atom</param>
            <returns>the CDK atom to have it's properties set</returns>
        </member>
        <member name="M:NCDK.Smiles.BeamToCDK.NewCDKAtom(NCDK.Beam.Atom)">
            <summary>
            Create a new CDK <see cref="T:NCDK.IAtom"/> from the Beam Atom. If the element is
            unknown (i.e. '*') then an pseudo atom is created.
            </summary>
            <param name="atom">an Atom from the Beam Graph</param>
            <returns>the CDK atom to have it's properties set</returns>
        </member>
        <member name="M:NCDK.Smiles.BeamToCDK.CreateEmptyContainer">
            <summary>
            Create a new empty atom container instance.
            </summary>
            <returns>a new atom container instance</returns>
        </member>
        <member name="M:NCDK.Smiles.BeamToCDK.CreateAtom(NCDK.Beam.Element)">
            <summary>
            Create a new atom for the provided symbol. The atom is created by cloning
            an existing 'template'. Unfortunately IChemObjectBuilders really show a
            slow down when SMILES processing.
            </summary>
            <param name="element">Beam element</param>
            <returns>new atom with configured symbol and atomic number</returns>
        </member>
        <member name="T:NCDK.Smiles.CDKToBeam">
            <summary>
            Convert a CDK <see cref="T:NCDK.IAtomContainer" /> to a Beam graph object for generating
            SMILES. Once converted the Beam ChemicalGraph can be manipulated further to
            generate a standard-from SMILES and/or arrange the vertices in a canonical
            output order.
            </summary>
            <remarks>
            <note type="important">
            The conversion respects the implicit hydrogen count and if
            the number of implicit hydrogen (<see cref="P:NCDK.IAtom.ImplicitHydrogenCount" />) is
            null an exception will be thrown. To ensure correct conversion please ensure
            all atoms have their implicit hydrogen count set.
            </note> 
            </remarks>
            <example>
            <code>using NCDK.Templates;

namespace NCDK.Smiles
{
    class CDKToBeam_Example
    {
        void Main()
        {
            IAtomContainer m = TestMoleculeFactory.MakeBenzene();

            // converter is thread-safe and can be used by multiple threads
            CDKToBeam c2g = new CDKToBeam();
            Beam.Graph g = c2g.ToBeamGraph(m);

            // get the SMILES notation from the Beam graph
            string smi = g.ToSmiles();
        }
    }
}
</code>
            </example>
            <seealso href="http://johnmay.github.io/Beam">Beam SMILES Toolkit</seealso>
        </member>
        <member name="F:NCDK.Smiles.CDKToBeam.flavour">
            <summary>
            Whether to convert the molecule with isotope and stereo information -
            Isomeric SMILES.
            </summary>
        </member>
        <member name="M:NCDK.Smiles.CDKToBeam.#ctor">
            <summary>Create a isomeric and aromatic converter.</summary>
        </member>
        <member name="M:NCDK.Smiles.CDKToBeam.ToBeamGraph(NCDK.IAtomContainer,NCDK.Smiles.SmiFlavor)">
            <summary>
            Convert a CDK <see cref="T:NCDK.IAtomContainer"/> to a Beam ChemicalGraph. The graph
            can when be written directly as to a SMILES or manipulated further (e.g
            canonical ordering/standard-form and other normalisations).
            </summary>
            <param name="ac">an atom container instance</param>
            <returns>the Beam ChemicalGraph for additional manipulation</returns>
        </member>
        <member name="M:NCDK.Smiles.CDKToBeam.ToBeamAtom(NCDK.IAtom,NCDK.Smiles.SmiFlavor)">
            <summary>
            Convert an CDK <see cref="T:NCDK.IAtom"/> to a Beam Atom. The symbol and implicit
            hydrogen count are not optional. If the symbol is not supported by the
            SMILES notation (e.g. 'R1') the element will automatically default to
            Unknown ('*').
            </summary>
            <param name="a">cdk Atom instance</param>
            <returns>a Beam atom</returns>
            <exception cref="T:System.NullReferenceException">the atom had an undefined symbol or implicit hydrogen count</exception>
        </member>
        <member name="M:NCDK.Smiles.CDKToBeam.ToBeamEdge(NCDK.IBond,NCDK.Smiles.SmiFlavor,System.Collections.Generic.IDictionary{NCDK.IAtom,System.Int32})">
            <summary>
            Convert a CDK <see cref="T:NCDK.IBond"/> to a Beam edge.
            </summary>
            <param name="b">the CDK bond</param>
            <param name="indices">map of atom indices</param>
            <returns>a Beam edge</returns>
            <exception cref="T:System.ArgumentException">the bond did not have 2 atoms or an unsupported order</exception>
            <exception cref="T:System.NullReferenceException">the bond order was undefined</exception>
        </member>
        <member name="M:NCDK.Smiles.CDKToBeam.ToBeamEdgeLabel(NCDK.IBond,NCDK.Smiles.SmiFlavor)">
            <summary>
            Convert a CDK <see cref="T:NCDK.IBond"/> to the Beam edge label type.
            </summary>
            <param name="b">cdk bond</param>
            <returns>the edge label for the Beam edge</returns>
            <exception cref="T:System.NullReferenceException">the bond order was null and the bond was not-aromatic</exception>
            <exception cref="T:System.ArgumentException">the bond order could not be converted</exception>
        </member>
        <member name="M:NCDK.Smiles.CDKToBeam.AddGeometricConfiguration(NCDK.IDoubleBondStereochemistry,NCDK.Smiles.SmiFlavor,NCDK.Beam.GraphBuilder,System.Collections.Generic.IDictionary{NCDK.IAtom,System.Int32})">
            <summary>
            Add double-bond stereo configuration to the Beam GraphBuilder.
            </summary>
            <param name="dbs">stereo element specifying double-bond configuration</param>
            <param name="gb">the current graph builder</param>
            <param name="indices">atom indices</param>
        </member>
        <member name="M:NCDK.Smiles.CDKToBeam.AddTetrahedralConfiguration(NCDK.ITetrahedralChirality,NCDK.Beam.GraphBuilder,System.Collections.Generic.IDictionary{NCDK.IAtom,System.Int32})">
            <summary>
            Add tetrahedral stereo configuration to the Beam GraphBuilder.
            </summary>
            <param name="tc">stereo element specifying tetrahedral configuration</param>
            <param name="gb">the current graph builder</param>
            <param name="indices">atom indices</param>
        </member>
        <member name="M:NCDK.Smiles.CDKToBeam.AddExtendedTetrahedralConfiguration(NCDK.Stereo.ExtendedTetrahedral,NCDK.Beam.GraphBuilder,System.Collections.Generic.IDictionary{NCDK.IAtom,System.Int32})">
            <summary>
            Add extended tetrahedral stereo configuration to the Beam GraphBuilder.
            </summary>
            <param name="et">stereo element specifying tetrahedral configuration</param>
            <param name="gb">the current graph builder</param>
            <param name="indices">atom indices</param>
        </member>
        <member name="T:NCDK.Smiles.CxSmilesParser">
            <summary>
            Parse CXSMILES (ChemAxon Extended SMILES) layers. 
            </summary>
            <remarks>
            The layers are suffixed after the SMILES but before the title
            and encode a large number of the features. CXSMILES was not intended for outside consumption so has some quirks
            but does provide some useful features. This parser handles a subset of the grammar:
            <list type="bullet">
            <item>Atom Labels</item>
            <item>Atom Values</item>
            <item>Atom Coordinates</item>
            <item>Positional Variations</item>
            <item>Polymer Sgroups</item>
            <item>Atom Radicals</item>
            <item>Fragment grouping</item>
            </list> 
            The following properties are ignored
            <list type="bullet">
            <item>cis/trans specification</item>
            <item>relative stereochemistry</item>
            </list> 
            </remarks>
        </member>
        <member name="M:NCDK.Smiles.CxSmilesParser.ProcessAtomLabels(NCDK.Smiles.CxSmilesParser.CharIter,System.Collections.Generic.IDictionary{System.Int32,System.String})">
            <summary>
            Process atom labels from extended SMILES in a char iter.
            </summary>
            <param name="iter">char iteration</param>
            <param name="dest">destination of labels (atomidx->label)</param>
            <returns>parse success/failure</returns>
        </member>
        <member name="M:NCDK.Smiles.CxSmilesParser.ProcessCoords(NCDK.Smiles.CxSmilesParser.CharIter,NCDK.Smiles.CxSmilesState)">
            <summary>
            Coordinates are written between parenthesis. The z-coord may be omitted '(0,1,),(2,3,)'.
            </summary>
            <param name="iter">input characters, iterator is progressed by this method</param>
            <param name="state">output CXSMILES state</param>
            <returns>parse was a success (or not)</returns>
        </member>
        <member name="M:NCDK.Smiles.CxSmilesParser.ProcessFragmentGrouping(NCDK.Smiles.CxSmilesParser.CharIter,NCDK.Smiles.CxSmilesState)">
            <summary>
            Fragment grouping defines disconnected components that should be considered part of a single molecule (i.e.
            Salts). Examples include NaH, AlCl3, Cs2CO3, HATU, etc.
            </summary>
            <param name="iter">input characters, iterator is progressed by this method</param>
            <param name="state">output CXSMILES state</param>
            <returns>parse was a success (or not)</returns>
        </member>
        <member name="M:NCDK.Smiles.CxSmilesParser.IsSgroupDelim(System.Char)">
            <summary>
            Sgroup polymers in CXSMILES can be variable length so may be terminated either with the next group
            or the end of the CXSMILES.
            </summary>
            <param name="c">character</param>
            <returns>character an delimit an Sgroup</returns>
        </member>
        <member name="M:NCDK.Smiles.CxSmilesParser.ProcessPolymerSgroups(NCDK.Smiles.CxSmilesParser.CharIter,NCDK.Smiles.CxSmilesState)">
            <summary>
            Polymer Sgroups describe variations of repeating units. Only the atoms and not crossing bonds are written.
            </summary>
            <param name="iter">input characters, iterator is progressed by this method</param>
            <param name="state">output CXSMILES state</param>
            <returns>parse was a success (or not)</returns>
        </member>
        <member name="M:NCDK.Smiles.CxSmilesParser.ProcessPositionalVariation(NCDK.Smiles.CxSmilesParser.CharIter,NCDK.Smiles.CxSmilesState)">
            <summary>
            Positional variation/multi centre bonding. Describe as a begin atom and one or more end points.
            </summary>
            <param name="iter">input characters, iterator is progressed by this method</param>
            <param name="state">output CXSMILES state</param>
            <returns>parse was a success (or not)</returns>
        </member>
        <member name="M:NCDK.Smiles.CxSmilesParser.ProcessRadicals(NCDK.Smiles.CxSmilesParser.CharIter,NCDK.Smiles.CxSmilesState)">
            <summary>
            CXSMILES radicals.
            </summary>
            <param name="iter">input characters, iterator is progressed by this method</param>
            <param name="state">output CXSMILES state</param>
            <returns>parse was a success (or not)</returns>
        </member>
        <member name="M:NCDK.Smiles.CxSmilesParser.ProcessCx(System.String,NCDK.Smiles.CxSmilesState)">
            <summary>
            Parse an string possibly containing CXSMILES into an intermediate state
            (<see cref="T:NCDK.Smiles.CxSmilesState"/>) representation.
            </summary>
            <param name="str">input character string (SMILES title field)</param>
            <param name="state">output CXSMILES state</param>
            <returns>position where CXSMILES ends (below 0 means no CXSMILES)</returns>
        </member>
        <member name="M:NCDK.Smiles.CxSmilesParser.ProcessIntList(NCDK.Smiles.CxSmilesParser.CharIter,System.Char,System.Collections.Generic.IList{System.Int32})">
            <summary>
            Process a list of unsigned integers.
            </summary>
            <param name="iter">char iter</param>
            <param name="sep">the separator</param>
            <param name="dest">output</param>
            <returns>int-list was successfully processed</returns>
        </member>
        <member name="T:NCDK.Smiles.CxSmilesParser.CharIter">
            <summary>
            Utility for parsing a sequence of characters. The char iter allows us to pull
            of one or more characters at a time and track where we are in the string.
            </summary>
        </member>
        <member name="M:NCDK.Smiles.CxSmilesParser.CharIter.NextIf(System.Char)">
            <summary>
            If the next character matches the provided query the iterator is progressed.
            </summary>
            <param name="c">query character</param>
            <returns>iterator was moved forwards</returns>
        </member>
        <member name="M:NCDK.Smiles.CxSmilesParser.CharIter.NextIf(System.String)">
            <summary>
            If the next sequence of characters matches the prefix the iterator
            is progressed to character following the prefix.
            </summary>
            <param name="prefix">prefix string</param>
            <returns>iterator was moved forwards</returns>
        </member>
        <member name="M:NCDK.Smiles.CxSmilesParser.CharIter.HasNext">
            <summary>
            Is there more chracters to read?
            </summary>
            <returns>whether more characters are available</returns>
        </member>
        <member name="M:NCDK.Smiles.CxSmilesParser.CharIter.Curr">
            <summary>
            Access the current character of the iterator.
            </summary>
            <returns>charactor</returns>
        </member>
        <member name="M:NCDK.Smiles.CxSmilesParser.CharIter.Next">
            <summary>
            Access the current character of the iterator and move
            to the next position.
            </summary>
            <returns>charactor</returns>
        </member>
        <member name="M:NCDK.Smiles.CxSmilesParser.CharIter.Substr(System.Int32,System.Int32)">
            <summary>
            Access a substring from the iterator.
            </summary>
            <param name="beg">begin position (inclusive)</param>
            <param name="end">end position (exclusive)</param>
            <returns>substring</returns>
        </member>
        <member name="T:NCDK.Smiles.DeduceBondSystemTool">
            <summary>
            Tool that tries to deduce bond orders based on connectivity and hybridization
            for a number of common ring systems of up to seven-membered rings. It assumes
            that atom types have been perceived before that class is used.
            </summary>
            <remarks>
            The calculation can be interrupted with <see cref="F:NCDK.Smiles.DeduceBondSystemTool.Interrupted"/>,
            but assumes that this class is not used in a threaded fashion. When a calculation
            is interrupted, the bool is reset to false.
            </remarks>
        </member>
        <member name="F:NCDK.Smiles.DeduceBondSystemTool.Interrupted">
            <summary>
            <see langword="true"/> if the next or running calculation should be interrupted.
            </summary>
        </member>
        <member name="M:NCDK.Smiles.DeduceBondSystemTool.#ctor">
            <summary>
            Constructor for the DeduceBondSystemTool object.
            </summary>
        </member>
        <member name="M:NCDK.Smiles.DeduceBondSystemTool.#ctor(NCDK.RingSearches.AllRingsFinder)">
            <summary>
            Constructor for the DeduceBondSystemTool object accepting a custom <see cref="T:NCDK.RingSearches.AllRingsFinder"/>.
            </summary>
            <param name="ringFinder">a custom <see cref="T:NCDK.RingSearches.AllRingsFinder"/>.</param>
        </member>
        <member name="M:NCDK.Smiles.DeduceBondSystemTool.IsOK(NCDK.IAtomContainer)">
            <summary>
            Determines if, according to the algorithms implemented in this class, the given
            AtomContainer has properly distributed double bonds.
            </summary>
            <param name="m"><see cref="T:NCDK.IAtomContainer"/> to check the bond orders for.</param>
            <returns>true, if bond orders are properly distributed</returns>
            <exception cref="T:NCDK.CDKException">thrown when something went wrong</exception>
        </member>
        <member name="M:NCDK.Smiles.DeduceBondSystemTool.FixAromaticBondOrders(NCDK.IAtomContainer)">
            <summary>
            Added missing bond orders based on atom type information.
            </summary>
            <param name="atomContainer"><see cref="T:NCDK.IAtomContainer"/> for which to distribute double bond orders</param>
            <returns>a <see cref="T:NCDK.IAtomContainer"/> with assigned double bonds.</returns>
            <exception cref="T:NCDK.CDKException">thrown when something went wrong</exception>
        </member>
        <member name="M:NCDK.Smiles.DeduceBondSystemTool.Loop(System.Int64,NCDK.IAtomContainer,System.Int32,System.Collections.Generic.IList{System.Collections.Generic.IList{System.Collections.Generic.IList{System.String}}},System.Int32[],NCDK.IChemObjectSet{NCDK.IAtomContainer})">
            <summary>
            
            </summary>
            <param name="starttime">Start time in ticks.</param>
            <param name="atomContainer"></param>
            <param name="index"></param>
            <param name="MasterList"></param>
            <param name="choices"></param>
            <param name="som"></param>
            <returns></returns>
        </member>
        <member name="M:NCDK.Smiles.DeduceBondSystemTool.RemoveExtraRings(NCDK.IAtomContainer)">
            <summary>
            Remove rings.
            </summary>
            <remarks>
            Removes rings which do not have all sp2/planar3 aromatic atoms and also gets rid of rings that have more than
            7 or less than 5 atoms in them.
            </remarks>
            <param name="m">The AtomContainer from which we want to remove rings</param>
            <returns>The set of reduced rings</returns>
        </member>
        <member name="M:NCDK.Smiles.DeduceBondSystemTool.StoreRingSystem(NCDK.IAtomContainer,NCDK.IRingSet)">
            <summary>
            Stores an IRingSet corresponding to a AtomContainer using the bond numbers.
            </summary>
            <param name="mol">The IAtomContainer for which to store the IRingSet.</param>
            <param name="ringSet">The IRingSet to store</param>
        </member>
        <member name="M:NCDK.Smiles.DeduceBondSystemTool.RecoverRingSystem(NCDK.IAtomContainer)">
            <summary>
            Recovers a RingSet corresponding to a AtomContainer that has been
            stored by StoreRingSystem().
            </summary>
            <param name="mol">The IAtomContainer for which to recover the IRingSet.</param>
        </member>
        <member name="T:NCDK.Smiles.FixBondOrdersTool">
             <summary>
             Class to Fix bond orders at present for Aromatic Rings only.
             </summary>
             <remarks>
             Contains one public function: KekuliseAromaticRings(IAtomContainer molecule)
             <list type="bullet">
             <item>Analyses which rings are marked aromatic/SP2/Planar3</item>
             <item>Splits rings into groups containing independent sets of single/fused rings</item>
             <item>Loops over each ring group</item>
             <item>Uses an adjacency matrix of bonds (rows) and atoms (columns) to represent
             each fused ring system</item>
             <item>Scans the adjacency matrix for bonds for which there
             is no order choice (eg - both bonds to the NH of pyrrole must be single)</item>
             <item>All choices made to match valency against bonds used (including implicit H atoms)</item>
             <item>Solves other bonds as possible - dependent on previous choices - makes free
             (random) choices only where necessary and possible</item>
             <item>Makes assumption that where there is a choice in bond order
             (not forced by previous choices) - either choice is consistent with correct solution</item>
            
             <item>Requires molecule with all rings to be solved being marked aromatic
             (SP2/Planar3 atoms). All bonds to non-ring atoms need to be fully defined
             (including implicit H atoms)</item>
             </list>
             </remarks>
        </member>
        <member name="F:NCDK.Smiles.FixBondOrdersTool.Interrupted">
            <summary>
            <see langword="true"/> if the next or running calculation should be interrupted.
            </summary>
        </member>
        <member name="M:NCDK.Smiles.FixBondOrdersTool.#ctor">
            <summary>
            Constructor for the FixBondOrdersTool object.
            </summary>
        </member>
        <member name="M:NCDK.Smiles.FixBondOrdersTool.KekuliseAromaticRings(NCDK.IAtomContainer)">
            <summary>
            kekuliseAromaticRings - function to add double/single bond order information for molecules having rings containing all atoms marked SP2 or Planar3 hybridisation.
            </summary>
            <param name="molecule">The <see cref="T:NCDK.IAtomContainer"/> to kekulise</param>
            <returns>The <see cref="T:NCDK.IAtomContainer"/> with kekule structure</returns>
        </member>
        <member name="M:NCDK.Smiles.FixBondOrdersTool.RemoveExtraRings(NCDK.IAtomContainer)">
            <summary>
            Removes rings which do not have all sp2/planar3 aromatic atoms.
            and also gets rid of rings that have more than 8 atoms in them.
            </summary>
            <param name="m">The <see cref="T:NCDK.IAtomContainer"/> from which we want to remove rings</param>
            <returns>The set of reduced rings</returns>
        </member>
        <member name="M:NCDK.Smiles.FixBondOrdersTool.GetRingSystem(NCDK.IAtomContainer,NCDK.IRingSet)">
            <summary>
            Stores an <see cref="T:NCDK.IRingSet"/> corresponding to a molecule using the bond numbers.
            </summary>
            <param name="mol">The IAtomContainer for which to store the IRingSet.</param>
            <param name="ringSet">The IRingSet to store</param>
            <returns>The List of int arrays for the bond numbers of each ringSet</returns>
        </member>
        <member name="M:NCDK.Smiles.FixBondOrdersTool.AssignRingGroups(System.Collections.Generic.IList{System.Int32[]})">
            <summary>
            Assigns a set of rings to groups each sharing a bond.
            </summary>
            <param name="rBondsArray"></param>
            <returns>A List of Lists each containing the ring indices of a set of fused rings</returns>
        </member>
        <member name="M:NCDK.Smiles.FixBondOrdersTool.SetAllRingBondsSingleOrder(System.Collections.Generic.IList{System.Int32},NCDK.IRingSet)">
            <summary>
            Sets all bonds in an <see cref="T:NCDK.IRingSet"/> to single order.
            </summary>
            <returns>True for success</returns>
        </member>
        <member name="M:NCDK.Smiles.FixBondOrdersTool.GetAtomNosForRingGroup(NCDK.IAtomContainer,System.Collections.Generic.IList{System.Int32},NCDK.IRingSet)">
            <summary>
            Gets the List of atom nos corresponding to a particular set of fused rings.
            </summary>
            <returns>List of atom numbers for each set</returns>
        </member>
        <member name="M:NCDK.Smiles.FixBondOrdersTool.GetBondNosForRingGroup(NCDK.IAtomContainer,System.Collections.Generic.IList{System.Int32},NCDK.IRingSet)">
            <summary>
            Gets the List of bond nos corresponding to a particular set of fused rings.
            </summary>
            <returns>List of bond numbers for each set</returns>
        </member>
        <member name="M:NCDK.Smiles.FixBondOrdersTool.GetAtomNoPairsForRingGroup(NCDK.IAtomContainer,System.Collections.Generic.IList{System.Int32})">
            <summary>
            Gets List of atom number pairs for each bond in a list of bonds for the molecule.
            </summary>
            <returns>List of atom pairs</returns>
        </member>
        <member name="M:NCDK.Smiles.FixBondOrdersTool.GetFreeValenciesForRingGroup(NCDK.IAtomContainer,System.Collections.Generic.IList{System.Int32},NCDK.Smiles.FixBondOrdersTool.Matrix,NCDK.IRingSet)">
            <summary>
            Function to set up an array of integers corresponding to indicate how many free valencies need fulfilling for each atom through ring bonds.
            </summary>
            <returns>The List of free valencies available for extra ring bonding</returns>
        </member>
        <member name="M:NCDK.Smiles.FixBondOrdersTool.SolveMatrix(NCDK.Smiles.FixBondOrdersTool.Matrix,System.Collections.Generic.IList{System.Int32},System.Collections.Generic.IList{System.Int32},System.Collections.Generic.IList{System.Int32},System.Collections.Generic.IList{System.Int32[]},System.Collections.Generic.IList{System.Int32})">
             <summary>
             Function to solve the adjacency Matrix.
             Returns true/false on success/failure.
             Passed a reference to an array of bond orders to be filled in.
             Passed a setup Matrix M indicating the atoms that are part of each bond.
             The system v = Mb represents the set of equations: valence[atomA] = SUM
             OF ( M[A][B]*bondOrder[bondB] ) where M[A][B] = 1 if atom A is part of
             bond B, and M[A][B] = 0 otherwise. Use the system to solve bondOrder. For
             example if atom 1 has free valence 2, and is part of bonds 5 and 6, we
             know that B5 = 1, B6 = 1 if then also, atom 2 has free valence 3, and is
             part of bond 5 and bond 9, we know, from the solved equation above that
             B9 = 2. And so forth.
            
             If nothing can be deduced from previously solved equations, the code
             assigns a 1 to the first unknown bond it finds in the bondOrder array and
             continues.
             </summary>
             <returns>True or false for success or failure</returns>
        </member>
        <member name="T:NCDK.Smiles.InvPair">
            <summary>
            This is used to hold the invariance numbers for the canonical labeling of
            <see cref="T:NCDK.IAtomContainer"/>s.
            </summary>
        </member>
        <member name="F:NCDK.Smiles.InvPair.INVARIANCE_PAIR">
            <summary> The description used to set the invariance numbers in the atom's property</summary>
        </member>
        <member name="P:NCDK.Smiles.InvPair.Curr">
            <summary>
            The value of the seed.
            </summary>
            <remarks>
            Note that use of this method implies that a new prime number is desired.
            If so, make sure to set <see cref="P:NCDK.Smiles.InvPair.Prime"/> to ensure that a new prime
            number is obtained using the new seed.
            Todo make the following robust!       
            </remarks>
        </member>
        <member name="M:NCDK.Smiles.InvPair.ToString">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.Smiles.InvPair.Prime">
            <summary>
            The prime number based on the current seed.
            </summary>
        </member>
        <member name="M:NCDK.Smiles.InvPair.SetPrime">
            <summary>
            Sets the prime number based on the current seed.
            </summary>
            <remarks>
            Note that if you change the seed via <see cref="P:NCDK.Smiles.InvPair.Curr"/>, you should make
            sure to call this method so that a new prime number is available via
            <see cref="P:NCDK.Smiles.InvPair.Prime"/>. 
            </remarks>
            <seealso cref="P:NCDK.Smiles.InvPair.Curr"/>
            <seealso cref="P:NCDK.Smiles.InvPair.Prime"/>
        </member>
        <member name="T:NCDK.Smiles.SmilesGenerator">
            <summary>
            Generate a SMILES <token>cdk-cite-WEI88</token>; <token>cdk-cite-WEI89</token>provides a compact representation of
            chemical structures and reactions.
            </summary>
            <remarks>
            Different <i>flavours</i> of SMILES can be generated and are fully configurable.
            The standard flavours of SMILES defined by Daylight are:
            <list type="bullet">
                <item><b>Generic</b> - non-canonical SMILES string, different atom ordering
                    produces different SMILES. No isotope or stereochemistry encoded.
                    </item>
                <item><b>Unique</b> - canonical SMILES string, different atom ordering
                    produces the same* SMILES. No isotope or stereochemistry encoded.
                    </item>
                <item><b>Isomeric</b> - non-canonical SMILES string, different atom ordering
                    produces different SMILES. Isotope and stereochemistry is encoded.
                    </item>
                <item><b>Absolute</b> - canonical SMILES string, different atom ordering
                    produces the same SMILES. Isotope and stereochemistry is encoded.</item>
            </list> 
            
            To output a given flavour the flags in <see cref="T:NCDK.Smiles.SmiFlavor" /> are used:
            <code>                SmilesGenerator smigen = new SmilesGenerator(SmiFlavor.Isomeric);
</code>
            <see cref="T:NCDK.Smiles.SmiFlavor" /> provides more fine grained control, for example,
            for the following is equivalent to <see cref="F:NCDK.Smiles.SmiFlavor.Isomeric" />:
            <code>                SmilesGenerator smigen = new SmilesGenerator(SmiFlavor.Stereo | SmiFlavor.AtomicMass);
</code>
            Bitwise logic can be used such that we can remove options:
            <see cref="F:NCDK.Smiles.SmiFlavor.Isomeric" /> <pre>^</pre> <see cref="F:NCDK.Smiles.SmiFlavor.AtomicMass" />
            will generate isomeric SMILES without atomic mass.
            </remarks>
            <example>
            A generator instance is created using one of the static methods, the SMILES
            are then created by invoking <see cref="M:NCDK.Smiles.SmilesGenerator.Create(NCDK.IAtomContainer)" />.
            <code>                    IAtomContainer ethanol = TestMoleculeFactory.MakeEthanol();
                    sg = new SmilesGenerator(SmiFlavor.Generic);
                    smi = sg.Create(ethanol); // CCO, C(C)O, C(O)C, or OCC

                    sg = SmilesGenerator.Unique();
                    smi = sg.Create(ethanol); // only CCO
</code>
            <para>
            The isomeric and absolute generator encode tetrahedral and double bond
            stereochemistry using <see cref="T:NCDK.IStereoElement" />s
            provided on the <see cref="T:NCDK.IAtomContainer" />. If stereochemistry is not being
            written it may need to be determined from 2D/3D coordinates using <see cref="T:NCDK.Stereo.StereoElementFactory" />.
            </para> 
            <para>
            By default the generator will not write aromatic SMILES.Kekul√© SMILES are
            generally preferred for compatibility and aromaticity can easily be
            re-perceived by most tool kits whilst kekulisation may fail. If you
            really want aromatic SMILES the following code demonstrates
            </para>
            <code>                    IAtomContainer benzene = TestMoleculeFactory.MakeBenzene();

                    // 'benzene' molecule has no arom flags, we always get Kekul√© output
                    sg = new SmilesGenerator(SmiFlavor.Generic);
                    smi = sg.Create(benzene); // C1=CC=CC=C1

                    sg = new SmilesGenerator(SmiFlavor.Generic |
                                                                 SmiFlavor.UseAromaticSymbols);
                    smi = sg.Create(benzene); // C1=CC=CC=C1 flags not set!

                    // Note, in practice we'd use an aromaticity algorithm
                    foreach (IAtom a in benzene.Atoms)
                        a.IsAromatic = true;
                    foreach (IBond b in benzene.Bonds)
                        b.IsAromatic = true;

                    // 'benzene' molecule now has arom flags, we always get aromatic SMILES if we request it
                    sg = new SmilesGenerator(SmiFlavor.Generic);
                    smi = sg.Create(benzene); // C1=CC=CC=C1

                    sg = new SmilesGenerator(SmiFlavor.Generic |
                                                                 SmiFlavor.UseAromaticSymbols);
                    smi = sg.Create(benzene); // c1ccccc1
</code>
            <para>
            
            It can be useful to know the output order of SMILES. On input the order of the atoms
            reflects the atom index. If we know this order we can refer to atoms by index and
            associate data with the SMILES string.
            The output order is obtained by parsing in an auxiliary array during creation. The
            following snippet demonstrates how we can write coordinates in order.
            
            </para>
            <code>                IAtomContainer mol = TestMoleculeFactory.MakeAlphaPinene();
                SmilesGenerator sg = new SmilesGenerator(SmiFlavor.Generic);

                int n = mol.Atoms.Count;
                int[] order = new int[n];

                // the order array is filled up as the SMILES is generated
                string smi = sg.Create(mol, order);

                // load the coordinates array such that they are in the order the atoms
                // are read when parsing the SMILES
                Vector2[] coords = new Vector2[mol.Atoms.Count];
                for (int i = 0; i &lt; coords.Length; i++)
                    coords[order[i]] = mol.Atoms[i].Point2D.Value;

                // SMILES string suffixed by the coordinates
                string smi2d = smi + " " + Arrays.ToJavaString(coords);
</code>
            <para>
            Using the output order of SMILES forms the basis of
            <see href="https://www.chemaxon.com/marvin-archive/latest/help/formats/cxsmiles-doc.html">
            ChemAxon Extended SMILES (CXSMILES)</see> which can also be generated. Extended SMILES
            allows additional structure data to be serialized including, atom labels/values, fragment
            grouping (for salts in reactions), polymer repeats, multi center bonds, and coordinates.
            The CXSMILES layer is appended after the SMILES so that parser which don't interpret it
            can ignore it.
            </para>
            <para>
            The two aggregate flavours are <see cref="F:NCDK.Smiles.SmiFlavor.CxSmiles" /> and <see cref="F:NCDK.Smiles.SmiFlavor.CxSmilesWithCoords" />.
            As with other flavours, fine grain control is possible <see cref="T:NCDK.Smiles.SmiFlavor" />.
            </para>
            <b>*</b> the unique SMILES generation uses a fast equitable labelling procedure
              and as such there are some structures which may not be unique. The number
              of such structures is generally minimal.
            </example>
            <seealso cref="T:NCDK.Aromaticities.Aromaticity" /> 
            <seealso cref="T:NCDK.Stereo.StereoElementFactory" />
            <seealso cref="T:NCDK.ITetrahedralChirality" />
            <seealso cref="T:NCDK.IDoubleBondStereochemistry" />
            <seealso cref="P:NCDK.IMolecularEntity.IsAromatic" /> 
            <seealso cref="T:NCDK.Smiles.SmilesParser" />
        </member>
        <member name="M:NCDK.Smiles.SmilesGenerator.#ctor">
            <summary>
            Create the SMILES generator, the default output is described by: <see cref="F:NCDK.Smiles.SmiFlavor.Default"/>
            but is best to choose/set this flavor.
            </summary>
            <seealso cref="F:NCDK.Smiles.SmiFlavor.Default"/>
        </member>
        <member name="M:NCDK.Smiles.SmilesGenerator.#ctor(NCDK.Smiles.SmiFlavor)">
            <summary>
            Create a SMILES generator with the specified <see cref="T:NCDK.Smiles.SmiFlavor"/>.
            </summary>
            <example>
            <code>
            SmilesGenerator smigen = new SmilesGenerator(SmiFlavor.Stereo |
                                                         SmiFlavor.Canonical);
            </code>
            </example>
            <param name="flavour">SMILES flavour flags <see cref="T:NCDK.Smiles.SmiFlavor"/></param>
        </member>
        <member name="M:NCDK.Smiles.SmilesGenerator.Aromatic">
            <summary>
            Derived a new generator that writes aromatic atoms in lower case.
            </summary>
            <example>
            The preferred way of doing this is now to use the <see cref="M:NCDK.Smiles.SmilesGenerator.#ctor(NCDK.Smiles.SmiFlavor)"/> constructor:
            <code>
            SmilesGenerator smigen = new SmilesGenerator(SmiFlavor.UseAromaticSymbols);
            </code>
            </example>
            <returns>a generator for aromatic SMILES</returns>
        </member>
        <member name="M:NCDK.Smiles.SmilesGenerator.WithAtomClasses">
            <summary>
            Specifies that the generator should write atom classes in SMILES. Atom
            classes are provided by the <see cref="F:NCDK.CDKPropertyName.AtomAtomMapping"/>
            property. This method returns a new SmilesGenerator to use.
            </summary>
            <example>
            <code>
            IAtomContainer  container = ...;
            SmilesGenerator smilesGen = SmilesGenerator.WithAtomClasses();
            smilesGen.CreateSMILES(container); // C[CH2:4]O second atom has class = 4
            </code>
            </example>
            <returns>a generator for SMILES with atom classes</returns>
        </member>
        <member name="M:NCDK.Smiles.SmilesGenerator.Generic">
            <summary>
            Create a generator for generic SMILES. Generic SMILES are
            non-canonical and useful for storing information when it is not used
            as an index (i.e. unique keys). The generated SMILES is dependant on
            the input order of the atoms.
            </summary>
            <returns>a new arbitrary SMILES generator</returns>
        </member>
        <member name="M:NCDK.Smiles.SmilesGenerator.Isomeric">
            <summary>
            Convenience method for creating an isomeric generator. Isomeric SMILES
            are non-unique but contain isotope numbers (e.g. <pre>[13C]</pre>) and
            stereo-chemistry.
            </summary>
            <returns>a new isomeric SMILES generator</returns>
        </member>
        <member name="M:NCDK.Smiles.SmilesGenerator.Unique">
            <summary>
            Create a unique SMILES generator. Unique SMILES use a fast canonisation
            algorithm but does not encode isotope or stereo-chemistry.
            </summary>
            <returns>a new unique SMILES generator</returns>
        </member>
        <member name="M:NCDK.Smiles.SmilesGenerator.CreateAbsolute">
            <summary>
            Create a absolute SMILES generator. 
            </summary>
            <remarks>
            Unique SMILES uses the InChI to
            canonise SMILES and encodes isotope or stereo-chemistry. The InChI
            module is not a dependency of the SMILES module but should be present
            on the path when generation absolute SMILES.
            </remarks>
            <returns>a new absolute SMILES generator</returns>
        </member>
        <member name="M:NCDK.Smiles.SmilesGenerator.CreateSMILES(NCDK.IAtomContainer)">
            <summary>
            Create a SMILES string for the provided molecule.
            </summary>
            <param name="molecule">the molecule to create the SMILES of</param>
            <returns>a SMILES string</returns>
        </member>
        <member name="M:NCDK.Smiles.SmilesGenerator.CreateSMILES(NCDK.IReaction)">
            <summary>
            Create a SMILES string for the provided reaction.
            </summary>
            <param name="reaction">the reaction to create the SMILES of</param>
            <returns>a reaction SMILES string</returns>
        </member>
        <member name="M:NCDK.Smiles.SmilesGenerator.Create(NCDK.IAtomContainer)">
            <summary>
            Generate SMILES for the provided <code>molecule</code>.
            </summary>
            <param name="molecule">The molecule to evaluate</param>
            <returns>the SMILES string</returns>
            <exception cref="T:NCDK.CDKException">SMILES could not be created</exception>
        </member>
        <member name="M:NCDK.Smiles.SmilesGenerator.Create(NCDK.IAtomContainer,System.Int32[])">
            <summary>
            Creates a SMILES string of the flavour specified in the constructor
            and write the output order to the provided array.
            </summary>
            <remarks>
            The output order allows one to arrange auxiliary atom data in the
            order that a SMILES string will be read. A simple example is seen below
            where 2D coordinates are stored with a SMILES string. This method
            forms the basis of CXSMILES.
            </remarks>
            <example>
            <code>                IAtomContainer mol = TestMoleculeFactory.MakeAlphaPinene();
                SmilesGenerator sg = new SmilesGenerator();

                int n = mol.Atoms.Count;
                int[] order = new int[n];

                // the order array is filled up as the SMILES is generated
                string smi = sg.Create(mol, order);

                // load the coordinates array such that they are in the order the atoms
                // are read when parsing the SMILES
                Vector2[] coords = new Vector2[mol.Atoms.Count];
                for (int i = 0; i &lt; coords.Length; i++)
                    coords[order[i]] = mol.Atoms[i].Point2D.Value;

                // SMILES string suffixed by the coordinates
                string smi2d = smi + " " + Arrays.ToJavaString(coords);
</code>
            </example>
            <param name="molecule">the molecule to write</param>
            <param name="order">array to store the output order of atoms</param>
            <returns>the SMILES string</returns>
            <exception cref="T:NCDK.CDKException">SMILES could not be created</exception>
        </member>
        <member name="M:NCDK.Smiles.SmilesGenerator.Create(NCDK.IAtomContainer,NCDK.Smiles.SmiFlavor,System.Int32[])">
            <summary>
            Creates a SMILES string of the flavour specified as a parameter
            and write the output order to the provided array.
            </summary>
            <remarks>
            The output order allows one to arrange auxiliary atom data in the
            order that a SMILES string will be read. A simple example is seen below
            where 2D coordinates are stored with a SMILES string. This method
            forms the basis of CXSMILES.
            </remarks>
            <example>
            <code>                IAtomContainer mol = TestMoleculeFactory.MakeAlphaPinene();
                SmilesGenerator sg = new SmilesGenerator();

                int n = mol.Atoms.Count;
                int[] order = new int[n];

                // the order array is filled up as the SMILES is generated
                string smi = sg.Create(mol, order);

                // load the coordinates array such that they are in the order the atoms
                // are read when parsing the SMILES
                Vector2[] coords = new Vector2[mol.Atoms.Count];
                for (int i = 0; i &lt; coords.Length; i++)
                    coords[order[i]] = container.Atoms[i].Point2D.Value;

                // SMILES string suffixed by the coordinates
                string smi2d = smi + " " + Arrays.ToJavaString(coords);
</code>
            </example>
            <param name="molecule">the molecule to write</param>
            <param name="order">array to store the output order of atoms</param>
            <returns>the SMILES string</returns>
            <exception cref="T:NCDK.CDKException">a valid SMILES could not be created</exception>
        </member>
        <member name="M:NCDK.Smiles.SmilesGenerator.CreateReactionSMILES(NCDK.IReaction)">
            <summary>
            Create a SMILES for a reaction.
            </summary>
            <param name="reaction">CDK reaction instance</param>
            <returns>reaction SMILES</returns>
            <exception cref="T:NCDK.CDKException">a valid SMILES could not be created</exception>
        </member>
        <member name="M:NCDK.Smiles.SmilesGenerator.Create(NCDK.IReaction)">
            <summary>
            Create a SMILES for a reaction of the flavour specified in the constructor.
            </summary>
            <param name="reaction">CDK reaction instance</param>
            <returns>reaction SMILES</returns>
        </member>
        <member name="M:NCDK.Smiles.SmilesGenerator.Create(NCDK.IReaction,System.Int32[])">
            <summary>
            Create a SMILES for a reaction of the flavour specified in the constructor and
            write the output order to the provided array.
            </summary>
            <param name="reaction">CDK reaction instance</param>
            <returns>reaction SMILES</returns>
        </member>
        <member name="M:NCDK.Smiles.SmilesGenerator.SetUseAromaticityFlag(System.Boolean)">
            <summary>
            Indicates whether output should be an aromatic SMILES.
            </summary>
            <param name="useAromaticityFlag">if false only SP2-hybridized atoms will be lower case (default), true=SP2 or aromaticity trigger lower case</param>
        </member>
        <member name="M:NCDK.Smiles.SmilesGenerator.Labels(NCDK.Smiles.SmiFlavor,NCDK.IAtomContainer)">
            <summary>
            Given a molecule (possibly disconnected) compute the labels which
            would order the atoms by increasing canonical labelling. If the SMILES
            are isomeric (i.e. stereo and isotope specific) the InChI numbers are
            used. These numbers are loaded via reflection and the 'cdk-inchi' module
            should be present on the path.
            </summary>
            <param name="molecule">the molecule to</param>
            <returns>the permutation</returns>
            <seealso cref="T:NCDK.Graphs.Invariant.Canon"/>
        </member>
        <member name="M:NCDK.Smiles.SmilesGenerator.InchiNumbers(NCDK.IAtomContainer)">
            <summary>
            Obtain the InChI numbering for canonising SMILES. The cdk-smiles module
            does not and should not depend on cdk-inchi and so the numbers are loaded
            via reflection. If the class cannot be found on the path an
            exception is thrown.
            </summary>
            <param name="container">a structure</param>
            <returns>the inchi numbers</returns>
            <exception cref="T:NCDK.CDKException">the inchi numbers could not be obtained</exception>
        </member>
        <member name="T:NCDK.Smiles.SmilesParser">
            <summary>
            Read molecules and reactions from a SMILES <token>cdk-cite-SMILESTUT</token> string.
            </summary>
            <example>
            <code>                SmilesParser sp = new SmilesParser(Silent.ChemObjectBuilder.Instance);
                IAtomContainer m = sp.ParseSmiles("c1[cH:5]cccc1");
                var c1 = m.Atoms[1].GetProperty&lt;int&gt;(CDKPropertyName.AtomAtomMapping); // 5
                var c2 = m.Atoms[2].GetProperty&lt;int&gt;(CDKPropertyName.AtomAtomMapping); // null
</code>
            </example>
            <remarks>
            Reading Aromatic SMILES
            <para>
            Aromatic SMILES are automatically kekulised producing a structure with
            assigned bond orders. The aromatic specification on the atoms is maintained
            from the SMILES even if the structures are not considered aromatic. For
            example 'c1ccc1' will correctly have two pi bonds assigned but the
            atoms/bonds will still be flagged as aromatic. Recomputing or clearing the
            aromaticty will remove these erroneous flags. If a kekul√© structure could not
            be assigned this is considered an error. The most common example is the
            omission of hydrogens on aromatic nitrogens (aromatic pyrrole is specified as
            '[nH]1cccc1' not 'n1cccc1'). These structures can not be corrected without
            modifying their formula. If there are multiple locations a hydrogen could be
            placed the returned structure would differ depending on the atom input order.
            If you wish to skip the kekulistation (not recommended) then it can be
            disabled with <see cref="F:NCDK.Smiles.SmilesParser.kekulise" />. SMILES can be verified for validity with the
            <see href="http://www.daylight.com/daycgi/depict">DEPICT</see> service.
            </para>
            Unsupported Features
            <para>
            The following features are not supported by this parser.
            <list type="bullet">
            <item>variable order of bracket atom attributes, '[C-H]', '[CH@]' are considered invalid.
            The predefined order required by this parser follows the 
            <see href="http://www.opensmiles.org/opensmiles.html">OpenSMILES</see> 
            specification of 'isotope', 'symbol', 'chiral', 'hydrogens', 'charge', 'atom class'</item>
            <item>atom class indication - <i>this information is loaded but not annotated on the structure</i> </item>
            <item>extended tetrahedral stereochemistry (cumulated double bonds)</item>
            <item>trigonal bipyramidal stereochemistry</item>
            <item>octahedral stereochemistry</item>
            </list>
            </para>
            Atom Class
            <para>
            The atom class is stored as the <see cref="F:NCDK.CDKPropertyName.AtomAtomMapping" /> property.
            </para>
            <code>                SmilesParser sp = new SmilesParser(Silent.ChemObjectBuilder.Instance);
                IAtomContainer m = sp.ParseSmiles("c1[cH:5]cccc1");
                var c1 = m.Atoms[1].GetProperty&lt;int&gt;(CDKPropertyName.AtomAtomMapping); // 5
                var c2 = m.Atoms[2].GetProperty&lt;int&gt;(CDKPropertyName.AtomAtomMapping); // null
</code>
            </remarks>
        </member>
        <member name="F:NCDK.Smiles.SmilesParser.builder">
            <summary>
            The builder determines which CDK domain objects to create.
            </summary>
        </member>
        <member name="F:NCDK.Smiles.SmilesParser.beamToCDK">
            <summary>
            Direct converter from Beam to CDK.
            </summary>
        </member>
        <member name="F:NCDK.Smiles.SmilesParser.kekulise">
            <summary>
            Kekulise the molecule on load. Generally this is a good idea as a
            lower-case symbols in a SMILES do not really mean 'aromatic' but rather
            'conjugated'. Loading with kekulise 'on' will automatically assign
            bond orders (if possible) using an efficient algorithm from the
            underlying Beam library (soon to be added to CDK).
            </summary>
        </member>
        <member name="M:NCDK.Smiles.SmilesParser.#ctor(NCDK.IChemObjectBuilder)">
            <summary>
            Create a new SMILES parser which will create <see cref="T:NCDK.IAtomContainer"/>s with
            the specified builder.
            </summary>
            <param name="builder">used to create the CDK domain objects</param>
        </member>
        <member name="M:NCDK.Smiles.SmilesParser.ParseReactionSmiles(System.String)">
            <summary>
            Parse a reaction SMILES.
            </summary>
            <param name="smiles">The SMILES string to parse</param>
            <returns>An instance of <see cref="T:NCDK.IReaction"/></returns>
            <exception cref="T:NCDK.InvalidSmilesException">if the string cannot be parsed</exception>
            <seealso cref="M:NCDK.Smiles.SmilesParser.ParseSmiles(System.String)"/>
        </member>
        <member name="M:NCDK.Smiles.SmilesParser.ParseSmiles(System.String)">
            <summary>
            Parses a SMILES string and returns a structure (<see cref="T:NCDK.IAtomContainer"/>).
            </summary>
            <param name="smiles">A SMILES string</param>
            <returns>A structure representing the provided SMILES</returns>
            <exception cref="T:NCDK.InvalidSmilesException">thrown when the SMILES string is invalid</exception>
        </member>
        <member name="M:NCDK.Smiles.SmilesParser.ParseIntSafe(System.String)">
            <summary>
            Safely parses an integer from a string and will not fail if a number is missing.
            </summary>
            <param name="val">value</param>
            <returns>the integer value</returns>
        </member>
        <member name="M:NCDK.Smiles.SmilesParser.ParseMolCXSMILES(System.String,NCDK.IAtomContainer)">
            <summary>
            Parses CXSMILES layer and set attributes for atoms and bonds on the provided molecule.
            </summary>
            <param name="title">SMILES title field</param>
            <param name="mol">molecule</param>
        </member>
        <member name="M:NCDK.Smiles.SmilesParser.ParseRxnCXSMILES(System.String,NCDK.IReaction)">
            <summary>
            Parses CXSMILES layer and set attributes for atoms and bonds on the provided reaction.
            </summary>
            <param name="title">SMILES title field</param>
            <param name="rxn">parsed reaction</param>
        </member>
        <member name="M:NCDK.Smiles.SmilesParser.HandleFragmentGrouping(NCDK.IReaction,NCDK.Smiles.CxSmilesState)">
            <summary>
            Handle fragment grouping of a reaction that specifies certain disconnected components
            are actually considered a single molecule. Normally used for salts, [Na+].[OH-].
            </summary>
            <param name="rxn">reaction</param>
            <param name="cxstate">state</param>
        </member>
        <member name="M:NCDK.Smiles.SmilesParser.AssignCxSmilesInfo(NCDK.IChemObjectBuilder,NCDK.IChemObject,System.Collections.Generic.IList{NCDK.IAtom},System.Collections.Generic.IDictionary{NCDK.IAtom,NCDK.IAtomContainer},NCDK.Smiles.CxSmilesState)">
            <summary>
            Transfers the CXSMILES state onto the CDK atom/molecule data-structures.
            </summary>
            <param name="bldr">chem-object builder</param>
            <param name="atoms">atoms parsed from the molecule or reaction. Reaction molecules are list  left to right.</param>
            <param name="atomToMol">look-up of atoms to molecules when connectivity/sgroups need modification</param>
            <param name="cxstate">the CXSMILES state to read from</param>
        </member>
        <member name="P:NCDK.Smiles.SmilesParser.IsPreservingAromaticity">
            <summary>
            The (default false) setting to preserve aromaticity as provided in
            the Smiles itself. Indicating if aromaticity is preserved.
            </summary>
        </member>
        <member name="M:NCDK.Smiles.SmilesParser.Kekulise(System.Boolean)">
            <summary>
            Indicated whether structures should be automatically kekulised if they
            are provided as aromatic. Kekulisation is on by default but can be
            turned off if it is believed the structures can be handled without
            assigned bond orders (not recommended).
            </summary>
            <param name="kekulise">should structures be kekulised</param>
        </member>
        <member name="T:NCDK.Geometries.AtomTools">
            <summary>
            A set of static utility classes for geometric calculations on Atoms.
            </summary>
        </member>
        <member name="M:NCDK.Geometries.AtomTools.add3DCoordinates1(NCDK.IAtomContainer)">
            <summary>
            Generate coordinates for all atoms which are singly bonded and have
            no coordinates. This is useful when hydrogens are present but have
            no coordinates. It knows about C, O, N, S only and will give tetrahedral or
            trigonal geometry elsewhere. Bond lengths are computed from covalent radii
            if available. Angles are tetrahedral or trigonal
            </summary>
            <param name="atomContainer">the set of atoms involved</param>
        </member>
        <member name="M:NCDK.Geometries.AtomTools.RescaleBondLength(NCDK.IAtom,NCDK.IAtom,NCDK.Numerics.Vector3)">
            <summary>
            Rescales Point2 so that length 1-2 is sum of covalent radii.
            if covalent radii cannot be found, use bond length of 1.0
            </summary>
            <param name="atom1">stationary atom</param>
            <param name="atom2">movable atom</param>
            <param name="point2">coordinates for atom 2</param>
            <returns>new coords for atom 2</returns>
        </member>
        <member name="M:NCDK.Geometries.AtomTools.Calculate3DCoordinatesForLigands(NCDK.IAtomContainer,NCDK.IAtom,System.Int32,System.Double,System.Double)">
            <summary>
            Adds 3D coordinates for singly-bonded ligands of a reference atom (A).
            Initially designed for hydrogens. The ligands of refAtom are identified
            and those with 3D coordinates used to generate the new points. (This
            allows structures with partially known 3D coordinates to be used, as when
            groups are added.)
            </summary>
            <remarks>
            "Bent" and "non-planar" groups can be formed by taking a subset of the
            calculated points. Thus R-NH2 could use 2 of the 3 points calculated
            from (1,iii)
            nomenclature: A is point to which new ones are "attached".
                A may have ligands B, C...
                B may have ligands J, K..
                points X1, X2... are returned
            The cases (see individual routines, which use idealised geometry by default):
            (0) zero ligands of refAtom. The resultant points are randomly oriented:
               (i) 1 points  required; +x,0,0
               (ii) 2 points: use +x,0,0 and -x,0,0
               (iii) 3 points: equilateral triangle in xy plane
               (iv) 4 points x,x,x, x,-x,-x, -x,x,-x, -x,-x,x
            (1a) 1 Ligand(B) of refAtom which itself has a ligand (J)
               (i) 1 points  required; vector along AB vector
               (ii) 2 points: 2 vectors in ABJ plane, staggered and eclipsed wrt J
               (iii) 3 points: 1 staggered wrt J, the others +- gauche wrt J
            (1b) 1 Ligand(B) of refAtom which has no other ligands. A random J is
            generated and (1a) applied
            (2) 2 Ligands(B, C) of refAtom A
               (i) 1 points  required; vector in ABC plane bisecting AB, AC. If ABC is linear, no points
               (ii) 2 points: 2 vectors at angle ang, whose resultant is 2i
            (3) 3 Ligands(B, C, D) of refAtom A
               (i) 1 points  required; if A, B, C, D coplanar, no points.
                  else vector is resultant of BA, CA, DA
            fails if atom itself has no coordinates or &gt;4 ligands
            </remarks>
            <param name="atomContainer">describing the ligands of refAtom. It could be the whole molecule, or could be a selected subset of ligands</param>
            <param name="refAtom">(A) to which new ligands coordinates could be added</param>
            <param name="length">A-X length</param>
            <param name="angle">B-A-X angle (used in certain cases)</param>
            <param name="nwanted"></param>
            <returns>Point3D[] points calculated. If request could not be fulfilled (e.g. too many atoms, or strange geometry, returns empty array (zero length, not null)</returns>
        </member>
        <member name="M:NCDK.Geometries.AtomTools.Calculate3DCoordinates0(NCDK.Numerics.Vector3,System.Int32,System.Double)">
             <summary>
             Calculates substituent points.
             Calculate substituent points for
            
             (0) zero ligands of aPoint. The resultant points are randomly oriented:
                (i) 1 points  required; +x,0,0
                (ii) 2 points: use +x,0,0 and -x,0,0
                (iii) 3 points: equilateral triangle in xy plane
                (iv) 4 points x,x,x, x,-x,-x, -x,x,-x, -x,-x,x where 3x**2 = bond length
             </summary>
             <param name="aPoint">to which substituents are added</param>
             <param name="nwanted">number of points to calculate (1-4)</param>
             <param name="length">from aPoint</param>
             <returns>Vector3[] nwanted points (or zero if failed)</returns>
        </member>
        <member name="M:NCDK.Geometries.AtomTools.Calculate3DCoordinates1(System.Nullable{NCDK.Numerics.Vector3},System.Nullable{NCDK.Numerics.Vector3},System.Nullable{NCDK.Numerics.Vector3},System.Int32,System.Double,System.Double)">
             <summary>
             Calculate new Point(s) X in a B-A system to form B-A-X.
             Use C as reference for * staggering about the B-A bond
            
             (1a) 1 Ligand(B) of refAtom (A) which itself has a ligand (C)
                (i) 1 points  required; vector along AB vector
                (ii) 2 points: 2 vectors in ABC plane, staggered and eclipsed wrt C
                (iii) 3 points: 1 staggered wrt C, the others +- gauche wrt C
             If C is null, a random non-colinear C is generated
             </summary>
             <param name="aPoint">to which substituents are added</param>
             <param name="bPoint">first ligand of A</param>
             <param name="cPoint">second ligand of A</param>
             <param name="nwanted">number of points to calculate (1-3)</param>
             <param name="length">A-X length</param>
             <param name="angle">B-A-X angle</param>
             <returns>Vector3[] nwanted points (or zero if failed)</returns>
        </member>
        <member name="M:NCDK.Geometries.AtomTools.Calculate3DCoordinates2(System.Nullable{NCDK.Numerics.Vector3},System.Nullable{NCDK.Numerics.Vector3},System.Nullable{NCDK.Numerics.Vector3},System.Int32,System.Double,System.Double)">
             <summary>
             Calculate new Point(s) X in a B-A-C system. It forms form a B-A(-C)-X system.
            
             (2) 2 Ligands(B, C) of refAtom A
                (i) 1 points  required; vector in ABC plane bisecting AB, AC. If ABC is
                    linear, no points
                (ii) 2 points: 2 points X1, X2, X1-A-X2 = angle about 2i vector
             </summary>
             <param name="aPoint">to which substituents are added</param>
             <param name="bPoint">first ligand of A</param>
             <param name="cPoint">second ligand of A</param>
             <param name="nwanted">number of points to calculate (1-2)</param>
             <param name="length">A-X length</param>
             <param name="angle">B-A-X angle</param>
             <returns>Vector3[] nwanted points (or zero if failed)</returns>
        </member>
        <member name="M:NCDK.Geometries.AtomTools.Calculate3DCoordinates3(NCDK.Numerics.Vector3,NCDK.Numerics.Vector3,NCDK.Numerics.Vector3,NCDK.Numerics.Vector3,System.Double)">
             <summary>
             Calculate new point X in a B-A(-D)-C system. It forms a B-A(-D)(-C)-X system.
            
             (3) 3 Ligands(B, C, D) of refAtom A
                (i) 1 points  required; if A, B, C, D coplanar, no points.
                   else vector is resultant of BA, CA, DA
             </summary>
             <param name="aPoint">to which substituents are added</param>
             <param name="bPoint">first ligand of A</param>
             <param name="cPoint">second ligand of A</param>
             <param name="dPoint">third ligand of A</param>
             <param name="length">A-X length</param>
             <returns>Vector3 nwanted points (or null if failed (coplanar))</returns>
        </member>
        <member name="M:NCDK.Geometries.AtomTools.GetNonColinearVector(NCDK.Numerics.Vector3)">
            gets a point not on vector a...b; this can be used to define a plan or cross products
        </member>
        <member name="T:NCDK.Geometries.Projector">
            <summary>
            Tool to make projections from 3D to 2D.
            </summary>
        </member>
        <member name="T:NCDK.Geometries.RDFCalculator">
            <summary>
            Calculator of radial distribution functions. The RDF has bins defined around
            a point, i.e. the first bin starts at 0 ‚Ñ´ and ends at 0.5*resolution
            ‚Ñ´, and the second bins ends at 1.5*resolution ‚Ñ´.
            </summary>
            <example>
            By default, the RDF is unweighted. By implementing and registering a
            <c>RDFWeightFunction</c>, the RDF can become weighted. For example,
            to weight according to partial charge interaction, this code could be used:
            <code>            RDFCalculator calculator = new RDFCalculator(0.0, 5.0, 0.1, 0.0,
                delegate(IAtom atom, IAtom atom2) { return atom.Charge.Value * atom2.Charge.Value; });
</code>
            </example>
            <seealso cref="T:NCDK.Geometries.RDFCalculator.WeightFunction" />
        </member>
        <member name="T:NCDK.Geometries.RDFCalculator.WeightFunction">
            <summary>
            Calculates the weight for the interaction between the two atoms.
            </summary>
            <param name="atom">First atom.</param>
            <param name="atom2">Second atom.</param>
            <returns></returns>
        </member>
        <member name="M:NCDK.Geometries.RDFCalculator.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Constructs a RDF calculator that calculates a unweighted, digitized
            RDF function.
            </summary>
            <param name="startCutoff">radial length in √Öngstrom at which the RDF starts</param>
            <param name="cutoff">radial length in √Öngstrom at which the RDF stops</param>
            <param name="resolution">width of the bins</param>
            <param name="peakWidth">width of the gaussian applied to the peaks in √Öngstrom</param>
        </member>
        <member name="M:NCDK.Geometries.RDFCalculator.#ctor(System.Double,System.Double,System.Double,System.Double,NCDK.Geometries.RDFCalculator.WeightFunction)">
            <summary>
            Constructs a RDF calculator that calculates a digitized RDF function.
            </summary>
            <param name="startCutoff">radial length in √Öngstrom at which the RDF starts</param>
            <param name="cutoff">radial length in √Öngstrom at which the RDF stops</param>
            <param name="resolution">width of the bins</param>
            <param name="peakWidth">width of the gaussian applied to the peaks in √Öngstrom</param>
            <param name="weightFunction">the weight function. If null, then an unweighted RDF is calculated</param>
        </member>
        <member name="M:NCDK.Geometries.RDFCalculator.Calculate(NCDK.IAtomContainer,NCDK.IAtom)">
            <summary>
            Calculates a RDF for <paramref name="atom"/> in the environment of the atoms in the <paramref name="container"/>.
            </summary>
        </member>
        <member name="T:NCDK.Geometries.CIP.Rules.AtomicNumberRule">
            <summary>
            Compares to <see cref="T:NCDK.Geometries.CIP.ILigand"/>s based on atomic numbers.
            </summary>
        </member>
        <member name="T:NCDK.Geometries.CIP.Rules.CIPLigandRule">
            <summary>
            Compares to <see cref="T:NCDK.Geometries.CIP.ILigand"/>s based on CIP sequences sub rules. The used CIP sub rules are:
            <list type="bullet">
            <item><see cref="T:NCDK.Geometries.CIP.Rules.MassNumberRule"/></item>
            <item><see cref="T:NCDK.Geometries.CIP.Rules.AtomicNumberRule"/></item>
            </list>
            </summary>
        </member>
        <member name="M:NCDK.Geometries.CIP.Rules.CIPLigandRule.Order(NCDK.Geometries.CIP.ILigand[])">
            <summary>
            Order the ligands from high to low precedence according to atomic and mass numbers.
            </summary>
        </member>
        <member name="T:NCDK.Geometries.CIP.Rules.CombinedAtomicMassNumberRule">
            <summary>
            Compares to <see cref="T:NCDK.Geometries.CIP.ILigand"/>s based on CIP sequences sub rules. The used CIP sub rules are:
            <list type="bullet">
            <item><see cref="T:NCDK.Geometries.CIP.Rules.MassNumberRule"/></item>
            <item><see cref="T:NCDK.Geometries.CIP.Rules.AtomicNumberRule"/></item>
            </list>
            </summary>
        </member>
        <member name="T:NCDK.Geometries.CIP.Rules.ISequenceSubRule`1">
            <summary>
            Sequence sub rule used in the CIP method to decide which of the two ligands takes
            precedence <token>cdk-cite-Cahn1966</token>. A list ordered based on these rules will be
            sorted from low to high precedence.
            </summary>
            <remarks>
            Compares two ligands according to the particular sequence sub rule. It returns
            1 if ligand1 takes precedence over ligand2, -1 if ligand2 takes precedence over
            ligand1, and 0 if they are equal.
            </remarks>
        </member>
        <member name="T:NCDK.Geometries.CIP.Rules.MassNumberRule">
            <summary>
            Compares to <see cref="T:NCDK.Geometries.CIP.ILigand"/>s based on mass numbers.
            </summary>
        </member>
        <member name="T:NCDK.Geometries.CIP.CIPTool">
            <summary>
            Tool to help determine the R,S and stereochemistry definitions of a subset of the
            CIP rules <token>cdk-cite-Cahn1966</token>. The used set up sub rules are specified in the
            <see cref="T:NCDK.Geometries.CIP.Rules.CIPLigandRule" /> class.
            </summary>
            <example>
            Basic use starts from a <see cref="T:NCDK.ITetrahedralChirality" /> and therefore
            assumes atoms with four neighbours:
            <code>            IAtom[] ligandAtoms = mol.GetConnectedAtoms(centralAtom).ToArray();
            ITetrahedralChirality tetraStereo = new TetrahedralChirality(centralAtom, ligandAtoms, TetrahedralStereo.AntiClockwise);
            CIPChiralities cipChirality = CIPTool.GetCIPChirality(mol, tetraStereo);
</code>
            The <see cref="T:NCDK.BondStereo" /> value can be
            reconstructed from 3D coordinates with the <see cref="T:NCDK.Stereo.StereoTool" />.
            </example>
        </member>
        <member name="F:NCDK.Geometries.CIP.CIPTool.Hydrogen">
            <summary>
            IAtom index to indicate an implicit hydrogen, not present in the chemical graph.
            </summary>
        </member>
        <member name="T:NCDK.Geometries.CIP.CIPTool.CIPChiralities">
            <summary>
            Enumeration with the two tetrahedral chiralities defined by the CIP schema.
            </summary>
        </member>
        <member name="M:NCDK.Geometries.CIP.CIPTool.GetCIPChirality(NCDK.Geometries.CIP.LigancyFourChirality)">
            <summary>
            Returns the R or S chirality according to the CIP rules, based on the given
            chirality information.
            </summary>
            <param name="stereoCenter">Chiral center for which the CIP chirality is to be
                                determined as <see cref="T:NCDK.Geometries.CIP.LigancyFourChirality"/> object.</param>
            <returns>A <see cref="T:NCDK.Geometries.CIP.CIPTool.CIPChiralities"/> value.</returns>
        </member>
        <member name="M:NCDK.Geometries.CIP.CIPTool.Label(NCDK.IAtomContainer)">
            <summary>
            Convenience method for labelling all stereo elements. The <see cref="T:NCDK.Geometries.CIP.CIPTool.CIPChiralities"/> is determined for each element and stored as as <see cref="T:System.String"/> 
            on the <see cref="F:NCDK.CDKPropertyName.CIP_Descriptor"/> property key.
            Atoms/bonds that are not stereocenters have no label assigned and the
            property will be null.
            </summary>
            <param name="container">structure to label</param>
        </member>
        <member name="M:NCDK.Geometries.CIP.CIPTool.GetCIPChirality(NCDK.IAtomContainer,NCDK.ITetrahedralChirality)">
            <summary>
            Returns the R or S chirality according to the CIP rules, based on the given
            chirality information.
            </summary>
            <param name="container"><see cref="T:NCDK.IAtomContainer"/> to which the <paramref name="stereoCenter"/> belongs.</param>              
            <param name="stereoCenter">Chiral center for which the CIP chirality is to be determined as <see cref="T:NCDK.ITetrahedralChirality"/> object.</param>
            <returns>A <see cref="T:NCDK.Geometries.CIP.CIPTool.CIPChiralities"/> value.</returns>
        </member>
        <member name="M:NCDK.Geometries.CIP.CIPTool.GetLigands(NCDK.IAtom,NCDK.IAtomContainer,NCDK.IAtom)">
            <summary>
            Obtain the ligands connected to the 'atom' excluding 'exclude'. This is
            mainly meant as a utility for double-bond labelling.
            </summary>
            <param name="atom">an atom</param>
            <param name="container">a structure to which 'atom' belongs</param>
            <param name="exclude">exclude this atom - can not be null</param>
            <returns>the ligands</returns>
        </member>
        <member name="M:NCDK.Geometries.CIP.CIPTool.CheckIfAllLigandsAreDifferent(NCDK.Geometries.CIP.ILigand[])">
            <summary>
            Checks if each next <see cref="T:NCDK.Geometries.CIP.ILigand"/> is different from the previous
            one according to the <see cref="T:NCDK.Geometries.CIP.Rules.CIPLigandRule"/>. It assumes that the input
            is sorted based on that rule.
            </summary>
            <param name="ligands">array of <see cref="T:NCDK.Geometries.CIP.ILigand"/> to check</param>
            <returns>true, if all ligands are different</returns>
        </member>
        <member name="M:NCDK.Geometries.CIP.CIPTool.Order(NCDK.Geometries.CIP.ILigand[])">
            <summary>
            Reorders the <see cref="T:NCDK.Geometries.CIP.ILigand"/> objects in the array according to the CIP rules.
            </summary>
            <param name="ligands">Array of <see cref="T:NCDK.Geometries.CIP.ILigand"/>s to be reordered.</param>
            <returns>Reordered array of <see cref="T:NCDK.Geometries.CIP.ILigand"/>s.</returns>
        </member>
        <member name="M:NCDK.Geometries.CIP.CIPTool.PermParity(NCDK.Geometries.CIP.ILigand[])">
            <summary>
            Obtain the permutation parity (-1,0,+1) to put the ligands in descending
            order (highest first). A parity of 0 indicates two or more ligands were
            equivalent.
            </summary>
            <param name="ligands">the ligands to sort</param>
            <returns>parity, odd (-1), even (+1) or none (0)</returns>
        </member>
        <member name="M:NCDK.Geometries.CIP.CIPTool.DefineLigancyFourChirality(NCDK.IAtomContainer,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,NCDK.TetrahedralStereo)">
            <summary>
            Creates a ligancy for chirality around a single chiral atom, where the involved
            atoms are identified by there index in the <see cref="T:NCDK.IAtomContainer"/>. For the four ligand
            atoms, <see cref="F:NCDK.Geometries.CIP.CIPTool.Hydrogen"/> can be passed as index, which will indicate the presence of
            an implicit hydrogen, not explicitly present in the chemical graph of the
            given <paramref name="container"/>.
            </summary>
            <param name="container"><see cref="T:NCDK.IAtomContainer"/> for which the returned <see cref="T:NCDK.Geometries.CIP.ILigand"/>s are defined</param>
            <param name="chiralAtom">int pointing to the <see cref="T:NCDK.IAtom"/> index of the chiral atom</param>
            <param name="ligand1">int pointing to the <see cref="T:NCDK.IAtom"/> index of the first <see cref="T:NCDK.Geometries.CIP.ILigand"/></param>
            <param name="ligand2">int pointing to the <see cref="T:NCDK.IAtom"/> index of the second <see cref="T:NCDK.Geometries.CIP.ILigand"/></param>
            <param name="ligand3">int pointing to the <see cref="T:NCDK.IAtom"/> index of the third <see cref="T:NCDK.Geometries.CIP.ILigand"/></param>
            <param name="ligand4">int pointing to the <see cref="T:NCDK.IAtom"/> index of the fourth <see cref="T:NCDK.Geometries.CIP.ILigand"/></param>
            <param name="stereo"><see cref="T:NCDK.TetrahedralStereo"/> for the chirality</param>
            <returns>the created <see cref="T:NCDK.Geometries.CIP.LigancyFourChirality"/></returns>
        </member>
        <member name="M:NCDK.Geometries.CIP.CIPTool.DefineLigand(NCDK.IAtomContainer,NCDK.Geometries.CIP.VisitedAtoms,System.Int32,System.Int32)">
            <summary>
            Creates a ligand attached to a single chiral atom, where the involved
            atoms are identified by there index in the <see cref="T:NCDK.IAtomContainer"/>. For ligand
            atom, <see cref="F:NCDK.Geometries.CIP.CIPTool.Hydrogen"/> can be passed as index, which will indicate the presence of
            an implicit hydrogen, not explicitly present in the chemical graph of the
            given <paramref name="container"/>.
            </summary>
            <param name="container"><see cref="T:NCDK.IAtomContainer"/> for which the returned <see cref="T:NCDK.Geometries.CIP.ILigand"/>s are defined</param>
            <param name="visitedAtoms">a list of atoms already visited in the analysis</param>
            <param name="chiralAtom">an integer pointing to the <see cref="T:NCDK.IAtom"/> index of the chiral atom</param>
            <param name="ligandAtom">an integer pointing to the <see cref="T:NCDK.IAtom"/> index of the <see cref="T:NCDK.Geometries.CIP.ILigand"/></param>
            <returns>the created <see cref="T:NCDK.Geometries.CIP.ILigand"/></returns>
        </member>
        <member name="M:NCDK.Geometries.CIP.CIPTool.GetLigandLigands(NCDK.Geometries.CIP.ILigand)">
            <summary>
            Returns a CIP-expanded array of side chains of a ligand. If the ligand atom is only connected to
            the chiral atom, the method will return an empty list. The expansion involves the CIP rules,
            so that a double bonded oxygen will be represented twice in the list.
            </summary>
            <param name="ligand">the <see cref="T:NCDK.Geometries.CIP.ILigand"/> for which to return the ILigands</param>
            <returns>a <see cref="T:NCDK.Geometries.CIP.ILigand"/> array with the side chains of the ligand atom</returns>
        </member>
        <member name="M:NCDK.Geometries.CIP.CIPTool.GetDuplication(NCDK.BondOrder)">
            <summary>
            Returns the number of times the side chain should end up as the CIP-expanded ligand list. The CIP
            rules prescribe that a double bonded oxygen should be represented twice in the list.
            </summary>
            <param name="order"><see cref="T:NCDK.BondOrder"/> of the bond</param>
            <returns>int reflecting the duplication number</returns>
        </member>
        <member name="T:NCDK.Geometries.CIP.ILigand">
            <summary>
            Concept of a ligand in CIP terms, reflecting a side chain of a central atom that can
            have precedence over another.
            </summary>
        </member>
        <member name="M:NCDK.Geometries.CIP.ILigand.GetAtomContainer">
            <summary>
            <see cref="T:NCDK.IAtomContainer"/> of which this ligand is part.
            </summary>
            <returns>the IAtomContainer</returns>
        </member>
        <member name="M:NCDK.Geometries.CIP.ILigand.GetCentralAtom">
            <summary>
            The central <see cref="T:NCDK.IAtom"/> to which this ligand is connected via one <see cref="T:NCDK.IBond"/>.
            </summary>
            <returns>the central atom</returns>
        </member>
        <member name="M:NCDK.Geometries.CIP.ILigand.GetLigandAtom">
            <summary>
            <see cref="T:NCDK.IAtom"/> of the ligand that is connected to the central <see cref="T:NCDK.IAtom"/> via
            one <see cref="T:NCDK.IBond"/>.
            </summary>
            <returns>the ligand atom</returns>
        </member>
        <member name="M:NCDK.Geometries.CIP.ILigand.GetVisitedAtoms">
            <summary>
            Returns a list of visitedAtoms.
            </summary>
            <returns>a <see cref="T:NCDK.Geometries.CIP.VisitedAtoms"/> list with visited atoms</returns>
        </member>
        <member name="M:NCDK.Geometries.CIP.ILigand.IsVisited(NCDK.IAtom)">
            <summary>
            Returns a true if the atom has been visited before.
            </summary>
            <param name="atom">the atom to be analyzed</param>
            <returns>true if the <see cref="T:NCDK.IAtom"/> is the chiral atom, or part of the ligand</returns>
        </member>
        <member name="T:NCDK.Geometries.CIP.ImmutableHydrogen">
            <summary>
            Helper class to represent a immutable hydrogen. All set methods are void, and only
            <see cref="P:NCDK.Geometries.CIP.ImmutableHydrogen.Symbol"/>, <see cref="P:NCDK.Geometries.CIP.ImmutableHydrogen.AtomicNumber"/>, and <see cref="P:NCDK.Geometries.CIP.ImmutableHydrogen.MassNumber"/> are
            implemented.
            </summary>
        </member>
        <member name="P:NCDK.Geometries.CIP.ImmutableHydrogen.Charge">
            <summary>
            This field is not used by this immutable hydrogen.
            Any setting will have no effect what so ever.
            </summary>
        </member>
        <member name="P:NCDK.Geometries.CIP.ImmutableHydrogen.Listeners">
            <summary>
            List for listener administration.
            </summary>
        </member>
        <member name="T:NCDK.Geometries.CIP.ImplicitHydrogenLigand">
            <summary>
            Subclass of <see cref="T:NCDK.Geometries.CIP.Ligand"/> to which no further recursion must be applied.
            </summary>
        </member>
        <member name="T:NCDK.Geometries.CIP.LigancyFourChirality">
            <summary>
            Stereochemistry specification for quadrivalent atoms to be used for the CIP algorithm only.
            </summary>
            <remarks>
            The data model defines the central, chiral <see cref="T:NCDK.IAtom"/>,
            and its four <see cref="T:NCDK.Geometries.CIP.ILigand"/>s, each of which has an ligand <see cref="T:NCDK.IAtom"/>, directly bonded to the chiral atom via
            an <see cref="T:NCDK.IBond"/>. The ordering of the four ligands is important, and defines together with the <see cref="P:NCDK.Geometries.CIP.LigancyFourChirality.Stereo"/>
            to spatial geometry around the chiral atom. The first ligand points towards to observer, and the three other
            ligands point away from the observer; the <see cref="P:NCDK.Geometries.CIP.LigancyFourChirality.Stereo"/> then defines the order of the second, third, and
            fourth ligand to be clockwise or anti-clockwise.
            </remarks>
        </member>
        <member name="M:NCDK.Geometries.CIP.LigancyFourChirality.#ctor(NCDK.IAtom,NCDK.Geometries.CIP.ILigand[],NCDK.TetrahedralStereo)">
            <summary>
            Creates a new data model for chirality for the CIP rules.
            </summary>
            <param name="chiralAtom">The <see cref="T:NCDK.IAtom"/> that is actually chiral.</param>
            <param name="ligands">An array with exactly four <see cref="T:NCDK.Geometries.CIP.ILigand"/>s.</param>
            <param name="stereo">A indication of clockwise or anticlockwise orientation of the atoms.</param>
            <seealso cref="T:NCDK.TetrahedralStereo"/>
        </member>
        <member name="M:NCDK.Geometries.CIP.LigancyFourChirality.#ctor(NCDK.IAtomContainer,NCDK.ITetrahedralChirality)">
            <summary>
            Creates a new data model for chirality for the CIP rules based on a chirality definition
            in the CDK data model with <see cref="T:NCDK.ITetrahedralChirality"/>.
            </summary>
            <param name="container"><see cref="T:NCDK.IAtomContainer"/> to which the chiral atom belongs.</param>
            <param name="cdkChirality"><see cref="T:NCDK.ITetrahedralChirality"/> object specifying the chirality.</param>
        </member>
        <member name="P:NCDK.Geometries.CIP.LigancyFourChirality.Ligands">
            <summary>
            Returns the four ligands for this chirality.
            </summary>
            <returns>An array of four <see cref="T:NCDK.Geometries.CIP.ILigand"/>s.</returns>
        </member>
        <member name="P:NCDK.Geometries.CIP.LigancyFourChirality.ChiralAtom">
            <summary>
            Returns the chiral <see cref="T:NCDK.IAtom"/> to which the four ligands are connected..
            </summary>
            <returns>The chiral <see cref="T:NCDK.IAtom"/>.</returns>
        </member>
        <member name="P:NCDK.Geometries.CIP.LigancyFourChirality.Stereo">
            <summary>
            Returns the chirality value for this stereochemistry object.
            </summary>
            <returns>A <see cref="T:NCDK.TetrahedralStereo"/> value.</returns>
        </member>
        <member name="M:NCDK.Geometries.CIP.LigancyFourChirality.Project(NCDK.Geometries.CIP.ILigand[])">
            <summary>
            Recalculates the <see cref="T:NCDK.Geometries.CIP.LigancyFourChirality"/> based on the new, given atom ordering.
            </summary>
            <param name="newOrder">new order of atoms</param>
            <returns>the chirality following the new atom order</returns>
        </member>
        <member name="T:NCDK.Geometries.CIP.Ligand">
            <summary>
            Concept of a ligand in CIP terms, reflecting a side chain of a central atom that can
            have precedence over another.
            </summary>
        </member>
        <member name="M:NCDK.Geometries.CIP.Ligand.GetAtomContainer">
            <summary>
            <see cref="T:NCDK.IAtomContainer"/> of which this ligand is part.
            </summary>
            <returns>the IAtomContainer</returns>
        </member>
        <member name="M:NCDK.Geometries.CIP.Ligand.GetCentralAtom">
            <summary>
            The central <see cref="T:NCDK.IAtom"/> to which this ligand is connected via one <see cref="T:NCDK.IBond"/>.
            </summary>
            <returns>the central atom</returns>
        </member>
        <member name="M:NCDK.Geometries.CIP.Ligand.GetLigandAtom">
            <summary>
            <see cref="T:NCDK.IAtom"/> of the ligand that is connected to the chiral <see cref="T:NCDK.IAtom"/> via
            one <see cref="T:NCDK.IBond"/>.
            </summary>
            <returns>the ligand atom</returns>
        </member>
        <member name="T:NCDK.Geometries.CIP.TerminalLigand">
            <summary>
            Subclass of <see cref="T:NCDK.Geometries.CIP.Ligand"/> to which no further recursion must be applied.
            </summary>
        </member>
        <member name="T:NCDK.Geometries.CIP.VisitedAtoms">
            <summary>
            Helper class for the <see cref="T:NCDK.Geometries.CIP.CIPTool"/> to keep track of which atoms have
            already been visited.
            </summary>
        </member>
        <member name="F:NCDK.Geometries.CIP.VisitedAtoms.visitedItems">
            <summary>
            <see cref="T:System.Collections.Generic.List`1"/> to hold the visited <see cref="T:NCDK.IAtom"/>s.
            </summary>
        </member>
        <member name="M:NCDK.Geometries.CIP.VisitedAtoms.#ctor">
            <summary>
            Creates a new empty list of visited <see cref="T:NCDK.IAtom"/>s.
            </summary>
        </member>
        <member name="M:NCDK.Geometries.CIP.VisitedAtoms.IsVisited(NCDK.IAtom)">
            <summary>
            Returns true if the given atom already has been visited.
            </summary>
            <param name="atom"><see cref="T:NCDK.IAtom"/> which may have been visited</param>
            <returns>true if the <see cref="T:NCDK.IAtom"/> was visited</returns>
        </member>
        <member name="M:NCDK.Geometries.CIP.VisitedAtoms.Visited(NCDK.IAtom)">
            <summary>
            Marks the given atom as visited.
            </summary>
            <param name="atom"><see cref="T:NCDK.IAtom"/> that is now marked as visited</param>
        </member>
        <member name="M:NCDK.Geometries.CIP.VisitedAtoms.Visited(NCDK.Geometries.CIP.VisitedAtoms)">
            <summary>
            Adds all atoms from the <paramref name="visitedAtoms"/> list to the current list.
            </summary>
            <param name="visitedAtoms">the <see cref="T:NCDK.Geometries.CIP.VisitedAtoms"/> from which all atoms are added</param>
        </member>
        <member name="T:NCDK.Geometries.BondTools">
            <summary>
            A set of static utility classes for geometric calculations on <see cref="T:NCDK.IBond"/>s.
            The methods for detecting stereo configurations are described in CDK news, vol 2, p. 64 - 66.
            </summary>
        </member>
        <member name="M:NCDK.Geometries.BondTools.IsValidDoubleBondConfiguration(NCDK.IAtomContainer,NCDK.IBond)">
            FIXME: class JavaDoc should use <token>cdk-cite-BLA</token> for the CDK News article
            <summary>
            Tells if a certain bond is center of a valid double bond configuration.
            </summary>
            <param name="container">The atomcontainer.</param>
            <param name="bond">The bond.</param>
            <returns>true=is a potential configuration, false=is not.</returns>
        </member>
        <member name="M:NCDK.Geometries.BondTools.IsCisTrans(NCDK.IAtom,NCDK.IAtom,NCDK.IAtom,NCDK.IAtom,NCDK.IAtomContainer)">
            <summary>
            Says if two atoms are in cis or trans position around a double bond.
            The atoms have to be given to the method like this:  firstOuterAtom - firstInnerAtom = secondInnterAtom - secondOuterAtom
            </summary>
            <param name="firstOuterAtom">See above.</param>
            <param name="firstInnerAtom">See above.</param>
            <param name="secondInnerAtom">See above.</param>
            <param name="secondOuterAtom">See above.</param>
            <param name="ac">The atom container the atoms are in.</param>
            <returns>true=trans, false=cis.</returns>
            <exception cref="T:NCDK.CDKException"> The atoms are not in a double bond configuration (no double bond in the middle, same atoms on one side)</exception>
        </member>
        <member name="M:NCDK.Geometries.BondTools.IsLeft(NCDK.IAtom,NCDK.IAtom,NCDK.IAtom)">
            <summary>
            Says if an atom is on the left side of a another atom seen from a certain
            atom or not.
            </summary>
            <param name="whereIs">The atom the position of which is returned</param>
            <param name="viewFrom">The atom from which to look</param>
            <param name="viewTo">The atom to which to look</param>
            <returns>true=is left, false = is not</returns>
        </member>
        <member name="M:NCDK.Geometries.BondTools.CloseEnoughToBond(NCDK.IAtom,NCDK.IAtom,System.Double)">
            <summary>
            Returns true if the two atoms are within the distance fudge
            factor of each other.
            </summary>
            <param name="atom1">Description of Parameter</param>
            <param name="atom2">Description of Parameter</param>
            <param name="distanceFudgeFactor">Description of Parameter</param>
            <returns>Description of the Returned Value</returns>
        </member>
        <member name="M:NCDK.Geometries.BondTools.GiveAngleBothMethods(NCDK.IAtom,NCDK.IAtom,NCDK.IAtom,System.Boolean)">
            <summary>
            Gives the angle between two lines starting at atom from and going to to1
            and to2. If bool=false the angle starts from the middle line and goes from
            0 to PI or 0 to -PI if the to2 is on the left or right side of the line. If
            bool=true the angle goes from 0 to 2PI.
            </summary>
            <param name="from">the atom to view from.</param>
            <param name="to1">first direction to look in.</param>
            <param name="to2">second direction to look in.</param>
            <param name="flag">true=angle is 0 to 2PI, false=angel is -PI to PI.</param>
            <returns>The angle in rad.</returns>
        </member>
        <member name="M:NCDK.Geometries.BondTools.IsEndOfDoubleBond(NCDK.IAtomContainer,NCDK.IAtom,NCDK.IAtom,System.Boolean[])">
            <summary>
            Says if an atom is the end of a double bond configuration
            </summary>
            <param name="atom">The atom which is the end of configuration</param>
            <param name="container">The atomContainer the atom is in</param>
            <param name="parent">The atom we came from</param>
            <param name="doubleBondConfiguration">The array indicating where double bond
                configurations are specified (this method ensures that there is
                actually the possibility of a double bond configuration)</param>
            <returns>false=is not end of configuration, true=is</returns>
        </member>
        <member name="M:NCDK.Geometries.BondTools.IsStartOfDoubleBond(NCDK.IAtomContainer,NCDK.IAtom,NCDK.IAtom,System.Boolean[])">
            <summary>
            Says if an atom is the start of a double bond configuration
            </summary>
            <param name="a">The atom which is the start of configuration</param>
            <param name="container">The atomContainer the atom is in</param>
            <param name="parent">The atom we came from</param>
            <param name="doubleBondConfiguration">The array indicating where double bond
                configurations are specified (this method ensures that there is
                actually the possibility of a double bond configuration)</param>
            <returns>false=is not start of configuration, true=is</returns>
        </member>
        <member name="M:NCDK.Geometries.BondTools.IsTetrahedral(NCDK.IAtomContainer,NCDK.IAtom,System.Boolean)">
            <summary>
            Says if an atom as a center of a tetrahedral chirality.
            This method uses wedge bonds. 3D coordinates are not taken into account. If there
            are no wedge bonds around a potential stereo center, it will not be found.
            </summary>
            <param name="atom">The atom which is the center</param>
            <param name="container">The atomContainer the atom is in</param>
            <param name="strict"></param>
            <returns>0=is not tetrahedral; &gt;1 is a certain depiction of
                tetrahedrality (evaluated in parse chain)</returns>
        </member>
        <member name="M:NCDK.Geometries.BondTools.IsTrigonalBipyramidalOrOctahedral(NCDK.IAtomContainer,NCDK.IAtom)">
            <summary>
            Says if an atom as a center of a trigonal-bipyramidal or actahedral
            chirality. This method uses wedge bonds. 3D coordinates are not taken into account. If there
            are no wedge bonds around a potential stereo center, it will not be found.
            </summary>
            <param name="atom">The atom which is the center</param>
            <param name="container">The atomContainer the atom is in</param>
            <returns>true=is square planar, false=is not</returns>
        </member>
        <member name="M:NCDK.Geometries.BondTools.IsStereo(NCDK.IAtomContainer,NCDK.IAtom)">
            <summary>
            Says if an atom as a center of any valid stereo configuration or not.
            This method uses wedge bonds. 3D coordinates are not taken into account. If there
            are no wedge bonds around a potential stereo center, it will not be found.
            </summary>
            <param name="stereoAtom">The atom which is the center</param>
            <param name="container">The atomContainer the atom is in</param>
            <returns>true=is a stereo atom, false=is not</returns>
        </member>
        <member name="M:NCDK.Geometries.BondTools.IsSquarePlanar(NCDK.IAtomContainer,NCDK.IAtom)">
            <summary>
            Says if an atom as a center of a square planar chirality.
            This method uses wedge bonds. 3D coordinates are not taken into account. If there
            are no wedge bonds around a potential stereo center, it will not be found.
            </summary>
            <param name="atom">The atom which is the center</param>
            <param name="container">The atomContainer the atom is in</param>
            <returns>true=is square planar, false=is not</returns>
        </member>
        <member name="M:NCDK.Geometries.BondTools.StereosAreOpposite(NCDK.IAtomContainer,NCDK.IAtom)">
            <summary>
            Says if of four atoms connected two one atom the up and down bonds are
            opposite or not, i. e.if it's tetrehedral or square planar. The method
            does not check if there are four atoms and if two or up and two are down
            </summary>
            <param name="atom">The atom which is the center</param>
            <param name="container">The atomContainer the atom is in</param>
            <returns>true=are opposite, false=are not</returns>
        </member>
        <member name="M:NCDK.Geometries.BondTools.giveAngle(NCDK.IAtom,NCDK.IAtom,NCDK.IAtom)">
            <summary>
            Calls giveAngleBothMethods with bool = true.
            </summary>
            <param name="from">the atom to view from</param>
            <param name="to1">first direction to look in</param>
            <param name="to2">second direction to look in</param>
            <returns>The angle in rad from 0 to 2*PI</returns>
        </member>
        <member name="M:NCDK.Geometries.BondTools.GiveAngleFromMiddle(NCDK.IAtom,NCDK.IAtom,NCDK.IAtom)">
            <summary>
            Calls giveAngleBothMethods with bool = false.
            </summary>
            <param name="from">the atom to view from</param>
            <param name="to1">first direction to look in</param>
            <param name="to2">second direction to look in</param>
            <returns>The angle in rad from -PI to PI</returns>
        </member>
        <member name="T:NCDK.Geometries.CrystalGeometryTools">
            <summary>
            A set of static methods for working with crystal coordinates.
            </summary>
        </member>
        <member name="M:NCDK.Geometries.CrystalGeometryTools.CalcInvertedAxes(NCDK.Numerics.Vector3,NCDK.Numerics.Vector3,NCDK.Numerics.Vector3)">
            <summary>
            Inverts three cell axes.
            </summary>
            <returns>a 3x3 matrix with the three Cartesian vectors representing the unit cell axes. The a axis is the first row.</returns>
        </member>
        <member name="M:NCDK.Geometries.CrystalGeometryTools.NotionalToCartesian(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Calculates Cartesian vectors for unit cell axes from axes lengths and angles
            between axes.
            <para>
            To calculate Cartesian coordinates, it places the a axis on the x axes,
            the b axis in the xy plane, making an angle gamma with the a axis, and places
            the c axis to fulfill the remaining constraints. (See also
            <see href="http://server.ccl.net/cca/documents/molecular-modeling/node4.html">the CCL archive</see>.)
            </para>
            </summary>
            <param name="alength">length of the a axis</param>
            <param name="blength">length of the b axis</param>
            <param name="clength">length of the c axis</param>
            <param name="alpha">angle between b and c axes in degrees</param>
            <param name="beta">angle between a and c axes in degrees</param>
            <param name="gamma">angle between a and b axes in degrees</param>
            <returns>an array of Vector3 objects with the three Cartesian vectors representing the unit cell axes.</returns>
        </member>
        <member name="M:NCDK.Geometries.CrystalGeometryTools.HasCrystalCoordinates(NCDK.IAtomContainer)">
            <summary>
            Determines if this model contains fractional (crystal) coordinates.
            </summary>
            <returns>bool indication that 3D coordinates are available</returns>
        </member>
        <member name="M:NCDK.Geometries.CrystalGeometryTools.FractionalToCartesian(NCDK.ICrystal)">
            <summary>
            Creates Cartesian coordinates for all Atoms in the Crystal.
            </summary>
        </member>
        <member name="T:NCDK.Geometries.GeometryUtil">
            <summary>
            A set of static utility classes for geometric calculations and operations. This class is
            extensively used, for example, by JChemPaint to edit molecule. All methods in this class change
            the coordinates of the atoms. Use GeometryTools if you use an external set of coordinates (e. g.
            renderingCoordinates from RendererModel)
            </summary>
        </member>
        <member name="T:NCDK.Geometries.GeometryUtil.CoordinateCoverages">
            <summary>
            Provides the coverage of coordinates for this molecule.
            </summary>
            <seealso cref="M:NCDK.Geometries.GeometryUtil.Get2DCoordinateCoverage(NCDK.IAtomContainer)"/>
            <seealso cref="M:NCDK.Geometries.GeometryUtil.Get3DCoordinateCoverage(NCDK.IAtomContainer)"/>
        </member>
        <member name="F:NCDK.Geometries.GeometryUtil.CoordinateCoverages.Full">
            <summary>
            All atoms have coordinates.
            </summary>
        </member>
        <member name="F:NCDK.Geometries.GeometryUtil.CoordinateCoverages.Partial">
            <summary>
            At least one atom has coordinates but not all.
            </summary>
        </member>
        <member name="F:NCDK.Geometries.GeometryUtil.CoordinateCoverages.None">
            <summary>
            No atoms have coordinates.
            </summary>
        </member>
        <member name="M:NCDK.Geometries.GeometryUtil.#ctor">
            <summary>
            Static utility class can not be instantiated.
            </summary>
        </member>
        <member name="M:NCDK.Geometries.GeometryUtil.TranslateAllPositive(NCDK.IAtomContainer)">
            <summary>
            Adds an automatically calculated offset to the coordinates of all atoms such that all
            coordinates are positive and the smallest x or y coordinate is exactly zero. 
            </summary>
            <param name="atomCon">AtomContainer for which all the atoms are translated to positive coordinates</param>
        </member>
        <member name="M:NCDK.Geometries.GeometryUtil.Translate2D(NCDK.IAtomContainer,System.Double,System.Double)">
            <summary>
            Translates the given molecule by the given Vector.
            </summary>
            <param name="atomCon">The molecule to be translated</param>
            <param name="transX">translation in x direction</param>
            <param name="transY">translation in y direction</param>
        </member>
        <member name="M:NCDK.Geometries.GeometryUtil.ScaleMolecule(NCDK.IAtomContainer,System.Double[],System.Double)">
            <summary>
            Scales a molecule such that it fills a given percentage of a given dimension. 
            </summary>
            <param name="atomCon">The molecule to be scaled {width, height}</param>
            <param name="areaDim">The dimension to be filled {width, height}</param>
            <param name="fillFactor">The percentage of the dimension to be filled</param>
        </member>
        <member name="M:NCDK.Geometries.GeometryUtil.ScaleMolecule(NCDK.IAtomContainer,System.Double)">
            <summary>
            Multiplies all the coordinates of the atoms of the given molecule with the scalefactor. 
            </summary>
            <param name="atomCon">The molecule to be scaled</param>
            <param name="scaleFactor">Description of the Parameter</param>
        </member>
        <member name="M:NCDK.Geometries.GeometryUtil.Center(NCDK.IAtomContainer,System.Double[])">
            <summary>
            Centers the molecule in the given area. 
            </summary>
            <param name="atomCon">molecule to be centered</param>
            <param name="areaDim">dimension in which the molecule is to be centered, array containing {width, height}</param>
        </member>
        <member name="M:NCDK.Geometries.GeometryUtil.Translate2D(NCDK.IAtomContainer,NCDK.Numerics.Vector2)">
            <summary>
            Translates a molecule from the origin to a new point denoted by a vector. See comment for
            Center(IAtomContainer atomCon, Dimension areaDim, Dictionary renderingCoordinates) for details
            on coordinate sets
            </summary>
            <param name="atomCon">molecule to be translated</param>
            <param name="vector">dimension that represents the translation vector</param>
        </member>
        <member name="M:NCDK.Geometries.GeometryUtil.Rotate(NCDK.IAtomContainer,NCDK.Numerics.Vector2,System.Double)">
            <summary>
            Rotates a molecule around a given center by a given angle.
            </summary>
            <param name="atomCon">The molecule to be rotated</param>
            <param name="center">A point giving the rotation center</param>
            <param name="angle">The angle by which to rotate the molecule, in radians</param>
        </member>
        <member name="M:NCDK.Geometries.GeometryUtil.Rotate(NCDK.IAtom,NCDK.Numerics.Vector3,NCDK.Numerics.Vector3,System.Double)">
            <summary>
            Rotates a 3D point about a specified line segment by a specified angle.
            </summary>
            <remarks>
            The code is based on code available <see href="http://astronomy.swin.edu.au/~pbourke/geometry/rotate/source.c">here</see>.
            Positive angles are anticlockwise looking down the axis towards the origin. Assume right hand
            coordinate system.</remarks>
            <param name="atom">The atom to rotate</param>
            <param name="p1">The  first point of the line segment</param>
            <param name="p2">The second point of the line segment</param>
            <param name="angle">The angle to rotate by (in degrees)</param>
        </member>
        <member name="M:NCDK.Geometries.GeometryUtil.Get2DDimension(NCDK.IAtomContainer)">
            <summary>
            Returns the dimension of a molecule (width/height).
            </summary>
            <param name="atomCon">of which the dimension should be returned</param>
            <returns>array containing {width, height}</returns>
        </member>
        <member name="M:NCDK.Geometries.GeometryUtil.GetMinMax(NCDK.IAtomContainer)">
            <summary>
            Returns the minimum and maximum X and Y coordinates of the atoms in the
            <see cref="T:NCDK.IAtomContainer"/>. The output is returned as: 
            <c>double[] {minX, minY, maxX, maxY }</c>.
            </summary>
            <param name="container"></param>
            <returns>An four int array as defined above.</returns>
        </member>
        <member name="M:NCDK.Geometries.GeometryUtil.Translate2DCentreOfMassTo(NCDK.IAtomContainer,NCDK.Numerics.Vector2)">
            <summary>
            Translates a molecule from the origin to a new point denoted by a vector. 
            </summary>
            <param name="atomCon">molecule to be translated</param>
            <param name="p">Description of the Parameter</param>
        </member>
        <member name="M:NCDK.Geometries.GeometryUtil.Get2DCenter(System.Collections.Generic.IEnumerable{NCDK.IAtom})">
            <summary>
            Calculates the center of the given atoms and returns it as a Vector2. 
            </summary>
            <param name="atoms">The vector of the given atoms</param>
            <returns>The center of the given atoms as Vector2</returns>
        </member>
        <member name="M:NCDK.Geometries.GeometryUtil.Get2DCenter(System.Collections.Generic.IEnumerable{NCDK.IRing})">
            <summary>
            Returns the geometric center of all the rings in this ringset. 
            </summary>
            <param name="ringSet">Description of the Parameter</param>
            <returns>the geometric center of the rings in this ringset</returns>
        </member>
        <member name="M:NCDK.Geometries.GeometryUtil.Get2DCentreOfMass(NCDK.IAtomContainer)">
            <summary>
            Calculates the center of mass for the <see cref="T:NCDK.IAtom"/>s in the AtomContainer for the 2D
            coordinates. 
            </summary>
            <param name="ac">AtomContainer for which the center of mass is calculated</param>
            <returns>Null, if any of the atomcontainer <see cref="T:NCDK.IAtom"/>'s</returns>
            masses are null
        </member>
        <member name="M:NCDK.Geometries.GeometryUtil.Get2DCenter(NCDK.IAtomContainer)">
            <summary>
            Returns the geometric center of all the atoms in the atomContainer.
            </summary>
            <param name="container">Description of the Parameter</param>
            <returns>the geometric center of the atoms in this atomContainer</returns>
        </member>
        <member name="M:NCDK.Geometries.GeometryUtil.Translate2DCenterTo(NCDK.IAtomContainer,NCDK.Numerics.Vector2)">
            <summary>
            Translates the geometric 2DCenter of the given AtomContainer container to the specified
            Vector2 p.
            </summary>
            <param name="container">AtomContainer which should be translated.</param>
            <param name="p">New Location of the geometric 2D Center.</param>
            <seealso cref="M:NCDK.Geometries.GeometryUtil.Get2DCenter(NCDK.IAtomContainer)"/>
            <seealso cref="M:NCDK.Geometries.GeometryUtil.Translate2DCentreOfMassTo(NCDK.IAtomContainer,NCDK.Numerics.Vector2)"/>
        </member>
        <member name="M:NCDK.Geometries.GeometryUtil.Get3DCentreOfMass(NCDK.IAtomContainer)">
            <summary>
            Calculates the center of mass for the <see cref="T:NCDK.IAtom"/>s in the AtomContainer.
            </summary>
            <param name="ac">AtomContainer for which the center of mass is calculated</param>
            <returns>The center of mass of the molecule, or <see langword="null"/> if the molecule does not have 3D coordinates or if any of the atoms do not have a valid atomic mass</returns>
        </member>
        <member name="M:NCDK.Geometries.GeometryUtil.Get3DCenter(NCDK.IAtomContainer)">
            <summary>
            Returns the geometric center of all the atoms in this atomContainer. 
            </summary>
            <param name="ac">Description of the Parameter</param>
            <returns>the geometric center of the atoms in this atomContainer</returns>
        </member>
        <member name="M:NCDK.Geometries.GeometryUtil.GetAngle(System.Double,System.Double)">
            <summary>
            Gets the angle attribute of the GeometryTools class.
            </summary>
            <param name="xDiff">Description of the Parameter</param>
            <param name="yDiff">Description of the Parameter</param>
            <returns>The angle value</returns>
        </member>
        <member name="M:NCDK.Geometries.GeometryUtil.DistanceCalculator(System.Int32[],System.Double)">
            <summary>
            Gets the coordinates of two points (that represent a bond) and calculates for each the
            coordinates of two new points that have the given distance vertical to the bond.
            </summary>
            <param name="coords">The coordinates of the two given points of the bond like this [point1x,  point1y, point2x, point2y]</param>
            <param name="dist">The vertical distance between the given points and those to be calculated</param>
            <returns>The coordinates of the calculated four points</returns>
        </member>
        <member name="M:NCDK.Geometries.GeometryUtil.GetBondCoordinates(NCDK.IBond)">
            <summary>
            Writes the coordinates of the atoms participating the given bond into an array. 
            </summary>
            <param name="bond">The given bond</param>
            <returns>The array with the coordinates</returns>
        </member>
        <member name="M:NCDK.Geometries.GeometryUtil.GetClosestAtom(System.Int32,System.Int32,NCDK.IAtomContainer)">
            <summary>
            Returns the atom of the given molecule that is closest to the given coordinates. 
            </summary>
            <param name="xPosition">The x coordinate</param>
            <param name="yPosition">The y coordinate</param>
            <param name="atomCon">The molecule that is searched for the closest atom</param>
            <returns>The atom that is closest to the given coordinates</returns>
        </member>
        <member name="M:NCDK.Geometries.GeometryUtil.GetClosestAtom(NCDK.IAtomContainer,NCDK.IAtom)">
            <summary>
            Returns the atom of the given molecule that is closest to the given atom (excluding itself).
            </summary>
            <param name="atomCon">The molecule that is searched for the closest atom</param>
            <param name="atom">The atom to search around</param>
            <returns>The atom that is closest to the given coordinates</returns>
        </member>
        <member name="M:NCDK.Geometries.GeometryUtil.GetClosestAtom(System.Double,System.Double,NCDK.IAtomContainer,NCDK.IAtom)">
            <summary>
            Returns the atom of the given molecule that is closest to the given coordinates and is not
            the atom.
            </summary>
            <param name="xPosition">The x coordinate</param>
            <param name="yPosition">The y coordinate</param>
            <param name="atomCon">The molecule that is searched for the closest atom</param>
            <param name="toignore">This molecule will not be returned.</param>
            <returns>The atom that is closest to the given coordinates</returns>
        </member>
        <member name="M:NCDK.Geometries.GeometryUtil.GetClosestAtom(System.Double,System.Double,NCDK.IAtomContainer)">
            <summary>
            Returns the atom of the given molecule that is closest to the given coordinates. 
            </summary>
            <param name="xPosition">The x coordinate</param>
            <param name="yPosition">The y coordinate</param>
            <param name="atomCon">The molecule that is searched for the closest atom</param>
            <returns>The atom that is closest to the given coordinates</returns>
        </member>
        <member name="M:NCDK.Geometries.GeometryUtil.GetClosestBond(System.Int32,System.Int32,NCDK.IAtomContainer)">
            <summary>
            Returns the bond of the given molecule that is closest to the given coordinates.
            </summary>
            <param name="xPosition">The x coordinate</param>
            <param name="yPosition">The y coordinate</param>
            <param name="atomCon">The molecule that is searched for the closest bond</param>
            <returns>The bond that is closest to the given coordinates</returns>
        </member>
        <member name="M:NCDK.Geometries.GeometryUtil.GetClosestBond(System.Double,System.Double,NCDK.IAtomContainer)">
            <summary>
            Returns the bond of the given molecule that is closest to the given coordinates.
            </summary>
            <param name="xPosition">The x coordinate</param>
            <param name="yPosition">The y coordinate</param>
            <param name="atomCon">The molecule that is searched for the closest bond</param>
            <returns>The bond that is closest to the given coordinates</returns>
        </member>
        <member name="M:NCDK.Geometries.GeometryUtil.SortBy2DDistance(NCDK.IAtom[],NCDK.Numerics.Vector2)">
            <summary>
            Sorts a Vector of atoms such that the 2D distances of the atom locations from a given point
            are smallest for the first atoms in the vector. 
            </summary>
            <param name="point">The point from which the distances to the atoms are measured</param>
            <param name="atoms">The atoms for which the distances to point are measured</param>
        </member>
        <member name="M:NCDK.Geometries.GeometryUtil.GetScaleFactor(NCDK.IAtomContainer,System.Double)">
            <summary>
            Determines the scale factor for displaying a structure loaded from disk in a frame. An
            average of all bond length values is produced and a scale factor is determined which would
            scale the given molecule.
            </summary>
            <param name="container">The AtomContainer for which the ScaleFactor is to be calculated</param>
            <param name="bondLength">The target bond length</param>
            <returns>The ScaleFactor with which the AtomContainer must be scaled to have the target bond length</returns>
        </member>
        <member name="M:NCDK.Geometries.GeometryUtil.GetBondLengthAverage(NCDK.IAtomContainer)">
            <summary>
            An average of all 2D bond length values is produced. Bonds which have Atom's with no
            coordinates are disregarded. See comment for Center(IAtomContainer atomCon, Dimension
            areaDim, Dictionary renderingCoordinates) for details on coordinate sets
            </summary>
            <param name="container">The AtomContainer for which the average bond length is to be calculated</param>
            <returns>the average bond length</returns>
        </member>
        <member name="M:NCDK.Geometries.GeometryUtil.GetLength2D(NCDK.IBond)">
            <summary>
            Returns the geometric length of this bond in 2D space. See comment for Center(IAtomContainer
            atomCon, Dimension areaDim, Dictionary renderingCoordinates) for details on coordinate sets
            </summary>
            <param name="bond">Description of the Parameter</param>
            <returns>The geometric length of this bond</returns>
        </member>
        <member name="M:NCDK.Geometries.GeometryUtil.Has2DCoordinates(NCDK.IAtomContainer)">
            <summary>
            Determines if all this <see cref="T:NCDK.IAtomContainer"/>'s atoms contain
            2D coordinates. If any atom is null or has unset 2D coordinates this method will return
            false.
            </summary>
            <param name="container">the atom container to examine</param>
            <returns>indication that all 2D coordinates are available</returns>
            <seealso cref="P:NCDK.IAtom.Point2D"/>
        </member>
        <member name="M:NCDK.Geometries.GeometryUtil.Get2DCoordinateCoverage(NCDK.IAtomContainer)">
            <summary>
            Determines the coverage of this <see cref="T:NCDK.IAtomContainer"/>'s 2D
            coordinates. If all atoms are non-null and have 2D coordinates this method will return 
            <see cref="F:NCDK.Geometries.GeometryUtil.CoordinateCoverages.Full"/>. If one or more atoms does have 2D coordinates and any others atoms
            are null or are missing 2D coordinates this method will return
            <see cref="F:NCDK.Geometries.GeometryUtil.CoordinateCoverages.Partial"/>. If all atoms are null or are all missing 2D coordinates this
            method will return <see cref="F:NCDK.Geometries.GeometryUtil.CoordinateCoverages.None"/>. If the provided container is null 
            <see cref="F:NCDK.Geometries.GeometryUtil.CoordinateCoverages.None"/> is also returned.
            </summary>
            <param name="container">the container to inspect</param>
            <returns><see cref="F:NCDK.Geometries.GeometryUtil.CoordinateCoverages.Full"/>, <see cref="F:NCDK.Geometries.GeometryUtil.CoordinateCoverages.Partial"/> or <see cref="F:NCDK.Geometries.GeometryUtil.CoordinateCoverages.None"/> depending on the number of 3D coordinates present</returns>
            <seealso cref="T:NCDK.Geometries.GeometryUtil.CoordinateCoverages"/>
            <seealso cref="M:NCDK.Geometries.GeometryUtil.Has2DCoordinates(NCDK.IAtomContainer)"/>
            <seealso cref="M:NCDK.Geometries.GeometryUtil.Get3DCoordinateCoverage(NCDK.IAtomContainer)"/>
            <seealso cref="P:NCDK.IAtom.Point2D"/>
        </member>
        <member name="M:NCDK.Geometries.GeometryUtil.Has2DCoordinatesNew(NCDK.IAtomContainer)">
            <summary>
            Determines if this AtomContainer contains 2D coordinates for some or all molecules.
            </summary>
            <param name="container">the molecule to be considered</param>
            <returns>0 no 2d, 1=some, 2= for each atom</returns>
            <seealso cref="M:NCDK.Geometries.GeometryUtil.Get2DCoordinateCoverage(NCDK.IAtomContainer)"/>
        </member>
        <member name="M:NCDK.Geometries.GeometryUtil.Has2DCoordinates(NCDK.IAtom)">
            <summary>
            Determines if this Atom contains 2D coordinates. 
            </summary>
            <param name="atom">Description of the Parameter</param>
            <returns>bool indication that 2D coordinates are available</returns>
        </member>
        <member name="M:NCDK.Geometries.GeometryUtil.Has2DCoordinates(NCDK.IBond)">
            <summary>
            Determines if this Bond contains 2D coordinates.
            </summary>
            <param name="bond">Description of the Parameter</param>
            <returns>bool indication that 2D coordinates are available</returns>
        </member>
        <member name="M:NCDK.Geometries.GeometryUtil.Has3DCoordinates(NCDK.IAtomContainer)">
            <summary>
            Determines if all this <see cref="T:NCDK.IAtomContainer"/>'s atoms contain
            3D coordinates. If any atom is null or has unset 3D coordinates this method will return
            false. If the provided container is null false is returned.
            </summary>
            <param name="container">the atom container to examine</param>
            <returns>indication that all 3D coordinates are available</returns>
            <seealso cref="P:NCDK.IAtom.Point3D"/>
        </member>
        <member name="M:NCDK.Geometries.GeometryUtil.Get3DCoordinateCoverage(NCDK.IAtomContainer)">
            <summary>
            Determines the coverage of this <see cref="T:NCDK.IAtomContainer"/>'s 3D
            coordinates. If all atoms are non-null and have 3D coordinates this method will return <see cref="F:NCDK.Geometries.GeometryUtil.CoordinateCoverages.Full"/>. If one or more atoms does have 3D coordinates and any others atoms
            are null or are missing 3D coordinates this method will return <see cref="F:NCDK.Geometries.GeometryUtil.CoordinateCoverages.Partial"/>. If all atoms are null or are all missing 3D coordinates this
            method will return <see cref="F:NCDK.Geometries.GeometryUtil.CoordinateCoverages.None"/>. If the provided container is null <see cref="F:NCDK.Geometries.GeometryUtil.CoordinateCoverages.None"/> is also returned.
            </summary>
            <param name="container">the container to inspect</param>
            <returns><see cref="F:NCDK.Geometries.GeometryUtil.CoordinateCoverages.Full"/>, <see cref="F:NCDK.Geometries.GeometryUtil.CoordinateCoverages.Partial"/> or <see cref="F:NCDK.Geometries.GeometryUtil.CoordinateCoverages.None"/> depending on the number of 3D coordinates present</returns>
            <seealso cref="T:NCDK.Geometries.GeometryUtil.CoordinateCoverages"/>
            <seealso cref="M:NCDK.Geometries.GeometryUtil.Has3DCoordinates(NCDK.IAtomContainer)"/>
            <seealso cref="M:NCDK.Geometries.GeometryUtil.Get2DCoordinateCoverage(NCDK.IAtomContainer)"/>
            <seealso cref="P:NCDK.IAtom.Point3D"/>
        </member>
        <member name="M:NCDK.Geometries.GeometryUtil.CalculatePerpendicularUnitVector(NCDK.Numerics.Vector2,NCDK.Numerics.Vector2)">
            <summary>
            Determines the normalized vector orthogonal on the vector p1-&gt;p2.
            </summary>
            <param name="point1">Description of the Parameter</param>
            <param name="point2">Description of the Parameter</param>
            <returns>Description of the Return Value</returns>
        </member>
        <member name="M:NCDK.Geometries.GeometryUtil.GetNormalizationFactor(NCDK.IAtomContainer)">
            <summary>
            Calculates the normalization factor in order to get an average bond length of 1.5. It takes
            only into account Bond's with two atoms.
            </summary>
            <param name="container">Description of the Parameter</param>
            <returns>The normalizationFactor value</returns>
        </member>
        <member name="M:NCDK.Geometries.GeometryUtil.GetBestAlignmentForLabel(NCDK.IAtomContainer,NCDK.IAtom)">
            <summary>
            Determines the best alignment for the label of an atom in 2D space. It returns 1 if left
            aligned, and -1 if right aligned. 
            </summary>
            <param name="container">Description of the Parameter</param>
            <param name="atom">Description of the Parameter</param>
            <returns>The bestAlignmentForLabel value</returns>
        </member>
        <member name="M:NCDK.Geometries.GeometryUtil.GetBestAlignmentForLabelXY(NCDK.IAtomContainer,NCDK.IAtom)">
            <summary>
            Determines the best alignment for the label of an atom in 2D space. It returns 1 if right
            (=default) aligned, and -1 if left aligned. returns 2 if top aligned, and -2 if H is aligned
            below the atom.
            </summary>
            <param name="container">Description of the Parameter</param>
            <param name="atom">Description of the Parameter</param>
            <returns>The bestAlignmentForLabel value</returns>
        </member>
        <member name="M:NCDK.Geometries.GeometryUtil.FindClosestInSpace(NCDK.IAtomContainer,NCDK.IAtom,System.Int32)">
            <summary>
            Returns the atoms which are closes to an atom in an AtomContainer by distance in 3d.
            </summary>
            <param name="container">The AtomContainer to examine</param>
            <param name="startAtom">the atom to start from</param>
            <param name="max">the number of neighbours to return</param>
            <returns>the average bond length</returns>
        </member>
        <member name="M:NCDK.Geometries.GeometryUtil.MapAtomsOfAlignedStructures(NCDK.IAtomContainer,NCDK.IAtomContainer,System.Double,System.Collections.Generic.IDictionary{System.Int32,System.Int32})">
             <summary>
             Returns a IDictionary with the AtomNumbers, the first number corresponds to the first (or the largest
             AtomContainer) atomcontainer. It is recommend to sort the atomContainer due to their number
             of atoms before calling this function.
            
             The molecules needs to be aligned before! (coordinates are needed)
             </summary>
             <param name="firstAtomContainer">the (largest) first aligned AtomContainer which is the reference</param>
             <param name="secondAtomContainer">the second aligned AtomContainer</param>
             <param name="searchRadius">the radius of space search from each atom</param>
             <param name="mappedAtoms"></param>
             <returns>a IDictionary of the mapped atoms</returns>
             <exception cref="T:NCDK.CDKException"></exception>
        </member>
        <member name="M:NCDK.Geometries.GeometryUtil.GetLargestAtomContainer(NCDK.IAtomContainer,NCDK.IAtomContainer)">
            FIXME: huh!?!?!
        </member>
        <member name="M:NCDK.Geometries.GeometryUtil.GetBondLengthRMSD(NCDK.IAtomContainer,NCDK.IAtomContainer,System.Collections.Generic.IDictionary{System.Int32,System.Int32},System.Boolean)">
            <summary>
            Return the RMSD of bonds length between the 2 aligned molecules.
            </summary>
            <param name="firstAtomContainer">the (largest) first aligned AtomContainer which is the reference</param>
            <param name="secondAtomContainer">the second aligned AtomContainer</param>
            <param name="mappedAtoms">IDictionary: a IDictionary of the mapped atoms</param>
            <param name="Coords3d">bool: true if moecules has 3D coords, false if molecules has 2D coords</param>
            <returns>double: all the RMSD of bonds length</returns>
        </member>
        <member name="M:NCDK.Geometries.GeometryUtil.GetAngleRMSD(NCDK.IAtomContainer,NCDK.IAtomContainer,System.Collections.Generic.IDictionary{System.Int32,System.Int32})">
            <summary>
            Return the variation of each angle value between the 2 aligned molecules.
            </summary>
            <param name="firstAtomContainer">the (largest) first aligned AtomContainer which is the reference</param>
            <param name="secondAtomContainer">the second aligned AtomContainer</param>
            <param name="mappedAtoms">IDictionary: a IDictionary of the mapped atoms</param>
            <returns>double: the value of the RMSD</returns>
        </member>
        <member name="M:NCDK.Geometries.GeometryUtil.GetAllAtomRMSD(NCDK.IAtomContainer,NCDK.IAtomContainer,System.Collections.Generic.IDictionary{System.Int32,System.Int32},System.Boolean)">
            <summary>
            Return the RMSD between the 2 aligned molecules.
            </summary>
            <param name="firstAtomContainer">the (largest) first aligned AtomContainer which is the reference</param>
            <param name="secondAtomContainer">the second aligned AtomContainer</param>
            <param name="mappedAtoms">IDictionary: a IDictionary of the mapped atoms</param>
            <param name="Coords3d">bool: true if molecules has 3D coords, false if molecules has 2D coords</param>
            <returns>double: the value of the RMSD</returns>
            <exception cref="T:NCDK.CDKException">if there is an error in getting mapped atoms</exception>
        </member>
        <member name="M:NCDK.Geometries.GeometryUtil.GetHeavyAtomRMSD(NCDK.IAtomContainer,NCDK.IAtomContainer,System.Collections.Generic.IDictionary{System.Int32,System.Int32},System.Boolean,System.Boolean)">
            <summary>
            Return the RMSD of the heavy atoms between the 2 aligned molecules.
            </summary>
            <param name="firstAtomContainer">the (largest) first aligned AtomContainer which is the reference</param>
            <param name="secondAtomContainer">the second aligned AtomContainer</param>
            <param name="mappedAtoms">IDictionary: a IDictionary of the mapped atoms</param>
            <param name="hetAtomOnly">bool: true if only hetero atoms should be considered</param>
            <param name="Coords3d">bool: true if molecules has 3D coords, false if molecules has 2D coords</param>
            <returns>double: the value of the RMSD</returns>
        </member>
        <member name="M:NCDK.Geometries.GeometryUtil.GetBondLengthAverage3D(NCDK.IAtomContainer)">
            <summary>
            An average of all 3D bond length values is produced, using point3ds in atoms. Atom's with no
            coordinates are disregarded.
            </summary>
            <param name="container">The AtomContainer for which the average bond length is to be calculated</param>
            <returns>the average bond length</returns>
        </member>
        <member name="M:NCDK.Geometries.GeometryUtil.ShiftContainer(NCDK.IAtomContainer,System.Double[],System.Double[],System.Double)">
            <summary>
            Shift the container horizontally to the right to make its bounds not overlap with the other
            bounds. To avoid dependence on Java AWT, rectangles are described by arrays of double. Each
            rectangle is specified by {minX, minY, maxX, maxY}.
            </summary>
            <param name="container">the <see cref="T:NCDK.IAtomContainer"/> to shift to the right</param>
            <param name="bounds">the bounds of the <see cref="T:NCDK.IAtomContainer"/> to shift</param>
            <param name="last">the bounds that is used as reference</param>
            <param name="gap">the gap between the two rectangles</param>
            <returns>the rectangle of the <see cref="T:NCDK.IAtomContainer"/> after the shift</returns>
        </member>
        <member name="M:NCDK.Geometries.GeometryUtil.GetBondLengthAverage(NCDK.IReaction)">
            <summary>
            Returns the average 2D bond length values of all products and reactants
            of the given reaction. The method uses  <see cref="M:NCDK.Geometries.GeometryUtil.GetBondLengthAverage(NCDK.IAtomContainer)"/> internally.
            </summary>
            <param name="reaction">The IReaction for which the average 2D bond length is calculated</param>
            <returns>the average 2D bond length</returns>
            <seealso cref="M:NCDK.Geometries.GeometryUtil.GetBondLengthAverage(NCDK.IAtomContainer)"/>
        </member>
        <member name="M:NCDK.Geometries.GeometryUtil.GetBondLengthMedian(NCDK.IAtomContainer)">
            <summary>
            Calculate the median bond length of an atom container.
            </summary>
            <param name="container">structure representation</param>
            <returns>median bond length</returns>
            <exception cref="T:System.ArgumentException">unset coordinates or no bonds</exception>
        </member>
        <member name="M:NCDK.Geometries.GeometryUtil.Has3DCoordinates(NCDK.IChemModel)">
            <summary>
            Determines if this model contains 3D coordinates for all atoms.
            </summary>
            <param name="chemModel">the ChemModel to consider</param>
            <returns>bool indication that 3D coordinates are available for all atoms.</returns>
        </member>
        <member name="M:NCDK.Geometries.GeometryUtil.ShiftReactionVertical(NCDK.IReaction,System.Double[],System.Double[],System.Double)">
            <summary>
            Shift the containers in a reaction vertically upwards to not overlap with the reference
            rectangle. The shift is such that the given gap is realized, but only if the reactions are
            actually overlapping. To avoid dependence on Java AWT, rectangles are described by
            arrays of double. Each rectangle is specified by {minX, minY, maxX, maxY}.
            </summary>
            <param name="reaction">the reaction to shift</param>
            <param name="bounds">the bounds of the reaction to shift</param>
            <param name="last">the bounds of the last reaction</param>
            <param name="gap"></param>
            <returns>the rectangle of the shifted reaction</returns>
        </member>
        <member name="T:NCDK.Geometries.Volume.VABCVolume">
            <summary>
            Calculates the Van der Waals volume using the method proposed
            in <token>cdk-cite-Zhao2003</token>. The method is limited to molecules
            with the following elements: H, C, N, O, F, Cl, Br, I,
            P, S, As, B, Si, Se, and Te.
            </summary>
        </member>
        <member name="F:NCDK.Geometries.Volume.VABCVolume.bondiiVolumes">
            <summary>
            Values are taken from the spreadsheet where possible. The values in the
            paper are imprecise.
            </summary>
        </member>
        <member name="M:NCDK.Geometries.Volume.VABCVolume.Calculate(NCDK.IAtomContainer)">
            <summary>
            Calculates the volume for the given <see cref="T:NCDK.IAtomContainer"/>. This methods assumes
            that atom types have been perceived.
            </summary>
            <param name="molecule"><see cref="T:NCDK.IAtomContainer"/> to calculate the volume of.</param>
            <returns>the volume in cubic √Öngstrom.</returns>
        </member>
        <member name="T:NCDK.Geometries.ZMatrixTools">
            <summary>
            A set of static utility classes for dealing with Z matrices.
            </summary>
        </member>
        <member name="M:NCDK.Geometries.ZMatrixTools.ZMatrixToCartesian(System.Double[],System.Int32[],System.Double[],System.Int32[],System.Double[],System.Int32[])">
            <summary>
            Takes the given Z Matrix coordinates and converts them to cartesian coordinates.
            The first Atom end up in the origin, the second on on the x axis, and the third
            one in the XY plane. The rest is added by applying the Zmatrix distances, angles
            and dihedrals. Angles are in degrees.
            </summary>
            <param name="distances">Array of distance variables of the Z matrix</param>
            <param name="first_atoms">Array of angle variables of the Z matrix</param>
            <param name="angles">Array of distance variables of the Z matrix</param>
            <param name="second_atoms">Array of atom ids of the first invoked atom in distance, angle and dihedral</param>
            <param name="dihedrals">Array of atom ids of the second invoked atom in angle and dihedral</param>
            <param name="third_atoms">Array of atom ids of the third invoked atom in dihedral</param>
            <returns>The cartesian coordinates</returns>
        </member>
        <member name="T:NCDK.Geometries.Surface.NeighborList">
            <summary>
            Creates a list of atoms neighboring each atom in the molecule.
            </summary>
            <remarks>
            The routine is a simplified version of the neighbor list described
            in <token>cdk-cite-EIS95</token> and is based on the implementation by Peter McCluskey.
            Due to the fact that it divides the cube into a fixed number of sub cubes,
            some accuracy may be lost.
            </remarks>
        </member>
        <member name="T:NCDK.Geometries.Surface.NumericalSurface">
            <summary>
            A class representing the solvent accessible surface area surface of a molecule.
            </summary>
            <remarks>
            <para>This class is based on the Python implementation of the DCLM method
            (<token>cdk-cite-EIS95</token>) by Peter McCluskey, which is a non-analytical method to generate a set of points
            representing the solvent accessible surface area of a molecule.
            </para>
            <para>
            The neighbor list is a simplified version of that
            described in <token>cdk-cite-EIS95</token> and as a result, the surface areas of the atoms may not be exact
            (compared to analytical calculations). The tessellation is slightly different from
            that described by McCluskey and uses recursive subdivision starting from an icosahedral
            representation.
            </para>
            <para>
            The default solvent radius used is 1.4A and setting this to 0 will give the
            Van der Waals surface. The accuracy can be increased by increasing the tessellation
            level, though the default of 4 is a good balance between accuracy and speed.
            </para>
            </remarks>
        </member>
        <member name="M:NCDK.Geometries.Surface.NumericalSurface.#ctor(NCDK.IAtomContainer)">
            <summary>
            Constructor to initialize the surface calculation with default values.
            This constructor use the Van der Waals radii as defined in <i>NCDK.Config.Data.jmol_atomtypes.txt</i>
            of the source distribution. Also uses a tesselation level of 4 and solvent radius of 1.4A.
            </summary>
            <param name="atomContainer">The <see cref="T:NCDK.IAtomContainer"/> for which the surface is to be calculated</param>
        </member>
        <member name="M:NCDK.Geometries.Surface.NumericalSurface.#ctor(NCDK.IAtomContainer,System.Double,System.Int32)">
            <summary>
            Constructor to initialize the surface calculation with user specified values.
            This constructor use the Van der Waals radii as defined in <i>NCDK.Config.Data.jmol_atomtypes.txt</i>
            of the source distribution
            </summary>
            <param name="atomContainer">The <see cref="T:NCDK.IAtomContainer"/> for which the surface is to be calculated</param>
            <param name="solventRadius">The radius of a solvent molecule that is used to extend
            the radius of each atom. Setting to 0 gives the Van der Waals surface</param>
            <param name="tesslevel">The number of levels that the subdivision algorithm for tessellation should use</param>
        </member>
        <member name="M:NCDK.Geometries.Surface.NumericalSurface.CalculateSurface">
             <summary>
             Evaluate the surface.
            
             This method generates the points on the accessible surface area of each atom
             as well as calculating the surface area of each atom
             </summary>
        </member>
        <member name="M:NCDK.Geometries.Surface.NumericalSurface.GetAllSurfacePoints">
             <summary>
             Get an array of all the points on the molecular surface.
            
             This returns an array of Vector3 objects representing all the points
             on the molecular surface
             </summary>
             <returns>An array of Vector3 objects</returns>
        </member>
        <member name="M:NCDK.Geometries.Surface.NumericalSurface.GetSurfacePoints(System.Int32)">
            <summary>
            Get an array of the points on the accessible surface of a specific atom.
            </summary>
            <param name="atomIdx">The index of the atom. Ranges from 0 to n-1, where n is the</param>
            number of atoms in the AtomContainer that the surface was calculated for
            <returns>An array of Vector3 objects</returns>
            <exception cref="T:NCDK.CDKException">if the atom index is outside the range of allowable indices</exception>
        </member>
        <member name="M:NCDK.Geometries.Surface.NumericalSurface.GetSurfaceArea(System.Int32)">
            <summary>
            Get the surface area for the specified atom.
            </summary>
            <param name="atomIdx">The index of the atom. Ranges from 0 to n-1, where n is the
            number of atoms in the AtomContainer that the surface was calculated for</param>
            <returns>A double representing the accessible surface area of the atom</returns>
            <exception cref="T:NCDK.CDKException">if the atom index is outside the range of allowable indices</exception>
        </member>
        <member name="M:NCDK.Geometries.Surface.NumericalSurface.GetAllSurfaceAreas">
            <summary>
            Get an array containing the accessible surface area for each atom.
            </summary>
            <returns>An array of double giving the surface areas of all the atoms</returns>
        </member>
        <member name="M:NCDK.Geometries.Surface.NumericalSurface.GetTotalSurfaceArea">
            <summary>
            Get the total surface area for the AtomContainer.
            </summary>
            <returns>A double containing the total surface area of the AtomContainer for
            which the surface was calculated for</returns>
        </member>
        <member name="T:NCDK.Geometries.Surface.Tessellate">
            <summary>
            Performs a tessellation of the unit sphere.
            <para>
            This class generates the coordinates of the triangles that will
            tessellate the unit sphere. The algorithm is recursive subdivision
            of an initial representation which can be tetrahedral, octahedral or
            icosahedral. The default is icosahedral. The number of points generated
            depends on the level of subdivision. The default is 4 levels and with the
            initial icosahedral representation this gives 1536 points.
            </para>
            <para>
            The constants for the tetrahedral and icosahedral representations were
            taken from http://eeg.sourceforge.net/eegdoc/eeg_toolbox/sphere_tri.html
            </para>
            </summary>
        </member>
        <member name="T:NCDK.Geometries.Surface.Triangle">
             <summary>
             Representation of a triangle in 3D.
            
             By default this class represent the triangle in clockwise
             fashion.
             </summary>
        </member>
        <member name="T:NCDK.Indexes.CASNumber">
            <summary>
            Tools to work with CAS registry numbers.
            </summary>
            <remarks>
            References:
            <list type="bullet">
                <item><see href="http://www.cas.org/EO/regsys.html">A CAS Registry Number</see></item>
                <item><see href="http://www.cas.org/EO/checkdig.html">Check Digit Verification of CAS Registry Numbers</see></item>
            </list> 
            <see href="http://www.cas.org">CAS website</see>
            </remarks>
        </member>
        <member name="M:NCDK.Indexes.CASNumber.IsValid(System.String)">
            <summary>
            Checks whether the registry number is valid.
            </summary>
            <param name="casNumber">the CAS number to validate</param>
            <returns>true if a valid CAS number, false otherwise</returns>
        </member>
        <member name="T:NCDK.Proteins.ProteinPocketFinder">
            <summary>
            The detection of pocket and cavities in a bioPolymer is done similar to the program LIGSITE <token>cdk-cite-MH1997</token>.
            TODO: Optimisation of the cubic grid placement
            </summary>
        </member>
        <member name="M:NCDK.Proteins.ProteinPocketFinder.#ctor(System.String,System.Boolean)">
            <summary>
            
            </summary>
            <param name="biopolymerFile">The file name containing the protein</param>
            <param name="cubicGrid">if true generate the grid</param>
        </member>
        <member name="M:NCDK.Proteins.ProteinPocketFinder.ReadBioPolymer(System.String)">
            <summary>Creates from a PDB File a BioPolymer.</summary>
        </member>
        <member name="M:NCDK.Proteins.ProteinPocketFinder.FindGridBoundaries">
            <summary>
            Method determines the minimum and maximum values of a coordinate space up to 3D space.
            </summary>
            <returns>double[] stores min,max,min,max,min,max</returns>
        </member>
        <member name="M:NCDK.Proteins.ProteinPocketFinder.CreateCubicGrid">
            <summary>Method creates a cubic grid with the grid generator class.</summary>
        </member>
        <member name="M:NCDK.Proteins.ProteinPocketFinder.AssignProteinToGrid">
            <summary>
            Method assigns the atoms of a biopolymer to the grid. For every atom
            the corresponding grid point is identified and set to the value
            of the proteinInterior variable.
            The atom radius and solvent radius is accounted for with the variables:
            double rAtom, and double rSolvent.
            </summary>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:NCDK.Proteins.ProteinPocketFinder.SiteFinder">
            <summary>
            Main method which calls the methods: assignProteinToGrid,
            GridScan, and FindPockets.
            </summary>
        </member>
        <member name="M:NCDK.Proteins.ProteinPocketFinder.SortPockets">
            <summary>
            Method sorts the pockets due to its size. The biggest pocket is the first.
            </summary>
        </member>
        <member name="M:NCDK.Proteins.ProteinPocketFinder.FindPockets">
            <summary>
            Method which finds the pocket, with a simple nearest neighbour clustering. The points
            which should be clustered or form a pocket can be determined with:
                minPSPocket, minPSCluster, linkageRadius, and pocketSize.
            </summary>
        </member>
        <member name="M:NCDK.Proteins.ProteinPocketFinder.ClusterPSPPocket(NCDK.Numerics.Vector3,System.Collections.Generic.List{NCDK.Numerics.Vector3},System.Int32[])">
            <summary>Method performs the clustering, is called by FindPockets().</summary>
        </member>
        <member name="M:NCDK.Proteins.ProteinPocketFinder.CheckBoundaries(System.Int32[],System.Int32[])">
            <summary>
            Method checks boundaries.
            </summary>
            <param name="minMax">with minMax values</param>
            <param name="dim">dimension</param>
            <returns>new minMax values between 0 and dim</returns>
        </member>
        <member name="M:NCDK.Proteins.ProteinPocketFinder.FirePSPEvent(System.Collections.Generic.List{NCDK.Numerics.Vector3})">
            <summary>Method which assigns upon a PSP event +1 to these grid points.</summary>
        </member>
        <member name="M:NCDK.Proteins.ProteinPocketFinder.DiagonalAxisScanXZY(System.Int32,System.Int32,System.Int32)">
            <summary>
            Method performs a scan; works only for cubic grids!
            </summary>
            <param name="dimK">first dimension</param>
            <param name="dimL">second dimension</param>
            <param name="dimM">third dimension</param>
        </member>
        <member name="M:NCDK.Proteins.ProteinPocketFinder.DiagonalAxisScanYZX(System.Int32,System.Int32,System.Int32)">
            <summary>
            Method performs a scan; works only for cubic grids!
            </summary>
            <param name="dimK">first dimension</param>
            <param name="dimL">second dimension</param>
            <param name="dimM">third dimension</param>
        </member>
        <member name="M:NCDK.Proteins.ProteinPocketFinder.DiagonalAxisScanYXZ(System.Int32,System.Int32,System.Int32)">
            <summary>
            Method performs a scan; works only for cubic grids!
            </summary>
            <param name="dimK">first dimension</param>
            <param name="dimL">second dimension</param>
            <param name="dimM">third dimension</param>
        </member>
        <member name="M:NCDK.Proteins.ProteinPocketFinder.DiagonalAxisScanXYZ(System.Int32,System.Int32,System.Int32)">
            <summary>
            Method performs a scan; works only for cubic grids!
            </summary>
            <param name="dimK">first dimension</param>
            <param name="dimL">second dimension</param>
            <param name="dimM">third dimension</param>
        </member>
        <member name="M:NCDK.Proteins.ProteinPocketFinder.AxisScanX(System.Int32,System.Int32,System.Int32)">
            <summary>
            Method performs a scan; works only for cubic grids!
            </summary>
            <param name="dimK">first dimension</param>
            <param name="dimL">second dimension</param>
            <param name="dimM">third dimension</param>
        </member>
        <member name="M:NCDK.Proteins.ProteinPocketFinder.AxisScanY(System.Int32,System.Int32,System.Int32)">
            <summary>
            Method performs a scan; works only for cubic grids!
            </summary>
            <param name="dimK">first dimension</param>
            <param name="dimL">second dimension</param>
            <param name="dimM">third dimension</param>
        </member>
        <member name="M:NCDK.Proteins.ProteinPocketFinder.AxisScanZ(System.Int32,System.Int32,System.Int32)">
            <summary>
            Method performs a scan; works only for cubic grids!
            </summary>
            <param name="dimK">first dimension</param>
            <param name="dimL">second dimension</param>
            <param name="dimM">third dimension</param>
        </member>
        <member name="M:NCDK.Proteins.ProteinPocketFinder.AssignVdWRadiiToProtein">
            <summary>
            Method which assigns van der Waals radii to the biopolymer
            default org/openscience/cdk/config/data/pdb_atomtypes.xml
            stored in the variable string vanDerWaalsFile.
            </summary>
        </member>
        <member name="M:NCDK.Proteins.ProteinPocketFinder.GridToPmesh(System.String)">
            <summary>Method writes the grid to pmesh format.</summary>
        </member>
        <member name="M:NCDK.Proteins.ProteinPocketFinder.PspGridToPmesh(System.String)">
            <summary>Method writes the PSP points (ÔøΩÔøΩminPSPocket) to pmesh format.</summary>
        </member>
        <member name="M:NCDK.Proteins.ProteinPocketFinder.ProteinGridToPmesh(System.String)">
            <summary>Method writes the protein grid points to pmesh format.</summary>
        </member>
        <member name="M:NCDK.Proteins.ProteinPocketFinder.WritePocketsToPMesh(System.String)">
            <summary>Method writes the pockets to pmesh format.</summary>
        </member>
        <member name="T:NCDK.Reactions.ReactionChain">
            <summary>
            Classes that extends the definition of reaction to a chain reaction.
            This is designed to contains a set of reactions which are lineal linked as
            chain. That would mean no exist branches or cycles and in this concept
            you have a start reaction and final reaction. Each reaction is included
            in a step of the chain.
            </summary>
        </member>
        <member name="M:NCDK.Reactions.ReactionChain.Add(NCDK.IReaction,System.Int32)">
            <summary>
            Added a IReaction for this chain in position.
            </summary>
            <param name="reaction">The IReaction</param>
            <param name="position">The position in this chain where the reaction is to be inserted</param>
        </member>
        <member name="M:NCDK.Reactions.ReactionChain.GetReactionStep(NCDK.IReaction)">
            <summary>
            Get the position of the reaction into this chain reaction object.
            </summary>
            <param name="reaction">The IReaction to look at</param>
            <returns>The position of the IReaction in this chain</returns>
        </member>
        <member name="P:NCDK.Reactions.ReactionChain.Item(System.Int32)">
            <summary>
            The reaction of this chain reaction object at the position.
            </summary>
            <param name="position">The position of the IReaction in this chain to look for</param>
            <returns>Reaction The IReaction to look at</returns>
        </member>
        <member name="P:NCDK.Reactions.Types.AbstractRadicalSiteInitiationReaction.Specification">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Reactions.Types.AbstractRadicalSiteInitiationReaction.Initiate(NCDK.IChemObjectSet{NCDK.IAtomContainer},NCDK.IChemObjectSet{NCDK.IAtomContainer})">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.Reactions.Types.AbstractRadicalSiteReaction.Specification">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Reactions.Types.AbstractRadicalSiteReaction.Initiate(NCDK.IChemObjectSet{NCDK.IAtomContainer},NCDK.IChemObjectSet{NCDK.IAtomContainer})">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.Reactions.Types.AbstractAdductionLPReaction.Specification">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Reactions.Types.AbstractAdductionLPReaction.Initiate(NCDK.IChemObjectSet{NCDK.IAtomContainer},NCDK.IChemObjectSet{NCDK.IAtomContainer})">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.Reactions.Types.AbstractElectronImpactDBReaction.Specification">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Reactions.Types.AbstractElectronImpactDBReaction.Initiate(NCDK.IChemObjectSet{NCDK.IAtomContainer},NCDK.IChemObjectSet{NCDK.IAtomContainer})">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.Reactions.Types.AbstractHeterolyticCleavageReaction.Specification">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Reactions.Types.AbstractHeterolyticCleavageReaction.Initiate(NCDK.IChemObjectSet{NCDK.IAtomContainer},NCDK.IChemObjectSet{NCDK.IAtomContainer})">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.Reactions.Types.AbstractRearrangementReaction.Specification">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Reactions.Types.AbstractRearrangementReaction.Initiate(NCDK.IChemObjectSet{NCDK.IAtomContainer},NCDK.IChemObjectSet{NCDK.IAtomContainer})">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.Reactions.Types.AbstractSharingReaction.Specification">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Reactions.Types.AbstractSharingReaction.Initiate(NCDK.IChemObjectSet{NCDK.IAtomContainer},NCDK.IChemObjectSet{NCDK.IAtomContainer})">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Reactions.Types.AdductionProtonLPReaction">
             <example>
             <code>
             var setOfReactants = ChemObjectBuilder.Instance.NewAtomContainerSet&lt;IAtomContainer&gt;();
             setOfReactants.Add(molecular);
             var type = new AdductionProtonLPReaction();
             IParameterReaction param = new SetReactionCenter();
             param.IsSetParameter = false;
             var paramList = new[] { param };
             type.ParameterList = paramList;
             IReactionSet setOfReactions = type.Initiate(setOfReactants, null);
              </code>
            
             <para>We have the possibility to localize the reactive center. Good method if you
             want to localize the reaction in a fixed point</para>
             <code>atoms[0].IsReactiveCenter = true;</code>
             <para>Moreover you must put the parameter true</para>
             <para>If the reactive center is not localized then the reaction process will
             try to find automatically the possible reactive center.</para>
             </example>
            <summary>
            <see cref="T:NCDK.Reactions.IReactionProcess"/> which produces a protonation.
            </summary>
            <para>
            As most commonly encountered, this reaction results in the formal migration
            of a hydrogen atom or proton, accompanied by a switch of a single bond and adjacent double bond
            </para>
            <para>
            [X-] + [H+] =&gt; X -H<br/>
            |X + [H+]   =&gt; [X+]-H<br/>
            </para>
            <seealso cref="T:NCDK.Reactions.Mechanisms.AdductionLPMechanism"/>
        </member>
        <member name="P:NCDK.Reactions.Types.AdductionProtonLPReaction.Specification">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Reactions.Types.AdductionProtonLPReaction.Initiate(NCDK.IChemObjectSet{NCDK.IAtomContainer},NCDK.IChemObjectSet{NCDK.IAtomContainer})">
            <summary>
             Initiate process.
             It is needed to call the addExplicitHydrogensToSatisfyValency
             from the class tools.HydrogenAdder.
            </summary>
            <exception cref="T:NCDK.CDKException"></exception>
            <param name="reactants">reactants of the reaction</param>
            <param name="agents">agents of the reaction (Must be in this case null)</param>
        </member>
        <member name="T:NCDK.Reactions.Types.AdductionProtonPBReaction">
             <example>
             <code>
             var setOfReactants = ChemObjectBuilder.Instance.NewAtomContainerSet&lt;IAtomContainer&gt;();
             setOfReactants.Add(molecular);
             var type = new AdductionProtonPBReaction();
             IParameterReaction param = new SetReactionCenter();
             param.IsSetParameter = false;
             var paramList = new[] { param };
             type.ParameterList = paramList;
             IReactionSet setOfReactions = type.Initiate(setOfReactants, null);
              </code>
            
             <para>We have the possibility to localize the reactive center. Good method if you
             want to localize the reaction in a fixed point</para>
             <code>atoms[0].IsReactiveCenter = true;</code>
             <para>Moreover you must put the parameter true</para>
             <para>If the reactive center is not localized then the reaction process will
             try to find automatically the possible reactive center.</para>
             </example>
            <summary>
            IReactionProcess which produces a protonation to double bond.
            As most commonly encountered, this reaction results in the formal migration
            of a hydrogen atom or proton, accompanied by a switch of a single bond and adjacent double bond
            <para>A=B + [H+] =&gt; [A+]-B-H</para>
            </summary>
            <seealso cref="T:NCDK.Reactions.Mechanisms.AdductionPBMechanism"/>
        </member>
        <member name="M:NCDK.Reactions.Types.AdductionProtonPBReaction.#ctor">
            <summary>
            Constructor of the AdductionProtonPBReaction object.
            </summary>
        </member>
        <member name="P:NCDK.Reactions.Types.AdductionProtonPBReaction.Specification">
            <summary>
            Gets the specification attribute of the AdductionProtonPBReaction object.
            </summary>
            <returns>The specification value</returns>
        </member>
        <member name="M:NCDK.Reactions.Types.AdductionProtonPBReaction.Initiate(NCDK.IChemObjectSet{NCDK.IAtomContainer},NCDK.IChemObjectSet{NCDK.IAtomContainer})">
            <summary>
             Initiate process.
             It is needed to call the addExplicitHydrogensToSatisfyValency
             from the class tools.HydrogenAdder.
            </summary>
            <exception cref="T:NCDK.CDKException"> Description of the Exception</exception>
            <param name="reactants">reactants of the reaction</param>
            <param name="agents">agents of the reaction (Must be in this case null)</param>
        </member>
        <member name="M:NCDK.Reactions.Types.AdductionProtonPBReaction.SetActiveCenters(NCDK.IAtomContainer)">
            <summary>
            set the active center for this molecule.
            The active center will be those which correspond with X=Y.
            </summary>
            <param name="reactant">The molecule to set the activity</param>
        </member>
        <member name="T:NCDK.Reactions.Types.AdductionSodiumLPReaction">
             <example>
             <code>
             var setOfReactants = ChemObjectBuilder.Instance.NewAtomContainerSet&lt;IAtomContainer&gt;();
             setOfReactants.Add(molecular);
             var type = new AdductionSodiumLPReaction();
             IParameterReaction param = new SetReactionCenter();
             param.IsSetParameter = false;
             var paramList = new[] { param };
             type.ParameterList = paramList;
             IReactionSet setOfReactions = type.Initiate(setOfReactants, null);
              </code>
            
             <para>We have the possibility to localize the reactive center. Good method if you
             want to localize the reaction in a fixed point</para>
             <code>atoms[0].IsReactiveCenter = true;</code>
             <para>Moreover you must put the parameter true</para>
             <para>If the reactive center is not localized then the reaction process will
             try to find automatically the possible reactive center.</para>
             </example>
            <summary>
            IReactionProcess which produces an adduction of the Sodium.
            As most commonly encountered, this reaction results in the formal migration
            of a hydrogen atom or proton, accompanied by a switch of a single bond and adjacent double bond
            <pre>[X-] + [Na+] =&gt; X -Na</pre>
            <pre>|X + [Na+]   =&gt; [X+]-Na</pre>
            </summary>
            <seealso cref="T:NCDK.Reactions.Mechanisms.AdductionLPMechanism"/>
        </member>
        <member name="M:NCDK.Reactions.Types.AdductionSodiumLPReaction.#ctor">
            <summary>
            Constructor of the AdductionSodiumLPReaction object.
            </summary>
        </member>
        <member name="P:NCDK.Reactions.Types.AdductionSodiumLPReaction.Specification">
            <summary>
             Gets the specification attribute of the AdductionSodiumLPReaction object.
            <returns>The specification value</returns>
            </summary>
        </member>
        <member name="M:NCDK.Reactions.Types.AdductionSodiumLPReaction.Initiate(NCDK.IChemObjectSet{NCDK.IAtomContainer},NCDK.IChemObjectSet{NCDK.IAtomContainer})">
            <summary>
             Initiate process.
             It is needed to call the addExplicitHydrogensToSatisfyValency
             from the class tools.HydrogenAdder.
            </summary>
            <exception cref="T:NCDK.CDKException"></exception>
            <param name="reactants">reactants of the reaction</param>
            <param name="agents">agents of the reaction (Must be in this case null)</param>
        </member>
        <member name="T:NCDK.Reactions.Types.CarbonylEliminationReaction">
             <example>
             <code>
             var setOfReactants = ChemObjectBuilder.Instance.NewAtomContainerSet&lt;IAtomContainer&gt;();
             setOfReactants.Add(molecular);
             var type = new CarbonylEliminationReaction();
             IParameterReaction param = new SetReactionCenter();
             param.IsSetParameter = false;
             var paramList = new[] { param };
             type.ParameterList = paramList;
             IReactionSet setOfReactions = type.Initiate(setOfReactants, null);
              </code>
            
             <para>We have the possibility to localize the reactive center. Good method if you
             want to localize the reaction in a fixed point</para>
             <code>atoms[0].IsReactiveCenter = true;</code>
             <para>Moreover you must put the parameter true</para>
             <para>If the reactive center is not localized then the reaction process will
             try to find automatically the possible reactive center.</para>
             </example>
            <summary>
            <para>IReactionProcess which participate mass spectrum process.
            This reaction could be represented as RC-C#[O+] =&gt; R[C] + |C#[O+]</para>
            Make sure that the molecule has the correspond lone pair electrons
            for each atom. You can use <see cref="T:NCDK.Tools.LonePairElectronChecker"/>.
            </summary>
            <seealso cref="T:NCDK.Reactions.Mechanisms.HeterolyticCleavageMechanism"/>
        </member>
        <member name="M:NCDK.Reactions.Types.CarbonylEliminationReaction.#ctor">
            <summary>
            Constructor of the CarbonylEliminationReaction object.
            </summary>
        </member>
        <member name="P:NCDK.Reactions.Types.CarbonylEliminationReaction.Specification">
            <summary>
             Gets the specification attribute of the CarbonylEliminationReaction object.
            </summary>
            <returns>The specification value</returns>
        </member>
        <member name="M:NCDK.Reactions.Types.CarbonylEliminationReaction.Initiate(NCDK.IChemObjectSet{NCDK.IAtomContainer},NCDK.IChemObjectSet{NCDK.IAtomContainer})">
            <summary>
             Initiate process.
            </summary>
            <exception cref="T:NCDK.CDKException"> Description of the Exception</exception>
            <param name="reactants">reactants of the reaction</param>
            <param name="agents">agents of the reaction (Must be in this case null)</param>
        </member>
        <member name="M:NCDK.Reactions.Types.CarbonylEliminationReaction.SetActiveCenters(NCDK.IAtomContainer)">
            <summary>
            set the active center for this molecule.
            The active center will be those which correspond with RC-C#[O+].
            <pre>
            C: Atom
            -: single bond
            C: Atom
            #: triple bond
            O: Atom with formal charge = 1
             </pre>
            </summary>
            <param name="reactant">The molecule to set the activity</param>
        </member>
        <member name="T:NCDK.Reactions.Types.ElectronImpactNBEReaction">
             <example>
             <code>
             var setOfReactants = ChemObjectBuilder.Instance.NewAtomContainerSet&lt;IAtomContainer&gt;();
             setOfReactants.Add(molecular);
             var type = new ElectronImpactNBEReaction();
             IParameterReaction param = new SetReactionCenter();
             param.IsSetParameter = false;
             var paramList = new[] { param };
             type.ParameterList = paramList;
             IReactionSet setOfReactions = type.Initiate(setOfReactants, null);
              </code>
            
             <para>We have the possibility to localize the reactive center. Good method if you
             want to localize the reaction in a fixed point</para>
             <code>atoms[0].IsReactiveCenter = true;</code>
             <para>Moreover you must put the parameter true</para>
             <para>If the reactive center is not localized then the reaction process will
             try to find automatically the possible reactive center.</para>
             </example>
            <summary>
            <para>IReactionProcess which make an electron impact for for Non-Bonding Electron Lost.</para>
            <para>This reaction type is a representation of the processes which occurs in the mass spectrometer.</para>
            </summary>
            <seealso cref="T:NCDK.Reactions.Mechanisms.RemovingSEofNBMechanism"/>
        </member>
        <member name="M:NCDK.Reactions.Types.ElectronImpactNBEReaction.#ctor">
            <summary>
            Constructor of the ElectronImpactNBEReaction object.
            </summary>
        </member>
        <member name="P:NCDK.Reactions.Types.ElectronImpactNBEReaction.Specification">
            <summary>
            Gets the specification attribute of the ElectronImpactNBEReaction object.
            </summary>
            <returns>The specification value</returns>
        </member>
        <member name="M:NCDK.Reactions.Types.ElectronImpactNBEReaction.Initiate(NCDK.IChemObjectSet{NCDK.IAtomContainer},NCDK.IChemObjectSet{NCDK.IAtomContainer})">
            <summary>
             Initiate process.
             It is needed to call the addExplicitHydrogensToSatisfyValency
             from the class tools.HydrogenAdder.
            </summary>
            <param name="reactants">Reactants of the reaction</param>
            <param name="agents">Agents of the reaction (Must be in this case null)</param>
            <exception cref="T:NCDK.CDKException"> Description of the Exception</exception>
        </member>
        <member name="M:NCDK.Reactions.Types.ElectronImpactNBEReaction.SetActiveCenters(NCDK.IAtomContainer)">
            <summary>
            set the active center for this molecule. The active center
            will be heteroatoms which contain at least one group of
            lone pair electrons.
            </summary>
            <param name="reactant">The molecule to set the activity</param>
        </member>
        <member name="T:NCDK.Reactions.Types.ElectronImpactPDBReaction">
             <example>
             <code>
             var setOfReactants = ChemObjectBuilder.Instance.NewAtomContainerSet&lt;IAtomContainer&gt;();
             setOfReactants.Add(molecular);
             var type = new ElectronImpactPDBReaction();
             IParameterReaction param = new SetReactionCenter();
             param.IsSetParameter = false;
             var paramList = new[] { param };
             type.ParameterList = paramList;
             IReactionSet setOfReactions = type.Initiate(setOfReactants, null);
              </code>
            
             <para>We have the possibility to localize the reactive center. Good method if you
             want to localize the reaction in a fixed point</para>
             <code>atoms[0].IsReactiveCenter = true;</code>
             <para>Moreover you must put the parameter true</para>
             <para>If the reactive center is not localized then the reaction process will
             try to find automatically the possible reactive center.</para>
             </example>
            <summary>
            <para>IReactionProcess which make an electron impact for ÔøΩÔøΩ-Bond Dissociation.</para>
            <para>This reaction type is a representation of the processes which occurs in the mass spectrometer.</para>
            </summary>
            <seealso cref="T:NCDK.Reactions.Mechanisms.RemovingSEofBMechanism"/>
        </member>
        <member name="P:NCDK.Reactions.Types.ElectronImpactPDBReaction.Specification">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Reactions.Types.ElectronImpactPDBReaction.Initiate(NCDK.IChemObjectSet{NCDK.IAtomContainer},NCDK.IChemObjectSet{NCDK.IAtomContainer})">
            <summary>
             Initiate process.
             It is needed to call the addExplicitHydrogensToSatisfyValency
             from the class tools.HydrogenAdder.
            </summary>
            <exception cref="T:NCDK.CDKException"> Description of the Exception</exception>
            <param name="reactants">reactants of the reaction.</param>
            <param name="agents">agents of the reaction (Must be in this case null).</param>
        </member>
        <member name="T:NCDK.Reactions.Types.ElectronImpactSDBReaction">
             <example>
             <code>
             var setOfReactants = ChemObjectBuilder.Instance.NewAtomContainerSet&lt;IAtomContainer&gt;();
             setOfReactants.Add(molecular);
             var type = new ElectronImpactSDBReaction();
             IParameterReaction param = new SetReactionCenter();
             param.IsSetParameter = false;
             var paramList = new[] { param };
             type.ParameterList = paramList;
             IReactionSet setOfReactions = type.Initiate(setOfReactants, null);
              </code>
            
             <para>We have the possibility to localize the reactive center. Good method if you
             want to localize the reaction in a fixed point</para>
             <code>atoms[0].IsReactiveCenter = true;</code>
             <para>Moreover you must put the parameter true</para>
             <para>If the reactive center is not localized then the reaction process will
             try to find automatically the possible reactive center.</para>
             </example>
            <summary>
            <para>IReactionProcess which make an electron impact for ÔøΩÔøΩ-Bond Dissociation.</para>
            <para>This reaction type is a representation of the processes which occurs in the mass spectrometer.</para>
            </summary>
            <seealso cref="T:NCDK.Reactions.Mechanisms.RemovingSEofBMechanism"/>
        </member>
        <member name="P:NCDK.Reactions.Types.ElectronImpactSDBReaction.Specification">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Reactions.Types.ElectronImpactSDBReaction.Initiate(NCDK.IChemObjectSet{NCDK.IAtomContainer},NCDK.IChemObjectSet{NCDK.IAtomContainer})">
            <summary>
             Initiate process.
             It is needed to call the addExplicitHydrogensToSatisfyValency
             from the class tools.HydrogenAdder.
            </summary>
            <exception cref="T:NCDK.CDKException"> Description of the Exception</exception>
            <param name="reactants">reactants of the reaction.</param>
            <param name="agents">agents of the reaction (Must be in this case null).</param>
        </member>
        <member name="T:NCDK.Reactions.Types.HeterolyticCleavagePBReaction">
             <example>
             <code>
             var setOfReactants = ChemObjectBuilder.Instance.NewAtomContainerSet&lt;IAtomContainer&gt;();
             setOfReactants.Add(molecular);
             var type = new HeterolyticCleavagePBReaction();
             IParameterReaction param = new SetReactionCenter();
             param.IsSetParameter = false;
             var paramList = new[] { param };
             type.ParameterList = paramList;
             IReactionSet setOfReactions = type.Initiate(setOfReactants, null);
              </code>
            
             <para>We have the possibility to localize the reactive center. Good method if you
             want to localize the reaction in a fixed point</para>
             <code>atoms[0].IsReactiveCenter = true;</code>
             <para>Moreover you must put the parameter true</para>
             <para>If the reactive center is not localized then the reaction process will
             try to find automatically the possible reactive center.</para>
             </example>
             <summary>
             <para>IReactionProcess which a bond is broken displacing the electron to one of the
             atoms. The mechanism will produce one atom with excess of charge and the other one deficiency.
             Depending of the bond order, the bond will be removed or simply the order decreased.</para>
             <para>
             As there are two directions for displacing a bond in a polar manner,
             each case is investigated twice:</para>
            
             <pre>A=B =&gt; [A+]-|[B-]</pre>
             <pre>A=B =&gt; |[A-]-[B+]</pre>
            
             <para>It will not be created structures no possible, e.g; C=O =&gt; [C-][O+].</para>
             </summary>
             <seealso cref="T:NCDK.Reactions.Mechanisms.HeterolyticCleavageMechanism"/>
        </member>
        <member name="M:NCDK.Reactions.Types.HeterolyticCleavagePBReaction.#ctor">
            <summary>
            Constructor of the HeterolyticCleavagePBReaction object.
            </summary>
        </member>
        <member name="P:NCDK.Reactions.Types.HeterolyticCleavagePBReaction.Specification">
            <summary>
             Gets the specification attribute of the HeterolyticCleavagePBReaction object.
            </summary>
            <returns>The specification value</returns>
        </member>
        <member name="M:NCDK.Reactions.Types.HeterolyticCleavagePBReaction.Initiate(NCDK.IChemObjectSet{NCDK.IAtomContainer},NCDK.IChemObjectSet{NCDK.IAtomContainer})">
            <summary>
             Initiate process.
             It is needed to call the addExplicitHydrogensToSatisfyValency
             from the class tools.HydrogenAdder.
            </summary>
            <exception cref="T:NCDK.CDKException"> Description of the Exception</exception>
            <param name="reactants">reactants of the reaction</param>
            <param name="agents">agents of the reaction (Must be in this case null)</param>
        </member>
        <member name="T:NCDK.Reactions.Types.HeterolyticCleavageSBReaction">
             <example>
             <code>
             var setOfReactants = ChemObjectBuilder.Instance.NewAtomContainerSet&lt;IAtomContainer&gt;();
             setOfReactants.Add(molecular);
             var type = new HeterolyticCleavageSBReaction();
             IParameterReaction param = new SetReactionCenter();
             param.IsSetParameter = false;
             var paramList = new[] { param };
             type.ParameterList = paramList;
             IReactionSet setOfReactions = type.Initiate(setOfReactants, null);
              </code>
            
             <para>We have the possibility to localize the reactive center. Good method if you
             want to localize the reaction in a fixed point</para>
             <code>atoms[0].IsReactiveCenter = true;</code>
             <para>Moreover you must put the parameter true</para>
             <para>If the reactive center is not localized then the reaction process will
             try to find automatically the possible reactive center.</para>
             </example>
             <summary>
             <para>IReactionProcess which a bond is broken displacing the electron to one of the
             atoms. The mechanism will produce one atom with excess of charge and the other one deficiency.
             Depending of the bond order, the bond will be removed or simply the order decreased.
             As there are two directions for displacing a bond in a polar manner,
             each case is investigated twice:</para>
            
             <pre>A-B =&gt; [A+] + |[B-]</pre>
             <pre>A-B =&gt; |[A-] + [B+]</pre>
            
             <para>It will not be created structures no possible, e.g; C=O =&gt; [C-][O+].</para>
             </summary>
             <seealso cref="T:NCDK.Reactions.Mechanisms.HeterolyticCleavageMechanism"/>
        </member>
        <member name="M:NCDK.Reactions.Types.HeterolyticCleavageSBReaction.#ctor">
            <summary>
            Constructor of the HeterolyticCleavageSBReaction object.
            </summary>
        </member>
        <member name="P:NCDK.Reactions.Types.HeterolyticCleavageSBReaction.Specification">
            <summary>
            The specification attribute of the HeterolyticCleavageSBReaction object.
            </summary>
        </member>
        <member name="M:NCDK.Reactions.Types.HeterolyticCleavageSBReaction.Initiate(NCDK.IChemObjectSet{NCDK.IAtomContainer},NCDK.IChemObjectSet{NCDK.IAtomContainer})">
            <summary>
             Initiate process.
             It is needed to call the addExplicitHydrogensToSatisfyValency
             from the class tools.HydrogenAdder.
            </summary>
            <exception cref="T:NCDK.CDKException"> Description of the Exception</exception>
            <param name="reactants">reactants of the reaction</param>
            <param name="agents">agents of the reaction (Must be in this case null)</param>
        </member>
        <member name="T:NCDK.Reactions.Types.HomolyticCleavageReaction">
             <example>
             <code>
             var setOfReactants = ChemObjectBuilder.Instance.NewAtomContainerSet&lt;IAtomContainer&gt;();
             setOfReactants.Add(molecular);
             var type = new HomolyticCleavageReaction();
             IParameterReaction param = new SetReactionCenter();
             param.IsSetParameter = false;
             var paramList = new[] { param };
             type.ParameterList = paramList;
             IReactionSet setOfReactions = type.Initiate(setOfReactants, null);
              </code>
            
             <para>We have the possibility to localize the reactive center. Good method if you
             want to localize the reaction in a fixed point</para>
             <code>atoms[0].IsReactiveCenter = true;</code>
             <para>Moreover you must put the parameter true</para>
             <para>If the reactive center is not localized then the reaction process will
             try to find automatically the possible reactive center.</para>
             </example>
            <summary>
            <para>IReactionProcess which breaks the bond homogeneously leading to radical ions.
            It is also called homogeneous bond-breaking.Depending of the bond order,
            the bond will be removed or simply the order decreased.</para>
            <pre>A-B =&gt; [A*] + [B*]</pre>
            </summary>
            <seealso cref="T:NCDK.Reactions.Mechanisms.HomolyticCleavageMechanism"/>
        </member>
        <member name="M:NCDK.Reactions.Types.HomolyticCleavageReaction.#ctor">
            <summary>
            Constructor of the HomolyticCleavageReaction object.
            </summary>
        </member>
        <member name="P:NCDK.Reactions.Types.HomolyticCleavageReaction.Specification">
            <summary>
            The specification attribute of the HomolyticCleavageReaction object.
            </summary>
        </member>
        <member name="M:NCDK.Reactions.Types.HomolyticCleavageReaction.Initiate(NCDK.IChemObjectSet{NCDK.IAtomContainer},NCDK.IChemObjectSet{NCDK.IAtomContainer})">
            <summary>
             Initiate process.
             It is needed to call the addExplicitHydrogensToSatisfyValency
             from the class tools.HydrogenAdder.
            </summary>
            <exception cref="T:NCDK.CDKException"> Description of the Exception</exception>
            <param name="reactants">reactants of the reaction.</param>
            <param name="agents">agents of the reaction (Must be in this case null).</param>
        </member>
        <member name="T:NCDK.Reactions.Types.HyperconjugationReaction">
             <example>
             <code>
             var setOfReactants = ChemObjectBuilder.Instance.NewAtomContainerSet&lt;IAtomContainer&gt;();
             setOfReactants.Add(molecular);
             var type = new HyperconjugationReaction();
             IParameterReaction param = new SetReactionCenter();
             param.IsSetParameter = false;
             var paramList = new[] { param };
             type.ParameterList = paramList;
             IReactionSet setOfReactions = type.Initiate(setOfReactants, null);
              </code>
            
             <para>We have the possibility to localize the reactive center. Good method if you
             want to localize the reaction in a fixed point</para>
             <code>atoms[0].IsReactiveCenter = true;</code>
             <para>Moreover you must put the parameter true</para>
             <para>If the reactive center is not localized then the reaction process will
             try to find automatically the possible reactive center.</para>
             </example>
            <summary>
            <para>HyperconjugationReaction is the stabilizing interaction that results
            from the interaction of the electrons in a s-bond (for our case only C-H)
            with an adjacent empty (or partially filled) p-orbital.</para>
            <para>Based on the valence bond model of bonding, hyperconjugation can be described as
            "double bond - no bond resonance"</para>
            <para>This reaction could be represented like</para>
            <pre>[C+]-C =&gt; C=C + [H+] </pre>
            </summary>
        </member>
        <member name="M:NCDK.Reactions.Types.HyperconjugationReaction.#ctor">
            <summary>
            Constructor of the HyperconjugationReaction object
            </summary>
        </member>
        <member name="P:NCDK.Reactions.Types.HyperconjugationReaction.Specification">
            <summary>
             Gets the specification attribute of the HyperconjugationReaction object
            </summary>
            <returns>The specification value</returns>
        </member>
        <member name="M:NCDK.Reactions.Types.HyperconjugationReaction.Initiate(NCDK.IChemObjectSet{NCDK.IAtomContainer},NCDK.IChemObjectSet{NCDK.IAtomContainer})">
            <summary>
             Initiate process.
             It is needed to call the addExplicitHydrogensToSatisfyValency
             from the class tools.HydrogenAdder.
            </summary>
            <exception cref="T:NCDK.CDKException"></exception>
            <param name="reactants">reactants of the reaction.</param>
            <param name="agents">agents of the reaction (Must be in this case null).</param>
        </member>
        <member name="M:NCDK.Reactions.Types.HyperconjugationReaction.SetActiveCenters(NCDK.IAtomContainer)">
            <summary>
            set the active center for this molecule.
            The active center will be those which correspond with [A+]-B([H]).
            <pre>
            A: Atom with charge
            -: Singlebond
            B: Atom
             </pre>
            </summary>
            <param name="reactant">The molecule to set the activity</param>
        </member>
        <member name="T:NCDK.Reactions.Types.PiBondingMovementReaction">
             <example>
             <code>
             var setOfReactants = ChemObjectBuilder.Instance.NewAtomContainerSet&lt;IAtomContainer&gt;();
             setOfReactants.Add(molecular);
             var type = new PiBondingMovementReaction();
             IParameterReaction param = new SetReactionCenter();
             param.IsSetParameter = false;
             var paramList = new[] { param };
             type.ParameterList = paramList;
             IReactionSet setOfReactions = type.Initiate(setOfReactants, null);
              </code>
            
             <para>We have the possibility to localize the reactive center. Good method if you
             want to localize the reaction in a fixed point</para>
             <code>atoms[0].IsReactiveCenter = true;</code>
             <para>Moreover you must put the parameter true</para>
             <para>If the reactive center is not localized then the reaction process will
             try to find automatically the possible reactive center.</para>
             </example>
            <summary>
            IReactionProcess which tries to reproduce the delocalization of electrons
            which are unsaturated bonds from conjugated rings. Only is allowed those
            movements which produces from neutral to neutral structures and not take account the possible
            movements influenced from lone pairs, or empty orbitals. This movements are
            typically from rings without any access or deficiency of charge and have a
            even number of atoms. 
            <para>The reaction don't care if the product are the same in symmetry.</para>
            </summary>
        </member>
        <member name="M:NCDK.Reactions.Types.PiBondingMovementReaction.#ctor">
            <summary>
            Constructor of the PiBondingMovementReaction object
            </summary>
        </member>
        <member name="P:NCDK.Reactions.Types.PiBondingMovementReaction.Specification">
            <summary>
             The specification attribute of the PiBondingMovementReaction object
            </summary>
        </member>
        <member name="M:NCDK.Reactions.Types.PiBondingMovementReaction.Initiate(NCDK.IChemObjectSet{NCDK.IAtomContainer},NCDK.IChemObjectSet{NCDK.IAtomContainer})">
            <summary>
             Initiate process.
             It is needed to call the addExplicitHydrogensToSatisfyValency
             from the class tools.HydrogenAdder.
            </summary>
            <exception cref="T:NCDK.CDKException"> Description of the Exception</exception>
            <param name="reactants">reactants of the reaction.</param>
            <param name="agents">agents of the reaction (Must be in this case null).</param>
        </member>
        <member name="M:NCDK.Reactions.Types.PiBondingMovementReaction.SetActiveCenters(NCDK.IAtomContainer)">
             <summary>
             Set the active center for this molecule.
             The active center will be those which correspond to a ring
             with pi electrons with resonance.
            
             FIXME REACT: It could be possible that a ring is a super ring of others small rings
             </summary>
             <param name="reactant">The molecule to set the activity</param>
        </member>
        <member name="T:NCDK.Reactions.Types.RadicalChargeSiteInitiationHReaction">
             <example>
             <code>
             var setOfReactants = ChemObjectBuilder.Instance.NewAtomContainerSet&lt;IAtomContainer&gt;();
             setOfReactants.Add(molecular);
             var type = new RadicalChargeSiteInitiationHReaction();
             IParameterReaction param = new SetReactionCenter();
             param.IsSetParameter = false;
             var paramList = new[] { param };
             type.ParameterList = paramList;
             IReactionSet setOfReactions = type.Initiate(setOfReactants, null);
              </code>
            
             <para>We have the possibility to localize the reactive center. Good method if you
             want to localize the reaction in a fixed point</para>
             <code>atoms[0].IsReactiveCenter = true;</code>
             <para>Moreover you must put the parameter true</para>
             <para>If the reactive center is not localized then the reaction process will
             try to find automatically the possible reactive center.</para>
             </example>
            <summary>
            <para>IReactionProcess which participate mass spectrum process. Homolitic dissocitation.
            This reaction could be represented as H-B-[C*+] =&gt; [H*] + B=[C+]. H is hydrogen atom</para>
            <para>Make sure that the molecule has the correspond lone pair electrons
            for each atom. You can use the method: <see cref="T:NCDK.Tools.LonePairElectronChecker"/></para>
            </summary>
            <seealso cref="T:NCDK.Reactions.Mechanisms.RadicalSiteIonizationMechanism"/>
        </member>
        <member name="P:NCDK.Reactions.Types.RadicalChargeSiteInitiationHReaction.Specification">
            <summary>
             Gets the specification attribute of the RadicalChargeSiteInitiationHReaction object
            </summary>
            <returns>The specification value</returns>
        </member>
        <member name="M:NCDK.Reactions.Types.RadicalChargeSiteInitiationHReaction.Initiate(NCDK.IChemObjectSet{NCDK.IAtomContainer},NCDK.IChemObjectSet{NCDK.IAtomContainer})">
            <summary>
             Initiate process.
            </summary>
            <exception cref="T:NCDK.CDKException"> Description of the Exception</exception>
            <param name="reactants">reactants of the reaction.</param>
            <param name="agents">agents of the reaction (Must be in this case null).</param>
        </member>
        <member name="T:NCDK.Reactions.Types.RadicalChargeSiteInitiationReaction">
             <example>
             <code>
             var setOfReactants = ChemObjectBuilder.Instance.NewAtomContainerSet&lt;IAtomContainer&gt;();
             setOfReactants.Add(molecular);
             var type = new RadicalChargeSiteInitiationReaction();
             IParameterReaction param = new SetReactionCenter();
             param.IsSetParameter = false;
             var paramList = new[] { param };
             type.ParameterList = paramList;
             IReactionSet setOfReactions = type.Initiate(setOfReactants, null);
              </code>
            
             <para>We have the possibility to localize the reactive center. Good method if you
             want to localize the reaction in a fixed point</para>
             <code>atoms[0].IsReactiveCenter = true;</code>
             <para>Moreover you must put the parameter true</para>
             <para>If the reactive center is not localized then the reaction process will
             try to find automatically the possible reactive center.</para>
             </example>
            <summary>
            <para>IReactionProcess which participate mass spectrum process. Homolitic dissocitation.
            This reaction could be represented as A-B-[c*+] =&gt; [A*] + B=[C+].</para>
            <para>Make sure that the molecule has the corresponend lone pair electrons
            for each atom. You can use the method: <see cref="T:NCDK.Tools.LonePairElectronChecker"/></para>
            </summary>
            <seealso cref="T:NCDK.Reactions.Mechanisms.RadicalSiteIonizationMechanism"/>
        </member>
        <member name="P:NCDK.Reactions.Types.RadicalChargeSiteInitiationReaction.Specification">
            <summary>
             Gets the specification attribute of the RadicalChargeSiteInitiationReaction object
            </summary>
            <returns>The specification value</returns>
        </member>
        <member name="M:NCDK.Reactions.Types.RadicalChargeSiteInitiationReaction.Initiate(NCDK.IChemObjectSet{NCDK.IAtomContainer},NCDK.IChemObjectSet{NCDK.IAtomContainer})">
            <summary>
             Initiate process.
            </summary>
            <exception cref="T:NCDK.CDKException"> Description of the Exception</exception>
            <param name="reactants">reactants of the reaction.</param>
            <param name="agents">agents of the reaction (Must be in this case null).</param>
        </member>
        <member name="T:NCDK.Reactions.Types.RadicalSiteHrAlphaReaction">
             <example>
             <code>
             var setOfReactants = ChemObjectBuilder.Instance.NewAtomContainerSet&lt;IAtomContainer&gt;();
             setOfReactants.Add(molecular);
             var type = new RadicalSiteHrAlphaReaction();
             IParameterReaction param = new SetReactionCenter();
             param.IsSetParameter = false;
             var paramList = new[] { param };
             type.ParameterList = paramList;
             IReactionSet setOfReactions = type.Initiate(setOfReactants, null);
              </code>
            
             <para>We have the possibility to localize the reactive center. Good method if you
             want to localize the reaction in a fixed point</para>
             <code>atoms[0].IsReactiveCenter = true;</code>
             <para>Moreover you must put the parameter true</para>
             <para>If the reactive center is not localized then the reaction process will
             try to find automatically the possible reactive center.</para>
             </example>
            <summary>
            <para>
            This reaction could be represented as [A*]-(C)_2-C3[H] =&gt; A([H])-(C_2)-[C3*]. Due to
            the single electron of atom A the proton is moved.</para>
            </summary>
            <seealso cref="T:NCDK.Reactions.Mechanisms.RadicalSiteRearrangementMechanism"/>
        </member>
        <member name="M:NCDK.Reactions.Types.RadicalSiteHrAlphaReaction.#ctor">
            <summary>
            Constructor of the RadicalSiteHrAlphaReaction object
            </summary>
        </member>
        <member name="P:NCDK.Reactions.Types.RadicalSiteHrAlphaReaction.Specification">
            <summary>
             Gets the specification attribute of the RadicalSiteHrAlphaReaction object
            </summary>
            <returns>The specification value</returns>
        </member>
        <member name="M:NCDK.Reactions.Types.RadicalSiteHrAlphaReaction.Initiate(NCDK.IChemObjectSet{NCDK.IAtomContainer},NCDK.IChemObjectSet{NCDK.IAtomContainer})">
            <summary>
             Initiate process.
             It is needed to call the addExplicitHydrogensToSatisfyValency
             from the class tools.HydrogenAdder.
            </summary>
            <exception cref="T:NCDK.CDKException"> Description of the Exception</exception>
            <param name="reactants">reactants of the reaction.</param>
            <param name="agents">agents of the reaction (Must be in this case null).</param>
        </member>
        <member name="T:NCDK.Reactions.Types.RadicalSiteHrBetaReaction">
             <example>
             <code>
             var setOfReactants = ChemObjectBuilder.Instance.NewAtomContainerSet&lt;IAtomContainer&gt;();
             setOfReactants.Add(molecular);
             var type = new RadicalSiteHrBetaReaction();
             IParameterReaction param = new SetReactionCenter();
             param.IsSetParameter = false;
             var paramList = new[] { param };
             type.ParameterList = paramList;
             IReactionSet setOfReactions = type.Initiate(setOfReactants, null);
              </code>
            
             <para>We have the possibility to localize the reactive center. Good method if you
             want to localize the reaction in a fixed point</para>
             <code>atoms[0].IsReactiveCenter = true;</code>
             <para>Moreover you must put the parameter true</para>
             <para>If the reactive center is not localized then the reaction process will
             try to find automatically the possible reactive center.</para>
             </example>
            <summary>
            <para>
            This reaction could be represented as [A*]-(C)_3-C4[H] => A([H])-(C_3)-[C4*]. Due to
            the single electron of atom A the proton is moved.</para>
            </summary>
            <seealso cref="T:NCDK.Reactions.Mechanisms.RadicalSiteRearrangementMechanism"/>
        </member>
        <member name="M:NCDK.Reactions.Types.RadicalSiteHrBetaReaction.#ctor">
            <summary>
            Constructor of the RadicalSiteHrBetaReaction object
            </summary>
        </member>
        <member name="P:NCDK.Reactions.Types.RadicalSiteHrBetaReaction.Specification">
            <summary>
             Gets the specification attribute of the RadicalSiteHrBetaReaction object
            </summary>
            <returns>The specification value</returns>
        </member>
        <member name="M:NCDK.Reactions.Types.RadicalSiteHrBetaReaction.Initiate(NCDK.IChemObjectSet{NCDK.IAtomContainer},NCDK.IChemObjectSet{NCDK.IAtomContainer})">
            <summary>
             Initiate process.
             It is needed to call the addExplicitHydrogensToSatisfyValency
             from the class tools.HydrogenAdder.
            </summary>
            <exception cref="T:NCDK.CDKException"> Description of the Exception</exception>
            <param name="reactants">reactants of the reaction.</param>
            <param name="agents">agents of the reaction (Must be in this case null).</param>
        </member>
        <member name="T:NCDK.Reactions.Types.RadicalSiteHrDeltaReaction">
             <example>
             <code>
             var setOfReactants = ChemObjectBuilder.Instance.NewAtomContainerSet&lt;IAtomContainer&gt;();
             setOfReactants.Add(molecular);
             var type = new RadicalSiteHrDeltaReaction();
             IParameterReaction param = new SetReactionCenter();
             param.IsSetParameter = false;
             var paramList = new[] { param };
             type.ParameterList = paramList;
             IReactionSet setOfReactions = type.Initiate(setOfReactants, null);
              </code>
            
             <para>We have the possibility to localize the reactive center. Good method if you
             want to localize the reaction in a fixed point</para>
             <code>atoms[0].IsReactiveCenter = true;</code>
             <para>Moreover you must put the parameter true</para>
             <para>If the reactive center is not localized then the reaction process will
             try to find automatically the possible reactive center.</para>
             </example>
            <summary>
            <para>
            This reaction could be represented as [A*]-(C)_4-C5[H] =&gt; A([H])-(C_4)-[C5*]. Due to
            the single electron of atom A the proton is moved.</para>
            </summary>
            <seealso cref="T:NCDK.Reactions.Mechanisms.RadicalSiteRearrangementMechanism"/>
        </member>
        <member name="M:NCDK.Reactions.Types.RadicalSiteHrDeltaReaction.#ctor">
            <summary>
            Constructor of the RadicalSiteHrDeltaReaction object
            </summary>
        </member>
        <member name="P:NCDK.Reactions.Types.RadicalSiteHrDeltaReaction.Specification">
            <summary>
             Gets the specification attribute of the RadicalSiteHrDeltaReaction object
            </summary>
            <returns>The specification value</returns>
        </member>
        <member name="M:NCDK.Reactions.Types.RadicalSiteHrDeltaReaction.Initiate(NCDK.IChemObjectSet{NCDK.IAtomContainer},NCDK.IChemObjectSet{NCDK.IAtomContainer})">
            <summary>
             Initiate process.
             It is needed to call the addExplicitHydrogensToSatisfyValency
             from the class tools.HydrogenAdder.
            </summary>
            <exception cref="T:NCDK.CDKException"> Description of the Exception</exception>
            <param name="reactants">reactants of the reaction.</param>
            <param name="agents">agents of the reaction (Must be in this case null).</param>
        </member>
        <member name="T:NCDK.Reactions.Types.RadicalSiteHrGammaReaction">
             <example>
             <code>
             var setOfReactants = ChemObjectBuilder.Instance.NewAtomContainerSet&lt;IAtomContainer&gt;();
             setOfReactants.Add(molecular);
             var type = new RadicalSiteHrGammaReaction();
             IParameterReaction param = new SetReactionCenter();
             param.IsSetParameter = false;
             var paramList = new[] { param };
             type.ParameterList = paramList;
             IReactionSet setOfReactions = type.Initiate(setOfReactants, null);
              </code>
            
             <para>We have the possibility to localize the reactive center. Good method if you
             want to localize the reaction in a fixed point</para>
             <code>atoms[0].IsReactiveCenter = true;</code>
             <para>Moreover you must put the parameter true</para>
             <para>If the reactive center is not localized then the reaction process will
             try to find automatically the possible reactive center.</para>
             </example>
            <summary>
            <para>
            This reaction could be represented as [A*]-C1-C2-C3[H] =&gt; A([H])-C1-C2-[C3*]. Due to
            the single electron of atom A the proton is moved.</para>
            </summary>
            <seealso cref="T:NCDK.Reactions.Mechanisms.RadicalSiteRearrangementMechanism"/>
        </member>
        <member name="M:NCDK.Reactions.Types.RadicalSiteHrGammaReaction.#ctor">
            <summary>
            Constructor of the RadicalSiteHrGammaReaction object
            </summary>
        </member>
        <member name="P:NCDK.Reactions.Types.RadicalSiteHrGammaReaction.Specification">
            <summary>
             Gets the specification attribute of the RadicalSiteHrGammaReaction object
            </summary>
            <returns>The specification value</returns>
        </member>
        <member name="M:NCDK.Reactions.Types.RadicalSiteHrGammaReaction.Initiate(NCDK.IChemObjectSet{NCDK.IAtomContainer},NCDK.IChemObjectSet{NCDK.IAtomContainer})">
            <summary>
             Initiate process.
             It is needed to call the addExplicitHydrogensToSatisfyValency
             from the class tools.HydrogenAdder.
            </summary>
            <exception cref="T:NCDK.CDKException">Description of the Exception</exception>
            <param name="reactants">reactants of the reaction.</param>
            <param name="agents">agents of the reaction (Must be in this case null).</param>
        </member>
        <member name="T:NCDK.Reactions.Types.RadicalSiteInitiationHReaction">
             <example>
             <code>
             var setOfReactants = ChemObjectBuilder.Instance.NewAtomContainerSet&lt;IAtomContainer&gt;();
             setOfReactants.Add(molecular);
             var type = new RadicalSiteInitiationHReaction();
             IParameterReaction param = new SetReactionCenter();
             param.IsSetParameter = false;
             var paramList = new[] { param };
             type.ParameterList = paramList;
             IReactionSet setOfReactions = type.Initiate(setOfReactants, null);
              </code>
            
             <para>We have the possibility to localize the reactive center. Good method if you
             want to localize the reaction in a fixed point</para>
             <code>atoms[0].IsReactiveCenter = true;</code>
             <para>Moreover you must put the parameter true</para>
             <para>If the reactive center is not localized then the reaction process will
             try to find automatically the possible reactive center.</para>
             </example>
            <summary>
            <para>IReactionProcess which participate mass spectrum process. Homolitic dissocitation.
            This reaction could be represented as H-B-[C*] =&gt; [H*] + B=C. H is hydrogen atom</para>
            <para>
            Make sure that the molecule has the correspond lone pair electrons
            for each atom. You can use the method: <see cref="T:NCDK.Tools.LonePairElectronChecker"/></para>
            </summary>
            <seealso cref="T:NCDK.Reactions.Mechanisms.RadicalSiteIonizationMechanism"/>
        </member>
        <member name="P:NCDK.Reactions.Types.RadicalSiteInitiationHReaction.Specification">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Reactions.Types.RadicalSiteInitiationHReaction.Initiate(NCDK.IChemObjectSet{NCDK.IAtomContainer},NCDK.IChemObjectSet{NCDK.IAtomContainer})">
            <summary>
             Initiate process.
            </summary>
            <exception cref="T:NCDK.CDKException"></exception>
            <param name="reactants">reactants of the reaction.</param>
            <param name="agents">agents of the reaction (Must be in this case null).</param>
        </member>
        <member name="T:NCDK.Reactions.Types.RadicalSiteInitiationReaction">
             <example>
             <code>
             var setOfReactants = ChemObjectBuilder.Instance.NewAtomContainerSet&lt;IAtomContainer&gt;();
             setOfReactants.Add(molecular);
             var type = new RadicalSiteInitiationReaction();
             IParameterReaction param = new SetReactionCenter();
             param.IsSetParameter = false;
             var paramList = new[] { param };
             type.ParameterList = paramList;
             IReactionSet setOfReactions = type.Initiate(setOfReactants, null);
              </code>
            
             <para>We have the possibility to localize the reactive center. Good method if you
             want to localize the reaction in a fixed point</para>
             <code>atoms[0].IsReactiveCenter = true;</code>
             <para>Moreover you must put the parameter true</para>
             <para>If the reactive center is not localized then the reaction process will
             try to find automatically the possible reactive center.</para>
             </example>
            <summary>
            <para>IReactionProcess which participate mass spectrum process. Homolitic dissocitation.
            This reaction could be represented as A-B-[c*] =&gt; [A*] + B=C.</para>
            <para>Make sure that the molecule has the corresponend lone pair electrons
            for each atom. You can use the method: <see cref="T:NCDK.Tools.LonePairElectronChecker"/></para>
            </summary>
            <seealso cref="T:NCDK.Reactions.Mechanisms.RadicalSiteIonizationMechanism"/>
        </member>
        <member name="P:NCDK.Reactions.Types.RadicalSiteInitiationReaction.Specification">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Reactions.Types.RadicalSiteInitiationReaction.Initiate(NCDK.IChemObjectSet{NCDK.IAtomContainer},NCDK.IChemObjectSet{NCDK.IAtomContainer})">
            <summary>
             Initiate process.
            </summary>
            <exception cref="T:NCDK.CDKException"></exception>
            <param name="reactants">reactants of the reaction.</param>
            <param name="agents">agents of the reaction (Must be in this case null).</param>
        </member>
        <member name="T:NCDK.Reactions.Types.RadicalSiteRrAlphaReaction">
             <example>
             <code>
             var setOfReactants = ChemObjectBuilder.Instance.NewAtomContainerSet&lt;IAtomContainer&gt;();
             setOfReactants.Add(molecular);
             var type = new RadicalSiteRrAlphaReaction();
             IParameterReaction param = new SetReactionCenter();
             param.IsSetParameter = false;
             var paramList = new[] { param };
             type.ParameterList = paramList;
             IReactionSet setOfReactions = type.Initiate(setOfReactants, null);
              </code>
            
             <para>We have the possibility to localize the reactive center. Good method if you
             want to localize the reaction in a fixed point</para>
             <code>atoms[0].IsReactiveCenter = true;</code>
             <para>Moreover you must put the parameter true</para>
             <para>If the reactive center is not localized then the reaction process will
             try to find automatically the possible reactive center.</para>
             </example>
            <summary>
            <para>This reaction could be represented as [A*]-(C)_2-C3[R] =&gt; A([RH])-(C_2)-[C3*]. Due to
            the single electron of atom A the R is moved.</para>
            </summary>
            <seealso cref="T:NCDK.Reactions.Mechanisms.RadicalSiteRearrangementMechanism"/>
        </member>
        <member name="P:NCDK.Reactions.Types.RadicalSiteRrAlphaReaction.Specification">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Reactions.Types.RadicalSiteRrAlphaReaction.Initiate(NCDK.IChemObjectSet{NCDK.IAtomContainer},NCDK.IChemObjectSet{NCDK.IAtomContainer})">
            <summary>
             Initiate process.
             It is needed to call the addExplicitHydrogensToSatisfyValency
             from the class tools.HydrogenAdder.
            </summary>
            <exception cref="T:NCDK.CDKException"> Description of the Exception</exception>
            <param name="reactants">reactants of the reaction.</param>
            <param name="agents">agents of the reaction (Must be in this case null).</param>
        </member>
        <member name="T:NCDK.Reactions.Types.RadicalSiteRrBetaReaction">
             <example>
             <code>
             var setOfReactants = ChemObjectBuilder.Instance.NewAtomContainerSet&lt;IAtomContainer&gt;();
             setOfReactants.Add(molecular);
             var type = new RadicalSiteRrBetaReaction();
             IParameterReaction param = new SetReactionCenter();
             param.IsSetParameter = false;
             var paramList = new[] { param };
             type.ParameterList = paramList;
             IReactionSet setOfReactions = type.Initiate(setOfReactants, null);
              </code>
            
             <para>We have the possibility to localize the reactive center. Good method if you
             want to localize the reaction in a fixed point</para>
             <code>atoms[0].IsReactiveCenter = true;</code>
             <para>Moreover you must put the parameter true</para>
             <para>If the reactive center is not localized then the reaction process will
             try to find automatically the possible reactive center.</para>
             </example>
            <summary>
            <para>This reaction could be represented as [A*]-(C)_3-C4[R] =&gt; A([R])-(C_3)-[C4*]. Due to
            the single electron of atom A the R is moved.</para>
            </summary>
            <seealso cref="T:NCDK.Reactions.Mechanisms.RadicalSiteRearrangementMechanism"/>
        </member>
        <member name="M:NCDK.Reactions.Types.RadicalSiteRrBetaReaction.#ctor">
            <summary>
            Constructor of the RadicalSiteRrBetaReaction object
            </summary>
        </member>
        <member name="P:NCDK.Reactions.Types.RadicalSiteRrBetaReaction.Specification">
            <summary>
             The specification attribute of the RadicalSiteRrBetaReaction object
            </summary>
        </member>
        <member name="M:NCDK.Reactions.Types.RadicalSiteRrBetaReaction.Initiate(NCDK.IChemObjectSet{NCDK.IAtomContainer},NCDK.IChemObjectSet{NCDK.IAtomContainer})">
            <summary>
             Initiate process.
             It is needed to call the addExplicitHydrogensToSatisfyValency
             from the class tools.HydrogenAdder.
            </summary>
            <exception cref="T:NCDK.CDKException"> Description of the Exception</exception>
            <param name="reactants">reactants of the reaction.</param>
            <param name="agents">agents of the reaction (Must be in this case null).</param>
        </member>
        <member name="T:NCDK.Reactions.Types.RadicalSiteRrDeltaReaction">
             <example>
             <code>
             var setOfReactants = ChemObjectBuilder.Instance.NewAtomContainerSet&lt;IAtomContainer&gt;();
             setOfReactants.Add(molecular);
             var type = new RadicalSiteRrDeltaReaction();
             IParameterReaction param = new SetReactionCenter();
             param.IsSetParameter = false;
             var paramList = new[] { param };
             type.ParameterList = paramList;
             IReactionSet setOfReactions = type.Initiate(setOfReactants, null);
              </code>
            
             <para>We have the possibility to localize the reactive center. Good method if you
             want to localize the reaction in a fixed point</para>
             <code>atoms[0].IsReactiveCenter = true;</code>
             <para>Moreover you must put the parameter true</para>
             <para>If the reactive center is not localized then the reaction process will
             try to find automatically the possible reactive center.</para>
             </example>
            <summary>
            <para>This reaction could be represented as [A*]-(C)_4-C5[R] =&gt; A([R])-(C_4)-[C5*]. Due to
            the single electron of atom A the R is moved.</para>
            </summary>
            <seealso cref="T:NCDK.Reactions.Mechanisms.RadicalSiteRearrangementMechanism"/>
        </member>
        <member name="P:NCDK.Reactions.Types.RadicalSiteRrDeltaReaction.Specification">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Reactions.Types.RadicalSiteRrDeltaReaction.Initiate(NCDK.IChemObjectSet{NCDK.IAtomContainer},NCDK.IChemObjectSet{NCDK.IAtomContainer})">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Reactions.Types.RadicalSiteRrGammaReaction">
             <example>
             <code>
             var setOfReactants = ChemObjectBuilder.Instance.NewAtomContainerSet&lt;IAtomContainer&gt;();
             setOfReactants.Add(molecular);
             var type = new RadicalSiteRrGammaReaction();
             IParameterReaction param = new SetReactionCenter();
             param.IsSetParameter = false;
             var paramList = new[] { param };
             type.ParameterList = paramList;
             IReactionSet setOfReactions = type.Initiate(setOfReactants, null);
              </code>
            
             <para>We have the possibility to localize the reactive center. Good method if you
             want to localize the reaction in a fixed point</para>
             <code>atoms[0].IsReactiveCenter = true;</code>
             <para>Moreover you must put the parameter true</para>
             <para>If the reactive center is not localized then the reaction process will
             try to find automatically the possible reactive center.</para>
             </example>
            <summary>
            <para>
            This reaction could be represented as [A*]-(C)_5-C6[R] =&gt; A([R])-(C_5)-[C6*]. Due to
            the single electron of atom A the R is moved.</para>
            </summary>
            <seealso cref="T:NCDK.Reactions.Mechanisms.RadicalSiteRearrangementMechanism"/>
        </member>
        <member name="P:NCDK.Reactions.Types.RadicalSiteRrGammaReaction.Specification">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Reactions.Types.RadicalSiteRrGammaReaction.Initiate(NCDK.IChemObjectSet{NCDK.IAtomContainer},NCDK.IChemObjectSet{NCDK.IAtomContainer})">
            <summary>
             Initiate process.
             It is needed to call the addExplicitHydrogensToSatisfyValency
             from the class tools.HydrogenAdder.
            </summary>
            <exception cref="T:NCDK.CDKException"> Description of the Exception</exception>
            <param name="reactants">reactants of the reaction.</param>
            <param name="agents">agents of the reaction (Must be in this case null).</param>
        </member>
        <member name="T:NCDK.Reactions.Types.RearrangementAnionReaction">
             <example>
             <code>
             var setOfReactants = ChemObjectBuilder.Instance.NewAtomContainerSet&lt;IAtomContainer&gt;();
             setOfReactants.Add(molecular);
             var type = new RearrangementAnionReaction();
             IParameterReaction param = new SetReactionCenter();
             param.IsSetParameter = false;
             var paramList = new[] { param };
             type.ParameterList = paramList;
             IReactionSet setOfReactions = type.Initiate(setOfReactants, null);
              </code>
            
             <para>We have the possibility to localize the reactive center. Good method if you
             want to localize the reaction in a fixed point</para>
             <code>atoms[0].IsReactiveCenter = true;</code>
             <para>Moreover you must put the parameter true</para>
             <para>If the reactive center is not localized then the reaction process will
             try to find automatically the possible reactive center.</para>
             </example>
            <summary>
            <para>IReactionProcess which participate in movement resonance.
            This reaction could be represented as [A-]-B=C =&gt; A=B-[C-]. Due to
            excess of charge of the atom B, the double bond in the position 2 is
            desplaced.</para>
            <para>
            Make sure that the molecule has the correspond lone pair electrons
            for each atom. You can use the method: <see cref="T:NCDK.Tools.LonePairElectronChecker"/></para>
            </summary>
            <seealso cref="T:NCDK.Reactions.Mechanisms.RearrangementChargeMechanism"/>
        </member>
        <member name="P:NCDK.Reactions.Types.RearrangementAnionReaction.Specification">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Reactions.Types.RearrangementAnionReaction.Initiate(NCDK.IChemObjectSet{NCDK.IAtomContainer},NCDK.IChemObjectSet{NCDK.IAtomContainer})">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Reactions.Types.RearrangementCationReaction">
             <example>
             <code>
             var setOfReactants = ChemObjectBuilder.Instance.NewAtomContainerSet&lt;IAtomContainer&gt;();
             setOfReactants.Add(molecular);
             var type = new RearrangementCationReaction();
             IParameterReaction param = new SetReactionCenter();
             param.IsSetParameter = false;
             var paramList = new[] { param };
             type.ParameterList = paramList;
             IReactionSet setOfReactions = type.Initiate(setOfReactants, null);
              </code>
            
             <para>We have the possibility to localize the reactive center. Good method if you
             want to localize the reaction in a fixed point</para>
             <code>atoms[0].IsReactiveCenter = true;</code>
             <para>Moreover you must put the parameter true</para>
             <para>If the reactive center is not localized then the reaction process will
             try to find automatically the possible reactive center.</para>
             </example>
            <summary>
            <para>IReactionProcess which participate in movement resonance.
            This reaction could be represented as [A+]-B=C =&gt; A=B-[c+]. Due to
            deficiency of charge of the atom A, the double bond is desplaced.</para>
            <para>Make sure that the molecule has the corresponend lone pair electrons
            for each atom. You can use the method: <see cref="T:NCDK.Tools.LonePairElectronChecker"/></para>
            </summary>
            <seealso cref="T:NCDK.Reactions.Mechanisms.RearrangementChargeMechanism"/>
        </member>
        <member name="P:NCDK.Reactions.Types.RearrangementCationReaction.Specification">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Reactions.Types.RearrangementCationReaction.Initiate(NCDK.IChemObjectSet{NCDK.IAtomContainer},NCDK.IChemObjectSet{NCDK.IAtomContainer})">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Reactions.Types.RearrangementLonePairReaction">
             <example>
             <code>
             var setOfReactants = ChemObjectBuilder.Instance.NewAtomContainerSet&lt;IAtomContainer&gt;();
             setOfReactants.Add(molecular);
             var type = new RearrangementLonePairReaction();
             IParameterReaction param = new SetReactionCenter();
             param.IsSetParameter = false;
             var paramList = new[] { param };
             type.ParameterList = paramList;
             IReactionSet setOfReactions = type.Initiate(setOfReactants, null);
              </code>
            
             <para>We have the possibility to localize the reactive center. Good method if you
             want to localize the reaction in a fixed point</para>
             <code>atoms[0].IsReactiveCenter = true;</code>
             <para>Moreover you must put the parameter true</para>
             <para>If the reactive center is not localized then the reaction process will
             try to find automatically the possible reactive center.</para>
             </example>
            <summary>
            <para>IReactionProcess which participate in movement resonance.
            This reaction could be represented as |A-B=C =&gt; [A+]=B-[C-]. Due to
            excess of charge of the atom B, the double bond in the position 2 is
            displaced.</para>
            <para>Make sure that the molecule has the correspond lone pair electrons
            for each atom. You can use the method: <see cref="T:NCDK.Tools.LonePairElectronChecker"/></para>
            </summary>
            <seealso cref="T:NCDK.Reactions.Mechanisms.RearrangementChargeMechanism"/>
        </member>
        <member name="P:NCDK.Reactions.Types.RearrangementLonePairReaction.Specification">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Reactions.Types.RearrangementLonePairReaction.Initiate(NCDK.IChemObjectSet{NCDK.IAtomContainer},NCDK.IChemObjectSet{NCDK.IAtomContainer})">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Reactions.Types.RearrangementRadicalReaction">
             <example>
             <code>
             var setOfReactants = ChemObjectBuilder.Instance.NewAtomContainerSet&lt;IAtomContainer&gt;();
             setOfReactants.Add(molecular);
             var type = new RearrangementRadicalReaction();
             IParameterReaction param = new SetReactionCenter();
             param.IsSetParameter = false;
             var paramList = new[] { param };
             type.ParameterList = paramList;
             IReactionSet setOfReactions = type.Initiate(setOfReactants, null);
              </code>
            
             <para>We have the possibility to localize the reactive center. Good method if you
             want to localize the reaction in a fixed point</para>
             <code>atoms[0].IsReactiveCenter = true;</code>
             <para>Moreover you must put the parameter true</para>
             <para>If the reactive center is not localized then the reaction process will
             try to find automatically the possible reactive center.</para>
             </example>
            <summary>
            <para>IReactionProcess which participate in movement resonance.
            This reaction could be represented as [A*]-B=C =&gt; A=B-[c*]. Due to
            excess of charge of the atom B, the single electron of the atom A is
            displaced through the double bond.</para>
            <para>Make sure that the molecule has the correspond lone pair electrons
            for each atom. You can use the method: <see cref="T:NCDK.Tools.LonePairElectronChecker"/></para>
            </summary>
            <seealso cref="T:NCDK.Reactions.Mechanisms.RearrangementChargeMechanism"/>
        </member>
        <member name="P:NCDK.Reactions.Types.RearrangementRadicalReaction.Specification">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Reactions.Types.RearrangementRadicalReaction.Initiate(NCDK.IChemObjectSet{NCDK.IAtomContainer},NCDK.IChemObjectSet{NCDK.IAtomContainer})">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Reactions.Types.SharingAnionReaction">
             <example>
             <code>
             var setOfReactants = ChemObjectBuilder.Instance.NewAtomContainerSet&lt;IAtomContainer&gt;();
             setOfReactants.Add(molecular);
             var type = new SharingAnionReaction();
             IParameterReaction param = new SetReactionCenter();
             param.IsSetParameter = false;
             var paramList = new[] { param };
             type.ParameterList = paramList;
             IReactionSet setOfReactions = type.Initiate(setOfReactants, null);
              </code>
            
             <para>We have the possibility to localize the reactive center. Good method if you
             want to localize the reaction in a fixed point</para>
             <code>atoms[0].IsReactiveCenter = true;</code>
             <para>Moreover you must put the parameter true</para>
             <para>If the reactive center is not localized then the reaction process will
             try to find automatically the possible reactive center.</para>
             </example>
            <summary>
            <para>IReactionProcess which participate in movement resonance.
            This reaction could be represented as [A+]-B| =&gt; A=[B+]. Due to
            deficiency of charge of the atom A, the lone pair electron of the atom A is
            desplaced.</para>
            <para>
            Make sure that the molecule has the correspond lone pair electrons
            for each atom. You can use the method: <see cref="T:NCDK.Tools.LonePairElectronChecker"/></para>
            </summary>
        </member>
        <member name="P:NCDK.Reactions.Types.SharingAnionReaction.Specification">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Reactions.Types.SharingAnionReaction.Initiate(NCDK.IChemObjectSet{NCDK.IAtomContainer},NCDK.IChemObjectSet{NCDK.IAtomContainer})">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Reactions.Types.SharingChargeDBReaction">
             <example>
             <code>
             var setOfReactants = ChemObjectBuilder.Instance.NewAtomContainerSet&lt;IAtomContainer&gt;();
             setOfReactants.Add(molecular);
             var type = new SharingChargeDBReaction();
             IParameterReaction param = new SetReactionCenter();
             param.IsSetParameter = false;
             var paramList = new[] { param };
             type.ParameterList = paramList;
             IReactionSet setOfReactions = type.Initiate(setOfReactants, null);
              </code>
            
             <para>We have the possibility to localize the reactive center. Good method if you
             want to localize the reaction in a fixed point</para>
             <code>atoms[0].IsReactiveCenter = true;</code>
             <para>Moreover you must put the parameter true</para>
             <para>If the reactive center is not localized then the reaction process will
             try to find automatically the possible reactive center.</para>
             </example>
            <summary>
            <para>IReactionProcess which participate in movement resonance.
            This reaction could be represented as [A+]=B =&gt; A|-[B+]. Due to
            deficiency of charge of the atom A, the double bond is displaced to atom A.
            Make sure that the molecule has the correspond lone pair electrons
            for each atom. You can use the method: <see cref="T:NCDK.Tools.LonePairElectronChecker"/></para>
            </summary>
            <seealso cref="T:NCDK.Reactions.Mechanisms.HeterolyticCleavageMechanism"/>
        </member>
        <member name="M:NCDK.Reactions.Types.SharingChargeDBReaction.#ctor">
            <summary>
            Constructor of the SharingChargeDBReaction object.
            </summary>
        </member>
        <member name="P:NCDK.Reactions.Types.SharingChargeDBReaction.Specification">
            <summary>
             Gets the specification attribute of the SharingChargeDBReaction object
            </summary>
            <returns>The specification value</returns>
        </member>
        <member name="M:NCDK.Reactions.Types.SharingChargeDBReaction.Initiate(NCDK.IChemObjectSet{NCDK.IAtomContainer},NCDK.IChemObjectSet{NCDK.IAtomContainer})">
            <summary>
             Initiate process.
             It is needed to call the addExplicitHydrogensToSatisfyValency
             from the class tools.HydrogenAdder.
            </summary>
            <param name="reactants">reactants of the reaction.</param>
            <param name="agents">agents of the reaction (Must be in this case null).</param>
            <exception cref="T:NCDK.CDKException"> Description of the Exception</exception>
        </member>
        <member name="M:NCDK.Reactions.Types.SharingChargeDBReaction.SetActiveCenters(NCDK.IAtomContainer)">
            <summary>
            set the active center for this molecule.
            The active center will be those which correspond with [A+]=B.
            <pre>
            A: Atom with positive charge
            =: Double bond
            B: Atom
             </pre>
            </summary>
            <param name="reactant">The molecule to set the activity</param>
        </member>
        <member name="T:NCDK.Reactions.Types.SharingChargeSBReaction">
             <example>
             <code>
             var setOfReactants = ChemObjectBuilder.Instance.NewAtomContainerSet&lt;IAtomContainer&gt;();
             setOfReactants.Add(molecular);
             var type = new SharingChargeSBReaction();
             IParameterReaction param = new SetReactionCenter();
             param.IsSetParameter = false;
             var paramList = new[] { param };
             type.ParameterList = paramList;
             IReactionSet setOfReactions = type.Initiate(setOfReactants, null);
              </code>
            
             <para>We have the possibility to localize the reactive center. Good method if you
             want to localize the reaction in a fixed point</para>
             <code>atoms[0].IsReactiveCenter = true;</code>
             <para>Moreover you must put the parameter true</para>
             <para>If the reactive center is not localized then the reaction process will
             try to find automatically the possible reactive center.</para>
             </example>
            <summary>
            <para>IReactionProcess which participate in movement resonance.
            This reaction could be represented as [A+]-B =&gt; A| + [B+]. Due to
            deficiency of charge of the atom A, the double bond is displaced to atom A.
            Make sure that the molecule has the correspond lone pair electrons
            for each atom. You can use the method: <see cref="T:NCDK.Tools.LonePairElectronChecker"/></para>
            </summary>
            <seealso cref="T:NCDK.Reactions.Mechanisms.HeterolyticCleavageMechanism"/>
        </member>
        <member name="M:NCDK.Reactions.Types.SharingChargeSBReaction.#ctor">
            <summary>
            Constructor of the SharingChargeSBReaction object.
            </summary>
        </member>
        <member name="P:NCDK.Reactions.Types.SharingChargeSBReaction.Specification">
            <summary>
             Gets the specification attribute of the SharingChargeSBReaction object
            </summary>
            <returns>The specification value</returns>
        </member>
        <member name="M:NCDK.Reactions.Types.SharingChargeSBReaction.Initiate(NCDK.IChemObjectSet{NCDK.IAtomContainer},NCDK.IChemObjectSet{NCDK.IAtomContainer})">
            <summary>
             Initiate process.
             It is needed to call the addExplicitHydrogensToSatisfyValency
             from the class tools.HydrogenAdder.
            </summary>
            <param name="reactants">reactants of the reaction.</param>
            <param name="agents">agents of the reaction (Must be in this case null).</param>
            <exception cref="T:NCDK.CDKException"></exception>
        </member>
        <member name="M:NCDK.Reactions.Types.SharingChargeSBReaction.SetActiveCenters(NCDK.IAtomContainer)">
            <summary>
            set the active center for this molecule.
            The active center will be those which correspond with [A+]-B.
            <pre>
            A: Atom with positive charge
            -: single bond
            B: Atom
             </pre>
            </summary>
            <param name="reactant">The molecule to set the activity</param>
        </member>
        <member name="T:NCDK.Reactions.Types.SharingLonePairReaction">
             <example>
             <code>
             var setOfReactants = ChemObjectBuilder.Instance.NewAtomContainerSet&lt;IAtomContainer&gt;();
             setOfReactants.Add(molecular);
             var type = new SharingLonePairReaction();
             IParameterReaction param = new SetReactionCenter();
             param.IsSetParameter = false;
             var paramList = new[] { param };
             type.ParameterList = paramList;
             IReactionSet setOfReactions = type.Initiate(setOfReactants, null);
              </code>
            
             <para>We have the possibility to localize the reactive center. Good method if you
             want to localize the reaction in a fixed point</para>
             <code>atoms[0].IsReactiveCenter = true;</code>
             <para>Moreover you must put the parameter true</para>
             <para>If the reactive center is not localized then the reaction process will
             try to find automatically the possible reactive center.</para>
             </example>
            <summary>
            <para>IReactionProcess which participate in movement resonance.
            This reaction could be represented as [A+]-B| =&gt; A=[B+]. Due to
            deficiency of charge of the atom A, the lone pair electron of the atom A is
            desplaced.</para>
            <para>Make sure that the molecule has the correspond lone pair electrons
            for each atom. You can use the method: <see cref="T:NCDK.Tools.LonePairElectronChecker"/></para>
            </summary>
        </member>
        <member name="P:NCDK.Reactions.Types.SharingLonePairReaction.Specification">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Reactions.Types.SharingLonePairReaction.Initiate(NCDK.IChemObjectSet{NCDK.IAtomContainer},NCDK.IChemObjectSet{NCDK.IAtomContainer})">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Reactions.Types.TautomerizationReaction">
             <example>
             <code>
             var setOfReactants = ChemObjectBuilder.Instance.NewAtomContainerSet&lt;IAtomContainer&gt;();
             setOfReactants.Add(molecular);
             var type = new TautomerizationReaction();
             IParameterReaction param = new SetReactionCenter();
             param.IsSetParameter = false;
             var paramList = new[] { param };
             type.ParameterList = paramList;
             IReactionSet setOfReactions = type.Initiate(setOfReactants, null);
              </code>
            
             <para>We have the possibility to localize the reactive center. Good method if you
             want to localize the reaction in a fixed point</para>
             <code>atoms[0].IsReactiveCenter = true;</code>
             <para>Moreover you must put the parameter true</para>
             <para>If the reactive center is not localized then the reaction process will
             try to find automatically the possible reactive center.</para>
             </example>
            <summary>
            <para>IReactionProcess which produces a tautomerization chemical reaction.
            As most commonly encountered, this reaction results in the formal migration
            of a hydrogen atom or proton, accompanied by a switch of a single bond and adjacent double bond</para>
            <pre>X=Y-Z-H =&gt; X(H)-Y=Z</pre>
            </summary>
            <seealso cref="T:NCDK.Reactions.Mechanisms.TautomerizationMechanism"/>
        </member>
        <member name="P:NCDK.Reactions.Types.TautomerizationReaction.Specification">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Reactions.Types.TautomerizationReaction.Initiate(NCDK.IChemObjectSet{NCDK.IAtomContainer},NCDK.IChemObjectSet{NCDK.IAtomContainer})">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Reactions.Types.TautomerizationReaction.SetActiveCenters(NCDK.IAtomContainer)">
            <summary>
            set the active center for this molecule.
            The active center will be those which correspond with X=Y-Z-H.
            <pre>
            X: Atom
            =: bond
            Y: Atom
            -: bond
            Z: Atom
            -: bond
            H: Atom
             </pre>
            </summary>
            <param name="reactant">The molecule to set the activity</param>
        </member>
        <member name="T:NCDK.Reactions.Types.Parameters.IParameterReaction">
            <summary>
            Interface for classes that generate parameters used in reactions.
            </summary>
        </member>
        <member name="P:NCDK.Reactions.Types.Parameters.IParameterReaction.IsSetParameter">
            <summary>
            This parameter needs to take account or not.
            </summary>
            <value><see langword="true"/>, if the parameter needs to take account</value>
        </member>
        <member name="P:NCDK.Reactions.Types.Parameters.IParameterReaction.Value">
            <summary>
            The value of the parameter.
            </summary>
        </member>
        <member name="T:NCDK.Reactions.Types.Parameters.ParameterReaction">
            <summary>
            Class which defines the allowed parameters of a reaction.
            </summary>
        </member>
        <member name="P:NCDK.Reactions.Types.Parameters.ParameterReaction.IsSetParameter">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.Reactions.Types.Parameters.ParameterReaction.Value">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Reactions.Types.Parameters.SetReactionCenter">
            <summary>
            Class extension of ParameterReact class which defines if a reaction is set already the reaction center
            in the reactants.
            </summary>
        </member>
        <member name="T:NCDK.Reactions.IReactionMechanism">
            <summary>
            Classes that implement this interface are reaction mechanisms.
            </summary>
        </member>
        <member name="M:NCDK.Reactions.IReactionMechanism.Initiate(NCDK.IChemObjectSet{NCDK.IAtomContainer},System.Collections.Generic.IList{NCDK.IAtom},System.Collections.Generic.IList{NCDK.IBond})">
            <summary>
            Initiates the process for the given mechanism. The atoms to apply are mapped between
            reactants and products.
            </summary>
            <param name="atomContainerSet"></param>
            <param name="atomList">The list of atoms taking part in the mechanism</param>
            <param name="bondList">The list of bonds taking part in the mechanism</param>
            <returns>The Reaction mechanism</returns>
            <exception cref="T:NCDK.CDKException">if an error occurs during the reaction process. See documentation for individual reaction processes</exception>
        </member>
        <member name="T:NCDK.Reactions.IReactionProcess">
            <summary>
            Classes that implement this interface are Reactions types.
            </summary>
        </member>
        <member name="P:NCDK.Reactions.IReactionProcess.Specification">
            <summary>
             The specification attribute of this object
            </summary>
            <returns>The specification value</returns>
        </member>
        <member name="P:NCDK.Reactions.IReactionProcess.ParameterList">
            <summary>
            the parameters for this reaction.
            </summary>
            <remarks>Must be done before calling calculate as the parameters influence the calculation outcome.</remarks>
        </member>
        <member name="M:NCDK.Reactions.IReactionProcess.Initiate(NCDK.IChemObjectSet{NCDK.IAtomContainer},NCDK.IChemObjectSet{NCDK.IAtomContainer})">
            <summary>
            Initiates the process for the given reaction.
            Optionally, parameters may be set which can affect the course of the process.
            </summary>
            <param name="reactants">An <see cref="T:NCDK.IAtomContainerSet"/> for which this process should be initiate.</param>
            <param name="agents">An <see cref="T:NCDK.IAtomContainerSet"/> for which this process should be initiate.</param>
            <returns>The set of reactions.</returns>
            <exception cref="T:NCDK.CDKException">if an error occurs during the reaction process. See documentation for individual reaction processes</exception>
        </member>
        <member name="M:NCDK.Reactions.IReactionProcess.GetParameterClass(System.Type)">
            <summary>
            Return the <see cref="T:NCDK.Reactions.Types.Parameters.IParameterReaction"/> if it exists given the class.
            </summary>
            <param name="paramClass"></param>
            <returns></returns>
        </member>
        <member name="T:NCDK.Reactions.Mechanisms.AdductionLPMechanism">
            <summary>
            <para>This mechanism adduct together two fragments. The second fragment will be deficient in charge.
            It returns the reaction mechanism which has been cloned the <see cref="T:NCDK.IAtomContainer"/>.</para>
            <para>This reaction could be represented as A + [B+] =&gt; A-B</para>
            </summary>
        </member>
        <member name="M:NCDK.Reactions.Mechanisms.AdductionLPMechanism.Initiate(NCDK.IChemObjectSet{NCDK.IAtomContainer},System.Collections.Generic.IList{NCDK.IAtom},System.Collections.Generic.IList{NCDK.IBond})">
            <summary>
            Initiates the process for the given mechanism. The atoms and bonds to apply are mapped between
            reactants and products.
            </summary>
            <param name="atomContainerSet"></param>
            <param name="atomList">The list of atoms taking part in the mechanism. Only allowed two atoms.</param>
            <param name="bondList">The list of bonds taking part in the mechanism. not allowed bonds.</param>
            <returns>The Reaction mechanism</returns>
        </member>
        <member name="T:NCDK.Reactions.Mechanisms.AdductionPBMechanism">
            <summary>
            <para>This mechanism adduct together two fragments due to a double bond.
            The second fragment will be deficient in charge.
            It returns the reaction mechanism which has been cloned the <see cref="T:NCDK.IAtomContainer"/>.</para>
            <para>This reaction could be represented as A=B + [C+] ==&gt; [A+]-B-C</para>
            </summary>
        </member>
        <member name="M:NCDK.Reactions.Mechanisms.AdductionPBMechanism.Initiate(NCDK.IChemObjectSet{NCDK.IAtomContainer},System.Collections.Generic.IList{NCDK.IAtom},System.Collections.Generic.IList{NCDK.IBond})">
            <summary>
            Initiates the process for the given mechanism. The atoms and bonds to apply are mapped between
            reactants and products.
            </summary>
            <param name="atomContainerSet"></param>
            <param name="atomList">The list of atoms taking part in the mechanism. Only allowed three atoms</param>
            <param name="bondList">The list of bonds taking part in the mechanism. Only allowed one bond</param>
            <returns>The Reaction mechanism</returns>
        </member>
        <member name="T:NCDK.Reactions.Mechanisms.HeterolyticCleavageMechanism">
            <summary>
            This mechanism displaces the chemical bond to an Atom. Generating one with
            excess charge and the other with deficiency.
            It returns the reaction mechanism which has been cloned the IAtomContainer.
            </summary>
        </member>
        <member name="M:NCDK.Reactions.Mechanisms.HeterolyticCleavageMechanism.Initiate(NCDK.IChemObjectSet{NCDK.IAtomContainer},System.Collections.Generic.IList{NCDK.IAtom},System.Collections.Generic.IList{NCDK.IBond})">
            <summary>
            Initiates the process for the given mechanism. The atoms to apply are mapped between
            reactants and products.
            </summary>
            <param name="atomContainerSet"></param>
            <param name="atomList">The list of atoms taking part in the mechanism. Only allowed two atoms.
                               The first atom receives the positive charge charge and the second
                               negative charge</param>
            <param name="bondList">The list of bonds taking part in the mechanism. Only allowed one bond</param>
            <returns>The Reaction mechanism</returns>
        </member>
        <member name="T:NCDK.Reactions.Mechanisms.HomolyticCleavageMechanism">
            <summary>
            This mechanism breaks the chemical bond between atoms. Generating two atoms with
            attached radicals.
            It returns the reaction mechanism which has been cloned the <see cref="T:NCDK.IAtomContainer"/>.
            </summary>
        </member>
        <member name="M:NCDK.Reactions.Mechanisms.HomolyticCleavageMechanism.Initiate(NCDK.IChemObjectSet{NCDK.IAtomContainer},System.Collections.Generic.IList{NCDK.IAtom},System.Collections.Generic.IList{NCDK.IBond})">
            <summary>
            Initiates the process for the given mechanism. The atoms to apply are mapped between
            reactants and products.
            </summary>
            <param name="atomContainerSet"></param>
            <param name="atomList">The list of atoms taking part in the mechanism. Only allowed two atoms. Both atoms acquire a ISingleElectron</param>
            <param name="bondList">The list of bonds taking part in the mechanism. Only allowed one bond</param>
            <returns>The Reaction mechanism</returns>
        </member>
        <member name="T:NCDK.Reactions.Mechanisms.RadicalSiteIonizationMechanism">
            <summary>
            <para>This mechanism extracts an atom because of the stabilization of a radical.
            It returns the reaction mechanism which has been cloned the IAtomContainer.</para>
            <para>This reaction could be represented as Y-B-[C*] =&gt; [Y*] + B=C</para>
            </summary>
        </member>
        <member name="M:NCDK.Reactions.Mechanisms.RadicalSiteIonizationMechanism.Initiate(NCDK.IChemObjectSet{NCDK.IAtomContainer},System.Collections.Generic.IList{NCDK.IAtom},System.Collections.Generic.IList{NCDK.IBond})">
            <summary>
            Initiates the process for the given mechanism. The atoms to apply are mapped between
            reactants and products.
            </summary>
            <param name="atomContainerSet"></param>
            <param name="atomList">
            The list of atoms taking part in the mechanism. Only allowed two atoms.
                               The first atom is the atom which contains the ISingleElectron and the second
                               third is the atom which will be removed
                               the first atom</param>
            <param name="bondList">The list of bonds taking part in the mechanism. Only allowed one bond.
                                  It is the bond which is moved</param>
            <returns>The Reaction mechanism</returns>
        </member>
        <member name="T:NCDK.Reactions.Mechanisms.RadicalSiteRearrangementMechanism">
            <summary>
            <para>This mechanism displaces an Atom or substructure (R) from one position to an other.
            It returns the reaction mechanism which has been cloned the <see cref="T:NCDK.IAtomContainer"/>.</para>
            <para>This reaction could be represented as [A*]-(X)_n-Y-Z =&gt; A(Z)-(X)_n-[Y*]</para>
            </summary>
        </member>
        <member name="M:NCDK.Reactions.Mechanisms.RadicalSiteRearrangementMechanism.Initiate(NCDK.IChemObjectSet{NCDK.IAtomContainer},System.Collections.Generic.IList{NCDK.IAtom},System.Collections.Generic.IList{NCDK.IBond})">
            <summary>
            Initiates the process for the given mechanism. The atoms to apply are mapped between
            reactants and products.
            </summary>
            <param name="atomContainerSet"></param>
            <param name="atomList">
            The list of atoms taking part in the mechanism. Only allowed two atoms.
                               The first atom is the atom which must be moved and the second
                               is the atom which receives the atom1 and the third is the atom which loss
                               the first atom</param>
            <param name="bondList">The list of bonds taking part in the mechanism. Only allowed one bond.
                                  It is the bond which is moved</param>
            <returns>The Reaction mechanism</returns>
        </member>
        <member name="T:NCDK.Reactions.Mechanisms.RearrangementChargeMechanism">
            <summary>
            <para>This mechanism displaces the Charge(radical, charge + or charge -) because of
            a double bond which is associated.
            It returns the reaction mechanism which has been cloned the <see cref="T:NCDK.IAtomContainer"/>.</para>
            <para>This reaction could be represented as [A*]-Y=Z =&gt; A=Z-[Y*]</para>
            </summary>
        </member>
        <member name="M:NCDK.Reactions.Mechanisms.RearrangementChargeMechanism.Initiate(NCDK.IChemObjectSet{NCDK.IAtomContainer},System.Collections.Generic.IList{NCDK.IAtom},System.Collections.Generic.IList{NCDK.IBond})">
            <summary>
            Initiates the process for the given mechanism. The atoms to apply are mapped between
            reactants and products.
            </summary>
            <param name="atomContainerSet"></param>
            <param name="atomList">The list of atoms taking part in the mechanism. Only allowed two three.
                               The first atom is the atom which must contain the charge to be moved, the second
                               is the atom which is in the middle and the third is the atom which acquires the new charge
            <param name="bondList">The list of bonds taking part in the mechanism. Only allowed two bond.</param>
                                  The first bond is the bond to increase the order and the second is the bond
                                  to decrease the order
                                  It is the bond which is moved</param>
            <returns>The Reaction mechanism</returns>
        </member>
        <member name="T:NCDK.Reactions.Mechanisms.RemovingSEofBMechanism">
            <summary>
            This mechanism extracts a single electron from a bonding orbital which located in
            an bond. It could have single, double as triple order. It returns the
            reaction mechanism which has been cloned the <see cref="T:NCDK.IAtomContainer"/> with a decrease
            of the order of the bond and a ISingleElectron more.
            </summary>
        </member>
        <member name="M:NCDK.Reactions.Mechanisms.RemovingSEofBMechanism.Initiate(NCDK.IChemObjectSet{NCDK.IAtomContainer},System.Collections.Generic.IList{NCDK.IAtom},System.Collections.Generic.IList{NCDK.IBond})">
            <summary>
            Initiates the process for the given mechanism. The atoms to apply are mapped between
            reactants and products.
            </summary>
            <param name="atomContainerSet"></param>
            <param name="atomList">The list of atoms taking part in the mechanism. Only allowed two atoms. The first atom receives the charge and the second the single electron</param>
            <param name="bondList">The list of bonds taking part in the mechanism. Only allowed one bond</param>
            <returns>The Reaction mechanism</returns>
        </member>
        <member name="T:NCDK.Reactions.Mechanisms.RemovingSEofNBMechanism">
             This mechanism extracts a single electron from a non-bonding orbital which located in
             a ILonePair container. It returns the reaction mechanism which has been cloned the
             <see cref="T:NCDK.IAtomContainer"/> with an ILonPair electron less and an ISingleElectron more.
            
             @author         miguelrojasch
             @cdk.created    2008-02-10
             @cdk.module     reaction
             @cdk.githash
        </member>
        <member name="M:NCDK.Reactions.Mechanisms.RemovingSEofNBMechanism.Initiate(NCDK.IChemObjectSet{NCDK.IAtomContainer},System.Collections.Generic.IList{NCDK.IAtom},System.Collections.Generic.IList{NCDK.IBond})">
             Initiates the process for the given mechanism. The atoms to apply are mapped between
             reactants and products.
            
            
             @param atomContainerSet
             @param atomList    The list of atoms taking part in the mechanism. Only allowed one atom
             @param bondList    The list of bonds taking part in the mechanism. Only allowed one Bond
             @return            The Reaction mechanism
            
        </member>
        <member name="T:NCDK.Reactions.Mechanisms.SharingElectronMechanism">
            <summary>
            <para>This mechanism displaces the charge (lonePair) because of
            deficiency of charge.
            It returns the reaction mechanism which has been cloned the <see cref="T:NCDK.IAtomContainer"/>.</para>
            <para>This reaction could be represented as [A*]-B| =&gt; A=[B*]</para>
            </summary>
        </member>
        <member name="M:NCDK.Reactions.Mechanisms.SharingElectronMechanism.Initiate(NCDK.IChemObjectSet{NCDK.IAtomContainer},System.Collections.Generic.IList{NCDK.IAtom},System.Collections.Generic.IList{NCDK.IBond})">
            <summary>
            Initiates the process for the given mechanism. The atoms to apply are mapped between
            reactants and products.
            </summary>
            <param name="atomContainerSet"></param>
            <param name="atomList"> The list of atoms taking part in the mechanism. Only allowed two atoms</param>
            <param name="bondList">The list of bonds taking part in the mechanism. Only allowed one bond</param>
            <returns>The Reaction mechanism</returns>
        </member>
        <member name="T:NCDK.Reactions.Mechanisms.TautomerizationMechanism">
            <summary>
            <para>This mechanism produces the tautomerization chemical reaction between two tautomers.
            It returns the reaction mechanism which has been cloned the <see cref="T:NCDK.IAtomContainer"/>.</para>
            <para>This reaction could be represented as X=Y-Z-H =&gt; X(H)-Y=Z</para>
            </summary>
        </member>
        <member name="M:NCDK.Reactions.Mechanisms.TautomerizationMechanism.Initiate(NCDK.IChemObjectSet{NCDK.IAtomContainer},System.Collections.Generic.IList{NCDK.IAtom},System.Collections.Generic.IList{NCDK.IBond})">
            <summary>
            Initiates the process for the given mechanism. The atoms and bonds to apply are mapped between
            reactants and products.
            </summary>
            <param name="atomContainerSet"></param>
            <param name="atomList">The list of atoms taking part in the mechanism. Only allowed fourth atoms.</param>
            <param name="bondList">The list of bonds taking part in the mechanism. Only allowed two bond.
                The first bond is the bond to decrease the order and the second is the bond to increase the order.
                It is the bond which is moved</param>
            <returns>The Reaction mechanism</returns>
        </member>
        <member name="T:NCDK.Reactions.ReactionEngine">
            <summary>
            The base class for all chemical reactions objects in this cdk.
            It provides methods for adding parameters
            </summary>
        </member>
        <member name="M:NCDK.Reactions.ReactionEngine.#ctor">
            <summary>
            Constructor of the ReactionEngine object.
            </summary>
        </member>
        <member name="M:NCDK.Reactions.ReactionEngine.ExtractMechanism(NCDK.Dict.EntryReact)">
            <summary>
            Extract the mechanism necessary for this reaction.
            </summary>
            <param name="entry">The EntryReact object</param>
        </member>
        <member name="M:NCDK.Reactions.ReactionEngine.InitiateDictionary(System.String,NCDK.Reactions.IReactionProcess)">
            <summary>
            Open the Dictionary OWLReact.
            </summary>
            <param name="nameDict">Name of the Dictionary</param>
            <param name="reaction">The IReactionProcess</param>
            <returns>The entry for this reaction</returns>
        </member>
        <member name="M:NCDK.Reactions.ReactionEngine.InitiateParameterMap2(NCDK.Dict.EntryReact)">
            <summary>
            Creates a map with the name and type of the parameters.
            </summary>
        </member>
        <member name="P:NCDK.Reactions.ReactionEngine.ParameterList">
            <summary>
            The current parameter IDictionary for this reaction.
            </summary>
            <remarks>Must be done before calling calculate as the parameters influence the calculation outcome.</remarks>
        </member>
        <member name="M:NCDK.Reactions.ReactionEngine.GetParameterClass(System.Type)">
            <summary>
            Return the IParameterReact if it exists given the class.
            </summary>
            <param name="paramClass">The class</param>
            <returns>The IParameterReact</returns>
        </member>
        <member name="T:NCDK.Reactions.ReactionSpecification">
            <summary>
            Class that is used to distribute reactions specifications.
            </summary>
        </member>
        <member name="M:NCDK.Reactions.ReactionSpecification.#ctor(System.String,System.String,System.String,System.String)">
            <summary>
            Container for specifying the type of reaction.
            </summary>
            <param name="specificationReference">Reference to a formal definition in a
                     dictionary (e.g. in STMML format) of the descriptor, preferably
                     refering to the original article. The format of the content is
                     expected to be &lt;dictionaryNameSpace&gt;:&lt;entryID&gt;.</param>
            <param name="implementationTitle">Title for the reaction process.</param>
            <param name="implementationIdentifier">Unique identifier for the actual
                     implementation, preferably including the exact version number of
                     the source code. E.g. $Id$ can be used when the source code is
                     in a CVS repository.</param>
            <param name="implementationVendor">Name of the organisation/person/program/whatever
                     who wrote/packaged the implementation.</param>
        </member>
        <member name="T:NCDK.SMARTS.SmartsFragmentExtractor">
            <summary>
            Utility class to create SMARTS that match part (substructure) of a molecule.
            SMARTS are generated by providing the atom indexes. An example use cases is
            encoding features from a fingerprint.
            </summary>
            <remarks>
            <para>
            The extractor has two modes. <see cref="F:NCDK.SMARTS.SmartsFragmentExtractor.MODE_EXACT"/> (default) captures the element,
            valence, hydrogen count, connectivity, and charge in the SMARTS atom expressions.
            The alternative mode, <see cref="F:NCDK.SMARTS.SmartsFragmentExtractor.MODE_JCOMPOUNDMAPPER"/>, only captures the element,
            non-zero charge, and peripheral bonds. Although the later looks cleaner, the
            peripheral bonds intend to capture the connectivity of the terminal atoms but
            since the valence is not bounded further substitution is still allowed. This
            mirrors functionality from jCompoundMapper <token>cdk-cite-Hinselmann2011</token>.
            </para>
            <para>
            The difference is easily demonstrated for methyl. Consider the compound
            of 2-methylpentane <pre>CC(C)CCC</pre>, if we extract one of the methyl atoms
            depending on the mode we obtain <pre>[CH3v4X4+0]</pre> or <pre>C*</pre>. The first
            of these patterns (obtained by <see cref="F:NCDK.SMARTS.SmartsFragmentExtractor.MODE_EXACT"/>) matches the compound in
            <b>three places</b> (the three methyl groups). The second matches <b>six</b>
            times (every atom) because the substituion on the carbon is not locked.
            A further complication is introduced by the inclusion of the peripheral atoms,
            for 1H-indole <pre>[nH]1ccc2c1cccc2</pre> we can obtain the SMARTS <pre>n(ccc(a)a)a</pre>
            that doesn't match at all. This is because one of the aromatic atoms ('a')
            needs to match the nitrogen.
            </para>
            </remarks>
            <example>
            <code>
            IChemObjectBuilder      bldr      = SilentChemObjectBuilder.getInstance();
            SmilesParser            smipar    = new SmilesParser(bldr);
            
            IAtomContainer          mol       = smipar.parseSmiles("[nH]1ccc2c1cccc2");
            SmartsFragmentExtractor subsmarts = new SmartsFragmentExtractor(mol);
            
            // smarts=[nH1v3X3+0][cH1v4X3+0][cH1v4X3+0][cH0v4X3+0]
            // hits  =1
            String             smarts    = mol.generate(new int[]{0,1,3,4});
            
            subsmarts.setMode(MODE_JCOMPOUNDMAPPER);
            // smarts=n(ccc(a)a)a
            // hits  = 0 - one of the 'a' atoms needs to match the nitrogen
            String             smarts    = mol.generate(new int[]{0,1,3,4});
            </code>
            </example>
        </member>
        <member name="F:NCDK.SMARTS.SmartsFragmentExtractor.MODE_JCOMPOUNDMAPPER">
            <summary>
            Sets the mode of the extractor to produce SMARTS similar to JCompoundMapper.
            </summary>
        </member>
        <member name="F:NCDK.SMARTS.SmartsFragmentExtractor.MODE_EXACT">
            <summary>
            Sets the mode of the extractor to produce exact SMARTS.
            </summary>
        </member>
        <member name="M:NCDK.SMARTS.SmartsFragmentExtractor.#ctor(NCDK.IAtomContainer)">
            <summary>
            Create a new instance over the provided molecule.
            </summary>
            <param name="mol">molecule</param>
        </member>
        <member name="M:NCDK.SMARTS.SmartsFragmentExtractor.SetMode(System.Int32)">
            <summary>
            Set the mode of SMARTS substructure selection
            </summary>
            <param name="mode">the mode</param>
        </member>
        <member name="M:NCDK.SMARTS.SmartsFragmentExtractor.Generate(System.Int32[])">
            <summary>
            Generate a SMARTS for the substructure formed of the provided
            atoms.
            </summary>
            <param name="atomIdxs">atom indexes</param>
            <returns>SMARTS, null if an empty array is passed</returns>
        </member>
        <member name="M:NCDK.SMARTS.SmartsFragmentExtractor.MarkRings(System.Int32,System.Int32)">
            <summary>
            Recursively marks ring closures (back edges) in the <see cref="F:NCDK.SMARTS.SmartsFragmentExtractor.rbnds"/>
            array in a depth first order.
            </summary>
            <param name="idx">atom index</param>
            <param name="bprev">previous bond</param>
        </member>
        <member name="M:NCDK.SMARTS.SmartsFragmentExtractor.EncodeExpr(System.Int32,System.Int32,System.Text.StringBuilder)">
            <summary>
            Recursively encodes a SMARTS expression into the provides
            string builder.
            </summary>
            <param name="idx">atom index</param>
            <param name="bprev">previous bond</param>
            <param name="sb">destition to write SMARTS to</param>
        </member>
        <member name="M:NCDK.SMARTS.SmartsFragmentExtractor.ChooseRingNumber">
            <summary>
            Select the lowest ring number for use in SMARTS.
            </summary>
            <returns>ring number</returns>
            <exception cref="T:System.InvalidOperationException">all ring numbers are used</exception>
        </member>
        <member name="M:NCDK.SMARTS.SmartsFragmentExtractor.ReleaseRingNumber(System.Int32)">
            <summary>
            Releases a ring number allowing it to be reused.
            </summary>
            <param name="rnum">ring number</param>
        </member>
        <member name="M:NCDK.SMARTS.SmartsFragmentExtractor.EncodeAtomExpr(System.Int32)">
            <summary>
            Encodes the atom at index (atmIdx) to a SMARTS
            expression that matches itself.
            </summary>
            <param name="atmIdx">atom index</param>
            <returns>SMARTS atom expression</returns>
        </member>
        <member name="M:NCDK.SMARTS.SmartsFragmentExtractor.EncodeBondExpr(System.Int32,System.Int32,System.Int32)">
            <summary>
            Encodes the bond at index (bondIdx) to a SMARTS
            expression that matches itself.
            </summary>
            <param name="bondIdx">bond index</param>
            <param name="beg">atom index of first atom</param>
            <param name="end">atom index of second atom</param>
            <returns>SMARTS bond expression</returns>
        </member>
        <member name="T:NCDK.Templates.IsoAlkanes">
            <summary>
            This class contains methods for generating simple organic alkanes.
            </summary>
        </member>
        <member name="T:NCDK.Templates.AminoAcids">
            <summary>
            Tool that provides templates for the (natural) amino acids.
            </summary>
        </member>
        <member name="M:NCDK.Templates.AminoAcids.CreateAABondInfo">
            <summary>
            Creates matrix with info about the bonds in the amino acids.
            0 = bond id, 1 = atom1 in bond, 2 = atom2 in bond, 3 = bond order.
            </summary>
            <returns>info</returns>
        </member>
        <member name="M:NCDK.Templates.AminoAcids.CreateAAs">
            <summary>
            Creates amino acid AminoAcid objects.
            </summary>
            <returns>aminoAcids, a Dictionary containing the amino acids as AminoAcids.</returns>
        </member>
        <member name="M:NCDK.Templates.AminoAcids.GetHashMapBySingleCharCode">
            <summary>
            Returns a Dictionary where the key is one of G, A, V, L, I, S, T, C, M, D,
            N, E, Q, R, K, H, F, Y, W and P.
            </summary>
        </member>
        <member name="M:NCDK.Templates.AminoAcids.GetHashMapByThreeLetterCode">
            <summary>
            Returns a Dictionary where the key is one of GLY, ALA, VAL, LEU, ILE, SER,
            THR, CYS, MET, ASP, ASN, GLU, GLN, ARG, LYS, HIS, PHE, TYR, TRP AND PRO.
            </summary>
        </member>
        <member name="M:NCDK.Templates.AminoAcids.ConvertThreeLetterCodeToOneLetterCode(System.String)">
            <summary>
            Returns the one letter code of an amino acid given a three letter code.
            For example, it will return "V" when "Val" was passed.
            </summary>
        </member>
        <member name="M:NCDK.Templates.AminoAcids.ConvertOneLetterCodeToThreeLetterCode(System.String)">
            <summary>
            Returns the three letter code of an amino acid given a one letter code.
            For example, it will return "Val" when "V" was passed.
            </summary>
        </member>
        <member name="T:NCDK.NInChI.INCHI_BOND_STEREO">
            <summary>
            Enumeration of InChI 2D stereo definitions.
            Corresponds to <tt>inchi_BondStereo2D</tt> in <tt>inchi_api.h</tt>.
            </summary>
        </member>
        <member name="F:NCDK.NInChI.INCHI_BOND_STEREO.None">
            <summary>
            No 2D stereo definition recorded.
            </summary>
        </member>
        <member name="F:NCDK.NInChI.INCHI_BOND_STEREO.Single1Up">
            <summary>
            Stereocenter-related; positive: the sharp end points to this atom.
            </summary>
        </member>
        <member name="F:NCDK.NInChI.INCHI_BOND_STEREO.Single1Either">
            <summary>
            Stereocenter-related; positive: the sharp end points to this atom.
            </summary>
        </member>
        <member name="F:NCDK.NInChI.INCHI_BOND_STEREO.Single1Down">
            <summary>
            Stereocenter-related; positive: the sharp end points to this atom.
            </summary>
        </member>
        <member name="F:NCDK.NInChI.INCHI_BOND_STEREO.Single2Up">
            <summary>
            Stereocenter-related; negative: the sharp end points to the opposite atom.
            </summary>
        </member>
        <member name="F:NCDK.NInChI.INCHI_BOND_STEREO.Single2Either">
            <summary>
            Stereocenter-related; negative: the sharp end points to the opposite atom.
            </summary>
        </member>
        <member name="F:NCDK.NInChI.INCHI_BOND_STEREO.Single2Down">
            <summary>
            Stereocenter-related; negative: the sharp end points to the opposite atom.
            </summary>
        </member>
        <member name="F:NCDK.NInChI.INCHI_BOND_STEREO.DoubleEither">
            <summary>
            Unknown stereobond geometry.
            </summary>
        </member>
        <member name="T:NCDK.NInChI.INCHI_BOND_TYPE">
            <summary>
            Enumeration of InChI bond type definitions.
            Corresponds to <tt>inchi_BondType</tt> in <tt>inchi_api.h</tt>.
            </summary>
        </member>
        <member name="F:NCDK.NInChI.INCHI_BOND_TYPE.Single">
            <summary>
            Single bond.
            </summary>
        </member>
        <member name="F:NCDK.NInChI.INCHI_BOND_TYPE.Double">
            <summary>
            Double bond.
            </summary>
        </member>
        <member name="F:NCDK.NInChI.INCHI_BOND_TYPE.Triple">
            <summary>
            Triple bond.
            </summary>
        </member>
        <member name="F:NCDK.NInChI.INCHI_BOND_TYPE.Altern">
            <summary>
            Alternating (single-double) bond. Avoid where possible.
            </summary>
        </member>
        <member name="T:NCDK.NInChI.INCHI_KEY">
             <summary>
             <para>Type-safe enumeration of InChI return codes.</para>
            
             <para>InChI library return values:
             <list type="bullet">
             <item>OK                      = 0</item>
             <item>UNKNOWN_ERROR          = 1</item>
             <item>EMPTY_INPUT              = 2</item>
             <item>NOT_INCHI_INPUT          = 3</item>
             <item>NOT_ENOUGH_MEMORY     = 4</item>
             <item>ERROR_IN_FLAG_CHAR      = 5</item>
             </list> 
             <para>See <tt>inchi_api.h</tt>.</para>
             </para>
             </summary>
        </member>
        <member name="T:NCDK.NInChI.INCHI_KEY_STATUS">
             <summary>
             <para>Type-safe enumeration of InChIKey check return codes.</para>
            
             <para>InChI library return values:
             <list type="bullet">
             <item>VALID_STANDARD            (0)</item>
             <item>INVALID_LENGTH     (1)</item>
             <item>INVALID_LAYOUT     (2)</item>
             <item>INVALID_VERSION    (3)</item>
             </list>
             </para>
             <para>See <tt>inchi_api.h</tt>.</para>
             </summary>
        </member>
        <member name="T:NCDK.NInChI.INCHI_OPTION">
            <summary>
            Type-safe enumeration of InChI options.  See <tt>inchi_api.h</tt>.
            </summary>
        </member>
        <member name="F:NCDK.NInChI.INCHI_OPTION.SUCF">
            <summary>
            Use Chiral Flag.
            </summary>
        </member>
        <member name="F:NCDK.NInChI.INCHI_OPTION.ChiralFlagON">
            <summary>
            Set Chiral Flag.
            </summary>
        </member>
        <member name="F:NCDK.NInChI.INCHI_OPTION.ChiralFlagOFF">
            <summary>
            Set Not-Chiral Flag.
            </summary>
        </member>
        <member name="F:NCDK.NInChI.INCHI_OPTION.SNon">
            <summary>
            Exclude stereo (Default: Include Absolute stereo).
            </summary>
        </member>
        <member name="F:NCDK.NInChI.INCHI_OPTION.SAbs">
            <summary>
            Absolute stereo.
            </summary>
        </member>
        <member name="F:NCDK.NInChI.INCHI_OPTION.SRel">
            <summary>
            Relative stereo.
            </summary>
        </member>
        <member name="F:NCDK.NInChI.INCHI_OPTION.SRac">
            <summary>
            Racemic stereo.
            </summary>
        </member>
        <member name="F:NCDK.NInChI.INCHI_OPTION.SUU">
            <summary>
            Include omitted unknown/undefined stereo.
            </summary>
        </member>
        <member name="F:NCDK.NInChI.INCHI_OPTION.NEWPS">
            <summary>
            Narrow end of wedge points to stereocentre (default: both).
            </summary>
        </member>
        <member name="F:NCDK.NInChI.INCHI_OPTION.RecMet">
            <summary>
            Include reconnected bond to metal results.
            </summary>
        </member>
        <member name="F:NCDK.NInChI.INCHI_OPTION.FixedH">
            <summary>
            Mobile H Perception Off (Default: On).
            </summary>
        </member>
        <member name="F:NCDK.NInChI.INCHI_OPTION.AuxNone">
            <summary>
            Omit auxiliary information (default: Include).
            </summary>
        </member>
        <member name="F:NCDK.NInChI.INCHI_OPTION.NoADP">
            <summary>
            Disable Aggressive Deprotonation (for testing only).
            </summary>
        </member>
        <member name="F:NCDK.NInChI.INCHI_OPTION.Compress">
            <summary>
            Compressed output.
            </summary>
        </member>
        <member name="F:NCDK.NInChI.INCHI_OPTION.DoNotAddH">
            <summary>
            Overrides inchi_Atom::num_iso_H[0] == -1.
            </summary>
        </member>
        <member name="F:NCDK.NInChI.INCHI_OPTION.Wnumber">
            <summary>
            Set time-out per structure in seconds; W0 means unlimited. In InChI
            library the default value is unlimited
            </summary>
        </member>
        <member name="F:NCDK.NInChI.INCHI_OPTION.OutputSDF">
            <summary>
            Output SDfile instead of InChI.
            </summary>
        </member>
        <member name="F:NCDK.NInChI.INCHI_OPTION.WarnOnEmptyStructure">
            <summary>
            Warn and produce empty InChI for empty structure.
            </summary>
        </member>
        <member name="F:NCDK.NInChI.INCHI_OPTION.FixSp3Bug">
            <summary>
            Fix bug leading to missing or undefined sp3 parity.
            </summary>
        </member>
        <member name="F:NCDK.NInChI.INCHI_OPTION.FB">
            <summary>
            Same as FixSp3Bug.
            </summary>
        </member>
        <member name="F:NCDK.NInChI.INCHI_OPTION.SPXYZ">
            <summary>
            Include Phosphines Stereochemistry.
            </summary>
        </member>
        <member name="F:NCDK.NInChI.INCHI_OPTION.SAsXYZ">
            <summary>
            Include Arsines Stereochemistry
            </summary>
        </member>
        <member name="T:NCDK.NInChI.INCHI_PARITY">
            <summary>
            Enumeration of InChI 0D parities.
            Corresponds to <tt>inchi_StereoParity0D</tt> in <tt>inchi_api.h</tt>.
            </summary>
        </member>
        <member name="F:NCDK.NInChI.INCHI_PARITY.None">
            <summary>
            None.
            </summary>
        </member>
        <member name="F:NCDK.NInChI.INCHI_PARITY.Odd">
            <summary>
            Odd.
            </summary>
        </member>
        <member name="F:NCDK.NInChI.INCHI_PARITY.Even">
            <summary>
            Even.
            </summary>
        </member>
        <member name="F:NCDK.NInChI.INCHI_PARITY.Unknown">
            <summary>
            Unknown.
            </summary>
        </member>
        <member name="F:NCDK.NInChI.INCHI_PARITY.Undefined">
            <summary>
            Undefined.
            </summary>
        </member>
        <member name="T:NCDK.NInChI.INCHI_RADICAL">
            <summary>
            Enumeration of InChI radical definitions.
            Corresponds to <tt>inchi_Radical</tt> in <tt>inchi_api.h</tt>.
            </summary>
        </member>
        <member name="F:NCDK.NInChI.INCHI_RADICAL.None">
            <summary>
            No radical status recorded.
            </summary>
        </member>
        <member name="F:NCDK.NInChI.INCHI_RADICAL.Singlet">
            <summary>
            Singlet.
            </summary>
        </member>
        <member name="F:NCDK.NInChI.INCHI_RADICAL.Doublet">
            <summary>
            Doublet.
            </summary>
        </member>
        <member name="F:NCDK.NInChI.INCHI_RADICAL.Triplet">
            <summary>
            Triplet.
            </summary>
        </member>
        <member name="T:NCDK.NInChI.INCHI_RET">
            <summary>
            Type-safe enumeration of InChI return codes.
            <para>
            InChI library return values:
            <list type="bullet">
            <item>SKIP     (-2)    Not used in InChI library</item>
            <item>EOF      (-1)    No structural data has been provided</item>
            <item>OKAY     (0)     Success, no errors or warnings</item>
            <item>WARNING  (1)     Success, Warning(s) issued</item>
            <item>ERROR    (2)     Error: no InChI has been created</item>
            <item>FATAL    (3)     Severe error: no InChI has been created (typically,
                             memory allocation failure)</item>
            <item>Unknown  (4)     Unknown program error</item>
            <item>BUSY     (5)     Previous call to InChI has not returned yet</item>
            </list> 
            </para>
            <para>See <tt>inchi_api.h</tt>.</para>
            </summary>
        </member>
        <member name="F:NCDK.NInChI.INCHI_RET.SKIP">
            <summary>
            Not used in InChI library.
            </summary>
        </member>
        <member name="F:NCDK.NInChI.INCHI_RET.EOF">
            <summary>
            No structural data has been provided.
            </summary>
        </member>
        <member name="F:NCDK.NInChI.INCHI_RET.OKAY">
            <summary>
            Success; no errors or warnings.
            </summary>
        </member>
        <member name="F:NCDK.NInChI.INCHI_RET.WARNING">
            <summary>
            Success; Warning(s) issued.
            </summary>
        </member>
        <member name="F:NCDK.NInChI.INCHI_RET.ERROR">
            <summary>
            Error: no InChI has been created.
            </summary>
        </member>
        <member name="F:NCDK.NInChI.INCHI_RET.FATAL">
            <summary>
            Severe error: no InChI has been created (typically, memory allocation failure).
            </summary>
        </member>
        <member name="F:NCDK.NInChI.INCHI_RET.Unknown">
            <summary>
            Unknown program error.
            </summary>
        </member>
        <member name="F:NCDK.NInChI.INCHI_RET.BUSY">
            <summary>
            Previuos call to InChI has not returned yet.
            </summary>
        </member>
        <member name="T:NCDK.NInChI.INCHI_STEREOTYPE">
            <summary>
            Enumeration of InChI 0D parity types.
            Corresponds to <tt>inchi_StereoType0D</tt> in <tt>inchi_api.h</tt>.
            </summary>
        </member>
        <member name="F:NCDK.NInChI.INCHI_STEREOTYPE.None">
            <summary>
            None.
            </summary>
        </member>
        <member name="F:NCDK.NInChI.INCHI_STEREOTYPE.DoubleBond">
            <summary>
            Stereogenic bond &gt;A=B&lt; or cumulene &gt;A=C=C=B&lt;.
            </summary>
        </member>
        <member name="F:NCDK.NInChI.INCHI_STEREOTYPE.Tetrahedral">
            <summary>
            Tetrahedral atom.
            </summary>
        </member>
        <member name="F:NCDK.NInChI.INCHI_STEREOTYPE.Allene">
            <summary>
            Allene.
            </summary>
        </member>
        <member name="T:NCDK.NInChI.NInchiAtom">
            <summary>
            Encapsulates properties of InChI Atom.  See <tt>inchi_api.h</tt>.
            </summary>
        </member>
        <member name="F:NCDK.NInChI.NInchiAtom.ISOTOPIC_SHIFT_FLAG">
            <summary>
            Indicates relative rather than absolute isotopic mass. Value
            from inchi_api.h.
            </summary>
        </member>
        <member name="P:NCDK.NInChI.NInchiAtom.X">
            <summary>
            Atom x-coordinate.
            </summary>
        </member>
        <member name="P:NCDK.NInChI.NInchiAtom.Y">
            <summary>
            Atom y-coordinate.
            </summary>
        </member>
        <member name="P:NCDK.NInChI.NInchiAtom.Z">
            <summary>
            Atom z-coordinate.
            </summary>
        </member>
        <member name="P:NCDK.NInChI.NInchiAtom.ElementType">
            <summary>
            Chemical element symbol eg C, O, Fe, Hg.
            </summary>
        </member>
        <member name="P:NCDK.NInChI.NInchiAtom.ImplicitH">
            <summary>
            Number of implicit hydrogens on atom. If set to -1, InChI will add
            implicit H automatically.
            </summary>
        </member>
        <member name="P:NCDK.NInChI.NInchiAtom.ImplicitProtium">
            <summary>
            Number of implicit protiums (isotopic 1-H) on atom.
            </summary>
        </member>
        <member name="P:NCDK.NInChI.NInchiAtom.ImplicitDeuterium">
            <summary>
            Number of implicit deuteriums (isotopic 2-H) on atom.
            </summary>
        </member>
        <member name="P:NCDK.NInChI.NInchiAtom.ImplicitTritium">
            <summary>
            Number of implicit tritiums (isotopic 3-H) on atom.
            </summary>
        </member>
        <member name="P:NCDK.NInChI.NInchiAtom.IsotopicMass">
            <summary>
            Mass of isotope. If set to 0, no isotopic mass set; otherwise, isotopic
            mass, or ISOTOPIC_SHIFT_FLAG + (mass - average atomic mass).
            </summary>
        </member>
        <member name="P:NCDK.NInChI.NInchiAtom.Radical">
            <summary>
            Radical status of atom.
            </summary>
        </member>
        <member name="P:NCDK.NInChI.NInchiAtom.Charge">
            <summary>
            Charge on atom.
            </summary>
        </member>
        <member name="M:NCDK.NInChI.NInchiAtom.#ctor(System.Double,System.Double,System.Double,System.String)">
            <summary>
            Create new atom.
            </summary>
            <remarks>
            Coordinates and element symbol must be set (unknown
            coordinates/dimensions should be set to zero).  All other
            parameters are initialised to default values:
             <list type="bullet">
               <item>Num Implicit H = 0</item>
               <item>Num Implicit 1H = 0</item>
               <item>Num Implicit 2H = 0</item>
               <item>Num Implicit 3H = 0</item>
               <item>Isotopic mass = 0 (non isotopic)</item>
               <item>Radical status = None  (radical status not defined)</item>
            </list>
            </remarks>
            <param name="x">x-coordinate</param>
            <param name="y">y-coordinate</param>
            <param name="z">z-coordinate</param>
            <param name="el">Chemical element symbol</param>
            <exception cref="T:System.ArgumentNullException">if the element symbol is null.</exception>
        </member>
        <member name="M:NCDK.NInChI.NInchiAtom.#ctor(System.String)">
            <summary>
            Convenience method to create a new atom with zero coordinates.
            <param name="el"></param>
            </summary>
        </member>
        <member name="M:NCDK.NInChI.NInchiAtom.SetIsotopicMassShift(System.Int32)">
            <summary>
            Sets isotopic mass, relative to standard mass.
            </summary>
            <param name="shift">Isotopic mass minus average atomic mass</param>
        </member>
        <member name="M:NCDK.NInChI.NInchiAtom.ToDebugString">
            <summary>
            Generates string representation of information on atom,
            for debugging purposes.
            </summary>
        </member>
        <member name="M:NCDK.NInChI.NInchiAtom.ToString(System.Double)">
            <summary>
            Java compatible <see cref="M:System.String.ToString"/>
            </summary>
        </member>
        <member name="M:NCDK.NInChI.NInchiAtom.PrintDebug">
            <summary>
            Outputs information on atom, for debugging purposes.
            </summary>
        </member>
        <member name="T:NCDK.NInChI.NInchiBond">
            <summary>
            Encapsulates properties of InChI Bond.  See <tt>inchi_api.h</tt>.
            </summary>
        </member>
        <member name="P:NCDK.NInChI.NInchiBond.OriginAtom">
            <summary>
            Origin atom in bond.
            </summary>
        </member>
        <member name="P:NCDK.NInChI.NInchiBond.TargetAtom">
            <summary>
            Target atom in bond.
            </summary>
        </member>
        <member name="P:NCDK.NInChI.NInchiBond.BondType">
            <summary>
            Bond type.
            </summary>
        </member>
        <member name="P:NCDK.NInChI.NInchiBond.BondStereo">
            <summary>
            Bond 2D stereo definition.
            </summary>
        </member>
        <member name="M:NCDK.NInChI.NInchiBond.#ctor(NCDK.NInChI.NInchiAtom,NCDK.NInChI.NInchiAtom,NCDK.NInChI.INCHI_BOND_TYPE,NCDK.NInChI.INCHI_BOND_STEREO)">
             <summary>
             Create bond.
            
             <param name="atO">Origin atom</param>
             <param name="atT">Target atom</param>
             <param name="type">Bond type</param>
             <param name="stereo">Bond 2D stereo definition</param>
             </summary>
        </member>
        <member name="M:NCDK.NInChI.NInchiBond.#ctor(NCDK.NInChI.NInchiAtom,NCDK.NInChI.NInchiAtom,NCDK.NInChI.INCHI_BOND_TYPE)">
             <summary>
             Create bond.
            
             <param name="atO">Origin atom</param>
             <param name="atT">Target atom</param>
             <param name="type">Bond type</param>
             </summary>
        </member>
        <member name="M:NCDK.NInChI.NInchiBond.ToDebugString">
            <summary>
            Generates string representation of information on bond,
            for debugging purposes.
            </summary>
        </member>
        <member name="M:NCDK.NInChI.NInchiBond.PrintDebug">
            <summary>
            Outputs information on bond, for debugging purposes.
            </summary>
        </member>
        <member name="T:NCDK.NInChI.NInchiException">
            <summary>
            Exception thrown by JniInchi.
            </summary>
        </member>
        <member name="M:NCDK.NInChI.NInchiException.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:NCDK.NInChI.NInchiException.#ctor(System.String)">
             <summary>
             Constructs a new exception with the specified detail message.
            
             <param name="message">the detail message.</param>
             </summary>
        </member>
        <member name="M:NCDK.NInChI.NInchiException.#ctor(System.Exception)">
             <summary>
             Constructs a new exception with the specified cause.
            
             <param name="ex">the cause.</param>
             </summary>
        </member>
        <member name="T:NCDK.NInChI.NInchiInput">
            <summary>
            Encapsulates structure input for InChI generation.
            </summary>
        </member>
        <member name="P:NCDK.NInChI.NInchiInput.Options">
            <summary>
            Options string,
            </summary>
        </member>
        <member name="M:NCDK.NInChI.NInchiInput.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:NCDK.NInChI.NInchiInput.#ctor(System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="opts">Options string.</param>
        </member>
        <member name="M:NCDK.NInChI.NInchiInput.#ctor(System.Collections.Generic.IList{NCDK.NInChI.INCHI_OPTION})">
            <summary>
            Constructor.
            </summary>
            <param name="opts">List of options.</param>
        </member>
        <member name="M:NCDK.NInChI.NInchiInput.#ctor(NCDK.NInChI.NInchiStructure)">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:NCDK.NInChI.NInchiInput.#ctor(NCDK.NInChI.NInchiStructure,System.String)">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="T:NCDK.NInChI.NInchiInputInchi">
            <summary>
            Encapsulates input for InChI to structure conversion.
            </summary>
        </member>
        <member name="P:NCDK.NInChI.NInchiInputInchi.Inchi">
            <summary>
            InChI ASCIIZ string to be converted to a strucure
            </summary>
        </member>
        <member name="P:NCDK.NInChI.NInchiInputInchi.Options">
            <summary>
            InChI options: space-delimited
            </summary>
        </member>
        <member name="M:NCDK.NInChI.NInchiInputInchi.#ctor(System.String)">
            <summary>
            Constructor.
            <param name="inchi">InChI string</param>
            </summary>
        </member>
        <member name="M:NCDK.NInChI.NInchiInputInchi.#ctor(System.String,System.String)">
            <summary>
            Constructor.
            <param name="inchi">InChI string</param>
            <param name="opts">Options</param>
            </summary>
        </member>
        <member name="M:NCDK.NInChI.NInchiInputInchi.#ctor(System.String,System.Collections.Generic.IList{NCDK.NInChI.INCHI_OPTION})">
            <summary>
            Constructor.
            <param name="inchi">InChI string</param>
            <param name="opts">Options</param>
            </summary>
        </member>
        <member name="T:NCDK.NInChI.NInchiOutput">
            <summary>
            Encapsulates output from InChI generation.
            </summary>
        </member>
        <member name="P:NCDK.NInChI.NInchiOutput.InChI">
            <summary>
            InChI ASCIIZ string
            </summary>
        </member>
        <member name="P:NCDK.NInChI.NInchiOutput.AuxInfo">
            <summary>
            Aux info ASCIIZ string
            </summary>
        </member>
        <member name="P:NCDK.NInChI.NInchiOutput.Message">
            <summary>
            Error/warning ASCIIZ message
            </summary>
        </member>
        <member name="P:NCDK.NInChI.NInchiOutput.Log">
            <summary>
            log-file ASCIIZ string, contains a human-readable list of recognized
            options and possibly an Error/warning message
            </summary>
        </member>
        <member name="T:NCDK.NInChI.NInchiOutputStructure">
            <summary>
            Encapsulates output from InChI to structure conversion.
            </summary>
        </member>
        <member name="P:NCDK.NInChI.NInchiOutputStructure.ReturnStatus">
            <summary>
            Return status from conversion.
            </summary>
        </member>
        <member name="P:NCDK.NInChI.NInchiOutputStructure.Message">
            <summary>
            Error/warning messages generated.
            </summary>
        </member>
        <member name="P:NCDK.NInChI.NInchiOutputStructure.Log">
            <summary>
            Log generated.
            </summary>
        </member>
        <member name="P:NCDK.NInChI.NInchiOutputStructure.WarningFlags">
            <summary>
            <para>Warning flags, see INCHIDIFF in inchicmp.h.</para>
            <para>[x][y]:
            <list type="bullet">
            <item>x=0 => Reconnected if present in InChI otherwise Disconnected/Normal</item>
            <item>x=1 => Disconnected layer if Reconnected layer is present</item>
            <item>y=1 => Main layer or Mobile-H</item>
            <item>y=0 => Fixed-H layer</item>
            </list> 
            </para>
            </summary>
        </member>
        <member name="T:NCDK.NInChI.NInchiStereo0D">
            <summary>
            Encapsulates properites of InChI Stereo Parity.  See <tt>inchi_api.h</tt>.
            </summary>
        </member>
        <member name="F:NCDK.NInChI.NInchiStereo0D.NO_ATOM">
            <summary>
            Indicates non-existent (central) atom. Value from inchi_api.h.
            </summary>
        </member>
        <member name="P:NCDK.NInChI.NInchiStereo0D.Neighbors">
            <summary>
            Neighbouring atoms.
            </summary>
        </member>
        <member name="P:NCDK.NInChI.NInchiStereo0D.CentralAtom">
            <summary>
            Central atom.
            </summary>
        </member>
        <member name="P:NCDK.NInChI.NInchiStereo0D.StereoType">
            <summary>
            Stereo parity type.
            </summary>
        </member>
        <member name="P:NCDK.NInChI.NInchiStereo0D.Parity">
            <summary>
            Parity.
            </summary>
        </member>
        <member name="P:NCDK.NInChI.NInchiStereo0D.DisconnectedParity">
            <summary>
            Second parity (for disconnected systems).
            </summary>
        </member>
        <member name="M:NCDK.NInChI.NInchiStereo0D.#ctor(NCDK.NInChI.NInchiAtom,NCDK.NInChI.NInchiAtom,NCDK.NInChI.NInchiAtom,NCDK.NInChI.NInchiAtom,NCDK.NInChI.NInchiAtom,NCDK.NInChI.INCHI_STEREOTYPE,NCDK.NInChI.INCHI_PARITY)">
            <summary>
            Constructor.  See <tt>inchi_api.h</tt> for details of usage.
            </summary>
            <param name="atC">Central atom</param>
            <param name="at0">Neighbour atom 0</param>
            <param name="at1">Neighbour atom 1</param>
            <param name="at2">Neighbour atom 2</param>
            <param name="at3">Neighbour atom 3</param>
            <param name="type">Stereo parity type</param>
            <param name="parity">Parity</param>
            <see cref="M:NCDK.NInChI.NInchiStereo0D.CreateNewTetrahedralStereo0D(NCDK.NInChI.NInchiAtom,NCDK.NInChI.NInchiAtom,NCDK.NInChI.NInchiAtom,NCDK.NInChI.NInchiAtom,NCDK.NInChI.NInchiAtom,NCDK.NInChI.INCHI_PARITY)"/> 
            <see cref="M:NCDK.NInChI.NInchiStereo0D.CreateNewDoublebondStereo0D(NCDK.NInChI.NInchiAtom,NCDK.NInChI.NInchiAtom,NCDK.NInChI.NInchiAtom,NCDK.NInChI.NInchiAtom,NCDK.NInChI.INCHI_PARITY)"/> 
        </member>
        <member name="M:NCDK.NInChI.NInchiStereo0D.ToDebugString">
            <summary>
            Generates string representation of information on stereo parity,
            for debugging purposes.
            </summary>
        </member>
        <member name="M:NCDK.NInChI.NInchiStereo0D.PrintDebug">
            <summary>
            Outputs information on stereo parity, for debugging purposes.
            </summary>
        </member>
        <member name="M:NCDK.NInChI.NInchiStereo0D.CreateNewTetrahedralStereo0D(NCDK.NInChI.NInchiAtom,NCDK.NInChI.NInchiAtom,NCDK.NInChI.NInchiAtom,NCDK.NInChI.NInchiAtom,NCDK.NInChI.NInchiAtom,NCDK.NInChI.INCHI_PARITY)">
             <summary>
             Convenience method for generating 0D stereo parities at tetrahedral
             atom centres.
            </summary>
             <remarks>
             <b>Usage notes from <i>inchi_api.h</i>:</b>
             <pre>
              4 neighbors
            
                       X                    neighbor[4] : {#W, #X, #Y, #Z}
                       |                    central_atom: #A
                    W--A--Y                 type        : INCHI_StereoType_Tetrahedral
                       |
                       Z
              parity: if (X,Y,Z) are clockwize when seen from W then parity is 'e' otherwise 'o'
              Example (see AXYZW above): if W is above the plane XYZ then parity = 'e'
            
              3 neighbors
            
                         Y          Y       neighbor[4] : {#A, #X, #Y, #Z}
                        /          /        central_atom: #A
                    X--A  (e.g. O=S   )     type        : INCHI_StereoType_Tetrahedral
                        \          \
                         Z          Z
            
              parity: if (X,Y,Z) are clockwize when seen from A then parity is 'e',
                                                                     otherwise 'o'
              unknown parity = 'u'
              Example (see AXYZ above): if A is above the plane XYZ then parity = 'e'
              This approach may be used also in case of an implicit H attached to A.
            
              ==============================================
              Note. Correspondence to CML 0D stereo parities
              ==============================================
              a list of 4 atoms corresponds to CML atomRefs4
            
              tetrahedral atom
              ================
              CML atomParity &gt; 0 &lt;=&gt; INCHI_PARITY_EVEN
              CML atomParity &lt; 0 &lt;=&gt; INCHI_PARITY_ODD
            
                                           | 1   1   1   1  |  where xW is x-coordinate of
                                           | xW  xX  xY  xZ |  atom W, etc. (xyz is a
              CML atomParity = determinant | yW  yX  yY  yZ |  'right-handed' Cartesian
                                           | zW  zX  xY  zZ |  coordinate system)
             </pre>
             </remarks>
             <param name="atC">Central atom</param>
             <param name="at0">Neighbour atom 0</param>
             <param name="at1">Neighbour atom 1</param>
             <param name="at2">Neighbour atom 2</param>
             <param name="at3">Neighbour atom 3</param>
             <param name="parity">Parity</param>
        </member>
        <member name="M:NCDK.NInChI.NInchiStereo0D.CreateNewDoublebondStereo0D(NCDK.NInChI.NInchiAtom,NCDK.NInChI.NInchiAtom,NCDK.NInChI.NInchiAtom,NCDK.NInChI.NInchiAtom,NCDK.NInChI.INCHI_PARITY)">
             <summary>
             Convenience method for generating 0D stereo parities at stereogenic
             double bonds.
             </summary>
             <remarks>
             <b>Usage notes from <i>inchi_api.h</i>:</b>
             <pre>
              =============================================
              stereogenic bond &gt;A=B&lt; or cumulene &gt;A=C=C=B&lt;
              =============================================
            
                                          neighbor[4]  : {#X,#A,#B,#Y} in this order
              X                           central_atom : NO_ATOM
               \            X      Y      type         : INCHI_StereoType_DoubleBond
                A==B         \    /
                    \         A==B
                     Y
            
              parity= 'e'    parity= 'o'   unknown parity = 'u'
            
              ==============================================
              Note. Correspondence to CML 0D stereo parities
              ==============================================
            
              stereogenic double bond and (not yet defined in CML) cumulenes
              ==============================================================
              CML 'C' (cis)      &lt;=&gt; INCHI_PARITY_ODD
              CML 'T' (trans)    &lt;=&gt; INCHI_PARITY_EVEN
             </pre>
             </remarks>
             <param name="at0">Neighbour atom 0</param>
             <param name="at1">Neighbour atom 1</param>
             <param name="at2">Neighbour atom 2</param>
             <param name="at3">Neighbour atom 3</param>
             <param name="parity">Parity</param>
             <returns></returns>
        </member>
        <member name="P:NCDK.NInChI.NInchiStructure.Atoms">
            <summary>
            List of atoms.
            </summary>
        </member>
        <member name="P:NCDK.NInChI.NInchiStructure.Bonds">
            <summary>
            List of bonds.
            </summary>
        </member>
        <member name="P:NCDK.NInChI.NInchiStructure.Stereos">
            <summary>
            List of stero parities.
            </summary>
        </member>
        <member name="T:NCDK.NInChI.NInchiWrapper">
             <summary>
             <para>.NET Framework Wrapper for International Chemical Identifier (InChI) C++ library.</para>
             </summary>
             <remarks>
             <para>This class is not intended to be used directly, but should be accessed
             through subclasses that read data formats and load them into the InChI
             data structures.</para>
            
             <para>Subclasses should load data through the addAtom, addBond and addParity
             methods. Once the molecule is fully loaded then the generateInchi method
             should be called. Ideally this should all take place within the subclass's
             constructor. The public get methods will all return null until this has
             happened.</para>
            
             <para>See <tt>inchi_api.h</tt>.</para>
             </remarks>
        </member>
        <member name="T:NCDK.NInChI.NInchiWrapper.Inchi_OutputStruct">
            <summary>
            4 pointers are allocated by GetStructFromINCHI()/GetStructFromStdINCHI()
            o deallocate all of them call FreeStructFromStdINCHI()/FreeStructFromStdINCHI()
            </summary>
        </member>
        <member name="F:NCDK.NInChI.NInchiWrapper.Inchi_OutputStruct.atom">
            <summary>
            array of <see cref="T:NCDK.NInChI.NInchiWrapper.Inchi_Atom"/> num_atoms elements
            </summary>
        </member>
        <member name="F:NCDK.NInChI.NInchiWrapper.Inchi_OutputStruct.stereo0D">
            <summary>
            array of <see cref="T:NCDK.NInChI.NInchiWrapper.Inchi_Stereo0D"/> num_stereo0D 0D stereo elements or NULL 
            </summary>
        </member>
        <member name="F:NCDK.NInChI.NInchiWrapper.InchiInpData.pInp">
            <summary>
            A pointer to <see cref="T:NCDK.NInChI.NInchiWrapper.Inchi_Input"/> that has all items 0 or NULL
            </summary>
        </member>
        <member name="F:NCDK.NInChI.NInchiWrapper.IS_WINDOWS">
            <summary>
            Flag indicating windows or linux.
            </summary>
        </member>
        <member name="F:NCDK.NInChI.NInchiWrapper.FlagChar">
            <summary>
            Switch character for passing options. / in windows, - on other systems.
            </summary>
        </member>
        <member name="M:NCDK.NInChI.NInchiWrapper.CheckOptions(System.Collections.Generic.IList{NCDK.NInChI.INCHI_OPTION})">
            <summary>
            Checks and canonicalises options.
            </summary>
            <param name="ops">List of INCHI_OPTION</param>
        </member>
        <member name="M:NCDK.NInChI.NInchiWrapper.CheckOptions(System.String)">
            <summary>
            Checks and canonicalises options.
            </summary>
            <param name="ops">Space delimited string of options to pass to InChI library.
                                Each option may optionally be preceded by a command line
                                switch (/ or -).</param>
        </member>
        <member name="M:NCDK.NInChI.NInchiWrapper.GetInchi(NCDK.NInChI.NInchiInput)">
             <summary>
             <para>Generates the InChI for a chemical structure.</para>
             </summary>
             <remarks>
             <para>If no InChI creation/stereo modification options are specified then a standard
             InChI is produced, otherwise the generated InChI will be a non-standard one.</para>
            
             <para><b>Valid options:</b></para>
             <pre>
              Structure perception (compatible with stdInChI):
                /NEWPSOFF   /DoNotAddH   /SNon
              Stereo interpretation (lead to generation of non-standard InChI)
                /SRel /SRac /SUCF /ChiralFlagON /ChiralFlagOFF
              InChI creation options (lead to generation of non-standard InChI)
                /SUU /SLUUD   /FixedH  /RecMet  /KET /15T
             </pre>
            
             <para><b>Other options:</b></para>
             <pre>
              /AuxNone    Omit auxiliary information (default: Include)
              /Wnumber    Set time-out per structure in seconds; W0 means unlimited In InChI library the default value is unlimited
              /OutputSDF  Output SDfile instead of InChI
              /WarnOnEmptyStructure Warn and produce empty InChI for empty structure
              /SaveOpt    Save custom InChI creation options (non-standard InChI)
             </pre>
             </remarks>
             <param name="input"></param>
             <returns></returns>
        </member>
        <member name="M:NCDK.NInChI.NInchiWrapper.GetStdInchi(NCDK.NInChI.NInchiInput)">
            <summary>
            <para>Calculates the Standard InChI string for a chemical structure.</para>
            <para>The only valid structure perception options are NEWPSOFF/DoNotAddH/SNon. In any other structural
            perception options are specified then the calculation will fail.</para>
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:NCDK.NInChI.NInchiWrapper.GetInchiFromInchi(NCDK.NInChI.NInchiInputInchi)">
            <summary>
            <para>Converts an InChI into an InChI for validation purposes (the same as the -InChI2InChI option).</para>
            <para>This method may also be used to filter out specific layers. For instance, /Snon would remove the
            stereochemical layer; Omitting /FixedH and/or /RecMet would remove Fixed-H or Reconnected layers.
            In order to keep all InChI layers use options string "/FixedH /RecMet"; option /InChI2InChI is not needed.</para>         
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:NCDK.NInChI.NInchiWrapper.GetStructureFromInchi(NCDK.NInChI.NInchiInputInchi)">
            <summary>
            Generated 0D structure from an InChI string.
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:NCDK.NInChI.NInchiWrapper.GetInchiKey(System.String)">
            <summary>
            Calculates the InChIKey for an InChI string.
            </summary>
            <param name="inchi">source InChI string</param>
            <returns>InChIKey output</returns>
            <exception cref="T:NCDK.NInChI.NInchiException"></exception>
        </member>
        <member name="M:NCDK.NInChI.NInchiWrapper.CheckInchiKey(System.String)">
            <summary>
            Checks whether a string represents valid InChIKey.
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NCDK.NInChI.NInchiWrapper.CheckInchi(System.String,System.Boolean)">
            <summary>
            <para>Checks if the string represents valid InChI/standard InChI.</para>
            </summary>
            <param name="inchi">source InChI</param>
            <param name="strict">if <see langword="false"/>, just briefly check for proper layout (prefix, version, etc.) The result
                          may not be strict.
                          If <see langword="true"/>, try to perform InChI2InChI conversion and returns success if a resulting
                          InChI string exactly match source. The result may be 'false alarm' due to imperfectness of</param>
        </member>
        <member name="M:NCDK.Numerics.HashCodeHelper.CombineHashCodes(System.Int32,System.Int32)">
            <summary>
            Combines two hash codes, useful for combining hash codes of individual vector elements
            </summary>
        </member>
        <member name="T:NCDK.Numerics.Matrix3x2">
            <summary>
            A structure encapsulating a 3x2 matrix.
            </summary>
        </member>
        <member name="F:NCDK.Numerics.Matrix3x2.M11">
            <summary>
            The first element of the first row
            </summary>
        </member>
        <member name="F:NCDK.Numerics.Matrix3x2.M12">
            <summary>
            The second element of the first row
            </summary>
        </member>
        <member name="F:NCDK.Numerics.Matrix3x2.M21">
            <summary>
            The first element of the second row
            </summary>
        </member>
        <member name="F:NCDK.Numerics.Matrix3x2.M22">
            <summary>
            The second element of the second row
            </summary>
        </member>
        <member name="F:NCDK.Numerics.Matrix3x2.M31">
            <summary>
            The first element of the third row
            </summary>
        </member>
        <member name="F:NCDK.Numerics.Matrix3x2.M32">
            <summary>
            The second element of the third row
            </summary>
        </member>
        <member name="P:NCDK.Numerics.Matrix3x2.Identity">
            <summary>
            Returns the multiplicative identity matrix.
            </summary>
        </member>
        <member name="P:NCDK.Numerics.Matrix3x2.IsIdentity">
            <summary>
            Returns whether the matrix is the identity matrix.
            </summary>
        </member>
        <member name="P:NCDK.Numerics.Matrix3x2.Translation">
            <summary>
            Gets or sets the translation component of this matrix.
            </summary>
        </member>
        <member name="M:NCDK.Numerics.Matrix3x2.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Constructs a Matrix3x2 from the given components.
            </summary>
        </member>
        <member name="M:NCDK.Numerics.Matrix3x2.CreateTranslation(NCDK.Numerics.Vector2)">
            <summary>
            Creates a translation matrix from the given vector.
            </summary>
            <param name="position">The translation position.</param>
            <returns>A translation matrix.</returns>
        </member>
        <member name="M:NCDK.Numerics.Matrix3x2.CreateTranslation(System.Double,System.Double)">
            <summary>
            Creates a translation matrix from the given X and Y components.
            </summary>
            <param name="xPosition">The X position.</param>
            <param name="yPosition">The Y position.</param>
            <returns>A translation matrix.</returns>
        </member>
        <member name="M:NCDK.Numerics.Matrix3x2.CreateScale(System.Double,System.Double)">
            <summary>
            Creates a scale matrix from the given X and Y components.
            </summary>
            <param name="xScale">Value to scale by on the X-axis.</param>
            <param name="yScale">Value to scale by on the Y-axis.</param>
            <returns>A scaling matrix.</returns>
        </member>
        <member name="M:NCDK.Numerics.Matrix3x2.CreateScale(System.Double,System.Double,NCDK.Numerics.Vector2)">
            <summary>
            Creates a scale matrix that is offset by a given center point.
            </summary>
            <param name="xScale">Value to scale by on the X-axis.</param>
            <param name="yScale">Value to scale by on the Y-axis.</param>
            <param name="centerPoint">The center point.</param>
            <returns>A scaling matrix.</returns>
        </member>
        <member name="M:NCDK.Numerics.Matrix3x2.CreateScale(NCDK.Numerics.Vector2)">
            <summary>
            Creates a scale matrix from the given vector scale.
            </summary>
            <param name="scales">The scale to use.</param>
            <returns>A scaling matrix.</returns>
        </member>
        <member name="M:NCDK.Numerics.Matrix3x2.CreateScale(NCDK.Numerics.Vector2,NCDK.Numerics.Vector2)">
            <summary>
            Creates a scale matrix from the given vector scale with an offset from the given center point.
            </summary>
            <param name="scales">The scale to use.</param>
            <param name="centerPoint">The center offset.</param>
            <returns>A scaling matrix.</returns>
        </member>
        <member name="M:NCDK.Numerics.Matrix3x2.CreateScale(System.Double)">
            <summary>
            Creates a scale matrix that scales uniformly with the given scale.
            </summary>
            <param name="scale">The uniform scale to use.</param>
            <returns>A scaling matrix.</returns>
        </member>
        <member name="M:NCDK.Numerics.Matrix3x2.CreateScale(System.Double,NCDK.Numerics.Vector2)">
            <summary>
            Creates a scale matrix that scales uniformly with the given scale with an offset from the given center.
            </summary>
            <param name="scale">The uniform scale to use.</param>
            <param name="centerPoint">The center offset.</param>
            <returns>A scaling matrix.</returns>
        </member>
        <member name="M:NCDK.Numerics.Matrix3x2.CreateSkew(System.Double,System.Double)">
            <summary>
            Creates a skew matrix from the given angles in radians.
            </summary>
            <param name="radiansX">The X angle, in radians.</param>
            <param name="radiansY">The Y angle, in radians.</param>
            <returns>A skew matrix.</returns>
        </member>
        <member name="M:NCDK.Numerics.Matrix3x2.CreateSkew(System.Double,System.Double,NCDK.Numerics.Vector2)">
            <summary>
            Creates a skew matrix from the given angles in radians and a center point.
            </summary>
            <param name="radiansX">The X angle, in radians.</param>
            <param name="radiansY">The Y angle, in radians.</param>
            <param name="centerPoint">The center point.</param>
            <returns>A skew matrix.</returns>
        </member>
        <member name="M:NCDK.Numerics.Matrix3x2.CreateRotation(System.Double)">
            <summary>
            Creates a rotation matrix using the given rotation in radians.
            </summary>
            <param name="radians">The amount of rotation, in radians.</param>
            <returns>A rotation matrix.</returns>
        </member>
        <member name="M:NCDK.Numerics.Matrix3x2.CreateRotation(System.Double,NCDK.Numerics.Vector2)">
            <summary>
            Creates a rotation matrix using the given rotation in radians and a center point.
            </summary>
            <param name="radians">The amount of rotation, in radians.</param>
            <param name="centerPoint">The center point.</param>
            <returns>A rotation matrix.</returns>
        </member>
        <member name="M:NCDK.Numerics.Matrix3x2.GetDeterminant">
            <summary>
            Calculates the determinant for this matrix. 
            The determinant is calculated by expanding the matrix with a third column whose values are (0,0,1).
            </summary>
            <returns>The determinant.</returns>
        </member>
        <member name="M:NCDK.Numerics.Matrix3x2.Invert(NCDK.Numerics.Matrix3x2,NCDK.Numerics.Matrix3x2@)">
            <summary>
            Attempts to invert the given matrix. If the operation succeeds, the inverted matrix is stored in the result parameter.
            </summary>
            <param name="matrix">The source matrix.</param>
            <param name="result">The output matrix.</param>
            <returns>True if the operation succeeded, False otherwise.</returns>
        </member>
        <member name="M:NCDK.Numerics.Matrix3x2.Lerp(NCDK.Numerics.Matrix3x2,NCDK.Numerics.Matrix3x2,System.Double)">
            <summary>
            Linearly interpolates from matrix1 to matrix2, based on the third parameter.
            </summary>
            <param name="matrix1">The first source matrix.</param>
            <param name="matrix2">The second source matrix.</param>
            <param name="amount">The relative weighting of matrix2.</param>
            <returns>The interpolated matrix.</returns>
        </member>
        <member name="M:NCDK.Numerics.Matrix3x2.Negate(NCDK.Numerics.Matrix3x2)">
            <summary>
            Negates the given matrix by multiplying all values by -1.
            </summary>
            <param name="value">The source matrix.</param>
            <returns>The negated matrix.</returns>
        </member>
        <member name="M:NCDK.Numerics.Matrix3x2.Add(NCDK.Numerics.Matrix3x2,NCDK.Numerics.Matrix3x2)">
            <summary>
            Adds each matrix element in value1 with its corresponding element in value2.
            </summary>
            <param name="value1">The first source matrix.</param>
            <param name="value2">The second source matrix.</param>
            <returns>The matrix containing the summed values.</returns>
        </member>
        <member name="M:NCDK.Numerics.Matrix3x2.Subtract(NCDK.Numerics.Matrix3x2,NCDK.Numerics.Matrix3x2)">
            <summary>
            Subtracts each matrix element in value2 from its corresponding element in value1.
            </summary>
            <param name="value1">The first source matrix.</param>
            <param name="value2">The second source matrix.</param>
            <returns>The matrix containing the resulting values.</returns>
        </member>
        <member name="M:NCDK.Numerics.Matrix3x2.Multiply(NCDK.Numerics.Matrix3x2,NCDK.Numerics.Matrix3x2)">
            <summary>
            Multiplies two matrices together and returns the resulting matrix.
            </summary>
            <param name="value1">The first source matrix.</param>
            <param name="value2">The second source matrix.</param>
            <returns>The product matrix.</returns>
        </member>
        <member name="M:NCDK.Numerics.Matrix3x2.Multiply(NCDK.Numerics.Matrix3x2,System.Double)">
            <summary>
            Scales all elements in a matrix by the given scalar factor.
            </summary>
            <param name="value1">The source matrix.</param>
            <param name="value2">The scaling value to use.</param>
            <returns>The resulting matrix.</returns>
        </member>
        <member name="M:NCDK.Numerics.Matrix3x2.op_UnaryNegation(NCDK.Numerics.Matrix3x2)">
            <summary>
            Negates the given matrix by multiplying all values by -1.
            </summary>
            <param name="value">The source matrix.</param>
            <returns>The negated matrix.</returns>
        </member>
        <member name="M:NCDK.Numerics.Matrix3x2.op_Addition(NCDK.Numerics.Matrix3x2,NCDK.Numerics.Matrix3x2)">
            <summary>
            Adds each matrix element in value1 with its corresponding element in value2.
            </summary>
            <param name="value1">The first source matrix.</param>
            <param name="value2">The second source matrix.</param>
            <returns>The matrix containing the summed values.</returns>
        </member>
        <member name="M:NCDK.Numerics.Matrix3x2.op_Subtraction(NCDK.Numerics.Matrix3x2,NCDK.Numerics.Matrix3x2)">
            <summary>
            Subtracts each matrix element in value2 from its corresponding element in value1.
            </summary>
            <param name="value1">The first source matrix.</param>
            <param name="value2">The second source matrix.</param>
            <returns>The matrix containing the resulting values.</returns>
        </member>
        <member name="M:NCDK.Numerics.Matrix3x2.op_Multiply(NCDK.Numerics.Matrix3x2,NCDK.Numerics.Matrix3x2)">
            <summary>
            Multiplies two matrices together and returns the resulting matrix.
            </summary>
            <param name="value1">The first source matrix.</param>
            <param name="value2">The second source matrix.</param>
            <returns>The product matrix.</returns>
        </member>
        <member name="M:NCDK.Numerics.Matrix3x2.op_Multiply(NCDK.Numerics.Matrix3x2,System.Double)">
            <summary>
            Scales all elements in a matrix by the given scalar factor.
            </summary>
            <param name="value1">The source matrix.</param>
            <param name="value2">The scaling value to use.</param>
            <returns>The resulting matrix.</returns>
        </member>
        <member name="M:NCDK.Numerics.Matrix3x2.op_Equality(NCDK.Numerics.Matrix3x2,NCDK.Numerics.Matrix3x2)">
            <summary>
            Returns a bool indicating whether the given matrices are equal.
            </summary>
            <param name="value1">The first source matrix.</param>
            <param name="value2">The second source matrix.</param>
            <returns>True if the matrices are equal; False otherwise.</returns>
        </member>
        <member name="M:NCDK.Numerics.Matrix3x2.op_Inequality(NCDK.Numerics.Matrix3x2,NCDK.Numerics.Matrix3x2)">
            <summary>
            Returns a bool indicating whether the given matrices are not equal.
            </summary>
            <param name="value1">The first source matrix.</param>
            <param name="value2">The second source matrix.</param>
            <returns>True if the matrices are not equal; False if they are equal.</returns>
        </member>
        <member name="M:NCDK.Numerics.Matrix3x2.Equals(NCDK.Numerics.Matrix3x2)">
            <summary>
            Returns a bool indicating whether the matrix is equal to the other given matrix.
            </summary>
            <param name="other">The other matrix to test equality against.</param>
            <returns>True if this matrix is equal to other; False otherwise.</returns>
        </member>
        <member name="M:NCDK.Numerics.Matrix3x2.Equals(System.Object)">
            <summary>
            Returns a bool indicating whether the given Object is equal to this matrix instance.
            </summary>
            <param name="obj">The Object to compare against.</param>
            <returns>True if the Object is equal to this matrix; False otherwise.</returns>
        </member>
        <member name="M:NCDK.Numerics.Matrix3x2.ToString">
            <summary>
            Returns a string representing this matrix instance.
            </summary>
            <returns>The string representation.</returns>
        </member>
        <member name="M:NCDK.Numerics.Matrix3x2.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <returns>The hash code.</returns>
        </member>
        <member name="T:NCDK.Numerics.Matrix4x4">
            <summary>
            A structure encapsulating a 4x4 matrix.
            </summary>
        </member>
        <member name="F:NCDK.Numerics.Matrix4x4.M11">
            <summary>
            Value at row 1, column 1 of the matrix.
            </summary>
        </member>
        <member name="F:NCDK.Numerics.Matrix4x4.M12">
            <summary>
            Value at row 1, column 2 of the matrix.
            </summary>
        </member>
        <member name="F:NCDK.Numerics.Matrix4x4.M13">
            <summary>
            Value at row 1, column 3 of the matrix.
            </summary>
        </member>
        <member name="F:NCDK.Numerics.Matrix4x4.M14">
            <summary>
            Value at row 1, column 4 of the matrix.
            </summary>
        </member>
        <member name="F:NCDK.Numerics.Matrix4x4.M21">
            <summary>
            Value at row 2, column 1 of the matrix.
            </summary>
        </member>
        <member name="F:NCDK.Numerics.Matrix4x4.M22">
            <summary>
            Value at row 2, column 2 of the matrix.
            </summary>
        </member>
        <member name="F:NCDK.Numerics.Matrix4x4.M23">
            <summary>
            Value at row 2, column 3 of the matrix.
            </summary>
        </member>
        <member name="F:NCDK.Numerics.Matrix4x4.M24">
            <summary>
            Value at row 2, column 4 of the matrix.
            </summary>
        </member>
        <member name="F:NCDK.Numerics.Matrix4x4.M31">
            <summary>
            Value at row 3, column 1 of the matrix.
            </summary>
        </member>
        <member name="F:NCDK.Numerics.Matrix4x4.M32">
            <summary>
            Value at row 3, column 2 of the matrix.
            </summary>
        </member>
        <member name="F:NCDK.Numerics.Matrix4x4.M33">
            <summary>
            Value at row 3, column 3 of the matrix.
            </summary>
        </member>
        <member name="F:NCDK.Numerics.Matrix4x4.M34">
            <summary>
            Value at row 3, column 4 of the matrix.
            </summary>
        </member>
        <member name="F:NCDK.Numerics.Matrix4x4.M41">
            <summary>
            Value at row 4, column 1 of the matrix.
            </summary>
        </member>
        <member name="F:NCDK.Numerics.Matrix4x4.M42">
            <summary>
            Value at row 4, column 2 of the matrix.
            </summary>
        </member>
        <member name="F:NCDK.Numerics.Matrix4x4.M43">
            <summary>
            Value at row 4, column 3 of the matrix.
            </summary>
        </member>
        <member name="F:NCDK.Numerics.Matrix4x4.M44">
            <summary>
            Value at row 4, column 4 of the matrix.
            </summary>
        </member>
        <member name="P:NCDK.Numerics.Matrix4x4.Identity">
            <summary>
            Returns the multiplicative identity matrix.
            </summary>
        </member>
        <member name="P:NCDK.Numerics.Matrix4x4.IsIdentity">
            <summary>
            Returns whether the matrix is the identity matrix.
            </summary>
        </member>
        <member name="P:NCDK.Numerics.Matrix4x4.Translation">
            <summary>
            Gets or sets the translation component of this matrix.
            </summary>
        </member>
        <member name="M:NCDK.Numerics.Matrix4x4.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Constructs a Matrix4x4 from the given components.
            </summary>
        </member>
        <member name="M:NCDK.Numerics.Matrix4x4.#ctor(NCDK.Numerics.Matrix3x2)">
            <summary>
            Constructs a Matrix4x4 from the given Matrix3x2.
            </summary>
            <param name="value">The source Matrix3x2.</param>
        </member>
        <member name="M:NCDK.Numerics.Matrix4x4.CreateBillboard(NCDK.Numerics.Vector3,NCDK.Numerics.Vector3,NCDK.Numerics.Vector3,NCDK.Numerics.Vector3)">
            <summary>
            Creates a spherical billboard that rotates around a specified object position.
            </summary>
            <param name="objectPosition">Position of the object the billboard will rotate around.</param>
            <param name="cameraPosition">Position of the camera.</param>
            <param name="cameraUpVector">The up vector of the camera.</param>
            <param name="cameraForwardVector">The forward vector of the camera.</param>
            <returns>The created billboard matrix</returns>
        </member>
        <member name="M:NCDK.Numerics.Matrix4x4.CreateConstrainedBillboard(NCDK.Numerics.Vector3,NCDK.Numerics.Vector3,NCDK.Numerics.Vector3,NCDK.Numerics.Vector3,NCDK.Numerics.Vector3)">
            <summary>
            Creates a cylindrical billboard that rotates around a specified axis.
            </summary>
            <param name="objectPosition">Position of the object the billboard will rotate around.</param>
            <param name="cameraPosition">Position of the camera.</param>
            <param name="rotateAxis">Axis to rotate the billboard around.</param>
            <param name="cameraForwardVector">Forward vector of the camera.</param>
            <param name="objectForwardVector">Forward vector of the object.</param>
            <returns>The created billboard matrix.</returns>
        </member>
        <member name="M:NCDK.Numerics.Matrix4x4.CreateTranslation(NCDK.Numerics.Vector3)">
            <summary>
            Creates a translation matrix.
            </summary>
            <param name="position">The amount to translate in each axis.</param>
            <returns>The translation matrix.</returns>
        </member>
        <member name="M:NCDK.Numerics.Matrix4x4.CreateTranslation(System.Double,System.Double,System.Double)">
            <summary>
            Creates a translation matrix.
            </summary>
            <param name="xPosition">The amount to translate on the X-axis.</param>
            <param name="yPosition">The amount to translate on the Y-axis.</param>
            <param name="zPosition">The amount to translate on the Z-axis.</param>
            <returns>The translation matrix.</returns>
        </member>
        <member name="M:NCDK.Numerics.Matrix4x4.CreateScale(System.Double,System.Double,System.Double)">
            <summary>
            Creates a scaling matrix.
            </summary>
            <param name="xScale">Value to scale by on the X-axis.</param>
            <param name="yScale">Value to scale by on the Y-axis.</param>
            <param name="zScale">Value to scale by on the Z-axis.</param>
            <returns>The scaling matrix.</returns>
        </member>
        <member name="M:NCDK.Numerics.Matrix4x4.CreateScale(System.Double,System.Double,System.Double,NCDK.Numerics.Vector3)">
            <summary>
            Creates a scaling matrix with a center point.
            </summary>
            <param name="xScale">Value to scale by on the X-axis.</param>
            <param name="yScale">Value to scale by on the Y-axis.</param>
            <param name="zScale">Value to scale by on the Z-axis.</param>
            <param name="centerPoint">The center point.</param>
            <returns>The scaling matrix.</returns>
        </member>
        <member name="M:NCDK.Numerics.Matrix4x4.CreateScale(NCDK.Numerics.Vector3)">
            <summary>
            Creates a scaling matrix.
            </summary>
            <param name="scales">The vector containing the amount to scale by on each axis.</param>
            <returns>The scaling matrix.</returns>
        </member>
        <member name="M:NCDK.Numerics.Matrix4x4.CreateScale(NCDK.Numerics.Vector3,NCDK.Numerics.Vector3)">
            <summary>
            Creates a scaling matrix with a center point.
            </summary>
            <param name="scales">The vector containing the amount to scale by on each axis.</param>
            <param name="centerPoint">The center point.</param>
            <returns>The scaling matrix.</returns>
        </member>
        <member name="M:NCDK.Numerics.Matrix4x4.CreateScale(System.Double)">
            <summary>
            Creates a uniform scaling matrix that scales equally on each axis.
            </summary>
            <param name="scale">The uniform scaling factor.</param>
            <returns>The scaling matrix.</returns>
        </member>
        <member name="M:NCDK.Numerics.Matrix4x4.CreateScale(System.Double,NCDK.Numerics.Vector3)">
            <summary>
            Creates a uniform scaling matrix that scales equally on each axis with a center point.
            </summary>
            <param name="scale">The uniform scaling factor.</param>
            <param name="centerPoint">The center point.</param>
            <returns>The scaling matrix.</returns>
        </member>
        <member name="M:NCDK.Numerics.Matrix4x4.CreateRotationX(System.Double)">
            <summary>
            Creates a matrix for rotating points around the X-axis.
            </summary>
            <param name="radians">The amount, in radians, by which to rotate around the X-axis.</param>
            <returns>The rotation matrix.</returns>
        </member>
        <member name="M:NCDK.Numerics.Matrix4x4.CreateRotationX(System.Double,NCDK.Numerics.Vector3)">
            <summary>
            Creates a matrix for rotating points around the X-axis, from a center point.
            </summary>
            <param name="radians">The amount, in radians, by which to rotate around the X-axis.</param>
            <param name="centerPoint">The center point.</param>
            <returns>The rotation matrix.</returns>
        </member>
        <member name="M:NCDK.Numerics.Matrix4x4.CreateRotationY(System.Double)">
            <summary>
            Creates a matrix for rotating points around the Y-axis.
            </summary>
            <param name="radians">The amount, in radians, by which to rotate around the Y-axis.</param>
            <returns>The rotation matrix.</returns>
        </member>
        <member name="M:NCDK.Numerics.Matrix4x4.CreateRotationY(System.Double,NCDK.Numerics.Vector3)">
            <summary>
            Creates a matrix for rotating points around the Y-axis, from a center point.
            </summary>
            <param name="radians">The amount, in radians, by which to rotate around the Y-axis.</param>
            <param name="centerPoint">The center point.</param>
            <returns>The rotation matrix.</returns>
        </member>
        <member name="M:NCDK.Numerics.Matrix4x4.CreateRotationZ(System.Double)">
            <summary>
            Creates a matrix for rotating points around the Z-axis.
            </summary>
            <param name="radians">The amount, in radians, by which to rotate around the Z-axis.</param>
            <returns>The rotation matrix.</returns>
        </member>
        <member name="M:NCDK.Numerics.Matrix4x4.CreateRotationZ(System.Double,NCDK.Numerics.Vector3)">
            <summary>
            Creates a matrix for rotating points around the Z-axis, from a center point.
            </summary>
            <param name="radians">The amount, in radians, by which to rotate around the Z-axis.</param>
            <param name="centerPoint">The center point.</param>
            <returns>The rotation matrix.</returns>
        </member>
        <member name="M:NCDK.Numerics.Matrix4x4.CreateFromAxisAngle(NCDK.Numerics.Vector3,System.Double)">
            <summary>
            Creates a matrix that rotates around an arbitrary vector.
            </summary>
            <param name="axis">The axis to rotate around.</param>
            <param name="angle">The angle to rotate around the given axis, in radians.</param>
            <returns>The rotation matrix.</returns>
        </member>
        <member name="M:NCDK.Numerics.Matrix4x4.CreatePerspectiveFieldOfView(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Creates a perspective projection matrix based on a field of view, aspect ratio, and near and far view plane distances. 
            </summary>
            <param name="fieldOfView">Field of view in the y direction, in radians.</param>
            <param name="aspectRatio">Aspect ratio, defined as view space width divided by height.</param>
            <param name="nearPlaneDistance">Distance to the near view plane.</param>
            <param name="farPlaneDistance">Distance to the far view plane.</param>
            <returns>The perspective projection matrix.</returns>
        </member>
        <member name="M:NCDK.Numerics.Matrix4x4.CreatePerspective(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Creates a perspective projection matrix from the given view volume dimensions.
            </summary>
            <param name="width">Width of the view volume at the near view plane.</param>
            <param name="height">Height of the view volume at the near view plane.</param>
            <param name="nearPlaneDistance">Distance to the near view plane.</param>
            <param name="farPlaneDistance">Distance to the far view plane.</param>
            <returns>The perspective projection matrix.</returns>
        </member>
        <member name="M:NCDK.Numerics.Matrix4x4.CreatePerspectiveOffCenter(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Creates a customized, perspective projection matrix.
            </summary>
            <param name="left">Minimum x-value of the view volume at the near view plane.</param>
            <param name="right">Maximum x-value of the view volume at the near view plane.</param>
            <param name="bottom">Minimum y-value of the view volume at the near view plane.</param>
            <param name="top">Maximum y-value of the view volume at the near view plane.</param>
            <param name="nearPlaneDistance">Distance to the near view plane.</param>
            <param name="farPlaneDistance">Distance to of the far view plane.</param>
            <returns>The perspective projection matrix.</returns>
        </member>
        <member name="M:NCDK.Numerics.Matrix4x4.CreateOrthographic(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Creates an orthographic perspective matrix from the given view volume dimensions.
            </summary>
            <param name="width">Width of the view volume.</param>
            <param name="height">Height of the view volume.</param>
            <param name="zNearPlane">Minimum Z-value of the view volume.</param>
            <param name="zFarPlane">Maximum Z-value of the view volume.</param>
            <returns>The orthographic projection matrix.</returns>
        </member>
        <member name="M:NCDK.Numerics.Matrix4x4.CreateOrthographicOffCenter(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Builds a customized, orthographic projection matrix.
            </summary>
            <param name="left">Minimum X-value of the view volume.</param>
            <param name="right">Maximum X-value of the view volume.</param>
            <param name="bottom">Minimum Y-value of the view volume.</param>
            <param name="top">Maximum Y-value of the view volume.</param>
            <param name="zNearPlane">Minimum Z-value of the view volume.</param>
            <param name="zFarPlane">Maximum Z-value of the view volume.</param>
            <returns>The orthographic projection matrix.</returns>
        </member>
        <member name="M:NCDK.Numerics.Matrix4x4.CreateLookAt(NCDK.Numerics.Vector3,NCDK.Numerics.Vector3,NCDK.Numerics.Vector3)">
            <summary>
            Creates a view matrix.
            </summary>
            <param name="cameraPosition">The position of the camera.</param>
            <param name="cameraTarget">The target towards which the camera is pointing.</param>
            <param name="cameraUpVector">The direction that is "up" from the camera's point of view.</param>
            <returns>The view matrix.</returns>
        </member>
        <member name="M:NCDK.Numerics.Matrix4x4.CreateWorld(NCDK.Numerics.Vector3,NCDK.Numerics.Vector3,NCDK.Numerics.Vector3)">
            <summary>
            Creates a world matrix with the specified parameters.
            </summary>
            <param name="position">The position of the object; used in translation operations.</param>
            <param name="forward">Forward direction of the object.</param>
            <param name="up">Upward direction of the object; usually [0, 1, 0].</param>
            <returns>The world matrix.</returns>
        </member>
        <member name="M:NCDK.Numerics.Matrix4x4.CreateFromQuaternion(NCDK.Numerics.Quaternion)">
            <summary>
            Creates a rotation matrix from the given Quaternion rotation value.
            </summary>
            <param name="quaternion">The source Quaternion.</param>
            <returns>The rotation matrix.</returns>
        </member>
        <member name="M:NCDK.Numerics.Matrix4x4.CreateFromYawPitchRoll(System.Double,System.Double,System.Double)">
            <summary>
            Creates a rotation matrix from the specified yaw, pitch, and roll.
            </summary>
            <param name="yaw">Angle of rotation, in radians, around the Y-axis.</param>
            <param name="pitch">Angle of rotation, in radians, around the X-axis.</param>
            <param name="roll">Angle of rotation, in radians, around the Z-axis.</param>
            <returns>The rotation matrix.</returns>
        </member>
        <member name="M:NCDK.Numerics.Matrix4x4.CreateShadow(NCDK.Numerics.Vector3,NCDK.Numerics.Plane)">
            <summary>
            Creates a Matrix that flattens geometry into a specified Plane as if casting a shadow from a specified light source.
            </summary>
            <param name="lightDirection">The direction from which the light that will cast the shadow is coming.</param>
            <param name="plane">The Plane onto which the new matrix should flatten geometry so as to cast a shadow.</param>
            <returns>A new Matrix that can be used to flatten geometry onto the specified plane from the specified direction.</returns>
        </member>
        <member name="M:NCDK.Numerics.Matrix4x4.CreateReflection(NCDK.Numerics.Plane)">
            <summary>
            Creates a Matrix that reflects the coordinate system about a specified Plane.
            </summary>
            <param name="value">The Plane about which to create a reflection.</param>
            <returns>A new matrix expressing the reflection.</returns>
        </member>
        <member name="M:NCDK.Numerics.Matrix4x4.GetDeterminant">
            <summary>
            Calculates the determinant of the matrix.
            </summary>
            <returns>The determinant of the matrix.</returns>
        </member>
        <member name="M:NCDK.Numerics.Matrix4x4.Invert(NCDK.Numerics.Matrix4x4,NCDK.Numerics.Matrix4x4@)">
            <summary>
            Attempts to calculate the inverse of the given matrix. If successful, result will contain the inverted matrix.
            </summary>
            <param name="matrix">The source matrix to invert.</param>
            <param name="result">If successful, contains the inverted matrix.</param>
            <returns>True if the source matrix could be inverted; False otherwise.</returns>
        </member>
        <member name="M:NCDK.Numerics.Matrix4x4.Decompose(NCDK.Numerics.Matrix4x4,NCDK.Numerics.Vector3@,NCDK.Numerics.Quaternion@,NCDK.Numerics.Vector3@)">
            <summary>
            Attempts to extract the scale, translation, and rotation components from the given scale/rotation/translation matrix.
            If successful, the out parameters will contained the extracted values.
            </summary>
            <param name="matrix">The source matrix.</param>
            <param name="scale">The scaling component of the transformation matrix.</param>
            <param name="rotation">The rotation component of the transformation matrix.</param>
            <param name="translation">The translation component of the transformation matrix</param>
            <returns>True if the source matrix was successfully decomposed; False otherwise.</returns>
        </member>
        <member name="M:NCDK.Numerics.Matrix4x4.Transform(NCDK.Numerics.Matrix4x4,NCDK.Numerics.Quaternion)">
            <summary>
            Transforms the given matrix by applying the given Quaternion rotation.
            </summary>
            <param name="value">The source matrix to transform.</param>
            <param name="rotation">The rotation to apply.</param>
            <returns>The transformed matrix.</returns>
        </member>
        <member name="M:NCDK.Numerics.Matrix4x4.Transpose(NCDK.Numerics.Matrix4x4)">
            <summary>
            Transposes the rows and columns of a matrix.
            </summary>
            <param name="matrix">The source matrix.</param>
            <returns>The transposed matrix.</returns>
        </member>
        <member name="M:NCDK.Numerics.Matrix4x4.Lerp(NCDK.Numerics.Matrix4x4,NCDK.Numerics.Matrix4x4,System.Double)">
            <summary>
            Linearly interpolates between the corresponding values of two matrices.
            </summary>
            <param name="matrix1">The first source matrix.</param>
            <param name="matrix2">The second source matrix.</param>
            <param name="amount">The relative weight of the second source matrix.</param>
            <returns>The interpolated matrix.</returns>
        </member>
        <member name="M:NCDK.Numerics.Matrix4x4.Negate(NCDK.Numerics.Matrix4x4)">
            <summary>
            Returns a new matrix with the negated elements of the given matrix.
            </summary>
            <param name="value">The source matrix.</param>
            <returns>The negated matrix.</returns>
        </member>
        <member name="M:NCDK.Numerics.Matrix4x4.Add(NCDK.Numerics.Matrix4x4,NCDK.Numerics.Matrix4x4)">
            <summary>
            Adds two matrices together.
            </summary>
            <param name="value1">The first source matrix.</param>
            <param name="value2">The second source matrix.</param>
            <returns>The resulting matrix.</returns>
        </member>
        <member name="M:NCDK.Numerics.Matrix4x4.Subtract(NCDK.Numerics.Matrix4x4,NCDK.Numerics.Matrix4x4)">
            <summary>
            Subtracts the second matrix from the first.
            </summary>
            <param name="value1">The first source matrix.</param>
            <param name="value2">The second source matrix.</param>
            <returns>The result of the subtraction.</returns>
        </member>
        <member name="M:NCDK.Numerics.Matrix4x4.Multiply(NCDK.Numerics.Matrix4x4,NCDK.Numerics.Matrix4x4)">
            <summary>
            Multiplies a matrix by another matrix.
            </summary>
            <param name="value1">The first source matrix.</param>
            <param name="value2">The second source matrix.</param>
            <returns>The result of the multiplication.</returns>
        </member>
        <member name="M:NCDK.Numerics.Matrix4x4.Multiply(NCDK.Numerics.Matrix4x4,System.Double)">
            <summary>
            Multiplies a matrix by a scalar value.
            </summary>
            <param name="value1">The source matrix.</param>
            <param name="value2">The scaling factor.</param>
            <returns>The scaled matrix.</returns>
        </member>
        <member name="M:NCDK.Numerics.Matrix4x4.op_UnaryNegation(NCDK.Numerics.Matrix4x4)">
            <summary>
            Returns a new matrix with the negated elements of the given matrix.
            </summary>
            <param name="value">The source matrix.</param>
            <returns>The negated matrix.</returns>
        </member>
        <member name="M:NCDK.Numerics.Matrix4x4.op_Addition(NCDK.Numerics.Matrix4x4,NCDK.Numerics.Matrix4x4)">
            <summary>
            Adds two matrices together.
            </summary>
            <param name="value1">The first source matrix.</param>
            <param name="value2">The second source matrix.</param>
            <returns>The resulting matrix.</returns>
        </member>
        <member name="M:NCDK.Numerics.Matrix4x4.op_Subtraction(NCDK.Numerics.Matrix4x4,NCDK.Numerics.Matrix4x4)">
            <summary>
            Subtracts the second matrix from the first.
            </summary>
            <param name="value1">The first source matrix.</param>
            <param name="value2">The second source matrix.</param>
            <returns>The result of the subtraction.</returns>
        </member>
        <member name="M:NCDK.Numerics.Matrix4x4.op_Multiply(NCDK.Numerics.Matrix4x4,NCDK.Numerics.Matrix4x4)">
            <summary>
            Multiplies a matrix by another matrix.
            </summary>
            <param name="value1">The first source matrix.</param>
            <param name="value2">The second source matrix.</param>
            <returns>The result of the multiplication.</returns>
        </member>
        <member name="M:NCDK.Numerics.Matrix4x4.op_Multiply(NCDK.Numerics.Matrix4x4,System.Double)">
            <summary>
            Multiplies a matrix by a scalar value.
            </summary>
            <param name="value1">The source matrix.</param>
            <param name="value2">The scaling factor.</param>
            <returns>The scaled matrix.</returns>
        </member>
        <member name="M:NCDK.Numerics.Matrix4x4.op_Equality(NCDK.Numerics.Matrix4x4,NCDK.Numerics.Matrix4x4)">
            <summary>
            Returns a bool indicating whether the given two matrices are equal.
            </summary>
            <param name="value1">The first matrix to compare.</param>
            <param name="value2">The second matrix to compare.</param>
            <returns>True if the given matrices are equal; False otherwise.</returns>
        </member>
        <member name="M:NCDK.Numerics.Matrix4x4.op_Inequality(NCDK.Numerics.Matrix4x4,NCDK.Numerics.Matrix4x4)">
            <summary>
            Returns a bool indicating whether the given two matrices are not equal.
            </summary>
            <param name="value1">The first matrix to compare.</param>
            <param name="value2">The second matrix to compare.</param>
            <returns>True if the given matrices are not equal; False if they are equal.</returns>
        </member>
        <member name="M:NCDK.Numerics.Matrix4x4.Equals(NCDK.Numerics.Matrix4x4)">
            <summary>
            Returns a bool indicating whether this matrix instance is equal to the other given matrix.
            </summary>
            <param name="other">The matrix to compare this instance to.</param>
            <returns>True if the matrices are equal; False otherwise.</returns>
        </member>
        <member name="M:NCDK.Numerics.Matrix4x4.Equals(System.Object)">
            <summary>
            Returns a bool indicating whether the given Object is equal to this matrix instance.
            </summary>
            <param name="obj">The Object to compare against.</param>
            <returns>True if the Object is equal to this matrix; False otherwise.</returns>
        </member>
        <member name="M:NCDK.Numerics.Matrix4x4.ToString">
            <summary>
            Returns a string representing this matrix instance.
            </summary>
            <returns>The string representation.</returns>
        </member>
        <member name="M:NCDK.Numerics.Matrix4x4.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <returns>The hash code.</returns>
        </member>
        <member name="T:NCDK.Numerics.Plane">
            <summary>
            A structure encapsulating a 3D Plane
            </summary>
        </member>
        <member name="F:NCDK.Numerics.Plane.Normal">
            <summary>
            The normal vector of the Plane.
            </summary>
        </member>
        <member name="F:NCDK.Numerics.Plane.D">
            <summary>
            The distance of the Plane along its normal from the origin.
            </summary>
        </member>
        <member name="M:NCDK.Numerics.Plane.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Constructs a Plane from the X, Y, and Z components of its normal, and its distance from the origin on that normal.
            </summary>
            <param name="x">The X-component of the normal.</param>
            <param name="y">The Y-component of the normal.</param>
            <param name="z">The Z-component of the normal.</param>
            <param name="d">The distance of the Plane along its normal from the origin.</param>
        </member>
        <member name="M:NCDK.Numerics.Plane.#ctor(NCDK.Numerics.Vector3,System.Double)">
            <summary>
            Constructs a Plane from the given normal and distance along the normal from the origin.
            </summary>
            <param name="normal">The Plane's normal vector.</param>
            <param name="d">The Plane's distance from the origin along its normal vector.</param>
        </member>
        <member name="M:NCDK.Numerics.Plane.#ctor(NCDK.Numerics.Vector4)">
            <summary>
            Constructs a Plane from the given Vector4.
            </summary>
            <param name="value">A vector whose first 3 elements describe the normal vector, 
            and whose W component defines the distance along that normal from the origin.</param>
        </member>
        <member name="M:NCDK.Numerics.Plane.CreateFromVertices(NCDK.Numerics.Vector3,NCDK.Numerics.Vector3,NCDK.Numerics.Vector3)">
            <summary>
            Creates a Plane that contains the three given points.
            </summary>
            <param name="point1">The first point defining the Plane.</param>
            <param name="point2">The second point defining the Plane.</param>
            <param name="point3">The third point defining the Plane.</param>
            <returns>The Plane containing the three points.</returns>
        </member>
        <member name="M:NCDK.Numerics.Plane.Normalize(NCDK.Numerics.Plane)">
            <summary>
            Creates a new Plane whose normal vector is the source Plane's normal vector normalized.
            </summary>
            <param name="value">The source Plane.</param>
            <returns>The normalized Plane.</returns>
        </member>
        <member name="M:NCDK.Numerics.Plane.Transform(NCDK.Numerics.Plane,NCDK.Numerics.Matrix4x4)">
            <summary>
            Transforms a normalized Plane by a Matrix.
            </summary>
            <param name="plane"> The normalized Plane to transform. 
            This Plane must already be normalized, so that its Normal vector is of unit length, before this method is called.</param>
            <param name="matrix">The transformation matrix to apply to the Plane.</param>
            <returns>The transformed Plane.</returns>
        </member>
        <member name="M:NCDK.Numerics.Plane.Transform(NCDK.Numerics.Plane,NCDK.Numerics.Quaternion)">
            <summary>
             Transforms a normalized Plane by a Quaternion rotation.
            </summary>
            <param name="plane"> The normalized Plane to transform.
            This Plane must already be normalized, so that its Normal vector is of unit length, before this method is called.</param>
            <param name="rotation">The Quaternion rotation to apply to the Plane.</param>
            <returns>A new Plane that results from applying the rotation.</returns>
        </member>
        <member name="M:NCDK.Numerics.Plane.Dot(NCDK.Numerics.Plane,NCDK.Numerics.Vector4)">
            <summary>
            Calculates the dot product of a Plane and Vector4.
            </summary>
            <param name="plane">The Plane.</param>
            <param name="value">The Vector4.</param>
            <returns>The dot product.</returns>
        </member>
        <member name="M:NCDK.Numerics.Plane.DotCoordinate(NCDK.Numerics.Plane,NCDK.Numerics.Vector3)">
            <summary>
            Returns the dot product of a specified Vector3 and the normal vector of this Plane plus the distance (D) value of the Plane.
            </summary>
            <param name="plane">The plane.</param>
            <param name="value">The Vector3.</param>
            <returns>The resulting value.</returns>
        </member>
        <member name="M:NCDK.Numerics.Plane.DotNormal(NCDK.Numerics.Plane,NCDK.Numerics.Vector3)">
            <summary>
            Returns the dot product of a specified Vector3 and the Normal vector of this Plane.
            </summary>
            <param name="plane">The plane.</param>
            <param name="value">The Vector3.</param>
            <returns>The resulting dot product.</returns>
        </member>
        <member name="M:NCDK.Numerics.Plane.op_Equality(NCDK.Numerics.Plane,NCDK.Numerics.Plane)">
            <summary>
            Returns a bool indicating whether the two given Planes are equal.
            </summary>
            <param name="value1">The first Plane to compare.</param>
            <param name="value2">The second Plane to compare.</param>
            <returns>True if the Planes are equal; False otherwise.</returns>
        </member>
        <member name="M:NCDK.Numerics.Plane.op_Inequality(NCDK.Numerics.Plane,NCDK.Numerics.Plane)">
            <summary>
            Returns a bool indicating whether the two given Planes are not equal.
            </summary>
            <param name="value1">The first Plane to compare.</param>
            <param name="value2">The second Plane to compare.</param>
            <returns>True if the Planes are not equal; False if they are equal.</returns>
        </member>
        <member name="M:NCDK.Numerics.Plane.Equals(NCDK.Numerics.Plane)">
            <summary>
            Returns a bool indicating whether the given Plane is equal to this Plane instance.
            </summary>
            <param name="other">The Plane to compare this instance to.</param>
            <returns>True if the other Plane is equal to this instance; False otherwise.</returns>
        </member>
        <member name="M:NCDK.Numerics.Plane.Equals(System.Object)">
            <summary>
            Returns a bool indicating whether the given Object is equal to this Plane instance.
            </summary>
            <param name="obj">The Object to compare against.</param>
            <returns>True if the Object is equal to this Plane; False otherwise.</returns>
        </member>
        <member name="M:NCDK.Numerics.Plane.ToString">
            <summary>
            Returns a string representing this Plane instance.
            </summary>
            <returns>The string representation.</returns>
        </member>
        <member name="M:NCDK.Numerics.Plane.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <returns>The hash code.</returns>
        </member>
        <member name="T:NCDK.Numerics.Quaternion">
            <summary>
            A structure encapsulating a four-dimensional vector (x,y,z,w), 
            which is used to efficiently rotate an object about the (x,y,z) vector by the angle theta, where w = Cos(theta/2).
            </summary>
        </member>
        <member name="F:NCDK.Numerics.Quaternion.X">
            <summary>
            Specifies the X-value of the vector component of the Quaternion.
            </summary>
        </member>
        <member name="F:NCDK.Numerics.Quaternion.Y">
            <summary>
            Specifies the Y-value of the vector component of the Quaternion.
            </summary>
        </member>
        <member name="F:NCDK.Numerics.Quaternion.Z">
            <summary>
            Specifies the Z-value of the vector component of the Quaternion.
            </summary>
        </member>
        <member name="F:NCDK.Numerics.Quaternion.W">
            <summary>
            Specifies the rotation component of the Quaternion.
            </summary>
        </member>
        <member name="P:NCDK.Numerics.Quaternion.Identity">
            <summary>
            Returns a Quaternion representing no rotation. 
            </summary>
        </member>
        <member name="P:NCDK.Numerics.Quaternion.IsIdentity">
            <summary>
            Returns whether the Quaternion is the identity Quaternion.
            </summary>
        </member>
        <member name="M:NCDK.Numerics.Quaternion.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Constructs a Quaternion from the given components.
            </summary>
            <param name="x">The X component of the Quaternion.</param>
            <param name="y">The Y component of the Quaternion.</param>
            <param name="z">The Z component of the Quaternion.</param>
            <param name="w">The W component of the Quaternion.</param>
        </member>
        <member name="M:NCDK.Numerics.Quaternion.#ctor(NCDK.Numerics.Vector3,System.Double)">
            <summary>
            Constructs a Quaternion from the given vector and rotation parts.
            </summary>
            <param name="vectorPart">The vector part of the Quaternion.</param>
            <param name="scalarPart">The rotation part of the Quaternion.</param>
        </member>
        <member name="M:NCDK.Numerics.Quaternion.Length">
            <summary>
            Calculates the length of the Quaternion.
            </summary>
            <returns>The computed length of the Quaternion.</returns>
        </member>
        <member name="M:NCDK.Numerics.Quaternion.LengthSquared">
            <summary>
            Calculates the length squared of the Quaternion. This operation is cheaper than Length().
            </summary>
            <returns>The length squared of the Quaternion.</returns>
        </member>
        <member name="M:NCDK.Numerics.Quaternion.Normalize(NCDK.Numerics.Quaternion)">
            <summary>
            Divides each component of the Quaternion by the length of the Quaternion.
            </summary>
            <param name="value">The source Quaternion.</param>
            <returns>The normalized Quaternion.</returns>
        </member>
        <member name="M:NCDK.Numerics.Quaternion.Conjugate(NCDK.Numerics.Quaternion)">
            <summary>
            Creates the conjugate of a specified Quaternion.
            </summary>
            <param name="value">The Quaternion of which to return the conjugate.</param>
            <returns>A new Quaternion that is the conjugate of the specified one.</returns>
        </member>
        <member name="M:NCDK.Numerics.Quaternion.Inverse(NCDK.Numerics.Quaternion)">
            <summary>
            Returns the inverse of a Quaternion.
            </summary>
            <param name="value">The source Quaternion.</param>
            <returns>The inverted Quaternion.</returns>
        </member>
        <member name="M:NCDK.Numerics.Quaternion.CreateFromAxisAngle(NCDK.Numerics.Vector3,System.Double)">
            <summary>
            Creates a Quaternion from a normalized vector axis and an angle to rotate about the vector.
            </summary>
            <param name="axis">The unit vector to rotate around.
            This vector must be normalized before calling this function or the resulting Quaternion will be incorrect.</param>
            <param name="angle">The angle, in radians, to rotate around the vector.</param>
            <returns>The created Quaternion.</returns>
        </member>
        <member name="M:NCDK.Numerics.Quaternion.CreateFromYawPitchRoll(System.Double,System.Double,System.Double)">
            <summary>
            Creates a new Quaternion from the given yaw, pitch, and roll, in radians.
            </summary>
            <param name="yaw">The yaw angle, in radians, around the Y-axis.</param>
            <param name="pitch">The pitch angle, in radians, around the X-axis.</param>
            <param name="roll">The roll angle, in radians, around the Z-axis.</param>
            <returns></returns>
        </member>
        <member name="M:NCDK.Numerics.Quaternion.CreateFromRotationMatrix(NCDK.Numerics.Matrix4x4)">
            <summary>
            Creates a Quaternion from the given rotation matrix.
            </summary>
            <param name="matrix">The rotation matrix.</param>
            <returns>The created Quaternion.</returns>
        </member>
        <member name="M:NCDK.Numerics.Quaternion.Dot(NCDK.Numerics.Quaternion,NCDK.Numerics.Quaternion)">
            <summary>
            Calculates the dot product of two Quaternions.
            </summary>
            <param name="quaternion1">The first source Quaternion.</param>
            <param name="quaternion2">The second source Quaternion.</param>
            <returns>The dot product of the Quaternions.</returns>
        </member>
        <member name="M:NCDK.Numerics.Quaternion.Slerp(NCDK.Numerics.Quaternion,NCDK.Numerics.Quaternion,System.Double)">
            <summary>
            Interpolates between two quaternions, using spherical linear interpolation.
            </summary>
            <param name="quaternion1">The first source Quaternion.</param>
            <param name="quaternion2">The second source Quaternion.</param>
            <param name="amount">The relative weight of the second source Quaternion in the interpolation.</param>
            <returns>The interpolated Quaternion.</returns>
        </member>
        <member name="M:NCDK.Numerics.Quaternion.Lerp(NCDK.Numerics.Quaternion,NCDK.Numerics.Quaternion,System.Double)">
            <summary>
             Linearly interpolates between two quaternions.
            </summary>
            <param name="quaternion1">The first source Quaternion.</param>
            <param name="quaternion2">The second source Quaternion.</param>
            <param name="amount">The relative weight of the second source Quaternion in the interpolation.</param>
            <returns>The interpolated Quaternion.</returns>
        </member>
        <member name="M:NCDK.Numerics.Quaternion.Concatenate(NCDK.Numerics.Quaternion,NCDK.Numerics.Quaternion)">
            <summary>
            Concatenates two Quaternions; the result represents the value1 rotation followed by the value2 rotation.
            </summary>
            <param name="value1">The first Quaternion rotation in the series.</param>
            <param name="value2">The second Quaternion rotation in the series.</param>
            <returns>A new Quaternion representing the concatenation of the value1 rotation followed by the value2 rotation.</returns>
        </member>
        <member name="M:NCDK.Numerics.Quaternion.Negate(NCDK.Numerics.Quaternion)">
            <summary>
            Flips the sign of each component of the quaternion.
            </summary>
            <param name="value">The source Quaternion.</param>
            <returns>The negated Quaternion.</returns>
        </member>
        <member name="M:NCDK.Numerics.Quaternion.Add(NCDK.Numerics.Quaternion,NCDK.Numerics.Quaternion)">
            <summary>
            Adds two Quaternions element-by-element.
            </summary>
            <param name="value1">The first source Quaternion.</param>
            <param name="value2">The second source Quaternion.</param>
            <returns>The result of adding the Quaternions.</returns>
        </member>
        <member name="M:NCDK.Numerics.Quaternion.Subtract(NCDK.Numerics.Quaternion,NCDK.Numerics.Quaternion)">
            <summary>
            Subtracts one Quaternion from another.
            </summary>
            <param name="value1">The first source Quaternion.</param>
            <param name="value2">The second Quaternion, to be subtracted from the first.</param>
            <returns>The result of the subtraction.</returns>
        </member>
        <member name="M:NCDK.Numerics.Quaternion.Multiply(NCDK.Numerics.Quaternion,NCDK.Numerics.Quaternion)">
            <summary>
            Multiplies two Quaternions together.
            </summary>
            <param name="value1">The Quaternion on the left side of the multiplication.</param>
            <param name="value2">The Quaternion on the right side of the multiplication.</param>
            <returns>The result of the multiplication.</returns>
        </member>
        <member name="M:NCDK.Numerics.Quaternion.Multiply(NCDK.Numerics.Quaternion,System.Double)">
            <summary>
            Multiplies a Quaternion by a scalar value.
            </summary>
            <param name="value1">The source Quaternion.</param>
            <param name="value2">The scalar value.</param>
            <returns>The result of the multiplication.</returns>
        </member>
        <member name="M:NCDK.Numerics.Quaternion.Divide(NCDK.Numerics.Quaternion,NCDK.Numerics.Quaternion)">
            <summary>
            Divides a Quaternion by another Quaternion.
            </summary>
            <param name="value1">The source Quaternion.</param>
            <param name="value2">The divisor.</param>
            <returns>The result of the division.</returns>
        </member>
        <member name="M:NCDK.Numerics.Quaternion.op_UnaryNegation(NCDK.Numerics.Quaternion)">
            <summary>
            Flips the sign of each component of the quaternion.
            </summary>
            <param name="value">The source Quaternion.</param>
            <returns>The negated Quaternion.</returns>
        </member>
        <member name="M:NCDK.Numerics.Quaternion.op_Addition(NCDK.Numerics.Quaternion,NCDK.Numerics.Quaternion)">
            <summary>
            Adds two Quaternions element-by-element.
            </summary>
            <param name="value1">The first source Quaternion.</param>
            <param name="value2">The second source Quaternion.</param>
            <returns>The result of adding the Quaternions.</returns>
        </member>
        <member name="M:NCDK.Numerics.Quaternion.op_Subtraction(NCDK.Numerics.Quaternion,NCDK.Numerics.Quaternion)">
            <summary>
            Subtracts one Quaternion from another.
            </summary>
            <param name="value1">The first source Quaternion.</param>
            <param name="value2">The second Quaternion, to be subtracted from the first.</param>
            <returns>The result of the subtraction.</returns>
        </member>
        <member name="M:NCDK.Numerics.Quaternion.op_Multiply(NCDK.Numerics.Quaternion,NCDK.Numerics.Quaternion)">
            <summary>
            Multiplies two Quaternions together.
            </summary>
            <param name="value1">The Quaternion on the left side of the multiplication.</param>
            <param name="value2">The Quaternion on the right side of the multiplication.</param>
            <returns>The result of the multiplication.</returns>
        </member>
        <member name="M:NCDK.Numerics.Quaternion.op_Multiply(NCDK.Numerics.Quaternion,System.Double)">
            <summary>
            Multiplies a Quaternion by a scalar value.
            </summary>
            <param name="value1">The source Quaternion.</param>
            <param name="value2">The scalar value.</param>
            <returns>The result of the multiplication.</returns>
        </member>
        <member name="M:NCDK.Numerics.Quaternion.op_Division(NCDK.Numerics.Quaternion,NCDK.Numerics.Quaternion)">
            <summary>
            Divides a Quaternion by another Quaternion.
            </summary>
            <param name="value1">The source Quaternion.</param>
            <param name="value2">The divisor.</param>
            <returns>The result of the division.</returns>
        </member>
        <member name="M:NCDK.Numerics.Quaternion.op_Equality(NCDK.Numerics.Quaternion,NCDK.Numerics.Quaternion)">
            <summary>
            Returns a bool indicating whether the two given Quaternions are equal.
            </summary>
            <param name="value1">The first Quaternion to compare.</param>
            <param name="value2">The second Quaternion to compare.</param>
            <returns>True if the Quaternions are equal; False otherwise.</returns>
        </member>
        <member name="M:NCDK.Numerics.Quaternion.op_Inequality(NCDK.Numerics.Quaternion,NCDK.Numerics.Quaternion)">
            <summary>
            Returns a bool indicating whether the two given Quaternions are not equal.
            </summary>
            <param name="value1">The first Quaternion to compare.</param>
            <param name="value2">The second Quaternion to compare.</param>
            <returns>True if the Quaternions are not equal; False if they are equal.</returns>
        </member>
        <member name="M:NCDK.Numerics.Quaternion.Equals(NCDK.Numerics.Quaternion)">
            <summary>
            Returns a bool indicating whether the given Quaternion is equal to this Quaternion instance.
            </summary>
            <param name="other">The Quaternion to compare this instance to.</param>
            <returns>True if the other Quaternion is equal to this instance; False otherwise.</returns>
        </member>
        <member name="M:NCDK.Numerics.Quaternion.Equals(System.Object)">
            <summary>
            Returns a bool indicating whether the given Object is equal to this Quaternion instance.
            </summary>
            <param name="obj">The Object to compare against.</param>
            <returns>True if the Object is equal to this Quaternion; False otherwise.</returns>
        </member>
        <member name="M:NCDK.Numerics.Quaternion.ToString">
            <summary>
            Returns a string representing this Quaternion instance.
            </summary>
            <returns>The string representation.</returns>
        </member>
        <member name="M:NCDK.Numerics.Quaternion.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <returns>The hash code.</returns>
        </member>
        <member name="T:NCDK.Numerics.Register">
            <summary>
            A structure describing the layout of an SSE2-sized register.
            Contains overlapping fields representing the set of valid numeric types.
            Allows the generic Vector'T struct to contain an explicit field layout.
            </summary>
        </member>
        <member name="T:NCDK.Numerics.Vector`1">
            <summary>
            A structure that represents a single Vector. The count of this Vector is fixed but CPU register dependent.
            This struct only supports numerical types. This type is intended to be used as a building block for vectorizing
            large algorithms. This type is immutable, individual elements cannot be modified.
            </summary>
        </member>
        <member name="P:NCDK.Numerics.Vector`1.Count">
            <summary>
            Returns the number of elements stored in the vector. This value is hardware dependent.
            </summary>
        </member>
        <member name="P:NCDK.Numerics.Vector`1.Zero">
            <summary>
            Returns a vector containing all zeroes.
            </summary>
        </member>
        <member name="P:NCDK.Numerics.Vector`1.One">
            <summary>
            Returns a vector containing all ones.
            </summary>
        </member>
        <member name="M:NCDK.Numerics.Vector`1.#ctor(`0)">
            <summary>
            Constructs a vector whose components are all <code>value</code>
            </summary>
        </member>
        <member name="M:NCDK.Numerics.Vector`1.#ctor(`0[])">
            <summary>
            Constructs a vector from the given array. The size of the given array must be at least Vector'T.Count.
            </summary>
        </member>
        <member name="M:NCDK.Numerics.Vector`1.#ctor(`0[],System.Int32)">
            <summary>
            Constructs a vector from the given array, starting from the given index.
            The array must contain at least Vector'T.Count from the given index.
            </summary>
        </member>
        <member name="M:NCDK.Numerics.Vector`1.CopyTo(`0[])">
            <summary>
            Copies the vector to the given destination array. The destination array must be at least size Vector'T.Count.
            </summary>
            <param name="destination">The destination array which the values are copied into</param>
            <exception cref="T:System.ArgumentNullException">If the destination array is null</exception>
            <exception cref="T:System.ArgumentException">If number of elements in source vector is greater than those available in destination array</exception>
        </member>
        <member name="M:NCDK.Numerics.Vector`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies the vector to the given destination array. The destination array must be at least size Vector'T.Count.
            </summary>
            <param name="destination">The destination array which the values are copied into</param>
            <param name="startIndex">The index to start copying to</param>
            <exception cref="T:System.ArgumentNullException">If the destination array is null</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">If index is greater than end of the array or index is less than zero</exception>
            <exception cref="T:System.ArgumentException">If number of elements in source vector is greater than those available in destination array</exception>
        </member>
        <member name="P:NCDK.Numerics.Vector`1.Item(System.Int32)">
            <summary>
            Returns the element at the given index.
            </summary>
        </member>
        <member name="M:NCDK.Numerics.Vector`1.Equals(System.Object)">
            <summary>
            Returns a bool indicating whether the given Object is equal to this vector instance.
            </summary>
            <param name="obj">The Object to compare against.</param>
            <returns>True if the Object is equal to this vector; False otherwise.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector`1.Equals(NCDK.Numerics.Vector{`0})">
            <summary>
            Returns a bool indicating whether the given vector is equal to this vector instance.
            </summary>
            <param name="other">The vector to compare this instance to.</param>
            <returns>True if the other vector is equal to this instance; False otherwise.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector`1.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <returns>The hash code.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector`1.ToString">
            <summary>
            Returns a string representing this vector.
            </summary>
            <returns>The string representation.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector`1.ToString(System.String)">
            <summary>
            Returns a string representing this vector, using the specified format string to format individual elements.
            </summary>
            <param name="format">The format of individual elements.</param>
            <returns>The string representation.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector`1.ToString(System.String,System.IFormatProvider)">
            <summary>
            Returns a string representing this vector, using the specified format string to format individual elements
            and the given IFormatProvider.
            </summary>
            <param name="format">The format of individual elements.</param>
            <param name="formatProvider">The format provider to use when formatting elements.</param>
            <returns>The string representation.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector`1.op_Addition(NCDK.Numerics.Vector{`0},NCDK.Numerics.Vector{`0})">
            <summary>
            Adds two vectors together.
            </summary>
            <param name="left">The first source vector.</param>
            <param name="right">The second source vector.</param>
            <returns>The summed vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector`1.op_Subtraction(NCDK.Numerics.Vector{`0},NCDK.Numerics.Vector{`0})">
            <summary>
            Subtracts the second vector from the first.
            </summary>
            <param name="left">The first source vector.</param>
            <param name="right">The second source vector.</param>
            <returns>The difference vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector`1.op_Multiply(NCDK.Numerics.Vector{`0},NCDK.Numerics.Vector{`0})">
            <summary>
            Multiplies two vectors together.
            </summary>
            <param name="left">The first source vector.</param>
            <param name="right">The second source vector.</param>
            <returns>The product vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector`1.op_Multiply(NCDK.Numerics.Vector{`0},`0)">
            <summary>
            Multiplies a vector by the given scalar.
            </summary>
            <param name="value">The source vector.</param>
            <param name="factor">The scalar value.</param>
            <returns>The scaled vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector`1.op_Multiply(`0,NCDK.Numerics.Vector{`0})">
            <summary>
            Multiplies a vector by the given scalar.
            </summary>
            <param name="factor">The scalar value.</param>
            <param name="value">The source vector.</param>
            <returns>The scaled vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector`1.op_Division(NCDK.Numerics.Vector{`0},NCDK.Numerics.Vector{`0})">
            <summary>
            Divides the first vector by the second.
            </summary>
            <param name="left">The first source vector.</param>
            <param name="right">The second source vector.</param>
            <returns>The vector resulting from the division.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector`1.op_UnaryNegation(NCDK.Numerics.Vector{`0})">
            <summary>
            Negates a given vector.
            </summary>
            <param name="value">The source vector.</param>
            <returns>The negated vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector`1.op_BitwiseAnd(NCDK.Numerics.Vector{`0},NCDK.Numerics.Vector{`0})">
            <summary>
            Returns a new vector by performing a bitwise-and operation on each of the elements in the given vectors.
            </summary>
            <param name="left">The first source vector.</param>
            <param name="right">The second source vector.</param>
            <returns>The resultant vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector`1.op_BitwiseOr(NCDK.Numerics.Vector{`0},NCDK.Numerics.Vector{`0})">
            <summary>
            Returns a new vector by performing a bitwise-or operation on each of the elements in the given vectors.
            </summary>
            <param name="left">The first source vector.</param>
            <param name="right">The second source vector.</param>
            <returns>The resultant vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector`1.op_ExclusiveOr(NCDK.Numerics.Vector{`0},NCDK.Numerics.Vector{`0})">
            <summary>
            Returns a new vector by performing a bitwise-exclusive-or operation on each of the elements in the given vectors.
            </summary>
            <param name="left">The first source vector.</param>
            <param name="right">The second source vector.</param>
            <returns>The resultant vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector`1.op_OnesComplement(NCDK.Numerics.Vector{`0})">
            <summary>
            Returns a new vector whose elements are obtained by taking the one's complement of the given vector's elements.
            </summary>
            <param name="value">The source vector.</param>
            <returns>The one's complement vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector`1.op_Equality(NCDK.Numerics.Vector{`0},NCDK.Numerics.Vector{`0})">
            <summary>
            Returns a bool indicating whether each pair of elements in the given vectors are equal.
            </summary>
            <param name="left">The first vector to compare.</param>
            <param name="right">The first vector to compare.</param>
            <returns>True if all elements are equal; False otherwise.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector`1.op_Inequality(NCDK.Numerics.Vector{`0},NCDK.Numerics.Vector{`0})">
            <summary>
            Returns a bool indicating whether any single pair of elements in the given vectors are equal.
            </summary>
            <param name="left">The first vector to compare.</param>
            <param name="right">The second vector to compare.</param>
            <returns>True if any element pairs are equal; False if no element pairs are equal.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector`1.op_Explicit(NCDK.Numerics.Vector{`0})~NCDK.Numerics.Vector{System.Byte}">
            <summary>
            Reinterprets the bits of the given vector into those of another type.
            </summary>
            <param name="value">The source vector</param>
            <returns>The reinterpreted vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector`1.op_Explicit(NCDK.Numerics.Vector{`0})~NCDK.Numerics.Vector{System.SByte}">
            <summary>
            Reinterprets the bits of the given vector into those of another type.
            </summary>
            <param name="value">The source vector</param>
            <returns>The reinterpreted vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector`1.op_Explicit(NCDK.Numerics.Vector{`0})~NCDK.Numerics.Vector{System.UInt16}">
            <summary>
            Reinterprets the bits of the given vector into those of another type.
            </summary>
            <param name="value">The source vector</param>
            <returns>The reinterpreted vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector`1.op_Explicit(NCDK.Numerics.Vector{`0})~NCDK.Numerics.Vector{System.Int16}">
            <summary>
            Reinterprets the bits of the given vector into those of another type.
            </summary>
            <param name="value">The source vector</param>
            <returns>The reinterpreted vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector`1.op_Explicit(NCDK.Numerics.Vector{`0})~NCDK.Numerics.Vector{System.UInt32}">
            <summary>
            Reinterprets the bits of the given vector into those of another type.
            </summary>
            <param name="value">The source vector</param>
            <returns>The reinterpreted vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector`1.op_Explicit(NCDK.Numerics.Vector{`0})~NCDK.Numerics.Vector{System.Int32}">
            <summary>
            Reinterprets the bits of the given vector into those of another type.
            </summary>
            <param name="value">The source vector</param>
            <returns>The reinterpreted vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector`1.op_Explicit(NCDK.Numerics.Vector{`0})~NCDK.Numerics.Vector{System.UInt64}">
            <summary>
            Reinterprets the bits of the given vector into those of another type.
            </summary>
            <param name="value">The source vector</param>
            <returns>The reinterpreted vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector`1.op_Explicit(NCDK.Numerics.Vector{`0})~NCDK.Numerics.Vector{System.Int64}">
            <summary>
            Reinterprets the bits of the given vector into those of another type.
            </summary>
            <param name="value">The source vector</param>
            <returns>The reinterpreted vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector`1.op_Explicit(NCDK.Numerics.Vector{`0})~NCDK.Numerics.Vector{System.Single}">
            <summary>
            Reinterprets the bits of the given vector into those of another type.
            </summary>
            <param name="value">The source vector</param>
            <returns>The reinterpreted vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector`1.op_Explicit(NCDK.Numerics.Vector{`0})~NCDK.Numerics.Vector{System.Double}">
            <summary>
            Reinterprets the bits of the given vector into those of another type.
            </summary>
            <param name="value">The source vector</param>
            <returns>The reinterpreted vector.</returns>
        </member>
        <member name="T:NCDK.Numerics.Vector2">
            <summary>
            A structure encapsulating two single precision floating point values and provides hardware accelerated methods.
            </summary>
        </member>
        <member name="P:NCDK.Numerics.Vector2.Zero">
            <summary>
            Returns the vector (0,0).
            </summary>
        </member>
        <member name="P:NCDK.Numerics.Vector2.One">
            <summary>
            Returns the vector (1,1).
            </summary>
        </member>
        <member name="P:NCDK.Numerics.Vector2.UnitX">
            <summary>
            Returns the vector (1,0).
            </summary>
        </member>
        <member name="P:NCDK.Numerics.Vector2.UnitY">
            <summary>
            Returns the vector (0,1).
            </summary>
        </member>
        <member name="M:NCDK.Numerics.Vector2.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <returns>The hash code.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector2.Equals(System.Object)">
            <summary>
            Returns a bool indicating whether the given Object is equal to this Vector2 instance.
            </summary>
            <param name="obj">The Object to compare against.</param>
            <returns>True if the Object is equal to this Vector2; False otherwise.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector2.ToString">
            <summary>
            Returns a string representing this Vector2 instance.
            </summary>
            <returns>The string representation.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector2.ToString(System.String)">
            <summary>
            Returns a string representing this Vector2 instance, using the specified format to format individual elements.
            </summary>
            <param name="format">The format of individual elements.</param>
            <returns>The string representation.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector2.ToString(System.String,System.IFormatProvider)">
            <summary>
            Returns a string representing this Vector2 instance, using the specified format to format individual elements 
            and the given IFormatProvider.
            </summary>
            <param name="format">The format of individual elements.</param>
            <param name="formatProvider">The format provider to use when formatting elements.</param>
            <returns>The string representation.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector2.Length">
            <summary>
            Returns the length of the vector.
            </summary>
            <returns>The vector's length.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector2.LengthSquared">
            <summary>
            Returns the length of the vector squared. This operation is cheaper than Length().
            </summary>
            <returns>The vector's length squared.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector2.Distance(NCDK.Numerics.Vector2,NCDK.Numerics.Vector2)">
            <summary>
            Returns the Euclidean distance between the two given points.
            </summary>
            <param name="value1">The first point.</param>
            <param name="value2">The second point.</param>
            <returns>The distance.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector2.DistanceSquared(NCDK.Numerics.Vector2,NCDK.Numerics.Vector2)">
            <summary>
            Returns the Euclidean distance squared between the two given points.
            </summary>
            <param name="value1">The first point.</param>
            <param name="value2">The second point.</param>
            <returns>The distance squared.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector2.Normalize(NCDK.Numerics.Vector2)">
            <summary>
            Returns a vector with the same direction as the given vector, but with a length of 1.
            </summary>
            <param name="value">The vector to normalize.</param>
            <returns>The normalized vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector2.Reflect(NCDK.Numerics.Vector2,NCDK.Numerics.Vector2)">
            <summary>
            Returns the reflection of a vector off a surface that has the specified normal.
            </summary>
            <param name="vector">The source vector.</param>
            <param name="normal">The normal of the surface being reflected off.</param>
            <returns>The reflected vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector2.Clamp(NCDK.Numerics.Vector2,NCDK.Numerics.Vector2,NCDK.Numerics.Vector2)">
            <summary>
            Restricts a vector between a min and max value.
            </summary>
            <param name="value1">The source vector.</param>
            <param name="min">The minimum value.</param>
            <param name="max">The maximum value.</param>
        </member>
        <member name="M:NCDK.Numerics.Vector2.Lerp(NCDK.Numerics.Vector2,NCDK.Numerics.Vector2,System.Double)">
            <summary>
            Linearly interpolates between two vectors based on the given weighting.
            </summary>
            <param name="value1">The first source vector.</param>
            <param name="value2">The second source vector.</param>
            <param name="amount">Value between 0 and 1 indicating the weight of the second source vector.</param>
            <returns>The interpolated vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector2.Transform(NCDK.Numerics.Vector2,NCDK.Numerics.Matrix3x2)">
            <summary>
            Transforms a vector by the given matrix.
            </summary>
            <param name="position">The source vector.</param>
            <param name="matrix">The transformation matrix.</param>
            <returns>The transformed vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector2.Transform(NCDK.Numerics.Vector2,NCDK.Numerics.Matrix4x4)">
            <summary>
            Transforms a vector by the given matrix.
            </summary>
            <param name="position">The source vector.</param>
            <param name="matrix">The transformation matrix.</param>
            <returns>The transformed vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector2.TransformNormal(NCDK.Numerics.Vector2,NCDK.Numerics.Matrix3x2)">
            <summary>
            Transforms a vector normal by the given matrix.
            </summary>
            <param name="normal">The source vector.</param>
            <param name="matrix">The transformation matrix.</param>
            <returns>The transformed vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector2.TransformNormal(NCDK.Numerics.Vector2,NCDK.Numerics.Matrix4x4)">
            <summary>
            Transforms a vector normal by the given matrix.
            </summary>
            <param name="normal">The source vector.</param>
            <param name="matrix">The transformation matrix.</param>
            <returns>The transformed vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector2.Transform(NCDK.Numerics.Vector2,NCDK.Numerics.Quaternion)">
            <summary>
            Transforms a vector by the given Quaternion rotation value.
            </summary>
            <param name="value">The source vector to be rotated.</param>
            <param name="rotation">The rotation to apply.</param>
            <returns>The transformed vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector2.Add(NCDK.Numerics.Vector2,NCDK.Numerics.Vector2)">
            <summary>
            Adds two vectors together.
            </summary>
            <param name="left">The first source vector.</param>
            <param name="right">The second source vector.</param>
            <returns>The summed vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector2.Subtract(NCDK.Numerics.Vector2,NCDK.Numerics.Vector2)">
            <summary>
            Subtracts the second vector from the first.
            </summary>
            <param name="left">The first source vector.</param>
            <param name="right">The second source vector.</param>
            <returns>The difference vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector2.Multiply(NCDK.Numerics.Vector2,NCDK.Numerics.Vector2)">
            <summary>
            Multiplies two vectors together.
            </summary>
            <param name="left">The first source vector.</param>
            <param name="right">The second source vector.</param>
            <returns>The product vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector2.Multiply(NCDK.Numerics.Vector2,System.Single)">
            <summary>
            Multiplies a vector by the given scalar.
            </summary>
            <param name="left">The source vector.</param>
            <param name="right">The scalar value.</param>
            <returns>The scaled vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector2.Multiply(System.Single,NCDK.Numerics.Vector2)">
            <summary>
            Multiplies a vector by the given scalar.
            </summary>
            <param name="left">The scalar value.</param>
            <param name="right">The source vector.</param>
            <returns>The scaled vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector2.Divide(NCDK.Numerics.Vector2,NCDK.Numerics.Vector2)">
            <summary>
            Divides the first vector by the second.
            </summary>
            <param name="left">The first source vector.</param>
            <param name="right">The second source vector.</param>
            <returns>The vector resulting from the division.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector2.Divide(NCDK.Numerics.Vector2,System.Single)">
            <summary>
            Divides the vector by the given scalar.
            </summary>
            <param name="left">The source vector.</param>
            <param name="divisor">The scalar value.</param>
            <returns>The result of the division.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector2.Negate(NCDK.Numerics.Vector2)">
            <summary>
            Negates a given vector.
            </summary>
            <param name="value">The source vector.</param>
            <returns>The negated vector.</returns>
        </member>
        <member name="F:NCDK.Numerics.Vector2.X">
            <summary>
            The X component of the vector.
            </summary>
        </member>
        <member name="F:NCDK.Numerics.Vector2.Y">
            <summary>
            The Y component of the vector.
            </summary>
        </member>
        <member name="M:NCDK.Numerics.Vector2.#ctor(System.Double)">
            <summary>
            Constructs a vector whose elements are all the single specified value.
            </summary>
            <param name="value">The element to fill the vector with.</param>
        </member>
        <member name="M:NCDK.Numerics.Vector2.#ctor(System.Double,System.Double)">
            <summary>
            Constructs a vector with the given individual elements.
            </summary>
            <param name="x">The X component.</param>
            <param name="y">The Y component.</param>
        </member>
        <member name="M:NCDK.Numerics.Vector2.CopyTo(System.Double[])">
            <summary>
            Copies the contents of the vector into the given array.
            </summary>
            <param name="array">The destination array.</param>
        </member>
        <member name="M:NCDK.Numerics.Vector2.CopyTo(System.Double[],System.Int32)">
            <summary>
            Copies the contents of the vector into the given array, starting from the given index.
            </summary>
            <exception cref="T:System.ArgumentNullException">If array is null.</exception>
            <exception cref="T:System.RankException">If array is multidimensional.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">If index is greater than end of the array or index is less than zero.</exception>
            <exception cref="T:System.ArgumentException">If number of elements in source vector is greater than those available in destination array
            or if there are not enough elements to copy.</exception>
        </member>
        <member name="M:NCDK.Numerics.Vector2.Equals(NCDK.Numerics.Vector2)">
            <summary>
            Returns a bool indicating whether the given Vector2 is equal to this Vector2 instance.
            </summary>
            <param name="other">The Vector2 to compare this instance to.</param>
            <returns>True if the other Vector2 is equal to this instance; False otherwise.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector2.Dot(NCDK.Numerics.Vector2,NCDK.Numerics.Vector2)">
            <summary>
            Returns the dot product of two vectors.
            </summary>
            <param name="value1">The first vector.</param>
            <param name="value2">The second vector.</param>
            <returns>The dot product.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector2.Min(NCDK.Numerics.Vector2,NCDK.Numerics.Vector2)">
            <summary>
            Returns a vector whose elements are the minimum of each of the pairs of elements in the two source vectors.
            </summary>
            <param name="value1">The first source vector.</param>
            <param name="value2">The second source vector.</param>
            <returns>The minimized vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector2.Max(NCDK.Numerics.Vector2,NCDK.Numerics.Vector2)">
            <summary>
            Returns a vector whose elements are the maximum of each of the pairs of elements in the two source vectors
            </summary>
            <param name="value1">The first source vector</param>
            <param name="value2">The second source vector</param>
            <returns>The maximized vector</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector2.Abs(NCDK.Numerics.Vector2)">
            <summary>
            Returns a vector whose elements are the absolute values of each of the source vector's elements.
            </summary>
            <param name="value">The source vector.</param>
            <returns>The absolute value vector.</returns>        
        </member>
        <member name="M:NCDK.Numerics.Vector2.SquareRoot(NCDK.Numerics.Vector2)">
            <summary>
            Returns a vector whose elements are the square root of each of the source vector's elements.
            </summary>
            <param name="value">The source vector.</param>
            <returns>The square root vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector2.op_Addition(NCDK.Numerics.Vector2,NCDK.Numerics.Vector2)">
            <summary>
            Adds two vectors together.
            </summary>
            <param name="left">The first source vector.</param>
            <param name="right">The second source vector.</param>
            <returns>The summed vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector2.op_Subtraction(NCDK.Numerics.Vector2,NCDK.Numerics.Vector2)">
            <summary>
            Subtracts the second vector from the first.
            </summary>
            <param name="left">The first source vector.</param>
            <param name="right">The second source vector.</param>
            <returns>The difference vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector2.op_Multiply(NCDK.Numerics.Vector2,NCDK.Numerics.Vector2)">
            <summary>
            Multiplies two vectors together.
            </summary>
            <param name="left">The first source vector.</param>
            <param name="right">The second source vector.</param>
            <returns>The product vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector2.op_Multiply(System.Double,NCDK.Numerics.Vector2)">
            <summary>
            Multiplies a vector by the given scalar.
            </summary>
            <param name="left">The scalar value.</param>
            <param name="right">The source vector.</param>
            <returns>The scaled vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector2.op_Multiply(NCDK.Numerics.Vector2,System.Double)">
            <summary>
            Multiplies a vector by the given scalar.
            </summary>
            <param name="left">The source vector.</param>
            <param name="right">The scalar value.</param>
            <returns>The scaled vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector2.op_Division(NCDK.Numerics.Vector2,NCDK.Numerics.Vector2)">
            <summary>
            Divides the first vector by the second.
            </summary>
            <param name="left">The first source vector.</param>
            <param name="right">The second source vector.</param>
            <returns>The vector resulting from the division.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector2.op_Division(NCDK.Numerics.Vector2,System.Double)">
            <summary>
            Divides the vector by the given scalar.
            </summary>
            <param name="value1">The source vector.</param>
            <param name="value2">The scalar value.</param>
            <returns>The result of the division.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector2.op_UnaryNegation(NCDK.Numerics.Vector2)">
            <summary>
            Negates a given vector.
            </summary>
            <param name="value">The source vector.</param>
            <returns>The negated vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector2.op_Equality(NCDK.Numerics.Vector2,NCDK.Numerics.Vector2)">
            <summary>
            Returns a bool indicating whether the two given vectors are equal.
            </summary>
            <param name="left">The first vector to compare.</param>
            <param name="right">The second vector to compare.</param>
            <returns>True if the vectors are equal; False otherwise.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector2.op_Inequality(NCDK.Numerics.Vector2,NCDK.Numerics.Vector2)">
            <summary>
            Returns a bool indicating whether the two given vectors are not equal.
            </summary>
            <param name="left">The first vector to compare.</param>
            <param name="right">The second vector to compare.</param>
            <returns>True if the vectors are not equal; False if they are equal.</returns>
        </member>
        <member name="T:NCDK.Numerics.Vector3">
            <summary>
            A structure encapsulating three single precision floating point values and provides hardware accelerated methods.
            </summary>
        </member>
        <member name="P:NCDK.Numerics.Vector3.Zero">
            <summary>
            Returns the vector (0,0,0).
            </summary>
        </member>
        <member name="P:NCDK.Numerics.Vector3.One">
            <summary>
            Returns the vector (1,1,1).
            </summary>
        </member>
        <member name="P:NCDK.Numerics.Vector3.UnitX">
            <summary>
            Returns the vector (1,0,0).
            </summary>
        </member>
        <member name="P:NCDK.Numerics.Vector3.UnitY">
            <summary>
            Returns the vector (0,1,0).
            </summary>
        </member>
        <member name="P:NCDK.Numerics.Vector3.UnitZ">
            <summary>
            Returns the vector (0,0,1).
            </summary>
        </member>
        <member name="M:NCDK.Numerics.Vector3.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <returns>The hash code.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector3.Equals(System.Object)">
            <summary>
            Returns a bool indicating whether the given Object is equal to this Vector3 instance.
            </summary>
            <param name="obj">The Object to compare against.</param>
            <returns>True if the Object is equal to this Vector3; False otherwise.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector3.ToString">
            <summary>
            Returns a string representing this Vector3 instance.
            </summary>
            <returns>The string representation.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector3.ToString(System.String)">
            <summary>
            Returns a string representing this Vector3 instance, using the specified format to format individual elements.
            </summary>
            <param name="format">The format of individual elements.</param>
            <returns>The string representation.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector3.ToString(System.String,System.IFormatProvider)">
            <summary>
            Returns a string representing this Vector3 instance, using the specified format to format individual elements 
            and the given IFormatProvider.
            </summary>
            <param name="format">The format of individual elements.</param>
            <param name="formatProvider">The format provider to use when formatting elements.</param>
            <returns>The string representation.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector3.Length">
            <summary>
            Returns the length of the vector.
            </summary>
            <returns>The vector's length.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector3.LengthSquared">
            <summary>
            Returns the length of the vector squared. This operation is cheaper than Length().
            </summary>
            <returns>The vector's length squared.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector3.Distance(NCDK.Numerics.Vector3,NCDK.Numerics.Vector3)">
            <summary>
            Returns the Euclidean distance between the two given points.
            </summary>
            <param name="value1">The first point.</param>
            <param name="value2">The second point.</param>
            <returns>The distance.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector3.DistanceSquared(NCDK.Numerics.Vector3,NCDK.Numerics.Vector3)">
            <summary>
            Returns the Euclidean distance squared between the two given points.
            </summary>
            <param name="value1">The first point.</param>
            <param name="value2">The second point.</param>
            <returns>The distance squared.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector3.Normalize(NCDK.Numerics.Vector3)">
            <summary>
            Returns a vector with the same direction as the given vector, but with a length of 1.
            </summary>
            <param name="value">The vector to normalize.</param>
            <returns>The normalized vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector3.Cross(NCDK.Numerics.Vector3,NCDK.Numerics.Vector3)">
            <summary>
            Computes the cross product of two vectors.
            </summary>
            <param name="vector1">The first vector.</param>
            <param name="vector2">The second vector.</param>
            <returns>The cross product.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector3.Reflect(NCDK.Numerics.Vector3,NCDK.Numerics.Vector3)">
            <summary>
            Returns the reflection of a vector off a surface that has the specified normal.
            </summary>
            <param name="vector">The source vector.</param>
            <param name="normal">The normal of the surface being reflected off.</param>
            <returns>The reflected vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector3.Clamp(NCDK.Numerics.Vector3,NCDK.Numerics.Vector3,NCDK.Numerics.Vector3)">
            <summary>
            Restricts a vector between a min and max value.
            </summary>
            <param name="value1">The source vector.</param>
            <param name="min">The minimum value.</param>
            <param name="max">The maximum value.</param>
            <returns>The restricted vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector3.Lerp(NCDK.Numerics.Vector3,NCDK.Numerics.Vector3,System.Double)">
            <summary>
            Linearly interpolates between two vectors based on the given weighting.
            </summary>
            <param name="value1">The first source vector.</param>
            <param name="value2">The second source vector.</param>
            <param name="amount">Value between 0 and 1 indicating the weight of the second source vector.</param>
            <returns>The interpolated vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector3.Transform(NCDK.Numerics.Vector3,NCDK.Numerics.Matrix4x4)">
            <summary>
            Transforms a vector by the given matrix.
            </summary>
            <param name="position">The source vector.</param>
            <param name="matrix">The transformation matrix.</param>
            <returns>The transformed vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector3.TransformNormal(NCDK.Numerics.Vector3,NCDK.Numerics.Matrix4x4)">
            <summary>
            Transforms a vector normal by the given matrix.
            </summary>
            <param name="normal">The source vector.</param>
            <param name="matrix">The transformation matrix.</param>
            <returns>The transformed vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector3.Transform(NCDK.Numerics.Vector3,NCDK.Numerics.Quaternion)">
            <summary>
            Transforms a vector by the given Quaternion rotation value.
            </summary>
            <param name="value">The source vector to be rotated.</param>
            <param name="rotation">The rotation to apply.</param>
            <returns>The transformed vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector3.Add(NCDK.Numerics.Vector3,NCDK.Numerics.Vector3)">
            <summary>
            Adds two vectors together.
            </summary>
            <param name="left">The first source vector.</param>
            <param name="right">The second source vector.</param>
            <returns>The summed vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector3.Subtract(NCDK.Numerics.Vector3,NCDK.Numerics.Vector3)">
            <summary>
            Subtracts the second vector from the first.
            </summary>
            <param name="left">The first source vector.</param>
            <param name="right">The second source vector.</param>
            <returns>The difference vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector3.Multiply(NCDK.Numerics.Vector3,NCDK.Numerics.Vector3)">
            <summary>
            Multiplies two vectors together.
            </summary>
            <param name="left">The first source vector.</param>
            <param name="right">The second source vector.</param>
            <returns>The product vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector3.Multiply(NCDK.Numerics.Vector3,System.Double)">
            <summary>
            Multiplies a vector by the given scalar.
            </summary>
            <param name="left">The source vector.</param>
            <param name="right">The scalar value.</param>
            <returns>The scaled vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector3.Multiply(System.Double,NCDK.Numerics.Vector3)">
            <summary>
            Multiplies a vector by the given scalar.
            </summary>
            <param name="left">The scalar value.</param>
            <param name="right">The source vector.</param>
            <returns>The scaled vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector3.Divide(NCDK.Numerics.Vector3,NCDK.Numerics.Vector3)">
            <summary>
            Divides the first vector by the second.
            </summary>
            <param name="left">The first source vector.</param>
            <param name="right">The second source vector.</param>
            <returns>The vector resulting from the division.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector3.Divide(NCDK.Numerics.Vector3,System.Double)">
            <summary>
            Divides the vector by the given scalar.
            </summary>
            <param name="left">The source vector.</param>
            <param name="divisor">The scalar value.</param>
            <returns>The result of the division.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector3.Negate(NCDK.Numerics.Vector3)">
            <summary>
            Negates a given vector.
            </summary>
            <param name="value">The source vector.</param>
            <returns>The negated vector.</returns>
        </member>
        <member name="F:NCDK.Numerics.Vector3.X">
            <summary>
            The X component of the vector.
            </summary>
        </member>
        <member name="F:NCDK.Numerics.Vector3.Y">
            <summary>
            The Y component of the vector.
            </summary>
        </member>
        <member name="F:NCDK.Numerics.Vector3.Z">
            <summary>
            The Z component of the vector.
            </summary>
        </member>
        <member name="M:NCDK.Numerics.Vector3.#ctor(System.Double)">
            <summary>
            Constructs a vector whose elements are all the single specified value.
            </summary>
            <param name="value">The element to fill the vector with.</param>
        </member>
        <member name="M:NCDK.Numerics.Vector3.#ctor(NCDK.Numerics.Vector2,System.Double)">
            <summary>
            Constructs a Vector3 from the given Vector2 and a third value.
            </summary>
            <param name="value">The Vector to extract X and Y components from.</param>
            <param name="z">The Z component.</param>
        </member>
        <member name="M:NCDK.Numerics.Vector3.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            Constructs a vector with the given individual elements.
            </summary>
            <param name="x">The X component.</param>
            <param name="y">The Y component.</param>
            <param name="z">The Z component.</param>
        </member>
        <member name="M:NCDK.Numerics.Vector3.CopyTo(System.Double[])">
            <summary>
            Copies the contents of the vector into the given array.
            </summary>
        </member>
        <member name="M:NCDK.Numerics.Vector3.CopyTo(System.Double[],System.Int32)">
            <summary>
            Copies the contents of the vector into the given array, starting from index.
            </summary>
            <exception cref="T:System.ArgumentNullException">If array is null.</exception>
            <exception cref="T:System.RankException">If array is multidimensional.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">If index is greater than end of the array or index is less than zero.</exception>
            <exception cref="T:System.ArgumentException">If number of elements in source vector is greater than those available in destination array.</exception>
        </member>
        <member name="M:NCDK.Numerics.Vector3.Equals(NCDK.Numerics.Vector3)">
            <summary>
            Returns a bool indicating whether the given Vector3 is equal to this Vector3 instance.
            </summary>
            <param name="other">The Vector3 to compare this instance to.</param>
            <returns>True if the other Vector3 is equal to this instance; False otherwise.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector3.Dot(NCDK.Numerics.Vector3,NCDK.Numerics.Vector3)">
            <summary>
            Returns the dot product of two vectors.
            </summary>
            <param name="vector1">The first vector.</param>
            <param name="vector2">The second vector.</param>
            <returns>The dot product.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector3.Min(NCDK.Numerics.Vector3,NCDK.Numerics.Vector3)">
            <summary>
            Returns a vector whose elements are the minimum of each of the pairs of elements in the two source vectors.
            </summary>
            <param name="value1">The first source vector.</param>
            <param name="value2">The second source vector.</param>
            <returns>The minimized vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector3.Max(NCDK.Numerics.Vector3,NCDK.Numerics.Vector3)">
            <summary>
            Returns a vector whose elements are the maximum of each of the pairs of elements in the two source vectors.
            </summary>
            <param name="value1">The first source vector.</param>
            <param name="value2">The second source vector.</param>
            <returns>The maximized vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector3.Abs(NCDK.Numerics.Vector3)">
            <summary>
            Returns a vector whose elements are the absolute values of each of the source vector's elements.
            </summary>
            <param name="value">The source vector.</param>
            <returns>The absolute value vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector3.SquareRoot(NCDK.Numerics.Vector3)">
            <summary>
            Returns a vector whose elements are the square root of each of the source vector's elements.
            </summary>
            <param name="value">The source vector.</param>
            <returns>The square root vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector3.op_Addition(NCDK.Numerics.Vector3,NCDK.Numerics.Vector3)">
            <summary>
            Adds two vectors together.
            </summary>
            <param name="left">The first source vector.</param>
            <param name="right">The second source vector.</param>
            <returns>The summed vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector3.op_Subtraction(NCDK.Numerics.Vector3,NCDK.Numerics.Vector3)">
            <summary>
            Subtracts the second vector from the first.
            </summary>
            <param name="left">The first source vector.</param>
            <param name="right">The second source vector.</param>
            <returns>The difference vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector3.op_Multiply(NCDK.Numerics.Vector3,NCDK.Numerics.Vector3)">
            <summary>
            Multiplies two vectors together.
            </summary>
            <param name="left">The first source vector.</param>
            <param name="right">The second source vector.</param>
            <returns>The product vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector3.op_Multiply(NCDK.Numerics.Vector3,System.Double)">
            <summary>
            Multiplies a vector by the given scalar.
            </summary>
            <param name="left">The source vector.</param>
            <param name="right">The scalar value.</param>
            <returns>The scaled vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector3.op_Multiply(System.Double,NCDK.Numerics.Vector3)">
            <summary>
            Multiplies a vector by the given scalar.
            </summary>
            <param name="left">The scalar value.</param>
            <param name="right">The source vector.</param>
            <returns>The scaled vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector3.op_Division(NCDK.Numerics.Vector3,NCDK.Numerics.Vector3)">
            <summary>
            Divides the first vector by the second.
            </summary>
            <param name="left">The first source vector.</param>
            <param name="right">The second source vector.</param>
            <returns>The vector resulting from the division.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector3.op_Division(NCDK.Numerics.Vector3,System.Double)">
            <summary>
            Divides the vector by the given scalar.
            </summary>
            <param name="value1">The source vector.</param>
            <param name="value2">The scalar value.</param>
            <returns>The result of the division.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector3.op_UnaryNegation(NCDK.Numerics.Vector3)">
            <summary>
            Negates a given vector.
            </summary>
            <param name="value">The source vector.</param>
            <returns>The negated vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector3.op_Equality(NCDK.Numerics.Vector3,NCDK.Numerics.Vector3)">
            <summary>
            Returns a bool indicating whether the two given vectors are equal.
            </summary>
            <param name="left">The first vector to compare.</param>
            <param name="right">The second vector to compare.</param>
            <returns>True if the vectors are equal; False otherwise.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector3.op_Inequality(NCDK.Numerics.Vector3,NCDK.Numerics.Vector3)">
            <summary>
            Returns a bool indicating whether the two given vectors are not equal.
            </summary>
            <param name="left">The first vector to compare.</param>
            <param name="right">The second vector to compare.</param>
            <returns>True if the vectors are not equal; False if they are equal.</returns>
        </member>
        <member name="T:NCDK.Numerics.Vector4">
            <summary>
            A structure encapsulating four single precision floating point values and provides hardware accelerated methods.
            </summary>
        </member>
        <member name="P:NCDK.Numerics.Vector4.Zero">
            <summary>
            Returns the vector (0,0,0,0).
            </summary>
        </member>
        <member name="P:NCDK.Numerics.Vector4.One">
            <summary>
            Returns the vector (1,1,1,1).
            </summary>
        </member>
        <member name="P:NCDK.Numerics.Vector4.UnitX">
            <summary>
            Returns the vector (1,0,0,0).
            </summary>
        </member>
        <member name="P:NCDK.Numerics.Vector4.UnitY">
            <summary>
            Returns the vector (0,1,0,0).
            </summary>
        </member>
        <member name="P:NCDK.Numerics.Vector4.UnitZ">
            <summary>
            Returns the vector (0,0,1,0).
            </summary>
        </member>
        <member name="P:NCDK.Numerics.Vector4.UnitW">
            <summary>
            Returns the vector (0,0,0,1).
            </summary>
        </member>
        <member name="M:NCDK.Numerics.Vector4.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <returns>The hash code.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector4.Equals(System.Object)">
            <summary>
            Returns a bool indicating whether the given Object is equal to this Vector4 instance.
            </summary>
            <param name="obj">The Object to compare against.</param>
            <returns>True if the Object is equal to this Vector4; False otherwise.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector4.ToString">
            <summary>
            Returns a string representing this Vector4 instance.
            </summary>
            <returns>The string representation.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector4.ToString(System.String)">
            <summary>
            Returns a string representing this Vector4 instance, using the specified format to format individual elements.
            </summary>
            <param name="format">The format of individual elements.</param>
            <returns>The string representation.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector4.ToString(System.String,System.IFormatProvider)">
            <summary>
            Returns a string representing this Vector4 instance, using the specified format to format individual elements 
            and the given IFormatProvider.
            </summary>
            <param name="format">The format of individual elements.</param>
            <param name="formatProvider">The format provider to use when formatting elements.</param>
            <returns>The string representation.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector4.Length">
            <summary>
            Returns the length of the vector. This operation is cheaper than Length().
            </summary>
            <returns>The vector's length.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector4.LengthSquared">
            <summary>
            Returns the length of the vector squared.
            </summary>
            <returns>The vector's length squared.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector4.Distance(NCDK.Numerics.Vector4,NCDK.Numerics.Vector4)">
            <summary>
            Returns the Euclidean distance between the two given points.
            </summary>
            <param name="value1">The first point.</param>
            <param name="value2">The second point.</param>
            <returns>The distance.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector4.DistanceSquared(NCDK.Numerics.Vector4,NCDK.Numerics.Vector4)">
            <summary>
            Returns the Euclidean distance squared between the two given points.
            </summary>
            <param name="value1">The first point.</param>
            <param name="value2">The second point.</param>
            <returns>The distance squared.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector4.Normalize(NCDK.Numerics.Vector4)">
            <summary>
            Returns a vector with the same direction as the given vector, but with a length of 1.
            </summary>
            <param name="vector">The vector to normalize.</param>
            <returns>The normalized vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector4.Clamp(NCDK.Numerics.Vector4,NCDK.Numerics.Vector4,NCDK.Numerics.Vector4)">
            <summary>
            Restricts a vector between a min and max value.
            </summary>
            <param name="value1">The source vector.</param>
            <param name="min">The minimum value.</param>
            <param name="max">The maximum value.</param>
            <returns>The restricted vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector4.Lerp(NCDK.Numerics.Vector4,NCDK.Numerics.Vector4,System.Double)">
            <summary>
            Linearly interpolates between two vectors based on the given weighting.
            </summary>
            <param name="value1">The first source vector.</param>
            <param name="value2">The second source vector.</param>
            <param name="amount">Value between 0 and 1 indicating the weight of the second source vector.</param>
            <returns>The interpolated vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector4.Transform(NCDK.Numerics.Vector2,NCDK.Numerics.Matrix4x4)">
            <summary>
            Transforms a vector by the given matrix.
            </summary>
            <param name="position">The source vector.</param>
            <param name="matrix">The transformation matrix.</param>
            <returns>The transformed vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector4.Transform(NCDK.Numerics.Vector3,NCDK.Numerics.Matrix4x4)">
            <summary>
            Transforms a vector by the given matrix.
            </summary>
            <param name="position">The source vector.</param>
            <param name="matrix">The transformation matrix.</param>
            <returns>The transformed vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector4.Transform(NCDK.Numerics.Vector4,NCDK.Numerics.Matrix4x4)">
            <summary>
            Transforms a vector by the given matrix.
            </summary>
            <param name="vector">The source vector.</param>
            <param name="matrix">The transformation matrix.</param>
            <returns>The transformed vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector4.Transform(NCDK.Numerics.Vector2,NCDK.Numerics.Quaternion)">
            <summary>
            Transforms a vector by the given Quaternion rotation value.
            </summary>
            <param name="value">The source vector to be rotated.</param>
            <param name="rotation">The rotation to apply.</param>
            <returns>The transformed vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector4.Transform(NCDK.Numerics.Vector3,NCDK.Numerics.Quaternion)">
            <summary>
            Transforms a vector by the given Quaternion rotation value.
            </summary>
            <param name="value">The source vector to be rotated.</param>
            <param name="rotation">The rotation to apply.</param>
            <returns>The transformed vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector4.Transform(NCDK.Numerics.Vector4,NCDK.Numerics.Quaternion)">
            <summary>
            Transforms a vector by the given Quaternion rotation value.
            </summary>
            <param name="value">The source vector to be rotated.</param>
            <param name="rotation">The rotation to apply.</param>
            <returns>The transformed vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector4.Add(NCDK.Numerics.Vector4,NCDK.Numerics.Vector4)">
            <summary>
            Adds two vectors together.
            </summary>
            <param name="left">The first source vector.</param>
            <param name="right">The second source vector.</param>
            <returns>The summed vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector4.Subtract(NCDK.Numerics.Vector4,NCDK.Numerics.Vector4)">
            <summary>
            Subtracts the second vector from the first.
            </summary>
            <param name="left">The first source vector.</param>
            <param name="right">The second source vector.</param>
            <returns>The difference vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector4.Multiply(NCDK.Numerics.Vector4,NCDK.Numerics.Vector4)">
            <summary>
            Multiplies two vectors together.
            </summary>
            <param name="left">The first source vector.</param>
            <param name="right">The second source vector.</param>
            <returns>The product vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector4.Multiply(NCDK.Numerics.Vector4,System.Single)">
            <summary>
            Multiplies a vector by the given scalar.
            </summary>
            <param name="left">The source vector.</param>
            <param name="right">The scalar value.</param>
            <returns>The scaled vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector4.Multiply(System.Single,NCDK.Numerics.Vector4)">
            <summary>
            Multiplies a vector by the given scalar.
            </summary>
            <param name="left">The scalar value.</param>
            <param name="right">The source vector.</param>
            <returns>The scaled vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector4.Divide(NCDK.Numerics.Vector4,NCDK.Numerics.Vector4)">
            <summary>
            Divides the first vector by the second.
            </summary>
            <param name="left">The first source vector.</param>
            <param name="right">The second source vector.</param>
            <returns>The vector resulting from the division.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector4.Divide(NCDK.Numerics.Vector4,System.Single)">
            <summary>
            Divides the vector by the given scalar.
            </summary>
            <param name="left">The source vector.</param>
            <param name="divisor">The scalar value.</param>
            <returns>The result of the division.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector4.Negate(NCDK.Numerics.Vector4)">
            <summary>
            Negates a given vector.
            </summary>
            <param name="value">The source vector.</param>
            <returns>The negated vector.</returns>
        </member>
        <member name="F:NCDK.Numerics.Vector4.X">
            <summary>
            The X component of the vector.
            </summary>
        </member>
        <member name="F:NCDK.Numerics.Vector4.Y">
            <summary>
            The Y component of the vector.
            </summary>
        </member>
        <member name="F:NCDK.Numerics.Vector4.Z">
            <summary>
            The Z component of the vector.
            </summary>
        </member>
        <member name="F:NCDK.Numerics.Vector4.W">
            <summary>
            The W component of the vector.
            </summary>
        </member>
        <member name="M:NCDK.Numerics.Vector4.#ctor(System.Double)">
            <summary>
            Constructs a vector whose elements are all the single specified value.
            </summary>
            <param name="value">The element to fill the vector with.</param>
        </member>
        <member name="M:NCDK.Numerics.Vector4.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Constructs a vector with the given individual elements.
            </summary>
            <param name="w">W component.</param>
            <param name="x">X component.</param>
            <param name="y">Y component.</param>
            <param name="z">Z component.</param>
        </member>
        <member name="M:NCDK.Numerics.Vector4.#ctor(NCDK.Numerics.Vector2,System.Double,System.Double)">
            <summary>
            Constructs a Vector4 from the given Vector2 and a Z and W component.
            </summary>
            <param name="value">The vector to use as the X and Y components.</param>
            <param name="z">The Z component.</param>
            <param name="w">The W component.</param>
        </member>
        <member name="M:NCDK.Numerics.Vector4.#ctor(NCDK.Numerics.Vector3,System.Double)">
            <summary>
            Constructs a Vector4 from the given Vector3 and a W component.
            </summary>
            <param name="value">The vector to use as the X, Y, and Z components.</param>
            <param name="w">The W component.</param>
        </member>
        <member name="M:NCDK.Numerics.Vector4.CopyTo(System.Double[])">
            <summary>
            Copies the contents of the vector into the given array.
            </summary>
        </member>
        <member name="M:NCDK.Numerics.Vector4.CopyTo(System.Double[],System.Int32)">
            <summary>
            Copies the contents of the vector into the given array, starting from index.
            </summary>
            <exception cref="T:System.ArgumentNullException">If array is null.</exception>
            <exception cref="T:System.RankException">If array is multidimensional.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">If index is greater than end of the array or index is less than zero.</exception>
            <exception cref="T:System.ArgumentException">If number of elements in source vector is greater than those available in destination array.</exception>
        </member>
        <member name="M:NCDK.Numerics.Vector4.Equals(NCDK.Numerics.Vector4)">
            <summary>
            Returns a bool indicating whether the given Vector4 is equal to this Vector4 instance.
            </summary>
            <param name="other">The Vector4 to compare this instance to.</param>
            <returns>True if the other Vector4 is equal to this instance; False otherwise.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector4.Dot(NCDK.Numerics.Vector4,NCDK.Numerics.Vector4)">
            <summary>
            Returns the dot product of two vectors.
            </summary>
            <param name="vector1">The first vector.</param>
            <param name="vector2">The second vector.</param>
            <returns>The dot product.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector4.Min(NCDK.Numerics.Vector4,NCDK.Numerics.Vector4)">
            <summary>
            Returns a vector whose elements are the minimum of each of the pairs of elements in the two source vectors.
            </summary>
            <param name="value1">The first source vector.</param>
            <param name="value2">The second source vector.</param>
            <returns>The minimized vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector4.Max(NCDK.Numerics.Vector4,NCDK.Numerics.Vector4)">
            <summary>
            Returns a vector whose elements are the maximum of each of the pairs of elements in the two source vectors.
            </summary>
            <param name="value1">The first source vector.</param>
            <param name="value2">The second source vector.</param>
            <returns>The maximized vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector4.Abs(NCDK.Numerics.Vector4)">
            <summary>
            Returns a vector whose elements are the absolute values of each of the source vector's elements.
            </summary>
            <param name="value">The source vector.</param>
            <returns>The absolute value vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector4.SquareRoot(NCDK.Numerics.Vector4)">
            <summary>
            Returns a vector whose elements are the square root of each of the source vector's elements.
            </summary>
            <param name="value">The source vector.</param>
            <returns>The square root vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector4.op_Addition(NCDK.Numerics.Vector4,NCDK.Numerics.Vector4)">
            <summary>
            Adds two vectors together.
            </summary>
            <param name="left">The first source vector.</param>
            <param name="right">The second source vector.</param>
            <returns>The summed vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector4.op_Subtraction(NCDK.Numerics.Vector4,NCDK.Numerics.Vector4)">
            <summary>
            Subtracts the second vector from the first.
            </summary>
            <param name="left">The first source vector.</param>
            <param name="right">The second source vector.</param>
            <returns>The difference vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector4.op_Multiply(NCDK.Numerics.Vector4,NCDK.Numerics.Vector4)">
            <summary>
            Multiplies two vectors together.
            </summary>
            <param name="left">The first source vector.</param>
            <param name="right">The second source vector.</param>
            <returns>The product vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector4.op_Multiply(NCDK.Numerics.Vector4,System.Double)">
            <summary>
            Multiplies a vector by the given scalar.
            </summary>
            <param name="left">The source vector.</param>
            <param name="right">The scalar value.</param>
            <returns>The scaled vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector4.op_Multiply(System.Double,NCDK.Numerics.Vector4)">
            <summary>
            Multiplies a vector by the given scalar.
            </summary>
            <param name="left">The scalar value.</param>
            <param name="right">The source vector.</param>
            <returns>The scaled vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector4.op_Division(NCDK.Numerics.Vector4,NCDK.Numerics.Vector4)">
            <summary>
            Divides the first vector by the second.
            </summary>
            <param name="left">The first source vector.</param>
            <param name="right">The second source vector.</param>
            <returns>The vector resulting from the division.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector4.op_Division(NCDK.Numerics.Vector4,System.Double)">
            <summary>
            Divides the vector by the given scalar.
            </summary>
            <param name="value1">The source vector.</param>
            <param name="value2">The scalar value.</param>
            <returns>The result of the division.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector4.op_UnaryNegation(NCDK.Numerics.Vector4)">
            <summary>
            Negates a given vector.
            </summary>
            <param name="value">The source vector.</param>
            <returns>The negated vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector4.op_Equality(NCDK.Numerics.Vector4,NCDK.Numerics.Vector4)">
            <summary>
            Returns a bool indicating whether the two given vectors are equal.
            </summary>
            <param name="left">The first vector to compare.</param>
            <param name="right">The second vector to compare.</param>
            <returns>True if the vectors are equal; False otherwise.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector4.op_Inequality(NCDK.Numerics.Vector4,NCDK.Numerics.Vector4)">
            <summary>
            Returns a bool indicating whether the two given vectors are not equal.
            </summary>
            <param name="left">The first vector to compare.</param>
            <param name="right">The second vector to compare.</param>
            <returns>True if the vectors are not equal; False if they are equal.</returns>
        </member>
        <member name="T:NCDK.Numerics.Vector">
            <summary>
            Contains various methods useful for creating, manipulating, combining, and converting generic vectors with one another.
            </summary>
        </member>
        <member name="M:NCDK.Numerics.Vector.ConditionalSelect(NCDK.Numerics.Vector{System.Int32},NCDK.Numerics.Vector{System.Double},NCDK.Numerics.Vector{System.Double})">
            <summary>
            Creates a new vector with elements selected between the two given source vectors, and based on a mask vector.
            </summary>
            <param name="condition">The integral mask vector used to drive selection.</param>
            <param name="left">The first source vector.</param>
            <param name="right">The second source vector.</param>
            <returns>The new vector with elements selected based on the mask.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector.ConditionalSelect(NCDK.Numerics.Vector{System.Int64},NCDK.Numerics.Vector{System.Double},NCDK.Numerics.Vector{System.Double})">
            <summary>
            Creates a new vector with elements selected between the two given source vectors, and based on a mask vector.
            </summary>
            <param name="condition">The integral mask vector used to drive selection.</param>
            <param name="left">The first source vector.</param>
            <param name="right">The second source vector.</param>
            <returns>The new vector with elements selected based on the mask.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector.ConditionalSelect``1(NCDK.Numerics.Vector{``0},NCDK.Numerics.Vector{``0},NCDK.Numerics.Vector{``0})">
            <summary>
            Creates a new vector with elements selected between the two given source vectors, and based on a mask vector.
            </summary>
            <param name="condition">The mask vector used to drive selection.</param>
            <param name="left">The first source vector.</param>
            <param name="right">The second source vector.</param>
            <returns>The new vector with elements selected based on the mask.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector.Equals``1(NCDK.Numerics.Vector{``0},NCDK.Numerics.Vector{``0})">
            <summary>
            Returns a new vector whose elements signal whether the elements in left and right were equal.
            </summary>
            <param name="left">The first vector to compare.</param>
            <param name="right">The second vector to compare.</param>
            <returns>The resultant vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector.Equals(NCDK.Numerics.Vector{System.Single},NCDK.Numerics.Vector{System.Single})">
            <summary>
            Returns an integral vector whose elements signal whether elements in the left and right doubleing point vectors were equal.
            </summary>
            <param name="left">The first vector to compare.</param>
            <param name="right">The second vector to compare.</param>
            <returns>The resultant vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector.Equals(NCDK.Numerics.Vector{System.Int32},NCDK.Numerics.Vector{System.Int32})">
            <summary>
            Returns a new vector whose elements signal whether the elements in left and right were equal.
            </summary>
            <param name="left">The first vector to compare.</param>
            <param name="right">The second vector to compare.</param>
            <returns>The resultant vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector.Equals(NCDK.Numerics.Vector{System.Double},NCDK.Numerics.Vector{System.Double})">
            <summary>
            Returns an integral vector whose elements signal whether elements in the left and right doubleing point vectors were equal.
            </summary>
            <param name="left">The first vector to compare.</param>
            <param name="right">The second vector to compare.</param>
            <returns>The resultant vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector.Equals(NCDK.Numerics.Vector{System.Int64},NCDK.Numerics.Vector{System.Int64})">
            <summary>
            Returns a new vector whose elements signal whether the elements in left and right were equal.
            </summary>
            <param name="left">The first vector to compare.</param>
            <param name="right">The second vector to compare.</param>
            <returns>The resultant vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector.EqualsAll``1(NCDK.Numerics.Vector{``0},NCDK.Numerics.Vector{``0})">
            <summary>
            Returns a bool indicating whether each pair of elements in the given vectors are equal.
            </summary>
            <param name="left">The first vector to compare.</param>
            <param name="right">The first vector to compare.</param>
            <returns>True if all elements are equal; False otherwise.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector.EqualsAny``1(NCDK.Numerics.Vector{``0},NCDK.Numerics.Vector{``0})">
            <summary>
            Returns a bool indicating whether any single pair of elements in the given vectors are equal.
            </summary>
            <param name="left">The first vector to compare.</param>
            <param name="right">The second vector to compare.</param>
            <returns>True if any element pairs are equal; False if no element pairs are equal.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector.LessThan``1(NCDK.Numerics.Vector{``0},NCDK.Numerics.Vector{``0})">
            <summary>
            Returns a new vector whose elements signal whether the elements in left were less than their
            corresponding elements in right.
            </summary>
            <param name="left">The first vector to compare.</param>
            <param name="right">The second vector to compare.</param>
            <returns>The resultant vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector.LessThan(NCDK.Numerics.Vector{System.Single},NCDK.Numerics.Vector{System.Single})">
            <summary>
            Returns an integral vector whose elements signal whether the elements in left were less than their
            corresponding elements in right.
            </summary>
            <param name="left">The first vector to compare.</param>
            <param name="right">The second vector to compare.</param>
            <returns>The resultant integral vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector.LessThan(NCDK.Numerics.Vector{System.Int32},NCDK.Numerics.Vector{System.Int32})">
            <summary>
            Returns a new vector whose elements signal whether the elements in left were less than their
            corresponding elements in right.
            </summary>
            <param name="left">The first vector to compare.</param>
            <param name="right">The second vector to compare.</param>
            <returns>The resultant vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector.LessThan(NCDK.Numerics.Vector{System.Double},NCDK.Numerics.Vector{System.Double})">
            <summary>
            Returns an integral vector whose elements signal whether the elements in left were less than their
            corresponding elements in right.
            </summary>
            <param name="left">The first vector to compare.</param>
            <param name="right">The second vector to compare.</param>
            <returns>The resultant integral vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector.LessThan(NCDK.Numerics.Vector{System.Int64},NCDK.Numerics.Vector{System.Int64})">
            <summary>
            Returns a new vector whose elements signal whether the elements in left were less than their
            corresponding elements in right.
            </summary>
            <param name="left">The first vector to compare.</param>
            <param name="right">The second vector to compare.</param>
            <returns>The resultant vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector.LessThanAll``1(NCDK.Numerics.Vector{``0},NCDK.Numerics.Vector{``0})">
            <summary>
            Returns a bool indicating whether all of the elements in left are less than their corresponding elements in right.
            </summary>
            <param name="left">The first vector to compare.</param>
            <param name="right">The second vector to compare.</param>
            <returns>True if all elements in left are less than their corresponding elements in right; False otherwise.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector.LessThanAny``1(NCDK.Numerics.Vector{``0},NCDK.Numerics.Vector{``0})">
            <summary>
            Returns a bool indicating whether any element in left is less than its corresponding element in right.
            </summary>
            <param name="left">The first vector to compare.</param>
            <param name="right">The second vector to compare.</param>
            <returns>True if any elements in left are less than their corresponding elements in right; False otherwise.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector.LessThanOrEqual``1(NCDK.Numerics.Vector{``0},NCDK.Numerics.Vector{``0})">
            <summary>
            Returns a new vector whose elements signal whether the elements in left were less than or equal to their
            corresponding elements in right.
            </summary>
            <param name="left">The first vector to compare.</param>
            <param name="right">The second vector to compare.</param>
            <returns>The resultant vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector.LessThanOrEqual(NCDK.Numerics.Vector{System.Single},NCDK.Numerics.Vector{System.Single})">
            <summary>
            Returns an integral vector whose elements signal whether the elements in left were less than or equal to their
            corresponding elements in right.
            </summary>
            <param name="left">The first vector to compare.</param>
            <param name="right">The second vector to compare.</param>
            <returns>The resultant integral vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector.LessThanOrEqual(NCDK.Numerics.Vector{System.Int32},NCDK.Numerics.Vector{System.Int32})">
            <summary>
            Returns a new vector whose elements signal whether the elements in left were less than or equal to their
            corresponding elements in right.
            </summary>
            <param name="left">The first vector to compare.</param>
            <param name="right">The second vector to compare.</param>
            <returns>The resultant vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector.LessThanOrEqual(NCDK.Numerics.Vector{System.Int64},NCDK.Numerics.Vector{System.Int64})">
            <summary>
            Returns a new vector whose elements signal whether the elements in left were less than or equal to their
            corresponding elements in right.
            </summary>
            <param name="left">The first vector to compare.</param>
            <param name="right">The second vector to compare.</param>
            <returns>The resultant vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector.LessThanOrEqual(NCDK.Numerics.Vector{System.Double},NCDK.Numerics.Vector{System.Double})">
            <summary>
            Returns an integral vector whose elements signal whether the elements in left were less than or equal to their
            corresponding elements in right.
            </summary>
            <param name="left">The first vector to compare.</param>
            <param name="right">The second vector to compare.</param>
            <returns>The resultant integral vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector.LessThanOrEqualAll``1(NCDK.Numerics.Vector{``0},NCDK.Numerics.Vector{``0})">
            <summary>
            Returns a bool indicating whether all elements in left are less than or equal to their corresponding elements in right.
            </summary>
            <param name="left">The first vector to compare.</param>
            <param name="right">The second vector to compare.</param>
            <returns>True if all elements in left are less than or equal to their corresponding elements in right; False otherwise.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector.LessThanOrEqualAny``1(NCDK.Numerics.Vector{``0},NCDK.Numerics.Vector{``0})">
            <summary>
            Returns a bool indicating whether any element in left is less than or equal to its corresponding element in right.
            </summary>
            <param name="left">The first vector to compare.</param>
            <param name="right">The second vector to compare.</param>
            <returns>True if any elements in left are less than their corresponding elements in right; False otherwise.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector.GreaterThan``1(NCDK.Numerics.Vector{``0},NCDK.Numerics.Vector{``0})">
            <summary>
            Returns a new vector whose elements signal whether the elements in left were greater than their
            corresponding elements in right.
            </summary>
            <param name="left">The first vector to compare.</param>
            <param name="right">The second vector to compare.</param>
            <returns>The resultant vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector.GreaterThan(NCDK.Numerics.Vector{System.Single},NCDK.Numerics.Vector{System.Single})">
            <summary>
            Returns an integral vector whose elements signal whether the elements in left were greater than their
            corresponding elements in right.
            </summary>
            <param name="left">The first vector to compare.</param>
            <param name="right">The second vector to compare.</param>
            <returns>The resultant integral vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector.GreaterThan(NCDK.Numerics.Vector{System.Int32},NCDK.Numerics.Vector{System.Int32})">
            <summary>
            Returns a new vector whose elements signal whether the elements in left were greater than their
            corresponding elements in right.
            </summary>
            <param name="left">The first vector to compare.</param>
            <param name="right">The second vector to compare.</param>
            <returns>The resultant vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector.GreaterThan(NCDK.Numerics.Vector{System.Double},NCDK.Numerics.Vector{System.Double})">
            <summary>
            Returns an integral vector whose elements signal whether the elements in left were greater than their
            corresponding elements in right.
            </summary>
            <param name="left">The first vector to compare.</param>
            <param name="right">The second vector to compare.</param>
            <returns>The resultant integral vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector.GreaterThan(NCDK.Numerics.Vector{System.Int64},NCDK.Numerics.Vector{System.Int64})">
            <summary>
            Returns a new vector whose elements signal whether the elements in left were greater than their
            corresponding elements in right.
            </summary>
            <param name="left">The first vector to compare.</param>
            <param name="right">The second vector to compare.</param>
            <returns>The resultant vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector.GreaterThanAll``1(NCDK.Numerics.Vector{``0},NCDK.Numerics.Vector{``0})">
            <summary>
            Returns a bool indicating whether all elements in left are greater than the corresponding elements in right.
            elements in right.
            </summary>
            <param name="left">The first vector to compare.</param>
            <param name="right">The second vector to compare.</param>
            <returns>True if all elements in left are greater than their corresponding elements in right; False otherwise.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector.GreaterThanAny``1(NCDK.Numerics.Vector{``0},NCDK.Numerics.Vector{``0})">
            <summary>
            Returns a bool indicating whether any element in left is greater than its corresponding element in right.
            </summary>
            <param name="left">The first vector to compare.</param>
            <param name="right">The second vector to compare.</param>
            <returns>True if any elements in left are greater than their corresponding elements in right; False otherwise.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector.GreaterThanOrEqual``1(NCDK.Numerics.Vector{``0},NCDK.Numerics.Vector{``0})">
            <summary>
            Returns a new vector whose elements signal whether the elements in left were greater than or equal to their
            corresponding elements in right.
            </summary>
            <param name="left">The first vector to compare.</param>
            <param name="right">The second vector to compare.</param>
            <returns>The resultant vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector.GreaterThanOrEqual(NCDK.Numerics.Vector{System.Single},NCDK.Numerics.Vector{System.Single})">
            <summary>
            Returns an integral vector whose elements signal whether the elements in left were greater than or equal to their
            corresponding elements in right.
            </summary>
            <param name="left">The first vector to compare.</param>
            <param name="right">The second vector to compare.</param>
            <returns>The resultant integral vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector.GreaterThanOrEqual(NCDK.Numerics.Vector{System.Int32},NCDK.Numerics.Vector{System.Int32})">
            <summary>
            Returns a new vector whose elements signal whether the elements in left were greater than or equal to their
            corresponding elements in right.
            </summary>
            <param name="left">The first vector to compare.</param>
            <param name="right">The second vector to compare.</param>
            <returns>The resultant vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector.GreaterThanOrEqual(NCDK.Numerics.Vector{System.Int64},NCDK.Numerics.Vector{System.Int64})">
            <summary>
            Returns a new vector whose elements signal whether the elements in left were greater than or equal to their
            corresponding elements in right.
            </summary>
            <param name="left">The first vector to compare.</param>
            <param name="right">The second vector to compare.</param>
            <returns>The resultant vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector.GreaterThanOrEqual(NCDK.Numerics.Vector{System.Double},NCDK.Numerics.Vector{System.Double})">
            <summary>
            Returns an integral vector whose elements signal whether the elements in left were greater than or equal to 
            their corresponding elements in right.
            </summary>
            <param name="left">The first vector to compare.</param>
            <param name="right">The second vector to compare.</param>
            <returns>The resultant integral vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector.GreaterThanOrEqualAll``1(NCDK.Numerics.Vector{``0},NCDK.Numerics.Vector{``0})">
            <summary>
            Returns a bool indicating whether all of the elements in left are greater than or equal to 
            their corresponding elements in right.
            </summary>
            <param name="left">The first vector to compare.</param>
            <param name="right">The second vector to compare.</param>
            <returns>True if all elements in left are greater than or equal to their corresponding elements in right; False otherwise.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector.GreaterThanOrEqualAny``1(NCDK.Numerics.Vector{``0},NCDK.Numerics.Vector{``0})">
            <summary>
            Returns a bool indicating whether any element in left is greater than or equal to its corresponding element in right.
            </summary>
            <param name="left">The first vector to compare.</param>
            <param name="right">The second vector to compare.</param>
            <returns>True if any elements in left are greater than or equal to their corresponding elements in right; False otherwise.</returns>
        </member>
        <member name="P:NCDK.Numerics.Vector.IsHardwareAccelerated">
            <summary>
            Returns whether or not vector operations are subject to hardware acceleration through JIT intrinsic support.
            </summary>
        </member>
        <member name="M:NCDK.Numerics.Vector.Abs``1(NCDK.Numerics.Vector{``0})">
            <summary>
            Returns a new vector whose elements are the absolute values of the given vector's elements.
            </summary>
            <param name="value">The source vector.</param>
            <returns>The absolute value vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector.Min``1(NCDK.Numerics.Vector{``0},NCDK.Numerics.Vector{``0})">
            <summary>
            Returns a new vector whose elements are the minimum of each pair of elements in the two given vectors.
            </summary>
            <param name="left">The first source vector.</param>
            <param name="right">The second source vector.</param>
            <returns>The minimum vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector.Max``1(NCDK.Numerics.Vector{``0},NCDK.Numerics.Vector{``0})">
            <summary>
            Returns a new vector whose elements are the maximum of each pair of elements in the two given vectors.
            </summary>
            <param name="left">The first source vector.</param>
            <param name="right">The second source vector.</param>
            <returns>The maximum vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector.Dot``1(NCDK.Numerics.Vector{``0},NCDK.Numerics.Vector{``0})">
            <summary>
            Returns the dot product of two vectors.
            </summary>
            <param name="left">The first source vector.</param>
            <param name="right">The second source vector.</param>
            <returns>The dot product.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector.SquareRoot``1(NCDK.Numerics.Vector{``0})">
            <summary>
            Returns a new vector whose elements are the square roots of the given vector's elements.
            </summary>
            <param name="value">The source vector.</param>
            <returns>The square root vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector.Add``1(NCDK.Numerics.Vector{``0},NCDK.Numerics.Vector{``0})">
            <summary>
            Creates a new vector whose values are the sum of each pair of elements from the two given vectors.
            </summary>
            <param name="left">The first source vector.</param>
            <param name="right">The second source vector.</param>
            <returns>The summed vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector.Subtract``1(NCDK.Numerics.Vector{``0},NCDK.Numerics.Vector{``0})">
            <summary>
            Creates a new vector whose values are the difference between each pairs of elements in the given vectors.
            </summary>
            <param name="left">The first source vector.</param>
            <param name="right">The second source vector.</param>
            <returns>The difference vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector.Multiply``1(NCDK.Numerics.Vector{``0},NCDK.Numerics.Vector{``0})">
            <summary>
            Creates a new vector whose values are the product of each pair of elements from the two given vectors.
            </summary>
            <param name="left">The first source vector.</param>
            <param name="right">The second source vector.</param>
            <returns>The summed vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector.Multiply``1(NCDK.Numerics.Vector{``0},``0)">
            <summary>
            Returns a new vector whose values are the values of the given vector each multiplied by a scalar value.
            </summary>
            <param name="left">The source vector.</param>
            <param name="right">The scalar factor.</param>
            <returns>The scaled vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector.Multiply``1(``0,NCDK.Numerics.Vector{``0})">
            <summary>
            Returns a new vector whose values are the values of the given vector each multiplied by a scalar value.
            </summary>
            <param name="left">The scalar factor.</param>
            <param name="right">The source vector.</param>
            <returns>The scaled vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector.Divide``1(NCDK.Numerics.Vector{``0},NCDK.Numerics.Vector{``0})">
            <summary>
            Returns a new vector whose values are the result of dividing the first vector's elements 
            by the corresponding elements in the second vector.
            </summary>
            <param name="left">The first source vector.</param>
            <param name="right">The second source vector.</param>
            <returns>The divided vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector.Negate``1(NCDK.Numerics.Vector{``0})">
            <summary>
            Returns a new vector whose elements are the given vector's elements negated.
            </summary>
            <param name="value">The source vector.</param>
            <returns>The negated vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector.BitwiseAnd``1(NCDK.Numerics.Vector{``0},NCDK.Numerics.Vector{``0})">
            <summary>
            Returns a new vector by performing a bitwise-and operation on each of the elements in the given vectors.
            </summary>
            <param name="left">The first source vector.</param>
            <param name="right">The second source vector.</param>
            <returns>The resultant vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector.BitwiseOr``1(NCDK.Numerics.Vector{``0},NCDK.Numerics.Vector{``0})">
            <summary>
            Returns a new vector by performing a bitwise-or operation on each of the elements in the given vectors.
            </summary>
            <param name="left">The first source vector.</param>
            <param name="right">The second source vector.</param>
            <returns>The resultant vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector.OnesComplement``1(NCDK.Numerics.Vector{``0})">
            <summary>
            Returns a new vector whose elements are obtained by taking the one's complement of the given vector's elements.
            </summary>
            <param name="value">The source vector.</param>
            <returns>The one's complement vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector.Xor``1(NCDK.Numerics.Vector{``0},NCDK.Numerics.Vector{``0})">
            <summary>
            Returns a new vector by performing a bitwise-exclusive-or operation on each of the elements in the given vectors.
            </summary>
            <param name="left">The first source vector.</param>
            <param name="right">The second source vector.</param>
            <returns>The resultant vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector.AndNot``1(NCDK.Numerics.Vector{``0},NCDK.Numerics.Vector{``0})">
            <summary>
            Returns a new vector by performing a bitwise-and-not operation on each of the elements in the given vectors.
            </summary>
            <param name="left">The first source vector.</param>
            <param name="right">The second source vector.</param>
            <returns>The resultant vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector.AsVectorByte``1(NCDK.Numerics.Vector{``0})">
            <summary>
            Reinterprets the bits of the given vector into those of a vector of unsigned bytes.
            </summary>
            <param name="value">The source vector</param>
            <returns>The reinterpreted vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector.AsVectorSByte``1(NCDK.Numerics.Vector{``0})">
            <summary>
            Reinterprets the bits of the given vector into those of a vector of signed bytes.
            </summary>
            <param name="value">The source vector</param>
            <returns>The reinterpreted vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector.AsVectorUInt16``1(NCDK.Numerics.Vector{``0})">
            <summary>
            Reinterprets the bits of the given vector into those of a vector of 16-bit integers.
            </summary>
            <param name="value">The source vector</param>
            <returns>The reinterpreted vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector.AsVectorInt16``1(NCDK.Numerics.Vector{``0})">
            <summary>
            Reinterprets the bits of the given vector into those of a vector of signed 16-bit integers.
            </summary>
            <param name="value">The source vector</param>
            <returns>The reinterpreted vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector.AsVectorUInt32``1(NCDK.Numerics.Vector{``0})">
            <summary>
            Reinterprets the bits of the given vector into those of a vector of unsigned 32-bit integers.
            </summary>
            <param name="value">The source vector</param>
            <returns>The reinterpreted vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector.AsVectorInt32``1(NCDK.Numerics.Vector{``0})">
            <summary>
            Reinterprets the bits of the given vector into those of a vector of signed 32-bit integers.
            </summary>
            <param name="value">The source vector</param>
            <returns>The reinterpreted vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector.AsVectorUInt64``1(NCDK.Numerics.Vector{``0})">
            <summary>
            Reinterprets the bits of the given vector into those of a vector of unsigned 64-bit integers.
            </summary>
            <param name="value">The source vector</param>
            <returns>The reinterpreted vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector.AsVectorInt64``1(NCDK.Numerics.Vector{``0})">
            <summary>
            Reinterprets the bits of the given vector into those of a vector of signed 64-bit integers.
            </summary>
            <param name="value">The source vector</param>
            <returns>The reinterpreted vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector.AsVectordouble``1(NCDK.Numerics.Vector{``0})">
            <summary>
            Reinterprets the bits of the given vector into those of a vector of 32-bit doubleing point numbers.
            </summary>
            <param name="value">The source vector</param>
            <returns>The reinterpreted vector.</returns>
        </member>
        <member name="M:NCDK.Numerics.Vector.AsVectorDouble``1(NCDK.Numerics.Vector{``0})">
            <summary>
            Reinterprets the bits of the given vector into those of a vector of 64-bit doubleing point numbers.
            </summary>
            <param name="value">The source vector</param>
            <returns>The reinterpreted vector.</returns>
        </member>
        <member name="T:NCDK.Default.AdductFormula">
            <summary>
            Class defining an adduct object in a MolecularFormula. It maintains
            a list of list IMolecularFormula.
            <para>
            Examples:
            <list type="bullet">
            <item>[C2H4O2+Na]+</item>
            </list>
            </para>
            </summary>
        </member>
        <member name="F:NCDK.Default.AdductFormula.components">
            <summary> Internal List of IMolecularFormula.</summary>
        </member>
        <member name="M:NCDK.Default.AdductFormula.#ctor">
            <summary>
            Constructs an empty AdductFormula.
            </summary>
        </member>
        <member name="M:NCDK.Default.AdductFormula.#ctor(NCDK.IMolecularFormula)">
            <summary>
            Constructs an AdductFormula with a copy AdductFormula of another
            AdductFormula (A shallow copy, i.e., with the same objects as in
            the original AdductFormula).
            </summary>
            <param name="formula">An MolecularFormula to copy from</param>
        </member>
        <member name="M:NCDK.Default.AdductFormula.Add(NCDK.IMolecularFormula)">
            <summary>
            Adds an molecularFormula to this chemObject.
            </summary>
            <param name="formula">The molecularFormula to be added to this chemObject</param>
        </member>
        <member name="M:NCDK.Default.AdductFormula.Add(NCDK.IMolecularFormulaSet)">
            <summary>
            Adds all molecularFormulas in the AdductFormula to this chemObject.
            </summary>
            <param name="formulaSet">The MolecularFormulaSet</param>
        </member>
        <member name="M:NCDK.Default.AdductFormula.Contains(NCDK.IIsotope)">
            <summary>
            True, if the AdductFormula contains the given IIsotope object and not
            the instance. The method looks for other isotopes which has the same
            symbol, natural abundance and exact mass.
            </summary>
            <param name="isotope">The IIsotope this AdductFormula is searched for</param>
            <returns>True, if the AdductFormula contains the given isotope object</returns>
        </member>
        <member name="P:NCDK.Default.AdductFormula.Charge">
            <summary>
            The partial charge of this Adduct. If the charge
            has not been set the return value is double.NaN.
            </summary>
        </member>
        <member name="M:NCDK.Default.AdductFormula.GetCount(NCDK.IIsotope)">
            <summary>
            Checks a set of Nodes for the occurrence of the isotope in the
            adduct formula from a particular isotope. It returns 0 if the does not exist.
            </summary>
            <param name="isotope">The IIsotope to look for</param>
            <returns>The occurrence of this isotope in this adduct</returns>
        </member>
        <member name="P:NCDK.Default.AdductFormula.IsotopeCount">
            <summary>
            The the number of different isotopes in this adduct formula
            </summary>
        </member>
        <member name="M:NCDK.Default.AdductFormula.GetIsotopes">
            <summary>
            An IEnumerator for looping over all isotopes in this adduct formula.
            </summary>
        </member>
        <member name="M:NCDK.Default.AdductFormula.IsotopesList">
            <summary>
            Returns a List for looping over all isotopes in this adduct formula.
            </summary>
            <returns>A List with the isotopes in this adduct formula</returns>
        </member>
        <member name="M:NCDK.Default.AdductFormula.GetEnumerator">
            <summary>
            Returns an Iterable for looping over all IMolecularFormula
            in this adduct formula.
            </summary>
            <returns>An Iterable with the IMolecularFormula in this adduct formula</returns>
        </member>
        <member name="P:NCDK.Default.AdductFormula.Count">
            <summary>
            The number of MolecularFormulas in this AdductFormula.
            </summary>
        </member>
        <member name="M:NCDK.Default.AdductFormula.Contains(NCDK.IMolecularFormula)">
             <summary>
             True, if the AdductFormula contains the given IMolecularFormula object.
            
             <param name="formula">The IMolecularFormula this AdductFormula is searched for</param>
             <returns>True, if the AdductFormula contains the given IMolecularFormula object</returns>
             </summary>
        </member>
        <member name="P:NCDK.Default.AdductFormula.Item(System.Int32)">
            <summary>
            The MolecularFormula at position <paramref name="position"/> in the hemObject.
            </summary>
            <param name="position">The position of the IMolecularFormula to be returned.</param>
            <returns>The IMolecularFormula at position <paramref name="position"/>.</returns>
        </member>
        <member name="M:NCDK.Default.AdductFormula.Clear">
            <summary>
            Removes all IMolecularFormula from this chemObject.
            </summary>
        </member>
        <member name="M:NCDK.Default.AdductFormula.Remove(NCDK.IMolecularFormula)">
            <summary>
            Removes an IMolecularFormula from this chemObject.
            </summary>
            <param name="formula">The IMolecularFormula to be removed from this chemObject</param>
        </member>
        <member name="M:NCDK.Default.AdductFormula.RemoveAt(System.Int32)">
            <summary>
            Removes an MolecularFormula from this chemObject.
            </summary>
            <param name="position">The position of the MolecularFormula to be removed from this chemObject</param>
        </member>
        <member name="M:NCDK.Default.AdductFormula.Clone">
            <summary>
            Clones this AdductFormula object and its content.
            </summary>
            <returns> The cloned object</returns>
        </member>
        <member name="M:NCDK.Default.AdductFormula.IsTheSame(NCDK.IIsotope,NCDK.IIsotope)">
            <summary>
            Compare to IIsotope. The method doesn't compare instance but if they
            have the same symbol, natural abundance and exact mass.
            </summary>
            <param name="isotopeOne">The first Isotope to compare</param>
            <param name="isotopeTwo">The second Isotope to compare</param>
            <returns>True, if both isotope are the same</returns>
        </member>
        <member name="T:NCDK.Default.Association">
            <summary>
            Base class for storing interactions like hydrogen bonds and ionic interactions.
            The ElectronContainer contains zero electrons by default.
            </summary>
        </member>
        <member name="P:NCDK.Default.Association.AssociatedAtoms">
            <summary>
            The atoms which take part in the association.
            </summary>
        </member>
        <member name="M:NCDK.Default.Association.#ctor(NCDK.IAtom,NCDK.IAtom)">
            <summary>
            Constructs an association between two Atom's.
            </summary>
            <param name="atom1">An atom to be associated with another atom</param>
            <param name="atom2">An atom to be associated with another atom</param>
            <seealso cref="T:NCDK.Default.Atom"/>
        </member>
        <member name="M:NCDK.Default.Association.#ctor">
            <summary>
            Constructs an empty association.
            </summary>
            <seealso cref="T:NCDK.Default.Atom"/>
        </member>
        <member name="P:NCDK.Default.Association.ElectronCount">
            <summary>
            The number of electrons in a Association.
            </summary>
        </member>
        <member name="T:NCDK.Default.ChemObject">
            <summary>
            The base class for all chemical objects in this cdk. It provides methods for
            adding listeners and for their notification of events, as well a a hash
            table for administration of physical or chemical properties
            </summary>
        </member>
        <member name="P:NCDK.Default.ChemObject.Listeners">
            <summary>
            List for listener administration.
            </summary>
        </member>
        <member name="P:NCDK.Default.ChemObject.IsVisited">
            <summary>
            Flag is set if chemobject has been visited
            </summary>
        </member>
        <member name="M:NCDK.Default.ChemObject.#ctor">
            <summary>
            Constructs a new IChemObject.
            </summary>
        </member>
        <member name="M:NCDK.Default.ChemObject.#ctor(NCDK.IChemObject)">
            <summary>
            Constructs a new IChemObject by copying the flags, and the. It does not copy the listeners and properties.
            </summary>
            <param name="chemObject">the object to copy</param>
        </member>
        <member name="M:NCDK.Default.ChemObject.NotifyChanged">
            <summary>
            This should be triggered by an method that changes the content of an object
             to that the registered listeners can react to it.
            </summary>
        </member>
        <member name="M:NCDK.Default.ChemObject.NotifyChanged(NCDK.ChemObjectChangeEventArgs)">
            <summary>
            This should be triggered by an method that changes the content of an object
            to that the registered listeners can react to it. This is a version of
            NotifyChanged() which allows to propagate a change event while preserving
            the original origin.
            </summary>
            <param name="evt">A ChemObjectChangeEvent pointing to the source of where the change happened</param>
        </member>
        <member name="F:NCDK.Default.ChemObject.properties">
            <summary>
            A dictionary for the storage of any kind of properties of this object.
            </summary>
        </member>
        <member name="M:NCDK.Default.ChemObject.SetProperty(System.Object,System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Default.ChemObject.RemoveProperty(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Default.ChemObject.GetProperty``1(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Default.ChemObject.GetProperty``1(System.Object,``0)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Default.ChemObject.GetProperties">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Default.ChemObject.SetProperties(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.Object,System.Object}})">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Default.ChemObject.AddProperties(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.Object,System.Object}})">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Default.ChemObject.Compare(System.Object)">
            <summary>
            Compares a <see cref="T:NCDK.IChemObject"/> with this <see cref="T:NCDK.IChemObject"/>.
            </summary>
            <param name="obj">Object of type <see cref="T:NCDK.Default.AtomType"/></param>
            <returns><see langword="true"/> if the atom types are equal</returns>
        </member>
        <member name="P:NCDK.Default.ChemObject.Id">
            <summary>
            The identifier (ID) of this object.
            </summary>
        </member>
        <member name="T:NCDK.Default.AminoAcid">
            <summary>
            A AminoAcid is Monomer which stores additional amino acid specific
            informations, like the N-terminus atom.
            </summary>
        </member>
        <member name="P:NCDK.Default.AminoAcid.NTerminus">
            <summary>N-terminus atom.</summary>
        </member>
        <member name="P:NCDK.Default.AminoAcid.CTerminus">
            <summary>C-terminus atom.</summary>
        </member>
        <member name="M:NCDK.Default.AminoAcid.AddNTerminus(NCDK.IAtom)">
            <summary>
            Add an <see cref="T:NCDK.IAtom"/> and makes it the N-terminus atom.
            </summary>
            <param name="atom">The <see cref="T:NCDK.IAtom"/> that is the N-terminus</param>
        </member>
        <member name="M:NCDK.Default.AminoAcid.AddCTerminus(NCDK.IAtom)">
            <summary>
            Add an <see cref="T:NCDK.IAtom"/> and makes it the C-terminus atom.
            </summary>
            <param name="atom">The <see cref="T:NCDK.IAtom"/> that is the C-terminus</param>
        </member>
        <member name="M:NCDK.Default.AminoAcid.Clone(NCDK.CDKObjectMap)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Default.AminoAcid.ToString">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Default.Atom">
             <summary>
             Represents the idea of an chemical atom.
             </summary>
             <example>
             An Atom class is instantiated with at least the atom symbol:
             <code>
               Atom a = new Atom("C");
             </code>
            
             Once instantiated all field not filled by passing parameters
             to the constructor are null. Atoms can be configured by using
             the IsotopeFactory.configure() method:
             <code>
               IsotopeFactory factory = SomeIsotopeFactory.GetInstance(a.Builder);
               factory.Configure(a);
             </code>
            
             More examples about using this class can be found in the
             Junit test for this class.
             </example>
             <seealso cref="M:NCDK.Config.XMLIsotopeFactory.GetInstance(NCDK.IChemObjectBuilder)"/>
        </member>
        <member name="M:NCDK.Default.Atom.#ctor">
            <summary>
            Constructs an completely unset Atom.
            </summary>
        </member>
        <member name="M:NCDK.Default.Atom.#ctor(System.Int32)">
            <summary>
            Create a new atom with of the specified element.
            </summary>
            <param name="elem">atomic number</param>
        </member>
        <member name="M:NCDK.Default.Atom.#ctor(System.Int32,System.Int32)">
            <summary>
            Create a new atom with of the specified element and hydrogen count.
            </summary>
            <param name="elem">atomic number</param>
            <param name="hcnt">hydrogen count</param>
        </member>
        <member name="M:NCDK.Default.Atom.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Create a new atom with of the specified element, hydrogen count, and formal charge.
            </summary>
            <param name="elem">atomic number</param>
            <param name="hcnt">hydrogen count</param>
            <param name="fchg">formal charge</param>
        </member>
        <member name="M:NCDK.Default.Atom.#ctor(System.String)">
            <summary>
            Constructs an Atom from a string containing an element symbol and optionally
            the atomic mass, hydrogen count, and formal charge. 
            </summary>
            <remarks>
            The symbol grammar allows
            easy construction from common symbols, for example:
            
            <code>
                new Atom("NH+");   // nitrogen cation with one hydrogen
                new Atom("OH");    // hydroxy
                new Atom("O-");    // oxygen anion
                new Atom("13CH3"); // methyl isotope 13
            </code>
            
            <pre>
                atom := {mass}? {symbol} {hcnt}? {fchg}?
                mass := \d+
                hcnt := 'H' \d+
                fchg := '+' \d+? | '-' \d+?
            </pre>
            </remarks>
            <param name="symbol">string with the element symbol</param>
        </member>
        <member name="M:NCDK.Default.Atom.#ctor(System.String,NCDK.Numerics.Vector2)">
            <summary>
            Constructs an <see cref="T:NCDK.IAtom"/> from an element name and a <see cref="T:NCDK.Numerics.Vector2"/>.
            </summary>
            <param name="elementSymbol">The Element</param>
            <param name="point2d">The Point</param>
        </member>
        <member name="M:NCDK.Default.Atom.#ctor(System.String,NCDK.Numerics.Vector3)">
            <summary>
            Constructs an <see cref="T:NCDK.IAtom"/> from an element name and a <see cref="T:NCDK.Numerics.Vector3"/>.
            </summary>
            <param name="elementSymbol">The Element</param>
            <param name="point3d">The Point</param>
        </member>
        <member name="M:NCDK.Default.Atom.#ctor(NCDK.IElement)">
            <summary>    
            Constructs an isotope by copying the symbol, atomic number,
            flags, identifier, exact mass, natural abundance, mass
            number, maximum bond order, bond order sum, van der Waals
            and covalent radii, formal charge, hybridization, electron
            valency, formal neighbour count and atom type name from the
            given IAtomType. It does not copy the listeners and
            properties. If the element is an instanceof
            IAtom, then the 2D, 3D and fractional coordinates, partial
            atomic charge, hydrogen count and stereo parity are copied
            too.
            </summary>
            <param name="element"><see cref="T:NCDK.IAtomType"/> to copy information from</param>
        </member>
        <member name="P:NCDK.Default.Atom.Charge">
            <summary>
            The partial charge of this atom.
            </summary>
        </member>
        <member name="P:NCDK.Default.Atom.ImplicitHydrogenCount">
            <summary>
            The number of implicit hydrogen count of this atom.
            </summary>
        </member>
        <member name="P:NCDK.Default.Atom.Point2D">
            <summary>
            A point specifying the location of this atom in a 2D space.
            </summary>
        </member>
        <member name="P:NCDK.Default.Atom.Point3D">
            <summary>
            A point specifying the location of this atom in a 3D space.
            </summary>
        </member>
        <member name="P:NCDK.Default.Atom.FractionalPoint3D">
            <summary>
            A point specifying the location of this atom in a <see cref="T:NCDK.Default.Crystal"/> unit cell.
            </summary>
        </member>
        <member name="P:NCDK.Default.Atom.StereoParity">
            <summary>
            The stereo parity for this atom.
            </summary>
        </member>
        <member name="P:NCDK.Default.Atom.IsSingleOrDouble">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Default.Atom.Compare(System.Object)">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Default.AtomContainer">
            <summary>
            Base class for all chemical objects that maintain a list of Atoms and
            ElectronContainers. 
            </summary>
            <example>
            Looping over all Bonds in the AtomContainer is typically done like: 
            <code>
            foreach (IBond aBond in atomContainer.Bonds)
            {
                    // do something
            }
            </code>
            </example>
        </member>
        <member name="F:NCDK.Default.AtomContainer.atoms">
            <summary>
            Atoms contained by this object.
            </summary>
        </member>
        <member name="F:NCDK.Default.AtomContainer.bonds">
            <summary>
            Bonds contained by this object.
            </summary>
        </member>
        <member name="F:NCDK.Default.AtomContainer.lonePairs">
            <summary>
            Lone pairs contained by this object.
            </summary>
        </member>
        <member name="F:NCDK.Default.AtomContainer.singleElectrons">
            <summary>
            Single electrons contained by this object.
            </summary>
        </member>
        <member name="F:NCDK.Default.AtomContainer.stereoElements">
            <summary>
            Stereo elements contained by this object.
            </summary>
        </member>
        <member name="M:NCDK.Default.AtomContainer.#ctor">
            <summary>
             Constructs an empty AtomContainer.
            </summary>
        </member>
        <member name="M:NCDK.Default.AtomContainer.#ctor(NCDK.IAtomContainer)">
            <summary>
            Constructs an AtomContainer with a copy of the atoms and electronContainers
            of another AtomContainer (A shallow copy, i.e., with the same objects as in
            the original AtomContainer).
            </summary>
            <param name="container">An AtomContainer to copy the atoms and electronContainers from</param>
        </member>
        <member name="P:NCDK.Default.AtomContainer.IsAromatic">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.Default.AtomContainer.IsSingleOrDouble">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.Default.AtomContainer.Atoms">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.Default.AtomContainer.Bonds">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.Default.AtomContainer.LonePairs">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.Default.AtomContainer.SingleElectrons">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.Default.AtomContainer.StereoElements">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Default.AtomContainer.SetStereoElements(System.Collections.Generic.IEnumerable{NCDK.IStereoElement})">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Default.AtomContainer.GetBond(NCDK.IAtom,NCDK.IAtom)">
            <summary>
            Returns the bond that connects the two given atoms.
            </summary>
            <param name="atom1">The first atom</param>
            <param name="atom2">The second atom</param>
            <returns>The bond that connects the two atoms</returns>
        </member>
        <member name="M:NCDK.Default.AtomContainer.GetConnectedAtoms(NCDK.IAtom)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Default.AtomContainer.GetConnectedBonds(NCDK.IAtom)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Default.AtomContainer.GetConnectedLonePairs(NCDK.IAtom)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Default.AtomContainer.GetConnectedSingleElectrons(NCDK.IAtom)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Default.AtomContainer.GetConnectedElectronContainers(NCDK.IAtom)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Default.AtomContainer.GetBondOrderSum(NCDK.IAtom)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Default.AtomContainer.GetMaximumBondOrder(NCDK.IAtom)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Default.AtomContainer.GetMinimumBondOrder(NCDK.IAtom)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Default.AtomContainer.Add(NCDK.IAtomContainer)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Default.AtomContainer.AddElectronContainer(NCDK.IElectronContainer)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Default.AtomContainer.Remove(NCDK.IAtomContainer)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Default.AtomContainer.RemoveElectronContainer(NCDK.IElectronContainer)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Default.AtomContainer.RemoveAtomAndConnectedElectronContainers(NCDK.IAtom)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Default.AtomContainer.RemoveAtom(NCDK.IAtom)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Default.AtomContainer.RemoveAllElements">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Default.AtomContainer.RemoveAllElectronContainers">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Default.AtomContainer.RemoveAllBonds">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Default.AtomContainer.AddBond(NCDK.IAtom,NCDK.IAtom,NCDK.BondOrder,NCDK.BondStereo)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Default.AtomContainer.AddBond(NCDK.IAtom,NCDK.IAtom,NCDK.BondOrder)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Default.AtomContainer.AddLonePairTo(NCDK.IAtom)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Default.AtomContainer.AddSingleElectronTo(NCDK.IAtom)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Default.AtomContainer.RemoveBond(NCDK.IAtom,NCDK.IAtom)">
            <summary>
            Removes the bond that connects the two given atoms.
            </summary>
            <param name="atom1">The first atom</param>
            <param name="atom2">The second atom</param>
            <returns>The bond that connects the two atoms</returns>
        </member>
        <member name="M:NCDK.Default.AtomContainer.Contains(NCDK.IAtom)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Default.AtomContainer.Contains(NCDK.IBond)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Default.AtomContainer.Contains(NCDK.ILonePair)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Default.AtomContainer.Contains(NCDK.ISingleElectron)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Default.AtomContainer.Contains(NCDK.IElectronContainer)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Default.AtomContainer.ToString">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Default.AtomContainer.Clone(NCDK.CDKObjectMap)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Default.AtomContainer.GetElectronContainers">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Default.AtomContainer.OnStateChanged(NCDK.ChemObjectChangeEventArgs)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Default.AtomContainer.SetAtoms(System.Collections.Generic.IEnumerable{NCDK.IAtom})">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Default.AtomContainer.SetBonds(System.Collections.Generic.IEnumerable{NCDK.IBond})">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Default.AtomContainer.IsEmpty">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Default.ChemObjectSet`1">
            <summary>
            A set of AtomContainers.
            </summary>
        </member>
        <member name="M:NCDK.Default.ChemObjectSet`1.#ctor">
            <summary> Constructs an empty ChemObjectSet.</summary>
        </member>
        <member name="M:NCDK.Default.ChemObjectSet`1.Add(`0)">
            <summary>
            Adds an atomContainer to this container.
            </summary>
            <param name="atomContainer">The atomContainer to be added to this container</param>
        </member>
        <member name="M:NCDK.Default.ChemObjectSet`1.Remove(`0)">
            <summary>
            Removes an AtomContainer from this container.
            </summary>
            <param name="atomContainer">The atomContainer to be removed from this container</param>
        </member>
        <member name="M:NCDK.Default.ChemObjectSet`1.Clear">
            <summary>
            Removes all AtomContainer from this container.
            </summary>
        </member>
        <member name="M:NCDK.Default.ChemObjectSet`1.RemoveAt(System.Int32)">
            <summary>
            Removes an AtomContainer from this container.
            </summary>
            <param name="pos">The position of the AtomContainer to be removed from this container</param>
        </member>
        <member name="P:NCDK.Default.ChemObjectSet`1.Item(System.Int32)">
            <summary>
            The AtomContainer at a specific position (array has to be large enough).
            </summary>
            <param name="position">position in array for AtomContainer</param>
        </member>
        <member name="M:NCDK.Default.ChemObjectSet`1.SetMultiplier(`0,System.Nullable{System.Double})">
            <summary>
            Sets the coefficient of a AtomContainer to a given value.
            </summary>
            <param name="container">The AtomContainer for which the multiplier is set</param>
            <param name="multiplier">The new multiplier for the AtomContatiner</param>
            <returns>true if multiplier has been set</returns>
            <seealso cref="M:NCDK.Default.ChemObjectSet`1.GetMultiplier(`0)"/>
        </member>
        <member name="M:NCDK.Default.ChemObjectSet`1.SetMultiplier(System.Int32,System.Nullable{System.Double})">
            <summary>
            Sets the coefficient of a AtomContainer to a given value.
            </summary>
            <param name="position">The position of the AtomContainer for which the multiplier is set in [0,..]</param>
            <param name="multiplier">The new multiplier for the AtomContatiner at <paramref name="position"/></param>
            <seealso cref="M:NCDK.Default.ChemObjectSet`1.GetMultiplier(System.Int32)"/>
        </member>
        <member name="M:NCDK.Default.ChemObjectSet`1.SetMultipliers(System.Collections.Generic.IEnumerable{System.Nullable{System.Double}})">
            <summary>
            Sets the multipliers of the AtomContainers.
            </summary>
            <param name="multipliers">The new multipliers for the AtomContainers in this set</param>
            <returns>true if multipliers have been set.</returns>
            <seealso cref="M:NCDK.Default.ChemObjectSet`1.GetMultipliers"/>
        </member>
        <member name="M:NCDK.Default.ChemObjectSet`1.Add(`0,System.Nullable{System.Double})">
            <summary>
            Adds an atomContainer to this container with the given
            multiplier.
            </summary>
            <param name="atomContainer">The atomContainer to be added to this container</param>
            <param name="multiplier">The multiplier of this atomContainer</param>
        </member>
        <member name="M:NCDK.Default.ChemObjectSet`1.Add(NCDK.IChemObjectSet{`0})">
            <summary>
             Adds all atomContainers in the ChemObjectSet to this container.
            </summary>
            <param name="atomContainerSet">The ChemObjectSet</param>
        </member>
        <member name="M:NCDK.Default.ChemObjectSet`1.GetMultiplier(System.Int32)">
            <summary>
            Returns the multiplier for the AtomContainer at position <code>number</code> in the
            container.
            </summary>
            <param name="number">The position of the multiplier of the AtomContainer to be returned.</param>
            <returns>The multiplier for the AtomContainer at position <paramref name="number"/>.</returns>
            <seealso cref="M:NCDK.Default.ChemObjectSet`1.SetMultiplier(System.Int32,System.Nullable{System.Double})"/>
        </member>
        <member name="M:NCDK.Default.ChemObjectSet`1.GetMultiplier(`0)">
            <summary>
            Returns the multiplier of the given AtomContainer.
            </summary>
            <param name="container">The AtomContainer for which the multiplier is given</param>
            <returns>-1, if the given molecule is not a container in this set</returns>
        </member>
        <member name="M:NCDK.Default.ChemObjectSet`1.ToString">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Default.ChemObjectSet`1.OnStateChanged(NCDK.ChemObjectChangeEventArgs)">
            <summary>
             Called by objects to which this object has
             registered as a listener.
            </summary>
            <param name="evt">A change event pointing to the source of the change</param>
        </member>
        <member name="M:NCDK.Default.ChemObjectSet`1.Sort(System.Collections.Generic.IComparer{`0})">
            <summary>
            Sort the AtomContainers and multipliers using a provided Comparator.
            </summary>
            <param name="comparator">defines the sorting method</param>
        </member>
        <member name="T:NCDK.Default.AtomType">
            <summary>
            The base class for atom types. Atom types are typically used to describe the
            behaviour of an atom of a particular element in different environment like
            sp<sup>3</sup>
            hybridized carbon C3, etc., in some molecular modelling applications.
            </summary>
        </member>
        <member name="F:NCDK.Default.AtomType.maxBondOrder">
            <summary>
             The maximum bond order allowed for this atom type.
            </summary>
        </member>
        <member name="F:NCDK.Default.AtomType.bondOrderSum">
            <summary>
             The maximum sum of all bond orders allowed for this atom type.
            </summary>
        </member>
        <member name="F:NCDK.Default.AtomType.covalentRadius">
            <summary>
            The covalent radius of this atom type.
            </summary>
        </member>
        <member name="F:NCDK.Default.AtomType.formalCharge">
            <summary>
             The formal charge of the atom with CDKConstants.UNSET as default. Implements RFC #6.
            </summary>
            <remarks>
             Note that some constructors (<see cref="M:NCDK.Default.AtomType.#ctor(System.String)"/> and
            <see cref="M:NCDK.Default.AtomType.#ctor(System.String,System.String)"/> ) will explicitly set this field to 0
            </remarks>
        </member>
        <member name="F:NCDK.Default.AtomType.hybridization">
            <summary>
            The hybridization state of this atom with CDKConstants.HYBRIDIZATION_UNSET
            as default.
            </summary>
        </member>
        <member name="F:NCDK.Default.AtomType.valency">
            <summary>
            The electron Valency of this atom with CDKConstants.UNSET as default.
            </summary>
        </member>
        <member name="F:NCDK.Default.AtomType.formalNeighbourCount">
            <summary>
            The formal number of neighbours this atom type can have with CDKConstants_UNSET
            as default. This includes explicitely and implicitely connected atoms, including
            implicit hydrogens.
            </summary>
        </member>
        <member name="M:NCDK.Default.AtomType.#ctor(System.String)">
            <summary>
            Constructor for the AtomType object.
            
            Defaults to a zero formal charge. All
            other fields are set to <see langword="null"/> or unset.
            </summary>
            <param name="elementSymbol">Symbol of the atom</param>
        </member>
        <member name="M:NCDK.Default.AtomType.#ctor(System.String,System.String)">
            <summary>
            Constructor for the AtomType object. Defaults to a zero formal charge.
            </summary>
            <param name="identifier">An id for this atom type, like C3 for sp3 carbon</param>
            <param name="elementSymbol">The element symbol identifying the element to which this atom type applies</param>
        </member>
        <member name="M:NCDK.Default.AtomType.#ctor(NCDK.IElement)">
            <summary>
            Constructs an isotope by copying the symbol, atomic number,
            flags, identifier, exact mass, natural abundance and mass
            number from the given IIsotope. It does not copy the
            listeners and properties. If the element is an instanceof
            IAtomType, then the maximum bond order, bond order sum,
            van der Waals and covalent radii, formal charge, hybridization,
            electron valency, formal neighbour count and atom type name
            are copied too.
            </summary>
            <param name="element">IIsotope to copy information from</param>
        </member>
        <member name="P:NCDK.Default.AtomType.AtomTypeName">
            <summary>
            The if attribute of the AtomType object.
            </summary>
        </member>
        <member name="P:NCDK.Default.AtomType.MaxBondOrder">
            <summary>
            The MaxBondOrder attribute of the AtomType object.
            </summary>
        </member>
        <member name="P:NCDK.Default.AtomType.BondOrderSum">
            <summary>
            The the exact bond order sum attribute of the AtomType object.
            </summary>
        </member>
        <member name="P:NCDK.Default.AtomType.FormalCharge">
            <summary>
            The formal charge of this atom.
            </summary>
        </member>
        <member name="P:NCDK.Default.AtomType.FormalNeighbourCount">
            <summary>
            The formal neighbour count of this atom.
            </summary>
        </member>
        <member name="P:NCDK.Default.AtomType.Hybridization">
            <summary>
            The hybridization of this atom.
            </summary>
        </member>
        <member name="M:NCDK.Default.AtomType.Compare(System.Object)">
            <summary>
            Compares a atom type with this atom type.
            </summary>
            <param name="obj">Object of type AtomType</param>
            <returns>true if the atom types are equal</returns>
        </member>
        <member name="P:NCDK.Default.AtomType.CovalentRadius">
            <summary>
            The covalent radius for this AtomType.
            </summary>
        </member>
        <member name="P:NCDK.Default.AtomType.Valency">
            <summary>
            The the exact electron valency of the AtomType object.
            </summary>
        </member>
        <member name="M:NCDK.Default.BioPolymer.AddAtom(NCDK.IAtom,NCDK.IStrand)">
            <summary>
            Adds the atom oAtom to a specified Strand, whereas the Monomer is unspecified. Hence
            the atom will be added to a Monomer of type Unknown in the specified Strand.
            </summary>
            <param name="oAtom">The atom to add</param>
            <param name="oStrand">The strand the atom belongs to</param>
        </member>
        <member name="T:NCDK.Default.Bond">
            <summary>
            Implements the concept of a covalent bond between two or more atoms. A bond is
            considered to be a number of electrons connecting two or more  of atoms.
            </summary>
            <remarks>
            <para>
            It should be noted that the majority of applications will consider 2-center bonds,
            especially since the bond orders currently supported are really only valid for
            2-center bonds. However the code does support multi-center bonds, though the
            orders may not make sense at this point.
            </para>
            <para>
            In general code that assumes bonds are 2-centered can use this class seamlessly, as
            the semantics are identical to the older versions. Care shoud be exercised when
            using multi-center bonds using this class as the orders may not make sense.
            </para>
            </remarks>
        </member>
        <member name="M:NCDK.Default.Bond.#ctor">
            <summary>
            Constructs an empty bond.
            </summary>
        </member>
        <member name="M:NCDK.Default.Bond.#ctor(NCDK.IAtom,NCDK.IAtom)">
            <summary>
            Constructs a bond with a single bond order.
            </summary>
            <param name="atom1">the first Atom in the bond</param>
            <param name="atom2">the second Atom in the bond</param>
        </member>
        <member name="M:NCDK.Default.Bond.#ctor(NCDK.IAtom,NCDK.IAtom,NCDK.BondOrder)">
            <summary>
            Constructs a bond with a single bond order.
            </summary>
            <param name="atom1">the first Atom in the bond</param>
            <param name="atom2">the second Atom in the bond</param>
            <param name="order">the bond order</param>
        </member>
        <member name="M:NCDK.Default.Bond.#ctor(System.Collections.Generic.IEnumerable{NCDK.IAtom})">
            <summary>
            Constructs a multi-center bond, with undefined order and no stereo information.
            </summary>
            <param name="atoms"><see cref="T:System.Collections.Generic.IEnumerable`1"/> of <see cref="T:NCDK.IAtom"/> containing the atoms constituting the bond</param>
        </member>
        <member name="M:NCDK.Default.Bond.#ctor(System.Collections.Generic.IEnumerable{NCDK.IAtom},NCDK.BondOrder)">
            <summary>
            Constructs a multi-center bond, with a specified order and no stereo information.
            </summary>
            <param name="atoms">An array of <see cref="T:NCDK.IAtom"/> containing the atoms constituting the bond</param>
            <param name="order">The order of the bond</param>
        </member>
        <member name="M:NCDK.Default.Bond.#ctor(NCDK.IAtom,NCDK.IAtom,NCDK.BondOrder,NCDK.BondStereo)">
            <summary>
            Constructs a bond with a single bond order.
            </summary>
            <param name="atom1">the first Atom in the bond</param>
            <param name="atom2">the second Atom in the bond</param>
            <param name="order">the bond order</param>
            <param name="stereo">a descriptor the stereochemical orientation of this bond</param>
        </member>
        <member name="P:NCDK.Default.Bond.Atoms">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.Default.Bond.Begin">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.Default.Bond.End">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Default.Bond.GetOther(NCDK.IAtom)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Default.Bond.GetConnectedAtom(NCDK.IAtom)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Default.Bond.GetConnectedAtoms(NCDK.IAtom)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Default.Bond.Contains(NCDK.IAtom)">
            <summary>
            Returns true if the given atom participates in this bond.
            </summary>
            <param name="atom">The atom to be tested if it participates in this bond</param>
            <returns>true if the atom participates in this bond</returns>
        </member>
        <member name="M:NCDK.Default.Bond.SetAtoms(System.Collections.Generic.IEnumerable{NCDK.IAtom})">
            <summary>
            Sets the array of atoms making up this bond.
            </summary>
            <param name="atoms">An array of atoms that forms this bond</param>
            <seealso cref="P:NCDK.Default.Bond.Atoms"/>
        </member>
        <member name="P:NCDK.Default.Bond.Order">
            <summary>
            The bond order of this bond.
            </summary>
        </member>
        <member name="P:NCDK.Default.Bond.Stereo">
            <summary>
            The stereo descriptor for this bond.
            </summary>
        </member>
        <member name="P:NCDK.Default.Bond.Geometric2DCenter">
            <summary>
            The geometric 2D center of the bond.
            </summary>
        </member>
        <member name="P:NCDK.Default.Bond.Geometric3DCenter">
            <summary>
            The geometric 3D center of the bond.
            </summary>
        </member>
        <member name="P:NCDK.Default.Bond.IsAromatic">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.Default.Bond.IsAliphatic">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.Default.Bond.IsInRing">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.Default.Bond.IsSingleOrDouble">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.Default.Bond.IsReactiveCenter">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Default.Bond.Compare(System.Object)">
            <summary>
            Compares a bond with this bond.
            </summary>
            <param name="obj">Object of type Bond</param>
            <returns> true if the bond is equal to this bond</returns>
        </member>
        <member name="M:NCDK.Default.Bond.IsConnectedTo(NCDK.IBond)">
            <summary>
            Checks whether a bond is connected to another one.
            This can only be true if the bonds have an Atom in common.
            </summary>
            <param name="bond">The bond which is checked to be connect with this one</param>
            <returns>true if the bonds share an atom, otherwise false</returns>
        </member>
        <member name="T:NCDK.Default.ChemFile">
            <summary>
            A Object containing a number of ChemSequences. This is supposed to be the
            top level container, which can contain all the concepts stored in a chemical
            document
            </summary>
        </member>
        <member name="F:NCDK.Default.ChemFile.chemSequences">
            <summary>
            List of ChemSquences.
            </summary>
        </member>
        <member name="M:NCDK.Default.ChemFile.#ctor">
            <summary>
             Constructs an empty ChemFile.
            </summary>
        </member>
        <member name="P:NCDK.Default.ChemFile.Item(System.Int32)">
            <summary>
            The ChemSequence at position <paramref name="number"/> in the container.
            </summary>
            <param name="number">The position of the ChemSequence</param>
            <returns>The ChemSequence at position <paramref name="number"/>.</returns>
            <seealso cref="M:NCDK.Default.ChemFile.Add(NCDK.IChemSequence)"/>
        </member>
        <member name="P:NCDK.Default.ChemFile.Count">
            <summary>
            The number of ChemSequences in this Container.
            </summary>
        </member>
        <member name="M:NCDK.Default.ChemFile.Add(NCDK.IChemSequence)">
            <summary>
             Adds a ChemSequence to this container.
            </summary>
            <param name="chemSequence">The chemSequence to be added to this container</param>
            <seealso cref="P:NCDK.Default.ChemFile.Item(System.Int32)"/>
        </member>
        <member name="M:NCDK.Default.ChemFile.RemoveAt(System.Int32)">
            <summary>
            Removes a ChemSequence from this container.
            </summary>
            <param name="pos">The position from which to remove</param>
            <seealso cref="F:NCDK.Default.ChemFile.chemSequences"/>
            <seealso cref="M:NCDK.Default.ChemFile.Add(NCDK.IChemSequence)"/>
        </member>
        <member name="M:NCDK.Default.ChemFile.OnStateChanged(NCDK.ChemObjectChangeEventArgs)">
            <summary>
             Called by objects to which this object has
             registered as a listener.
            </summary>
            <param name="evt">A change event pointing to the source of the change</param>
        </member>
        <member name="T:NCDK.Default.ChemModel">
            <summary>
            An object containing multiple MoleculeSet and
            the other lower level concepts like rings, sequences,
            fragments, etc.
            </summary>
        </member>
        <member name="F:NCDK.Default.ChemModel.setOfMolecules">
            <summary>
             A molecule set.
            </summary>
        </member>
        <member name="F:NCDK.Default.ChemModel.setOfReactions">
            <summary>
             A reaction set.
            </summary>
        </member>
        <member name="F:NCDK.Default.ChemModel.crystal">
            <summary>
             A Crystal.
            </summary>
        </member>
        <member name="M:NCDK.Default.ChemModel.#ctor">
            <summary>
             Constructs an new <see cref="T:NCDK.Default.ChemModel"/> with a null set of molecules.
            </summary>
        </member>
        <member name="P:NCDK.Default.ChemModel.MoleculeSet">
            <summary>
            The molecule set of this <see cref="T:NCDK.Default.ChemModel"/>.
            </summary>
        </member>
        <member name="P:NCDK.Default.ChemModel.RingSet">
            <summary>
            The ring set of this <see cref="T:NCDK.Default.ChemModel"/>.
            </summary>
        </member>
        <member name="P:NCDK.Default.ChemModel.Crystal">
            <summary>
            The crystal contained in this <see cref="T:NCDK.Default.ChemModel"/>.
            </summary>
        </member>
        <member name="P:NCDK.Default.ChemModel.ReactionSet">
            <summary>
            The reaction set contained in this <see cref="T:NCDK.Default.ChemModel"/>.
            </summary>
        </member>
        <member name="M:NCDK.Default.ChemModel.OnStateChanged(NCDK.ChemObjectChangeEventArgs)">
            <summary>
             Called by objects to which this object has
             registered as a listener.
            </summary>
            <param name="evt">A change event pointing to the source of the change</param>
        </member>
        <member name="M:NCDK.Default.ChemModel.IsEmpty">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Default.ChemObjectBuilder">
            <summary>
            A factory class to provide implementation independent <see cref="T:NCDK.ICDKObject"/>s.
            </summary>
            <example>
            <code>    
                IChemObjectBuilder builder = ChemObjectBuilder.Instance;
            
                IAtom a = builder.NewAtom();
                IAtom c12 = builder.NewAtom("C");
                IAtom c13 = builder.NewAtom(builder.NewIsotope("C", 13));
            </code>
            </example>
        </member>
        <member name="T:NCDK.Default.ChemSequence">
            <summary>
            A sequence of ChemModels, which can, for example, be used to
            store the course of a reaction. Each state of the reaction would be
            stored in one ChemModel.    
            </summary>
        </member>
        <member name="F:NCDK.Default.ChemSequence.chemModels">
            <summary>Array of ChemModels.</summary>
        </member>
        <member name="M:NCDK.Default.ChemSequence.Add(NCDK.IChemModel)">
            <summary>
            Adds an chemModel to this container.
            </summary>
            <param name="chemModel">The chemModel to be added to this container</param>
        </member>
        <member name="M:NCDK.Default.ChemSequence.OnStateChanged(NCDK.ChemObjectChangeEventArgs)">
            <summary>
             Called by objects to which this object has
             registered as a listener.
            </summary>
            <param name="evt">A change event pointing to the source of the change</param>
        </member>
        <member name="T:NCDK.Default.Crystal">
            <summary>
            Class representing a molecular crystal.
            The crystal is described with molecules in fractional
            coordinates and three cell axes: a,b and c.
            </summary>
            <remarks>
            The crystal is designed to store only the asymmetric atoms.
            Though this is not enforced, it is assumed by all methods.
            </remarks>
        </member>
        <member name="F:NCDK.Default.Crystal.a">
            <summary>The a axis.</summary>
        </member>
        <member name="P:NCDK.Default.Crystal.A">
            <summary>
            The A unit cell axes in Cartesian coordinates in a Euclidean space.
            </summary>
        </member>
        <member name="F:NCDK.Default.Crystal.b">
            <summary>The b axis.</summary>
        </member>
        <member name="P:NCDK.Default.Crystal.B">
            <summary>
            The B unit cell axes in Cartesian coordinates in a Euclidean space.
            </summary>
        </member>
        <member name="F:NCDK.Default.Crystal.c">
            <summary>The c axis.</summary>
        </member>
        <member name="P:NCDK.Default.Crystal.C">
            <summary>
            The C unit cell axes in Cartesian coordinates in a Euclidean space.
            </summary>
        </member>
        <member name="F:NCDK.Default.Crystal.spaceGroup">
            <summary>Number of symmetry related atoms.</summary>
        </member>
        <member name="P:NCDK.Default.Crystal.SpaceGroup">
            <summary>
            The space group of this crystal.
            </summary>
        </member>
        <member name="F:NCDK.Default.Crystal.z">
            <summary>Number of symmetry related atoms.</summary>
        </member>
        <member name="P:NCDK.Default.Crystal.Z">
            <summary>
            The number of asymmetric parts in the unit cell.
            </summary>
        </member>
        <member name="M:NCDK.Default.Crystal.#ctor">
            <summary>
            Constructs a new crystal with zero length cell axis.
            </summary>
        </member>
        <member name="M:NCDK.Default.Crystal.#ctor(NCDK.IAtomContainer)">
            <summary>
            Constructs a new crystal with zero length cell axis
            and adds the atoms in the AtomContainer as cell content.
            </summary>
            <param name="container">the AtomContainer providing the atoms and bonds</param>
        </member>
        <member name="M:NCDK.Default.Crystal.ToString">
            <summary>
            Returns a string representation of this crystal.
            </summary>
        </member>
        <member name="T:NCDK.Default.ElectronContainer">
            <summary>
            Base class for entities containing electrons, like bonds, orbitals, lone-pairs.
            </summary>
        </member>
        <member name="F:NCDK.Default.ElectronContainer.electronCount">
            <summary>
            Constructs an empty ElectronContainer.
            </summary>
        </member>
        <member name="M:NCDK.Default.ElectronContainer.#ctor">
            <summary>
            Returns the number of electrons in this electron container.
            </summary>
            <returns>The number of electrons in this electron container.</returns>
            <seealso cref="P:NCDK.Default.ElectronContainer.ElectronCount"/>
        </member>
        <member name="P:NCDK.Default.ElectronContainer.ElectronCount">
            <summary>
            The number of electrons in this electron container.
            </summary>
        </member>
        <member name="T:NCDK.Default.Element">
            <summary>
            Implements the idea of an element in the periodic table.
            </summary>
            <example>
            Use the IsotopeFactory to get a ready-to-use elements
            by symbol or atomic number:
            <code>
              IsotopeFactory f = IsotopeFactory.getInstance(new Element().Builder);
              Element e1 = f.GetElement("C");
              Element e2 = f.GetElement(12);
            </code></example>
        </member>
        <member name="F:NCDK.Default.Element.symbol">
            <summary>The element symbol for this element as listed in the periodic table.</summary>
        </member>
        <member name="F:NCDK.Default.Element.atomicNumber">
            <summary>The atomic number for this element giving their position in the periodic table.</summary>
        </member>
        <member name="M:NCDK.Default.Element.#ctor">
            <summary>
            Constructs an empty Element.
            </summary>
        </member>
        <member name="M:NCDK.Default.Element.#ctor(NCDK.IElement)">
            <summary>
            Constructs an empty by copying the symbol, atomic number,
            flags, and identifier from the given IElement. It does
            not copy the listeners and properties.
            </summary>
            <param name="element">IElement to copy information from</param>
        </member>
        <member name="M:NCDK.Default.Element.#ctor(System.String)">
            <summary>
            Constructs an Element with a given
            element symbol.
            </summary>
            <param name="symbol">The element symbol that this element should have.</param>
        </member>
        <member name="M:NCDK.Default.Element.#ctor(System.String,System.Nullable{System.Int32})">
            <summary>
            Constructs an Element with a given element symbol,
            atomic number and atomic mass.
            </summary>
            <param name="symbol">The element symbol of this element.</param>
            <param name="atomicNumber">The atomicNumber of this element.</param>
        </member>
        <member name="P:NCDK.Default.Element.AtomicNumber">
            <summary>
            The atomic number of this element.
            </summary>
            <example>
            Once instantiated all field not filled by passing parameters
            to the constructor are null. Elements can be configured by using
            the <see cref="M:NCDK.Config.IsotopeFactory.Configure(NCDK.IAtom)"/> method:
            <code>
              Element element = new Element("C");
              IsotopeFactory f = IsotopeFactory.GetInstance(element.Builder);
              f.Configure(element);
            </code>
            </example>
        </member>
        <member name="P:NCDK.Default.Element.Symbol">
            <summary>
            The element symbol of this element.
            </summary>
            <returns>The element symbol of this element. <see langword="null"/> if unset.</returns>
        </member>
        <member name="M:NCDK.Default.Element.Compare(System.Object)">
            <summary>
            Compares an Element with this Element.
            </summary>
            <param name="obj">Object of type AtomType</param>
            <returns>true if the atom types are equal</returns>
        </member>
        <member name="T:NCDK.Default.EnzymeResidueLocator">
            <summary>
            Atom that represents part of an residue in an enzyme, like Arg255.
            </summary>
        </member>
        <member name="M:NCDK.Default.EnzymeResidueLocator.#ctor(System.String)">
            <summary>
            Constructs an EnzymeResidueLocator from a string containing the locator.
            </summary>
            <param name="label">The string describing the residue and its location.</param>
        </member>
        <member name="M:NCDK.Default.EnzymeResidueLocator.#ctor(NCDK.IAtom)">
            <summary>
            Constructs an EnzymeResidueLocator from an existing Atom.
            </summary>
            <param name="atom">Atom that should be converted into a EnzymeResidueLocator.</param>
        </member>
        <member name="T:NCDK.Default.FragmentAtom">
            <summary>
            Class to represent an IPseudoAtom which embeds an IAtomContainer. Very much
            like the MDL Molfile <pre>Group</pre> concept.
            </summary>
        </member>
        <member name="P:NCDK.Default.FragmentAtom.ExactMass">
            <summary>
            The exact mass of an FragmentAtom is defined as the sum of exact masses
            of the IAtom's in the fragment.
            </summary>
        </member>
        <member name="T:NCDK.Default.Isotope">
            <summary>
            Used to store and retrieve data of a particular isotope.
            </summary>
            <example>
            For example, an carbon 13 isotope can be created with:
            <code>
              Isotope carbon = new Isotope("C", 13);
            </code>
            
            A full specification can be constructed with:
            <code>
              // make deuterium
              Isotope carbon = new Isotope(1, "H", 2, 2.01410179, 100.0);
            </code>
            
            Once instantiated all field not filled by passing parameters
            to the constructor are null. Isotopes can be configured by using
            the IsotopeFactory.Configure() method:
            <code>
              Isotope isotope = new Isotope("C", 13);
              IsotopeFactory f = IsotopeFactory.GetInstance(isotope.Builder);
              f.Configure(isotope);
            </code>
            </example>
        </member>
        <member name="M:NCDK.Default.Isotope.#ctor(System.String)">
            <summary>
             Constructor for the Isotope object.
            </summary>
            <param name="elementSymbol">The element symbol, "O" for Oxygen, etc.</param>
        </member>
        <member name="M:NCDK.Default.Isotope.#ctor(System.Int32,System.String,System.Int32,System.Double,System.Double)">
            <summary>
             Constructor for the Isotope object.
            </summary>
            <param name="atomicNumber">The atomic number of the isotope</param>
            <param name="elementSymbol">The element symbol, "O" for Oxygen, etc.</param>
            <param name="massNumber">The atomic mass of the isotope, 16 for Oxygen, e.g.</param>
            <param name="exactMass">The exact mass of the isotope, be a little more explicit here :-)</param>
            <param name="abundance">The natural abundance of the isotope</param>
        </member>
        <member name="M:NCDK.Default.Isotope.#ctor(System.Int32,System.String,System.Double,System.Double)">
            <summary>
             Constructor for the Isotope object.
            </summary>
            <param name="atomicNumber">The atomic number of the isotope, 8 for Oxygen</param>
            <param name="elementSymbol">The element symbol, "O" for Oxygen, etc.</param>
            <param name="exactMass">The exact mass of the isotope, be a little more explicit here :-)</param>
            <param name="abundance">The natural abundance of the isotope</param>
        </member>
        <member name="M:NCDK.Default.Isotope.#ctor(System.String,System.Int32)">
            <summary>
            Constructor for the Isotope object.
            </summary>
            <param name="elementSymbol">The element symbol, "O" for Oxygen, etc.</param>
            <param name="massNumber">The atomic mass of the isotope, 16 for Oxygen, e.g.</param>
        </member>
        <member name="M:NCDK.Default.Isotope.#ctor(NCDK.IElement)">
            <summary>
            Constructs an empty by copying the symbol, atomic number,
            flags, and identifier from the given IElement. It does
            not copy the listeners and properties. If the element is
            an instanceof IIsotope, then the exact mass, natural
            abundance and mass number are copied too.
            </summary>
            <param name="element">IElement to copy information from</param>
        </member>
        <member name="P:NCDK.Default.Isotope.NaturalAbundance">
            <summary>
            The NaturalAbundance attribute of the Isotope object.
            </summary>
            <example>
            Once instantiated all field not filled by passing parameters
            to the constructor are null. Isotopes can be configured by using
            the IsotopeFactory.configure() method:
            <code>
              Isotope isotope = new Isotope("C", 13);
              IsotopeFactory f = IsotopeFactory.GetInstance(isotope.Builder);
              f.Configure(isotope);
            </code>
            </example>
        </member>
        <member name="P:NCDK.Default.Isotope.ExactMass">
            <summary>
            The ExactMass attribute of the Isotope object.
            </summary>
            <example>
            Once instantiated all field not filled by passing parameters
            to the constructor are null. Isotopes can be configured by using
            the IsotopeFactory.configure() method:
            <code>
              Isotope isotope = new Isotope("C", 13);
              IsotopeFactory f = IsotopeFactory.GetInstance(isotope.Builder);
              f.Configure(isotope);
            </code>
            </example>
        </member>
        <member name="P:NCDK.Default.Isotope.MassNumber">
            <summary>
            The atomic mass of this element.
            </summary>
            <example>
            Once instantiated all field not filled by passing parameters
            to the constructor are null. Isotopes can be configured by using
            the IsotopeFactory.configure() method:
            <code>
              Isotope isotope = new Isotope("C", 13);
              IsotopeFactory f = IsotopeFactory.GetInstance(isotope.Builder);
              f.Configure(isotope);
            </code>
            </example>
        </member>
        <member name="M:NCDK.Default.Isotope.Compare(System.Object)">
            <summary>
            Compares an isotope with this isotope.
            </summary>
            <param name="obj">Object of type Isotope</param>
            <returns>true if the isotopes are equal</returns>
        </member>
        <member name="T:NCDK.Default.LonePair">
            <summary>
            A LonePair is an orbital primarily located with one Atom, containing
            two electrons.
            </summary>
        </member>
        <member name="F:NCDK.Default.LonePair.electronCount">
            <summary>Number of electrons in the lone pair.</summary>
        </member>
        <member name="F:NCDK.Default.LonePair.atom">
            <summary>The atom with which this lone pair is associated.</summary>
        </member>
        <member name="M:NCDK.Default.LonePair.#ctor">
            <summary>
            Constructs an unconnected lone pair.
            </summary>
        </member>
        <member name="M:NCDK.Default.LonePair.#ctor(NCDK.IAtom)">
            <summary>
            Constructs an lone pair on an Atom.
            </summary>
            <param name="atom">Atom to which this lone pair is connected</param>
        </member>
        <member name="P:NCDK.Default.LonePair.ElectronCount">
            <summary>
            The number of electrons in a LonePair.
            </summary>
        </member>
        <member name="P:NCDK.Default.LonePair.Atom">
            <summary>
            The associated Atom.
            </summary>
        </member>
        <member name="M:NCDK.Default.LonePair.Contains(NCDK.IAtom)">
            <summary>
            Returns true if the given atom participates in this lone pair.
            </summary>
            <param name="atom">The atom to be tested if it participates in this bond</param>
            <returns>true if this lone pair is associated with the atom</returns>
        </member>
        <member name="M:NCDK.Default.LonePair.ToString">
            <summary>
            Returns a one line string representation of this LonePair.
            This method is conform RFC #9.
            </summary>
            <returns>The string representation of this LonePair</returns>
        </member>
        <member name="T:NCDK.Default.Mapping">
            <summary>
            A Mapping is an relation between two ChemObjects in a non-chemical
            entity. It is not a Bond, nor a Association, merely a relation.
            An example of such a mapping, is the mapping between corresponding atoms
            in a Reaction.
            </summary>
        </member>
        <member name="M:NCDK.Default.Mapping.#ctor(NCDK.IChemObject,NCDK.IChemObject)">
            <summary>
            Constructs an unconnected lone pair.
            </summary>
            <param name="objectOne">The first IChemObject of the mapping</param>
            <param name="objectTwo">The second IChemObject of the mapping</param>
        </member>
        <member name="P:NCDK.Default.Mapping.Item(System.Int32)">
            <summary>
            Retrieves the first or second of the related IChemObjects.
            </summary>
            <param name="pos">The position of the IChemObject.</param>
            <returns>The IChemObject to retrieve.</returns>
        </member>
        <member name="M:NCDK.Default.Mapping.GetRelatedChemObjects">
            <summary>
            Enumerable to the two IChemObjects.
            </summary>
            <returns>An enumerable to two IChemObjects that define the mapping</returns>
        </member>
        <member name="T:NCDK.Default.Monomer">
            <summary>
            A Monomer is an AtomContainer which stores additional monomer specific
            informations for a group of Atoms.
            </summary>
        </member>
        <member name="F:NCDK.Default.Monomer.monomerName">
            <summary>The name of this monomer (e.g. Trp42).</summary>
        </member>
        <member name="F:NCDK.Default.Monomer.monomerType">
            <summary>The type of this monomer (e.g. TRP).</summary>
        </member>
        <member name="P:NCDK.Default.Monomer.MonomerName">
            <summary>The name of this monomer (e.g. Trp42).</summary>
        </member>
        <member name="P:NCDK.Default.Monomer.MonomerType">
            <summary>The type of this monomer (e.g. TRP).</summary>
        </member>
        <member name="T:NCDK.Default.PDBAtom">
            <summary>
            Represents the idea of an atom as used in PDB files. It contains extra fields
            normally associated with atoms in such files.
            </summary>
        </member>
        <member name="M:NCDK.Default.PDBAtom.#ctor(NCDK.IElement)">
            <summary>
            Constructs an IPDBAtom from a Element.
            </summary>
            <param name="element">IElement to copy information from</param>
        </member>
        <member name="M:NCDK.Default.PDBAtom.#ctor(System.String)">
            <summary>
            Constructs an <see cref="T:NCDK.IPDBAtom"/> from a string containing an element symbol.
            </summary>
            <param name="symbol">The string describing the element for the PDBAtom</param>
        </member>
        <member name="M:NCDK.Default.PDBAtom.#ctor(System.String,NCDK.Numerics.Vector3)">
            <summary>
            Constructs an <see cref="T:NCDK.IPDBAtom"/> from an Element and a Vector3.
            </summary>
            <param name="symbol">The symbol of the atom</param>
            <param name="coordinate">The 3D coordinates of the atom</param>
        </member>
        <member name="P:NCDK.Default.PDBAtom.Record">
            <summary>
            one entire line from the PDB entry file which describe the IPDBAtom.
            It consists of 80 columns.
            </summary>
            <returns>a string with all information</returns>
        </member>
        <member name="P:NCDK.Default.PDBAtom.TempFactor">
            <summary>
            The Temperature factor of this atom.
            </summary>
        </member>
        <member name="P:NCDK.Default.PDBAtom.ResName">
            <summary>
            The Residue name of this atom.
            </summary>
        </member>
        <member name="P:NCDK.Default.PDBAtom.ICode">
            <summary>
            The Code for insertion of residues of this atom.
            </summary>
        </member>
        <member name="P:NCDK.Default.PDBAtom.Name">
            <summary>
            The Atom name of this atom.
            </summary>
        </member>
        <member name="P:NCDK.Default.PDBAtom.ChainID">
            <summary>
            The Chain identifier of this atom.
            </summary>
        </member>
        <member name="P:NCDK.Default.PDBAtom.AltLoc">
            <summary>
            The Alternate location indicator of this atom.
            </summary>
        </member>
        <member name="P:NCDK.Default.PDBAtom.SegID">
            <summary>
            The Segment identifier, left-justified of this atom.
            </summary>
        </member>
        <member name="P:NCDK.Default.PDBAtom.Serial">
            <summary>
            The Atom serial number of this atom.
            </summary>
        </member>
        <member name="P:NCDK.Default.PDBAtom.ResSeq">
            <summary>
            The Residue sequence number of this atom.
            </summary>
        </member>
        <member name="P:NCDK.Default.PDBAtom.Occupancy">
            <summary>
            The Occupancy of this atom.
            </summary>
        </member>
        <member name="M:NCDK.Default.PDBAtom.ToString">
            <summary>
            Returns a one line string representation of this Atom.
            Methods is conform RFC #9.
            </summary>
            <returns>The string representation of this Atom</returns>
        </member>
        <member name="T:NCDK.Default.PDBMonomer">
            <summary>
            Represents the idea of an monomer as used in PDB files. It contains extra fields
            normally associated with atoms in such files.
            </summary>
        </member>
        <member name="P:NCDK.Default.PDBMonomer.ChainID">
            <summary>
            Denotes which chain in the PDB file this monomer is in.
            </summary>
        </member>
        <member name="P:NCDK.Default.PDBMonomer.ResSeq">
            <summary>
            Denotes which residue sequence in the current chain that this monomer is in.
            </summary>
        </member>
        <member name="M:NCDK.Default.PDBMonomer.ToString">
            <summary>
            Returns a one line string representation of this Atom.
            Methods is conform RFC #9.
            </summary>
            <returns>The string representation of this Atom</returns>
        </member>
        <member name="M:NCDK.Default.PDBMonomer.Clone">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Default.PDBPolymer">
            <summary>
            An entry in the PDB database. It is not just a regular protein, but the
            regular PDB mix of protein or protein complexes, ligands, water molecules
            and other species.
            </summary>
        </member>
        <member name="M:NCDK.Default.PDBPolymer.#ctor">
            <summary>
            Constructs a new Polymer to store the <see cref="T:NCDK.IMonomer"/>s.
            </summary>
        </member>
        <member name="M:NCDK.Default.PDBPolymer.Add(NCDK.IPDBAtom)">
            <summary>
            Adds the atom oAtom without specifying a <see cref="T:NCDK.IMonomer"/> or a Strand. Therefore the
            atom to this AtomContainer, but not to a certain Strand or <see cref="T:NCDK.IMonomer"/> (intended
            e.g. for HETATMs).
            </summary>
            <param name="oAtom">The <see cref="T:NCDK.IPDBAtom"/> to add</param>
        </member>
        <member name="M:NCDK.Default.PDBPolymer.AddAtom(NCDK.IPDBAtom,NCDK.IMonomer)">
            <summary>
            Adds the atom oAtom to a specified Monomer. Additionally, it keeps
            record of the iCode.
            </summary>
            <param name="oAtom">The IPDBAtom to add</param>
            <param name="oMonomer">The monomer the atom belongs to</param>
        </member>
        <member name="M:NCDK.Default.PDBPolymer.AddAtom(NCDK.IPDBAtom,NCDK.IMonomer,NCDK.IStrand)">
            <summary>
            Adds the IPDBAtom oAtom to a specified Monomer of a specified Strand.
            Additionally, it keeps record of the iCode.
            </summary>
            <param name="oAtom">The IPDBAtom to add</param>
            <param name="oMonomer">The monomer the atom belongs to</param>
            <param name="oStrand"></param>
        </member>
        <member name="M:NCDK.Default.PDBPolymer.GetMonomerNamesInSequentialOrder">
            <summary>
            Returns the monomer names in the order in which they were added.
            </summary>
            <seealso cref="M:NCDK.IPolymer.GetMonomerNames"/>
        </member>
        <member name="M:NCDK.Default.PDBPolymer.Clone">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Default.PDBStrand">
            <summary>
            An entry in the PDB database. It is not just a regular protein, but the
            regular PDB mix of protein or protein complexes, ligands, water molecules
            and other species.
            </summary>
        </member>
        <member name="M:NCDK.Default.PDBStrand.#ctor">
            <summary>
            Constructs a new Polymer to store the Monomers.
            </summary>
        </member>
        <member name="M:NCDK.Default.PDBStrand.AddAtom(NCDK.IAtom,NCDK.IMonomer)">
             <summary>
             Adds the atom oAtom to a specified Monomer. Additionally, it keeps
             record of the iCode.
            
             <param name="oAtom">The atom to add</param>
             <param name="oMonomer">The monomer the atom belongs to</param>
             </summary>
        </member>
        <member name="M:NCDK.Default.PDBStrand.GetMonomerNamesInSequentialOrder">
            <summary>
            Returns the monomer names in the order in which they were added.
            </summary>
            <seealso cref="M:NCDK.IPolymer.GetMonomerNames"/>
        </member>
        <member name="T:NCDK.Default.PDBStructure">
            <summary>
            Holder for secundary protein structure elements. Lously modeled after
            the Jmol Structure.java.
            </summary>
        </member>
        <member name="P:NCDK.Default.PDBStructure.StructureType">
            <summary>
            Structure Type of this structure.
            </summary>
        </member>
        <member name="P:NCDK.Default.PDBStructure.StartChainID">
            <summary>
            start Chain identifier of this structure.
            </summary>
        </member>
        <member name="P:NCDK.Default.PDBStructure.StartSequenceNumber">
            <summary>
            Start sequence number of this structure.
            </summary>
        </member>
        <member name="P:NCDK.Default.PDBStructure.StartInsertionCode">
            <summary>
            Start Code for insertion of residues of this structure.
            </summary>
        </member>
        <member name="P:NCDK.Default.PDBStructure.EndChainID">
            <summary>
            The ending Chain identifier of this structure.
            </summary>
        </member>
        <member name="P:NCDK.Default.PDBStructure.EndSequenceNumber">
            <summary>
            The ending sequence number of this structure.
            </summary>
        </member>
        <member name="P:NCDK.Default.PDBStructure.EndInsertionCode">
            <summary>
            The ending Code for insertion of residues of this structure.
            </summary>
        </member>
        <member name="T:NCDK.Default.Polymer">
            <summary>
            Subclass of Molecule to store Polymer specific attributes that a Polymer has.
            </summary>
        </member>
        <member name="M:NCDK.Default.Polymer.#ctor">
            <summary>
            Constructs a new Polymer to store the Monomers.
            </summary>
        </member>
        <member name="M:NCDK.Default.Polymer.AddAtom(NCDK.IAtom,NCDK.IMonomer)">
            <summary>
            Adds the atom oAtom to a specified Monomer.
            </summary>
            <param name="oAtom">The atom to add</param>
            <param name="oMonomer">The monomer the atom belongs to</param>
        </member>
        <member name="M:NCDK.Default.Polymer.GetMonomerMap">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Default.Polymer.GetMonomer(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Default.Polymer.GetMonomerNames">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Default.Polymer.RemoveMonomer(System.String)">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Default.PseudoAtom">
            <inheritdoc cref="T:NCDK.IPseudoAtom"/>
        </member>
        <member name="M:NCDK.Default.PseudoAtom.#ctor">
            <summary>
            Constructs an empty PseudoAtom.
            </summary>
        </member>
        <member name="M:NCDK.Default.PseudoAtom.#ctor(System.String)">
            <summary>
            Constructs an Atom from a String containing an element symbol.
            </summary>
            <param name="label">The String describing the PseudoAtom</param>
        </member>
        <member name="M:NCDK.Default.PseudoAtom.#ctor(NCDK.IElement)">
            <summary>
            Constructs an <see cref="T:NCDK.Default.PseudoAtom"/> from a <see cref="T:NCDK.IAtom"/>.
            </summary>
            <param name="element"><see cref="T:NCDK.IAtom"/> from which the <see cref="T:NCDK.Default.PseudoAtom"/> is constructed</param>
        </member>
        <member name="M:NCDK.Default.PseudoAtom.#ctor(System.String,NCDK.Numerics.Vector3)">
            <summary>
            Constructs a <see cref="T:NCDK.Default.PseudoAtom"/> from an element name and a <see cref="T:NCDK.Numerics.Vector3"/>.
            </summary>
            <param name="label">The <see cref="T:System.String"/> describing the <see cref="T:NCDK.Default.PseudoAtom"/></param>
            <param name="point3d">The 3D coordinates of the atom</param>
        </member>
        <member name="M:NCDK.Default.PseudoAtom.#ctor(System.String,NCDK.Numerics.Vector2)">
            <summary>
            Constructs a <see cref="T:NCDK.Default.PseudoAtom"/> from an element name and a <see cref="T:NCDK.Numerics.Vector2"/>.
            </summary>
            <param name="label">The <see cref="T:System.String"/> describing the <see cref="T:NCDK.Default.PseudoAtom"/></param>
            <param name="point2d">The 2D coordinates of the atom</param>
        </member>
        <member name="P:NCDK.Default.PseudoAtom.Label">
            <summary>
             The label of this <see cref="T:NCDK.Default.PseudoAtom"/>.
            </summary>
        </member>
        <member name="P:NCDK.Default.PseudoAtom.AttachPointNum">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.Default.PseudoAtom.StereoParity">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Default.Reaction">
            <inheritdoc cref="T:NCDK.IReaction"/>
        </member>
        <member name="P:NCDK.Default.Reaction.Reactants">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.Default.Reaction.Products">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.Default.Reaction.Agents">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.Default.Reaction.Mappings">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.Default.Reaction.Direction">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Default.Reaction.#ctor">
            <summary>
            Constructs an empty, forward reaction.
            </summary>
        </member>
        <member name="T:NCDK.Default.ReactionScheme">
            <summary>
            Classes that : the definition of reaction to a scheme.
            This is designed to contain a set of reactions which are linked in
            some way but without hard coded semantics.
            </summary>
        </member>
        <member name="F:NCDK.Default.ReactionScheme.reactionScheme">
            <summary>
            A List of reaction schemes
            </summary>
        </member>
        <member name="M:NCDK.Default.ReactionScheme.#ctor">
            <summary>
            Constructs an empty ReactionScheme.
            </summary>
        </member>
        <member name="M:NCDK.Default.ReactionScheme.Add(NCDK.IReactionScheme)">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.Default.ReactionScheme.Schemes">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Default.ReactionScheme.Remove(NCDK.IReactionScheme)">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.Default.ReactionScheme.Reactions">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Default.ReactionScheme.Clone(NCDK.CDKObjectMap)">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Default.ReactionSet">
             <summary>
             A set of reactions, for example those taking part in a reaction.
             </summary>
             <example>
             To retrieve the reactions from the set, there are two options:
             <code>
             ReactionSet reactions = ...
             foreach (var reaction in reactions)
             {
                 //
             }
             </code>
            
             and
            
             <code>
             for (int i = 0; i &lt; reactionSet.Count; i++)
             {
                    IReaction reaction = reactionSet[i]; 
             }
             </code>
             </example>
        </member>
        <member name="F:NCDK.Default.ReactionSet.reactions">
            <summary>
            Array of Reactions.
            </summary>
        </member>
        <member name="M:NCDK.Default.ReactionSet.#ctor">
            <summary>
            Constructs an empty ReactionSet.
            </summary>
        </member>
        <member name="P:NCDK.Default.ReactionSet.Item(System.Int32)">
            <summary>
            Returns the Reaction at position <paramref name="number"/> in the container.
            </summary>
            <param name="number">The position of the Reaction to be returned</param>
            <returns>The Reaction at position <paramref name="number"/></returns>
        </member>
        <member name="M:NCDK.Default.ReactionSet.Add(NCDK.IReaction)">
            <summary>
            Adds an reaction to this container.
            </summary>
            <param name="reaction">The reaction to be added to this container</param>
        </member>
        <member name="M:NCDK.Default.ReactionSet.RemoveAt(System.Int32)">
            <summary>
            Remove a reaction from this set.
            </summary>
            <param name="index">The position of the reaction to be removed.</param>
        </member>
        <member name="T:NCDK.Default.Ring">
            <summary>
            Class representing a ring structure in a molecule.
            A ring is a linear sequence of
            N atoms interconnected to each other by covalent bonds,
            such that atom i (1 &lt; i &lt; N) is bonded to
            atom i-1 and atom i + 1 and atom 1 is bonded to atom N and atom 2.
            </summary>
        </member>
        <member name="M:NCDK.Default.Ring.#ctor">
            <summary>
            Constructs an empty ring.
            </summary>
        </member>
        <member name="M:NCDK.Default.Ring.#ctor(NCDK.IAtomContainer)">
            <summary>
            Constructs a ring from the atoms in an <see cref="T:NCDK.IAtomContainer"/> object.
            </summary>
            <param name="atomContainer">The <see cref="T:NCDK.IAtomContainer"/> object containing the atoms to form the ring</param>
        </member>
        <member name="M:NCDK.Default.Ring.#ctor(System.Collections.Generic.IEnumerable{NCDK.IAtom},System.Collections.Generic.IEnumerable{NCDK.IBond})">
            <summary>
            Constructs a ring from the atoms and bonds.
            </summary>
            <param name="atoms">atoms</param>
            <param name="bonds">bonds</param>
        </member>
        <member name="M:NCDK.Default.Ring.#ctor(System.Int32,System.String)">
            <summary>
            Constructs a ring that will have a certain number of atoms of the given elements.
            </summary>
            <param name="ringSize">The number of atoms and bonds the ring will have</param>
            <param name="elementSymbol">The element of the atoms the ring will have</param>
        </member>
        <member name="P:NCDK.Default.Ring.RingSize">
            <summary>
            the number of atoms\edges in this ring.
            </summary>
        </member>
        <member name="M:NCDK.Default.Ring.GetNextBond(NCDK.IBond,NCDK.IAtom)">
            <summary>
            Returns the next bond in order, relative to a given bond and atom.
            Example: Let the ring be composed of 0-1, 1-2, 2-3 and 3-0. A request getNextBond(1-2, 2)
            will return Bond 2-3.
            </summary>
            <param name="bond"> A bond for which an atom from a consecutive bond is sought</param>
            <param name="atom">A atom from the bond above to assign a search direction</param>
            <returns>The next bond in the order given by the above assignment</returns>
        </member>
        <member name="P:NCDK.Default.Ring.BondOrderSum">
            <summary>
            The sum of all bond orders in the ring.
            </summary>
        </member>
        <member name="T:NCDK.Default.RingSet">
            <summary>
            Maintains a set of Ring objects.
            </summary>
        </member>
        <member name="M:NCDK.Default.RingSet.#ctor">
            <summary>
            The constructor.
            </summary>
        </member>
        <member name="M:NCDK.Default.RingSet.GetRings(NCDK.IAtom)">
            <summary>
            Returns a vector of all rings that this atom is part of.
            </summary>
            <param name="atom">The atom to be checked</param>
            <returns>A vector of all rings that this bond is part of</returns>
        </member>
        <member name="M:NCDK.Default.RingSet.GetRings(NCDK.IBond)">
            <summary>
            Returns a vector of all rings that this bond is part of.
            </summary>
            <param name="bond">The bond to be checked</param>
            <returns>A vector of all rings that this bond is part of</returns>
        </member>
        <member name="M:NCDK.Default.RingSet.GetConnectedRings(NCDK.IRing)">
            <summary>
            Returns all the rings in the RingSet that share one or more atoms with a given ring.
            </summary>
            <param name="ring">A ring with which all return rings must share one or more atoms</param>
            <returns>All the rings that share one or more atoms with a given ring.</returns>
        </member>
        <member name="M:NCDK.Default.RingSet.Add(NCDK.IRingSet)">
            <summary>
            Adds all rings of another RingSet if they are not already part of this ring set.
            
            If you want to add a single ring to the set use <see cref="M:NCDK.Default.RingSet.Add(NCDK.IRingSet)"/> 
            </summary>
            <param name="ringSet">the ring set to be united with this one.</param>
        </member>
        <member name="M:NCDK.Default.RingSet.Contains(NCDK.IAtom)">
            <summary>
            True, if at least one of the rings in the ringset contains the given atom.
            </summary>
            <param name="atom">Atom to check</param>
            <returns>true, if the ringset contains the atom</returns>
        </member>
        <member name="T:NCDK.Default.SingleElectron">
            <summary>
            A Single Electron is an orbital which is occupied by only one electron.
            </summary>
            <example>
            A radical in CDK is represented by an AtomContainer that contains an Atom
            and a SingleElectron type ElectronContainer:
            <code>
            AtomContainer radical = new AtomContainer();
            Atom carbon = new Atom("C");
            carbon.ImplicitHydrogenCount = 3;
            radical.SingleElectrons.Add(new SingleElectron(carbon));
            </code>
            </example>
        </member>
        <member name="M:NCDK.Default.SingleElectron.#ctor(NCDK.IAtom)">
            <summary>
            Constructs an single electron orbital on an Atom.
            </summary>
            <param name="atom">The atom to which the single electron belongs.</param>
        </member>
        <member name="M:NCDK.Default.SingleElectron.#ctor">
            <summary>
            Constructs an single electron orbital with an associated Atom.
            </summary>
        </member>
        <member name="P:NCDK.Default.SingleElectron.ElectronCount">
            <summary>
            Number of electron for this class is defined as one.
            </summary>
        </member>
        <member name="P:NCDK.Default.SingleElectron.Atom">
            <summary>
            The associated Atom.
            </summary>
        </member>
        <member name="M:NCDK.Default.SingleElectron.Contains(NCDK.IAtom)">
            <summary>
            Returns true if the given atom participates in this SingleElectron.
            </summary>
            <param name="atom">The atom to be tested if it participates in this bond</param>
            <returns>true if this SingleElectron is associated with the atom</returns>
        </member>
        <member name="T:NCDK.Default.Strand">
            <summary>
            A Strand is an AtomContainer which stores additional strand specific
            informations for a group of Atoms.
            </summary>
        </member>
        <member name="P:NCDK.Default.Strand.StrandName">
            <summary>
            The strand name.
            </summary>
        </member>
        <member name="P:NCDK.Default.Strand.StrandType">
            <summary>
             The strand type.
            </summary>
        </member>
        <member name="M:NCDK.Default.Strand.AddAtom(NCDK.IAtom)">
            <summary>
            Adds the atom oAtom without specifying a Monomer or a Strand. Therefore the
            atom gets added to a Monomer of type "Unknown" in a Strand of type  "Unknown".
            </summary>
            <param name="oAtom">The atom to add</param>
        </member>
        <member name="M:NCDK.Default.Strand.AddAtom(NCDK.IAtom,NCDK.IMonomer)">
            <summary>
            Adds the atom oAtom to a specific Monomer.
            </summary>
            <param name="oAtom">The atom to add</param>
            <param name="oMonomer">The monomer the atom belongs to</param>
        </member>
        <member name="T:NCDK.Silent.AdductFormula">
            <summary>
            Class defining an adduct object in a MolecularFormula. It maintains
            a list of list IMolecularFormula.
            <para>
            Examples:
            <list type="bullet">
            <item>[C2H4O2+Na]+</item>
            </list>
            </para>
            </summary>
        </member>
        <member name="F:NCDK.Silent.AdductFormula.components">
            <summary> Internal List of IMolecularFormula.</summary>
        </member>
        <member name="M:NCDK.Silent.AdductFormula.#ctor">
            <summary>
            Constructs an empty AdductFormula.
            </summary>
        </member>
        <member name="M:NCDK.Silent.AdductFormula.#ctor(NCDK.IMolecularFormula)">
            <summary>
            Constructs an AdductFormula with a copy AdductFormula of another
            AdductFormula (A shallow copy, i.e., with the same objects as in
            the original AdductFormula).
            </summary>
            <param name="formula">An MolecularFormula to copy from</param>
        </member>
        <member name="M:NCDK.Silent.AdductFormula.Add(NCDK.IMolecularFormula)">
            <summary>
            Adds an molecularFormula to this chemObject.
            </summary>
            <param name="formula">The molecularFormula to be added to this chemObject</param>
        </member>
        <member name="M:NCDK.Silent.AdductFormula.Add(NCDK.IMolecularFormulaSet)">
            <summary>
            Adds all molecularFormulas in the AdductFormula to this chemObject.
            </summary>
            <param name="formulaSet">The MolecularFormulaSet</param>
        </member>
        <member name="M:NCDK.Silent.AdductFormula.Contains(NCDK.IIsotope)">
            <summary>
            True, if the AdductFormula contains the given IIsotope object and not
            the instance. The method looks for other isotopes which has the same
            symbol, natural abundance and exact mass.
            </summary>
            <param name="isotope">The IIsotope this AdductFormula is searched for</param>
            <returns>True, if the AdductFormula contains the given isotope object</returns>
        </member>
        <member name="P:NCDK.Silent.AdductFormula.Charge">
            <summary>
            The partial charge of this Adduct. If the charge
            has not been set the return value is double.NaN.
            </summary>
        </member>
        <member name="M:NCDK.Silent.AdductFormula.GetCount(NCDK.IIsotope)">
            <summary>
            Checks a set of Nodes for the occurrence of the isotope in the
            adduct formula from a particular isotope. It returns 0 if the does not exist.
            </summary>
            <param name="isotope">The IIsotope to look for</param>
            <returns>The occurrence of this isotope in this adduct</returns>
        </member>
        <member name="P:NCDK.Silent.AdductFormula.IsotopeCount">
            <summary>
            The the number of different isotopes in this adduct formula
            </summary>
        </member>
        <member name="M:NCDK.Silent.AdductFormula.GetIsotopes">
            <summary>
            An IEnumerator for looping over all isotopes in this adduct formula.
            </summary>
        </member>
        <member name="M:NCDK.Silent.AdductFormula.IsotopesList">
            <summary>
            Returns a List for looping over all isotopes in this adduct formula.
            </summary>
            <returns>A List with the isotopes in this adduct formula</returns>
        </member>
        <member name="M:NCDK.Silent.AdductFormula.GetEnumerator">
            <summary>
            Returns an Iterable for looping over all IMolecularFormula
            in this adduct formula.
            </summary>
            <returns>An Iterable with the IMolecularFormula in this adduct formula</returns>
        </member>
        <member name="P:NCDK.Silent.AdductFormula.Count">
            <summary>
            The number of MolecularFormulas in this AdductFormula.
            </summary>
        </member>
        <member name="M:NCDK.Silent.AdductFormula.Contains(NCDK.IMolecularFormula)">
             <summary>
             True, if the AdductFormula contains the given IMolecularFormula object.
            
             <param name="formula">The IMolecularFormula this AdductFormula is searched for</param>
             <returns>True, if the AdductFormula contains the given IMolecularFormula object</returns>
             </summary>
        </member>
        <member name="P:NCDK.Silent.AdductFormula.Item(System.Int32)">
            <summary>
            The MolecularFormula at position <paramref name="position"/> in the hemObject.
            </summary>
            <param name="position">The position of the IMolecularFormula to be returned.</param>
            <returns>The IMolecularFormula at position <paramref name="position"/>.</returns>
        </member>
        <member name="M:NCDK.Silent.AdductFormula.Clear">
            <summary>
            Removes all IMolecularFormula from this chemObject.
            </summary>
        </member>
        <member name="M:NCDK.Silent.AdductFormula.Remove(NCDK.IMolecularFormula)">
            <summary>
            Removes an IMolecularFormula from this chemObject.
            </summary>
            <param name="formula">The IMolecularFormula to be removed from this chemObject</param>
        </member>
        <member name="M:NCDK.Silent.AdductFormula.RemoveAt(System.Int32)">
            <summary>
            Removes an MolecularFormula from this chemObject.
            </summary>
            <param name="position">The position of the MolecularFormula to be removed from this chemObject</param>
        </member>
        <member name="M:NCDK.Silent.AdductFormula.Clone">
            <summary>
            Clones this AdductFormula object and its content.
            </summary>
            <returns> The cloned object</returns>
        </member>
        <member name="M:NCDK.Silent.AdductFormula.IsTheSame(NCDK.IIsotope,NCDK.IIsotope)">
            <summary>
            Compare to IIsotope. The method doesn't compare instance but if they
            have the same symbol, natural abundance and exact mass.
            </summary>
            <param name="isotopeOne">The first Isotope to compare</param>
            <param name="isotopeTwo">The second Isotope to compare</param>
            <returns>True, if both isotope are the same</returns>
        </member>
        <member name="T:NCDK.Silent.Association">
            <summary>
            Base class for storing interactions like hydrogen bonds and ionic interactions.
            The ElectronContainer contains zero electrons by default.
            </summary>
        </member>
        <member name="P:NCDK.Silent.Association.AssociatedAtoms">
            <summary>
            The atoms which take part in the association.
            </summary>
        </member>
        <member name="M:NCDK.Silent.Association.#ctor(NCDK.IAtom,NCDK.IAtom)">
            <summary>
            Constructs an association between two Atom's.
            </summary>
            <param name="atom1">An atom to be associated with another atom</param>
            <param name="atom2">An atom to be associated with another atom</param>
            <seealso cref="T:NCDK.Silent.Atom"/>
        </member>
        <member name="M:NCDK.Silent.Association.#ctor">
            <summary>
            Constructs an empty association.
            </summary>
            <seealso cref="T:NCDK.Silent.Atom"/>
        </member>
        <member name="P:NCDK.Silent.Association.ElectronCount">
            <summary>
            The number of electrons in a Association.
            </summary>
        </member>
        <member name="T:NCDK.Silent.ChemObject">
            <summary>
            The base class for all chemical objects in this cdk. It provides methods for
            adding listeners and for their notification of events, as well a a hash
            table for administration of physical or chemical properties
            </summary>
        </member>
        <member name="P:NCDK.Silent.ChemObject.Listeners">
            <summary>
            List for listener administration.
            </summary>
        </member>
        <member name="P:NCDK.Silent.ChemObject.IsVisited">
            <summary>
            Flag is set if chemobject has been visited
            </summary>
        </member>
        <member name="M:NCDK.Silent.ChemObject.#ctor">
            <summary>
            Constructs a new IChemObject.
            </summary>
        </member>
        <member name="M:NCDK.Silent.ChemObject.#ctor(NCDK.IChemObject)">
            <summary>
            Constructs a new IChemObject by copying the flags, and the. It does not copy the listeners and properties.
            </summary>
            <param name="chemObject">the object to copy</param>
        </member>
        <member name="M:NCDK.Silent.ChemObject.NotifyChanged">
            <summary>
            This should be triggered by an method that changes the content of an object
             to that the registered listeners can react to it.
            </summary>
        </member>
        <member name="M:NCDK.Silent.ChemObject.NotifyChanged(NCDK.ChemObjectChangeEventArgs)">
            <summary>
            This should be triggered by an method that changes the content of an object
            to that the registered listeners can react to it. This is a version of
            NotifyChanged() which allows to propagate a change event while preserving
            the original origin.
            </summary>
            <param name="evt">A ChemObjectChangeEvent pointing to the source of where the change happened</param>
        </member>
        <member name="F:NCDK.Silent.ChemObject.properties">
            <summary>
            A dictionary for the storage of any kind of properties of this object.
            </summary>
        </member>
        <member name="M:NCDK.Silent.ChemObject.SetProperty(System.Object,System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Silent.ChemObject.RemoveProperty(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Silent.ChemObject.GetProperty``1(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Silent.ChemObject.GetProperty``1(System.Object,``0)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Silent.ChemObject.GetProperties">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Silent.ChemObject.SetProperties(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.Object,System.Object}})">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Silent.ChemObject.AddProperties(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.Object,System.Object}})">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Silent.ChemObject.Compare(System.Object)">
            <summary>
            Compares a <see cref="T:NCDK.IChemObject"/> with this <see cref="T:NCDK.IChemObject"/>.
            </summary>
            <param name="obj">Object of type <see cref="T:NCDK.Silent.AtomType"/></param>
            <returns><see langword="true"/> if the atom types are equal</returns>
        </member>
        <member name="P:NCDK.Silent.ChemObject.Id">
            <summary>
            The identifier (ID) of this object.
            </summary>
        </member>
        <member name="T:NCDK.Silent.AminoAcid">
            <summary>
            A AminoAcid is Monomer which stores additional amino acid specific
            informations, like the N-terminus atom.
            </summary>
        </member>
        <member name="P:NCDK.Silent.AminoAcid.NTerminus">
            <summary>N-terminus atom.</summary>
        </member>
        <member name="P:NCDK.Silent.AminoAcid.CTerminus">
            <summary>C-terminus atom.</summary>
        </member>
        <member name="M:NCDK.Silent.AminoAcid.AddNTerminus(NCDK.IAtom)">
            <summary>
            Add an <see cref="T:NCDK.IAtom"/> and makes it the N-terminus atom.
            </summary>
            <param name="atom">The <see cref="T:NCDK.IAtom"/> that is the N-terminus</param>
        </member>
        <member name="M:NCDK.Silent.AminoAcid.AddCTerminus(NCDK.IAtom)">
            <summary>
            Add an <see cref="T:NCDK.IAtom"/> and makes it the C-terminus atom.
            </summary>
            <param name="atom">The <see cref="T:NCDK.IAtom"/> that is the C-terminus</param>
        </member>
        <member name="M:NCDK.Silent.AminoAcid.Clone(NCDK.CDKObjectMap)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Silent.AminoAcid.ToString">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Silent.Atom">
             <summary>
             Represents the idea of an chemical atom.
             </summary>
             <example>
             An Atom class is instantiated with at least the atom symbol:
             <code>
               Atom a = new Atom("C");
             </code>
            
             Once instantiated all field not filled by passing parameters
             to the constructor are null. Atoms can be configured by using
             the IsotopeFactory.configure() method:
             <code>
               IsotopeFactory factory = SomeIsotopeFactory.GetInstance(a.Builder);
               factory.Configure(a);
             </code>
            
             More examples about using this class can be found in the
             Junit test for this class.
             </example>
             <seealso cref="M:NCDK.Config.XMLIsotopeFactory.GetInstance(NCDK.IChemObjectBuilder)"/>
        </member>
        <member name="M:NCDK.Silent.Atom.#ctor">
            <summary>
            Constructs an completely unset Atom.
            </summary>
        </member>
        <member name="M:NCDK.Silent.Atom.#ctor(System.Int32)">
            <summary>
            Create a new atom with of the specified element.
            </summary>
            <param name="elem">atomic number</param>
        </member>
        <member name="M:NCDK.Silent.Atom.#ctor(System.Int32,System.Int32)">
            <summary>
            Create a new atom with of the specified element and hydrogen count.
            </summary>
            <param name="elem">atomic number</param>
            <param name="hcnt">hydrogen count</param>
        </member>
        <member name="M:NCDK.Silent.Atom.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Create a new atom with of the specified element, hydrogen count, and formal charge.
            </summary>
            <param name="elem">atomic number</param>
            <param name="hcnt">hydrogen count</param>
            <param name="fchg">formal charge</param>
        </member>
        <member name="M:NCDK.Silent.Atom.#ctor(System.String)">
            <summary>
            Constructs an Atom from a string containing an element symbol and optionally
            the atomic mass, hydrogen count, and formal charge. 
            </summary>
            <remarks>
            The symbol grammar allows
            easy construction from common symbols, for example:
            
            <code>
                new Atom("NH+");   // nitrogen cation with one hydrogen
                new Atom("OH");    // hydroxy
                new Atom("O-");    // oxygen anion
                new Atom("13CH3"); // methyl isotope 13
            </code>
            
            <pre>
                atom := {mass}? {symbol} {hcnt}? {fchg}?
                mass := \d+
                hcnt := 'H' \d+
                fchg := '+' \d+? | '-' \d+?
            </pre>
            </remarks>
            <param name="symbol">string with the element symbol</param>
        </member>
        <member name="M:NCDK.Silent.Atom.#ctor(System.String,NCDK.Numerics.Vector2)">
            <summary>
            Constructs an <see cref="T:NCDK.IAtom"/> from an element name and a <see cref="T:NCDK.Numerics.Vector2"/>.
            </summary>
            <param name="elementSymbol">The Element</param>
            <param name="point2d">The Point</param>
        </member>
        <member name="M:NCDK.Silent.Atom.#ctor(System.String,NCDK.Numerics.Vector3)">
            <summary>
            Constructs an <see cref="T:NCDK.IAtom"/> from an element name and a <see cref="T:NCDK.Numerics.Vector3"/>.
            </summary>
            <param name="elementSymbol">The Element</param>
            <param name="point3d">The Point</param>
        </member>
        <member name="M:NCDK.Silent.Atom.#ctor(NCDK.IElement)">
            <summary>    
            Constructs an isotope by copying the symbol, atomic number,
            flags, identifier, exact mass, natural abundance, mass
            number, maximum bond order, bond order sum, van der Waals
            and covalent radii, formal charge, hybridization, electron
            valency, formal neighbour count and atom type name from the
            given IAtomType. It does not copy the listeners and
            properties. If the element is an instanceof
            IAtom, then the 2D, 3D and fractional coordinates, partial
            atomic charge, hydrogen count and stereo parity are copied
            too.
            </summary>
            <param name="element"><see cref="T:NCDK.IAtomType"/> to copy information from</param>
        </member>
        <member name="P:NCDK.Silent.Atom.Charge">
            <summary>
            The partial charge of this atom.
            </summary>
        </member>
        <member name="P:NCDK.Silent.Atom.ImplicitHydrogenCount">
            <summary>
            The number of implicit hydrogen count of this atom.
            </summary>
        </member>
        <member name="P:NCDK.Silent.Atom.Point2D">
            <summary>
            A point specifying the location of this atom in a 2D space.
            </summary>
        </member>
        <member name="P:NCDK.Silent.Atom.Point3D">
            <summary>
            A point specifying the location of this atom in a 3D space.
            </summary>
        </member>
        <member name="P:NCDK.Silent.Atom.FractionalPoint3D">
            <summary>
            A point specifying the location of this atom in a <see cref="T:NCDK.Silent.Crystal"/> unit cell.
            </summary>
        </member>
        <member name="P:NCDK.Silent.Atom.StereoParity">
            <summary>
            The stereo parity for this atom.
            </summary>
        </member>
        <member name="P:NCDK.Silent.Atom.IsSingleOrDouble">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Silent.Atom.Compare(System.Object)">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Silent.AtomContainer">
            <summary>
            Base class for all chemical objects that maintain a list of Atoms and
            ElectronContainers. 
            </summary>
            <example>
            Looping over all Bonds in the AtomContainer is typically done like: 
            <code>
            foreach (IBond aBond in atomContainer.Bonds)
            {
                    // do something
            }
            </code>
            </example>
        </member>
        <member name="F:NCDK.Silent.AtomContainer.atoms">
            <summary>
            Atoms contained by this object.
            </summary>
        </member>
        <member name="F:NCDK.Silent.AtomContainer.bonds">
            <summary>
            Bonds contained by this object.
            </summary>
        </member>
        <member name="F:NCDK.Silent.AtomContainer.lonePairs">
            <summary>
            Lone pairs contained by this object.
            </summary>
        </member>
        <member name="F:NCDK.Silent.AtomContainer.singleElectrons">
            <summary>
            Single electrons contained by this object.
            </summary>
        </member>
        <member name="F:NCDK.Silent.AtomContainer.stereoElements">
            <summary>
            Stereo elements contained by this object.
            </summary>
        </member>
        <member name="M:NCDK.Silent.AtomContainer.#ctor">
            <summary>
             Constructs an empty AtomContainer.
            </summary>
        </member>
        <member name="M:NCDK.Silent.AtomContainer.#ctor(NCDK.IAtomContainer)">
            <summary>
            Constructs an AtomContainer with a copy of the atoms and electronContainers
            of another AtomContainer (A shallow copy, i.e., with the same objects as in
            the original AtomContainer).
            </summary>
            <param name="container">An AtomContainer to copy the atoms and electronContainers from</param>
        </member>
        <member name="P:NCDK.Silent.AtomContainer.IsAromatic">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.Silent.AtomContainer.IsSingleOrDouble">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.Silent.AtomContainer.Atoms">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.Silent.AtomContainer.Bonds">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.Silent.AtomContainer.LonePairs">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.Silent.AtomContainer.SingleElectrons">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.Silent.AtomContainer.StereoElements">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Silent.AtomContainer.SetStereoElements(System.Collections.Generic.IEnumerable{NCDK.IStereoElement})">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Silent.AtomContainer.GetBond(NCDK.IAtom,NCDK.IAtom)">
            <summary>
            Returns the bond that connects the two given atoms.
            </summary>
            <param name="atom1">The first atom</param>
            <param name="atom2">The second atom</param>
            <returns>The bond that connects the two atoms</returns>
        </member>
        <member name="M:NCDK.Silent.AtomContainer.GetConnectedAtoms(NCDK.IAtom)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Silent.AtomContainer.GetConnectedBonds(NCDK.IAtom)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Silent.AtomContainer.GetConnectedLonePairs(NCDK.IAtom)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Silent.AtomContainer.GetConnectedSingleElectrons(NCDK.IAtom)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Silent.AtomContainer.GetConnectedElectronContainers(NCDK.IAtom)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Silent.AtomContainer.GetBondOrderSum(NCDK.IAtom)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Silent.AtomContainer.GetMaximumBondOrder(NCDK.IAtom)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Silent.AtomContainer.GetMinimumBondOrder(NCDK.IAtom)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Silent.AtomContainer.Add(NCDK.IAtomContainer)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Silent.AtomContainer.AddElectronContainer(NCDK.IElectronContainer)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Silent.AtomContainer.Remove(NCDK.IAtomContainer)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Silent.AtomContainer.RemoveElectronContainer(NCDK.IElectronContainer)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Silent.AtomContainer.RemoveAtomAndConnectedElectronContainers(NCDK.IAtom)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Silent.AtomContainer.RemoveAtom(NCDK.IAtom)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Silent.AtomContainer.RemoveAllElements">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Silent.AtomContainer.RemoveAllElectronContainers">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Silent.AtomContainer.RemoveAllBonds">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Silent.AtomContainer.AddBond(NCDK.IAtom,NCDK.IAtom,NCDK.BondOrder,NCDK.BondStereo)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Silent.AtomContainer.AddBond(NCDK.IAtom,NCDK.IAtom,NCDK.BondOrder)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Silent.AtomContainer.AddLonePairTo(NCDK.IAtom)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Silent.AtomContainer.AddSingleElectronTo(NCDK.IAtom)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Silent.AtomContainer.RemoveBond(NCDK.IAtom,NCDK.IAtom)">
            <summary>
            Removes the bond that connects the two given atoms.
            </summary>
            <param name="atom1">The first atom</param>
            <param name="atom2">The second atom</param>
            <returns>The bond that connects the two atoms</returns>
        </member>
        <member name="M:NCDK.Silent.AtomContainer.Contains(NCDK.IAtom)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Silent.AtomContainer.Contains(NCDK.IBond)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Silent.AtomContainer.Contains(NCDK.ILonePair)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Silent.AtomContainer.Contains(NCDK.ISingleElectron)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Silent.AtomContainer.Contains(NCDK.IElectronContainer)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Silent.AtomContainer.ToString">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Silent.AtomContainer.Clone(NCDK.CDKObjectMap)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Silent.AtomContainer.GetElectronContainers">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Silent.AtomContainer.OnStateChanged(NCDK.ChemObjectChangeEventArgs)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Silent.AtomContainer.SetAtoms(System.Collections.Generic.IEnumerable{NCDK.IAtom})">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Silent.AtomContainer.SetBonds(System.Collections.Generic.IEnumerable{NCDK.IBond})">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Silent.AtomContainer.IsEmpty">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Silent.ChemObjectSet`1">
            <summary>
            A set of AtomContainers.
            </summary>
        </member>
        <member name="M:NCDK.Silent.ChemObjectSet`1.#ctor">
            <summary> Constructs an empty ChemObjectSet.</summary>
        </member>
        <member name="M:NCDK.Silent.ChemObjectSet`1.Add(`0)">
            <summary>
            Adds an atomContainer to this container.
            </summary>
            <param name="atomContainer">The atomContainer to be added to this container</param>
        </member>
        <member name="M:NCDK.Silent.ChemObjectSet`1.Remove(`0)">
            <summary>
            Removes an AtomContainer from this container.
            </summary>
            <param name="atomContainer">The atomContainer to be removed from this container</param>
        </member>
        <member name="M:NCDK.Silent.ChemObjectSet`1.Clear">
            <summary>
            Removes all AtomContainer from this container.
            </summary>
        </member>
        <member name="M:NCDK.Silent.ChemObjectSet`1.RemoveAt(System.Int32)">
            <summary>
            Removes an AtomContainer from this container.
            </summary>
            <param name="pos">The position of the AtomContainer to be removed from this container</param>
        </member>
        <member name="P:NCDK.Silent.ChemObjectSet`1.Item(System.Int32)">
            <summary>
            The AtomContainer at a specific position (array has to be large enough).
            </summary>
            <param name="position">position in array for AtomContainer</param>
        </member>
        <member name="M:NCDK.Silent.ChemObjectSet`1.SetMultiplier(`0,System.Nullable{System.Double})">
            <summary>
            Sets the coefficient of a AtomContainer to a given value.
            </summary>
            <param name="container">The AtomContainer for which the multiplier is set</param>
            <param name="multiplier">The new multiplier for the AtomContatiner</param>
            <returns>true if multiplier has been set</returns>
            <seealso cref="M:NCDK.Silent.ChemObjectSet`1.GetMultiplier(`0)"/>
        </member>
        <member name="M:NCDK.Silent.ChemObjectSet`1.SetMultiplier(System.Int32,System.Nullable{System.Double})">
            <summary>
            Sets the coefficient of a AtomContainer to a given value.
            </summary>
            <param name="position">The position of the AtomContainer for which the multiplier is set in [0,..]</param>
            <param name="multiplier">The new multiplier for the AtomContatiner at <paramref name="position"/></param>
            <seealso cref="M:NCDK.Silent.ChemObjectSet`1.GetMultiplier(System.Int32)"/>
        </member>
        <member name="M:NCDK.Silent.ChemObjectSet`1.SetMultipliers(System.Collections.Generic.IEnumerable{System.Nullable{System.Double}})">
            <summary>
            Sets the multipliers of the AtomContainers.
            </summary>
            <param name="multipliers">The new multipliers for the AtomContainers in this set</param>
            <returns>true if multipliers have been set.</returns>
            <seealso cref="M:NCDK.Silent.ChemObjectSet`1.GetMultipliers"/>
        </member>
        <member name="M:NCDK.Silent.ChemObjectSet`1.Add(`0,System.Nullable{System.Double})">
            <summary>
            Adds an atomContainer to this container with the given
            multiplier.
            </summary>
            <param name="atomContainer">The atomContainer to be added to this container</param>
            <param name="multiplier">The multiplier of this atomContainer</param>
        </member>
        <member name="M:NCDK.Silent.ChemObjectSet`1.Add(NCDK.IChemObjectSet{`0})">
            <summary>
             Adds all atomContainers in the ChemObjectSet to this container.
            </summary>
            <param name="atomContainerSet">The ChemObjectSet</param>
        </member>
        <member name="M:NCDK.Silent.ChemObjectSet`1.GetMultiplier(System.Int32)">
            <summary>
            Returns the multiplier for the AtomContainer at position <code>number</code> in the
            container.
            </summary>
            <param name="number">The position of the multiplier of the AtomContainer to be returned.</param>
            <returns>The multiplier for the AtomContainer at position <paramref name="number"/>.</returns>
            <seealso cref="M:NCDK.Silent.ChemObjectSet`1.SetMultiplier(System.Int32,System.Nullable{System.Double})"/>
        </member>
        <member name="M:NCDK.Silent.ChemObjectSet`1.GetMultiplier(`0)">
            <summary>
            Returns the multiplier of the given AtomContainer.
            </summary>
            <param name="container">The AtomContainer for which the multiplier is given</param>
            <returns>-1, if the given molecule is not a container in this set</returns>
        </member>
        <member name="M:NCDK.Silent.ChemObjectSet`1.ToString">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Silent.ChemObjectSet`1.OnStateChanged(NCDK.ChemObjectChangeEventArgs)">
            <summary>
             Called by objects to which this object has
             registered as a listener.
            </summary>
            <param name="evt">A change event pointing to the source of the change</param>
        </member>
        <member name="M:NCDK.Silent.ChemObjectSet`1.Sort(System.Collections.Generic.IComparer{`0})">
            <summary>
            Sort the AtomContainers and multipliers using a provided Comparator.
            </summary>
            <param name="comparator">defines the sorting method</param>
        </member>
        <member name="T:NCDK.Silent.AtomType">
            <summary>
            The base class for atom types. Atom types are typically used to describe the
            behaviour of an atom of a particular element in different environment like
            sp<sup>3</sup>
            hybridized carbon C3, etc., in some molecular modelling applications.
            </summary>
        </member>
        <member name="F:NCDK.Silent.AtomType.maxBondOrder">
            <summary>
             The maximum bond order allowed for this atom type.
            </summary>
        </member>
        <member name="F:NCDK.Silent.AtomType.bondOrderSum">
            <summary>
             The maximum sum of all bond orders allowed for this atom type.
            </summary>
        </member>
        <member name="F:NCDK.Silent.AtomType.covalentRadius">
            <summary>
            The covalent radius of this atom type.
            </summary>
        </member>
        <member name="F:NCDK.Silent.AtomType.formalCharge">
            <summary>
             The formal charge of the atom with CDKConstants.UNSET as default. Implements RFC #6.
            </summary>
            <remarks>
             Note that some constructors (<see cref="M:NCDK.Silent.AtomType.#ctor(System.String)"/> and
            <see cref="M:NCDK.Silent.AtomType.#ctor(System.String,System.String)"/> ) will explicitly set this field to 0
            </remarks>
        </member>
        <member name="F:NCDK.Silent.AtomType.hybridization">
            <summary>
            The hybridization state of this atom with CDKConstants.HYBRIDIZATION_UNSET
            as default.
            </summary>
        </member>
        <member name="F:NCDK.Silent.AtomType.valency">
            <summary>
            The electron Valency of this atom with CDKConstants.UNSET as default.
            </summary>
        </member>
        <member name="F:NCDK.Silent.AtomType.formalNeighbourCount">
            <summary>
            The formal number of neighbours this atom type can have with CDKConstants_UNSET
            as default. This includes explicitely and implicitely connected atoms, including
            implicit hydrogens.
            </summary>
        </member>
        <member name="M:NCDK.Silent.AtomType.#ctor(System.String)">
            <summary>
            Constructor for the AtomType object.
            
            Defaults to a zero formal charge. All
            other fields are set to <see langword="null"/> or unset.
            </summary>
            <param name="elementSymbol">Symbol of the atom</param>
        </member>
        <member name="M:NCDK.Silent.AtomType.#ctor(System.String,System.String)">
            <summary>
            Constructor for the AtomType object. Defaults to a zero formal charge.
            </summary>
            <param name="identifier">An id for this atom type, like C3 for sp3 carbon</param>
            <param name="elementSymbol">The element symbol identifying the element to which this atom type applies</param>
        </member>
        <member name="M:NCDK.Silent.AtomType.#ctor(NCDK.IElement)">
            <summary>
            Constructs an isotope by copying the symbol, atomic number,
            flags, identifier, exact mass, natural abundance and mass
            number from the given IIsotope. It does not copy the
            listeners and properties. If the element is an instanceof
            IAtomType, then the maximum bond order, bond order sum,
            van der Waals and covalent radii, formal charge, hybridization,
            electron valency, formal neighbour count and atom type name
            are copied too.
            </summary>
            <param name="element">IIsotope to copy information from</param>
        </member>
        <member name="P:NCDK.Silent.AtomType.AtomTypeName">
            <summary>
            The if attribute of the AtomType object.
            </summary>
        </member>
        <member name="P:NCDK.Silent.AtomType.MaxBondOrder">
            <summary>
            The MaxBondOrder attribute of the AtomType object.
            </summary>
        </member>
        <member name="P:NCDK.Silent.AtomType.BondOrderSum">
            <summary>
            The the exact bond order sum attribute of the AtomType object.
            </summary>
        </member>
        <member name="P:NCDK.Silent.AtomType.FormalCharge">
            <summary>
            The formal charge of this atom.
            </summary>
        </member>
        <member name="P:NCDK.Silent.AtomType.FormalNeighbourCount">
            <summary>
            The formal neighbour count of this atom.
            </summary>
        </member>
        <member name="P:NCDK.Silent.AtomType.Hybridization">
            <summary>
            The hybridization of this atom.
            </summary>
        </member>
        <member name="M:NCDK.Silent.AtomType.Compare(System.Object)">
            <summary>
            Compares a atom type with this atom type.
            </summary>
            <param name="obj">Object of type AtomType</param>
            <returns>true if the atom types are equal</returns>
        </member>
        <member name="P:NCDK.Silent.AtomType.CovalentRadius">
            <summary>
            The covalent radius for this AtomType.
            </summary>
        </member>
        <member name="P:NCDK.Silent.AtomType.Valency">
            <summary>
            The the exact electron valency of the AtomType object.
            </summary>
        </member>
        <member name="M:NCDK.Silent.BioPolymer.AddAtom(NCDK.IAtom,NCDK.IStrand)">
            <summary>
            Adds the atom oAtom to a specified Strand, whereas the Monomer is unspecified. Hence
            the atom will be added to a Monomer of type Unknown in the specified Strand.
            </summary>
            <param name="oAtom">The atom to add</param>
            <param name="oStrand">The strand the atom belongs to</param>
        </member>
        <member name="T:NCDK.Silent.Bond">
            <summary>
            Implements the concept of a covalent bond between two or more atoms. A bond is
            considered to be a number of electrons connecting two or more  of atoms.
            </summary>
            <remarks>
            <para>
            It should be noted that the majority of applications will consider 2-center bonds,
            especially since the bond orders currently supported are really only valid for
            2-center bonds. However the code does support multi-center bonds, though the
            orders may not make sense at this point.
            </para>
            <para>
            In general code that assumes bonds are 2-centered can use this class seamlessly, as
            the semantics are identical to the older versions. Care shoud be exercised when
            using multi-center bonds using this class as the orders may not make sense.
            </para>
            </remarks>
        </member>
        <member name="M:NCDK.Silent.Bond.#ctor">
            <summary>
            Constructs an empty bond.
            </summary>
        </member>
        <member name="M:NCDK.Silent.Bond.#ctor(NCDK.IAtom,NCDK.IAtom)">
            <summary>
            Constructs a bond with a single bond order.
            </summary>
            <param name="atom1">the first Atom in the bond</param>
            <param name="atom2">the second Atom in the bond</param>
        </member>
        <member name="M:NCDK.Silent.Bond.#ctor(NCDK.IAtom,NCDK.IAtom,NCDK.BondOrder)">
            <summary>
            Constructs a bond with a single bond order.
            </summary>
            <param name="atom1">the first Atom in the bond</param>
            <param name="atom2">the second Atom in the bond</param>
            <param name="order">the bond order</param>
        </member>
        <member name="M:NCDK.Silent.Bond.#ctor(System.Collections.Generic.IEnumerable{NCDK.IAtom})">
            <summary>
            Constructs a multi-center bond, with undefined order and no stereo information.
            </summary>
            <param name="atoms"><see cref="T:System.Collections.Generic.IEnumerable`1"/> of <see cref="T:NCDK.IAtom"/> containing the atoms constituting the bond</param>
        </member>
        <member name="M:NCDK.Silent.Bond.#ctor(System.Collections.Generic.IEnumerable{NCDK.IAtom},NCDK.BondOrder)">
            <summary>
            Constructs a multi-center bond, with a specified order and no stereo information.
            </summary>
            <param name="atoms">An array of <see cref="T:NCDK.IAtom"/> containing the atoms constituting the bond</param>
            <param name="order">The order of the bond</param>
        </member>
        <member name="M:NCDK.Silent.Bond.#ctor(NCDK.IAtom,NCDK.IAtom,NCDK.BondOrder,NCDK.BondStereo)">
            <summary>
            Constructs a bond with a single bond order.
            </summary>
            <param name="atom1">the first Atom in the bond</param>
            <param name="atom2">the second Atom in the bond</param>
            <param name="order">the bond order</param>
            <param name="stereo">a descriptor the stereochemical orientation of this bond</param>
        </member>
        <member name="P:NCDK.Silent.Bond.Atoms">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.Silent.Bond.Begin">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.Silent.Bond.End">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Silent.Bond.GetOther(NCDK.IAtom)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Silent.Bond.GetConnectedAtom(NCDK.IAtom)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Silent.Bond.GetConnectedAtoms(NCDK.IAtom)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Silent.Bond.Contains(NCDK.IAtom)">
            <summary>
            Returns true if the given atom participates in this bond.
            </summary>
            <param name="atom">The atom to be tested if it participates in this bond</param>
            <returns>true if the atom participates in this bond</returns>
        </member>
        <member name="M:NCDK.Silent.Bond.SetAtoms(System.Collections.Generic.IEnumerable{NCDK.IAtom})">
            <summary>
            Sets the array of atoms making up this bond.
            </summary>
            <param name="atoms">An array of atoms that forms this bond</param>
            <seealso cref="P:NCDK.Silent.Bond.Atoms"/>
        </member>
        <member name="P:NCDK.Silent.Bond.Order">
            <summary>
            The bond order of this bond.
            </summary>
        </member>
        <member name="P:NCDK.Silent.Bond.Stereo">
            <summary>
            The stereo descriptor for this bond.
            </summary>
        </member>
        <member name="P:NCDK.Silent.Bond.Geometric2DCenter">
            <summary>
            The geometric 2D center of the bond.
            </summary>
        </member>
        <member name="P:NCDK.Silent.Bond.Geometric3DCenter">
            <summary>
            The geometric 3D center of the bond.
            </summary>
        </member>
        <member name="P:NCDK.Silent.Bond.IsAromatic">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.Silent.Bond.IsAliphatic">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.Silent.Bond.IsInRing">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.Silent.Bond.IsSingleOrDouble">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.Silent.Bond.IsReactiveCenter">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Silent.Bond.Compare(System.Object)">
            <summary>
            Compares a bond with this bond.
            </summary>
            <param name="obj">Object of type Bond</param>
            <returns> true if the bond is equal to this bond</returns>
        </member>
        <member name="M:NCDK.Silent.Bond.IsConnectedTo(NCDK.IBond)">
            <summary>
            Checks whether a bond is connected to another one.
            This can only be true if the bonds have an Atom in common.
            </summary>
            <param name="bond">The bond which is checked to be connect with this one</param>
            <returns>true if the bonds share an atom, otherwise false</returns>
        </member>
        <member name="T:NCDK.Silent.ChemFile">
            <summary>
            A Object containing a number of ChemSequences. This is supposed to be the
            top level container, which can contain all the concepts stored in a chemical
            document
            </summary>
        </member>
        <member name="F:NCDK.Silent.ChemFile.chemSequences">
            <summary>
            List of ChemSquences.
            </summary>
        </member>
        <member name="M:NCDK.Silent.ChemFile.#ctor">
            <summary>
             Constructs an empty ChemFile.
            </summary>
        </member>
        <member name="P:NCDK.Silent.ChemFile.Item(System.Int32)">
            <summary>
            The ChemSequence at position <paramref name="number"/> in the container.
            </summary>
            <param name="number">The position of the ChemSequence</param>
            <returns>The ChemSequence at position <paramref name="number"/>.</returns>
            <seealso cref="M:NCDK.Silent.ChemFile.Add(NCDK.IChemSequence)"/>
        </member>
        <member name="P:NCDK.Silent.ChemFile.Count">
            <summary>
            The number of ChemSequences in this Container.
            </summary>
        </member>
        <member name="M:NCDK.Silent.ChemFile.Add(NCDK.IChemSequence)">
            <summary>
             Adds a ChemSequence to this container.
            </summary>
            <param name="chemSequence">The chemSequence to be added to this container</param>
            <seealso cref="P:NCDK.Silent.ChemFile.Item(System.Int32)"/>
        </member>
        <member name="M:NCDK.Silent.ChemFile.RemoveAt(System.Int32)">
            <summary>
            Removes a ChemSequence from this container.
            </summary>
            <param name="pos">The position from which to remove</param>
            <seealso cref="F:NCDK.Silent.ChemFile.chemSequences"/>
            <seealso cref="M:NCDK.Silent.ChemFile.Add(NCDK.IChemSequence)"/>
        </member>
        <member name="M:NCDK.Silent.ChemFile.OnStateChanged(NCDK.ChemObjectChangeEventArgs)">
            <summary>
             Called by objects to which this object has
             registered as a listener.
            </summary>
            <param name="evt">A change event pointing to the source of the change</param>
        </member>
        <member name="T:NCDK.Silent.ChemModel">
            <summary>
            An object containing multiple MoleculeSet and
            the other lower level concepts like rings, sequences,
            fragments, etc.
            </summary>
        </member>
        <member name="F:NCDK.Silent.ChemModel.setOfMolecules">
            <summary>
             A molecule set.
            </summary>
        </member>
        <member name="F:NCDK.Silent.ChemModel.setOfReactions">
            <summary>
             A reaction set.
            </summary>
        </member>
        <member name="F:NCDK.Silent.ChemModel.crystal">
            <summary>
             A Crystal.
            </summary>
        </member>
        <member name="M:NCDK.Silent.ChemModel.#ctor">
            <summary>
             Constructs an new <see cref="T:NCDK.Silent.ChemModel"/> with a null set of molecules.
            </summary>
        </member>
        <member name="P:NCDK.Silent.ChemModel.MoleculeSet">
            <summary>
            The molecule set of this <see cref="T:NCDK.Silent.ChemModel"/>.
            </summary>
        </member>
        <member name="P:NCDK.Silent.ChemModel.RingSet">
            <summary>
            The ring set of this <see cref="T:NCDK.Silent.ChemModel"/>.
            </summary>
        </member>
        <member name="P:NCDK.Silent.ChemModel.Crystal">
            <summary>
            The crystal contained in this <see cref="T:NCDK.Silent.ChemModel"/>.
            </summary>
        </member>
        <member name="P:NCDK.Silent.ChemModel.ReactionSet">
            <summary>
            The reaction set contained in this <see cref="T:NCDK.Silent.ChemModel"/>.
            </summary>
        </member>
        <member name="M:NCDK.Silent.ChemModel.OnStateChanged(NCDK.ChemObjectChangeEventArgs)">
            <summary>
             Called by objects to which this object has
             registered as a listener.
            </summary>
            <param name="evt">A change event pointing to the source of the change</param>
        </member>
        <member name="M:NCDK.Silent.ChemModel.IsEmpty">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Silent.ChemObjectBuilder">
            <summary>
            A factory class to provide implementation independent <see cref="T:NCDK.ICDKObject"/>s.
            </summary>
            <example>
            <code>    
                IChemObjectBuilder builder = ChemObjectBuilder.Instance;
            
                IAtom a = builder.NewAtom();
                IAtom c12 = builder.NewAtom("C");
                IAtom c13 = builder.NewAtom(builder.NewIsotope("C", 13));
            </code>
            </example>
        </member>
        <member name="T:NCDK.Silent.ChemSequence">
            <summary>
            A sequence of ChemModels, which can, for example, be used to
            store the course of a reaction. Each state of the reaction would be
            stored in one ChemModel.    
            </summary>
        </member>
        <member name="F:NCDK.Silent.ChemSequence.chemModels">
            <summary>Array of ChemModels.</summary>
        </member>
        <member name="M:NCDK.Silent.ChemSequence.Add(NCDK.IChemModel)">
            <summary>
            Adds an chemModel to this container.
            </summary>
            <param name="chemModel">The chemModel to be added to this container</param>
        </member>
        <member name="M:NCDK.Silent.ChemSequence.OnStateChanged(NCDK.ChemObjectChangeEventArgs)">
            <summary>
             Called by objects to which this object has
             registered as a listener.
            </summary>
            <param name="evt">A change event pointing to the source of the change</param>
        </member>
        <member name="T:NCDK.Silent.Crystal">
            <summary>
            Class representing a molecular crystal.
            The crystal is described with molecules in fractional
            coordinates and three cell axes: a,b and c.
            </summary>
            <remarks>
            The crystal is designed to store only the asymmetric atoms.
            Though this is not enforced, it is assumed by all methods.
            </remarks>
        </member>
        <member name="F:NCDK.Silent.Crystal.a">
            <summary>The a axis.</summary>
        </member>
        <member name="P:NCDK.Silent.Crystal.A">
            <summary>
            The A unit cell axes in Cartesian coordinates in a Euclidean space.
            </summary>
        </member>
        <member name="F:NCDK.Silent.Crystal.b">
            <summary>The b axis.</summary>
        </member>
        <member name="P:NCDK.Silent.Crystal.B">
            <summary>
            The B unit cell axes in Cartesian coordinates in a Euclidean space.
            </summary>
        </member>
        <member name="F:NCDK.Silent.Crystal.c">
            <summary>The c axis.</summary>
        </member>
        <member name="P:NCDK.Silent.Crystal.C">
            <summary>
            The C unit cell axes in Cartesian coordinates in a Euclidean space.
            </summary>
        </member>
        <member name="F:NCDK.Silent.Crystal.spaceGroup">
            <summary>Number of symmetry related atoms.</summary>
        </member>
        <member name="P:NCDK.Silent.Crystal.SpaceGroup">
            <summary>
            The space group of this crystal.
            </summary>
        </member>
        <member name="F:NCDK.Silent.Crystal.z">
            <summary>Number of symmetry related atoms.</summary>
        </member>
        <member name="P:NCDK.Silent.Crystal.Z">
            <summary>
            The number of asymmetric parts in the unit cell.
            </summary>
        </member>
        <member name="M:NCDK.Silent.Crystal.#ctor">
            <summary>
            Constructs a new crystal with zero length cell axis.
            </summary>
        </member>
        <member name="M:NCDK.Silent.Crystal.#ctor(NCDK.IAtomContainer)">
            <summary>
            Constructs a new crystal with zero length cell axis
            and adds the atoms in the AtomContainer as cell content.
            </summary>
            <param name="container">the AtomContainer providing the atoms and bonds</param>
        </member>
        <member name="M:NCDK.Silent.Crystal.ToString">
            <summary>
            Returns a string representation of this crystal.
            </summary>
        </member>
        <member name="T:NCDK.Silent.ElectronContainer">
            <summary>
            Base class for entities containing electrons, like bonds, orbitals, lone-pairs.
            </summary>
        </member>
        <member name="F:NCDK.Silent.ElectronContainer.electronCount">
            <summary>
            Constructs an empty ElectronContainer.
            </summary>
        </member>
        <member name="M:NCDK.Silent.ElectronContainer.#ctor">
            <summary>
            Returns the number of electrons in this electron container.
            </summary>
            <returns>The number of electrons in this electron container.</returns>
            <seealso cref="P:NCDK.Silent.ElectronContainer.ElectronCount"/>
        </member>
        <member name="P:NCDK.Silent.ElectronContainer.ElectronCount">
            <summary>
            The number of electrons in this electron container.
            </summary>
        </member>
        <member name="T:NCDK.Silent.Element">
            <summary>
            Implements the idea of an element in the periodic table.
            </summary>
            <example>
            Use the IsotopeFactory to get a ready-to-use elements
            by symbol or atomic number:
            <code>
              IsotopeFactory f = IsotopeFactory.getInstance(new Element().Builder);
              Element e1 = f.GetElement("C");
              Element e2 = f.GetElement(12);
            </code></example>
        </member>
        <member name="F:NCDK.Silent.Element.symbol">
            <summary>The element symbol for this element as listed in the periodic table.</summary>
        </member>
        <member name="F:NCDK.Silent.Element.atomicNumber">
            <summary>The atomic number for this element giving their position in the periodic table.</summary>
        </member>
        <member name="M:NCDK.Silent.Element.#ctor">
            <summary>
            Constructs an empty Element.
            </summary>
        </member>
        <member name="M:NCDK.Silent.Element.#ctor(NCDK.IElement)">
            <summary>
            Constructs an empty by copying the symbol, atomic number,
            flags, and identifier from the given IElement. It does
            not copy the listeners and properties.
            </summary>
            <param name="element">IElement to copy information from</param>
        </member>
        <member name="M:NCDK.Silent.Element.#ctor(System.String)">
            <summary>
            Constructs an Element with a given
            element symbol.
            </summary>
            <param name="symbol">The element symbol that this element should have.</param>
        </member>
        <member name="M:NCDK.Silent.Element.#ctor(System.String,System.Nullable{System.Int32})">
            <summary>
            Constructs an Element with a given element symbol,
            atomic number and atomic mass.
            </summary>
            <param name="symbol">The element symbol of this element.</param>
            <param name="atomicNumber">The atomicNumber of this element.</param>
        </member>
        <member name="P:NCDK.Silent.Element.AtomicNumber">
            <summary>
            The atomic number of this element.
            </summary>
            <example>
            Once instantiated all field not filled by passing parameters
            to the constructor are null. Elements can be configured by using
            the <see cref="M:NCDK.Config.IsotopeFactory.Configure(NCDK.IAtom)"/> method:
            <code>
              Element element = new Element("C");
              IsotopeFactory f = IsotopeFactory.GetInstance(element.Builder);
              f.Configure(element);
            </code>
            </example>
        </member>
        <member name="P:NCDK.Silent.Element.Symbol">
            <summary>
            The element symbol of this element.
            </summary>
            <returns>The element symbol of this element. <see langword="null"/> if unset.</returns>
        </member>
        <member name="M:NCDK.Silent.Element.Compare(System.Object)">
            <summary>
            Compares an Element with this Element.
            </summary>
            <param name="obj">Object of type AtomType</param>
            <returns>true if the atom types are equal</returns>
        </member>
        <member name="T:NCDK.Silent.EnzymeResidueLocator">
            <summary>
            Atom that represents part of an residue in an enzyme, like Arg255.
            </summary>
        </member>
        <member name="M:NCDK.Silent.EnzymeResidueLocator.#ctor(System.String)">
            <summary>
            Constructs an EnzymeResidueLocator from a string containing the locator.
            </summary>
            <param name="label">The string describing the residue and its location.</param>
        </member>
        <member name="M:NCDK.Silent.EnzymeResidueLocator.#ctor(NCDK.IAtom)">
            <summary>
            Constructs an EnzymeResidueLocator from an existing Atom.
            </summary>
            <param name="atom">Atom that should be converted into a EnzymeResidueLocator.</param>
        </member>
        <member name="T:NCDK.Silent.FragmentAtom">
            <summary>
            Class to represent an IPseudoAtom which embeds an IAtomContainer. Very much
            like the MDL Molfile <pre>Group</pre> concept.
            </summary>
        </member>
        <member name="P:NCDK.Silent.FragmentAtom.ExactMass">
            <summary>
            The exact mass of an FragmentAtom is defined as the sum of exact masses
            of the IAtom's in the fragment.
            </summary>
        </member>
        <member name="T:NCDK.Silent.Isotope">
            <summary>
            Used to store and retrieve data of a particular isotope.
            </summary>
            <example>
            For example, an carbon 13 isotope can be created with:
            <code>
              Isotope carbon = new Isotope("C", 13);
            </code>
            
            A full specification can be constructed with:
            <code>
              // make deuterium
              Isotope carbon = new Isotope(1, "H", 2, 2.01410179, 100.0);
            </code>
            
            Once instantiated all field not filled by passing parameters
            to the constructor are null. Isotopes can be configured by using
            the IsotopeFactory.Configure() method:
            <code>
              Isotope isotope = new Isotope("C", 13);
              IsotopeFactory f = IsotopeFactory.GetInstance(isotope.Builder);
              f.Configure(isotope);
            </code>
            </example>
        </member>
        <member name="M:NCDK.Silent.Isotope.#ctor(System.String)">
            <summary>
             Constructor for the Isotope object.
            </summary>
            <param name="elementSymbol">The element symbol, "O" for Oxygen, etc.</param>
        </member>
        <member name="M:NCDK.Silent.Isotope.#ctor(System.Int32,System.String,System.Int32,System.Double,System.Double)">
            <summary>
             Constructor for the Isotope object.
            </summary>
            <param name="atomicNumber">The atomic number of the isotope</param>
            <param name="elementSymbol">The element symbol, "O" for Oxygen, etc.</param>
            <param name="massNumber">The atomic mass of the isotope, 16 for Oxygen, e.g.</param>
            <param name="exactMass">The exact mass of the isotope, be a little more explicit here :-)</param>
            <param name="abundance">The natural abundance of the isotope</param>
        </member>
        <member name="M:NCDK.Silent.Isotope.#ctor(System.Int32,System.String,System.Double,System.Double)">
            <summary>
             Constructor for the Isotope object.
            </summary>
            <param name="atomicNumber">The atomic number of the isotope, 8 for Oxygen</param>
            <param name="elementSymbol">The element symbol, "O" for Oxygen, etc.</param>
            <param name="exactMass">The exact mass of the isotope, be a little more explicit here :-)</param>
            <param name="abundance">The natural abundance of the isotope</param>
        </member>
        <member name="M:NCDK.Silent.Isotope.#ctor(System.String,System.Int32)">
            <summary>
            Constructor for the Isotope object.
            </summary>
            <param name="elementSymbol">The element symbol, "O" for Oxygen, etc.</param>
            <param name="massNumber">The atomic mass of the isotope, 16 for Oxygen, e.g.</param>
        </member>
        <member name="M:NCDK.Silent.Isotope.#ctor(NCDK.IElement)">
            <summary>
            Constructs an empty by copying the symbol, atomic number,
            flags, and identifier from the given IElement. It does
            not copy the listeners and properties. If the element is
            an instanceof IIsotope, then the exact mass, natural
            abundance and mass number are copied too.
            </summary>
            <param name="element">IElement to copy information from</param>
        </member>
        <member name="P:NCDK.Silent.Isotope.NaturalAbundance">
            <summary>
            The NaturalAbundance attribute of the Isotope object.
            </summary>
            <example>
            Once instantiated all field not filled by passing parameters
            to the constructor are null. Isotopes can be configured by using
            the IsotopeFactory.configure() method:
            <code>
              Isotope isotope = new Isotope("C", 13);
              IsotopeFactory f = IsotopeFactory.GetInstance(isotope.Builder);
              f.Configure(isotope);
            </code>
            </example>
        </member>
        <member name="P:NCDK.Silent.Isotope.ExactMass">
            <summary>
            The ExactMass attribute of the Isotope object.
            </summary>
            <example>
            Once instantiated all field not filled by passing parameters
            to the constructor are null. Isotopes can be configured by using
            the IsotopeFactory.configure() method:
            <code>
              Isotope isotope = new Isotope("C", 13);
              IsotopeFactory f = IsotopeFactory.GetInstance(isotope.Builder);
              f.Configure(isotope);
            </code>
            </example>
        </member>
        <member name="P:NCDK.Silent.Isotope.MassNumber">
            <summary>
            The atomic mass of this element.
            </summary>
            <example>
            Once instantiated all field not filled by passing parameters
            to the constructor are null. Isotopes can be configured by using
            the IsotopeFactory.configure() method:
            <code>
              Isotope isotope = new Isotope("C", 13);
              IsotopeFactory f = IsotopeFactory.GetInstance(isotope.Builder);
              f.Configure(isotope);
            </code>
            </example>
        </member>
        <member name="M:NCDK.Silent.Isotope.Compare(System.Object)">
            <summary>
            Compares an isotope with this isotope.
            </summary>
            <param name="obj">Object of type Isotope</param>
            <returns>true if the isotopes are equal</returns>
        </member>
        <member name="T:NCDK.Silent.LonePair">
            <summary>
            A LonePair is an orbital primarily located with one Atom, containing
            two electrons.
            </summary>
        </member>
        <member name="F:NCDK.Silent.LonePair.electronCount">
            <summary>Number of electrons in the lone pair.</summary>
        </member>
        <member name="F:NCDK.Silent.LonePair.atom">
            <summary>The atom with which this lone pair is associated.</summary>
        </member>
        <member name="M:NCDK.Silent.LonePair.#ctor">
            <summary>
            Constructs an unconnected lone pair.
            </summary>
        </member>
        <member name="M:NCDK.Silent.LonePair.#ctor(NCDK.IAtom)">
            <summary>
            Constructs an lone pair on an Atom.
            </summary>
            <param name="atom">Atom to which this lone pair is connected</param>
        </member>
        <member name="P:NCDK.Silent.LonePair.ElectronCount">
            <summary>
            The number of electrons in a LonePair.
            </summary>
        </member>
        <member name="P:NCDK.Silent.LonePair.Atom">
            <summary>
            The associated Atom.
            </summary>
        </member>
        <member name="M:NCDK.Silent.LonePair.Contains(NCDK.IAtom)">
            <summary>
            Returns true if the given atom participates in this lone pair.
            </summary>
            <param name="atom">The atom to be tested if it participates in this bond</param>
            <returns>true if this lone pair is associated with the atom</returns>
        </member>
        <member name="M:NCDK.Silent.LonePair.ToString">
            <summary>
            Returns a one line string representation of this LonePair.
            This method is conform RFC #9.
            </summary>
            <returns>The string representation of this LonePair</returns>
        </member>
        <member name="T:NCDK.Silent.Mapping">
            <summary>
            A Mapping is an relation between two ChemObjects in a non-chemical
            entity. It is not a Bond, nor a Association, merely a relation.
            An example of such a mapping, is the mapping between corresponding atoms
            in a Reaction.
            </summary>
        </member>
        <member name="M:NCDK.Silent.Mapping.#ctor(NCDK.IChemObject,NCDK.IChemObject)">
            <summary>
            Constructs an unconnected lone pair.
            </summary>
            <param name="objectOne">The first IChemObject of the mapping</param>
            <param name="objectTwo">The second IChemObject of the mapping</param>
        </member>
        <member name="P:NCDK.Silent.Mapping.Item(System.Int32)">
            <summary>
            Retrieves the first or second of the related IChemObjects.
            </summary>
            <param name="pos">The position of the IChemObject.</param>
            <returns>The IChemObject to retrieve.</returns>
        </member>
        <member name="M:NCDK.Silent.Mapping.GetRelatedChemObjects">
            <summary>
            Enumerable to the two IChemObjects.
            </summary>
            <returns>An enumerable to two IChemObjects that define the mapping</returns>
        </member>
        <member name="T:NCDK.Silent.Monomer">
            <summary>
            A Monomer is an AtomContainer which stores additional monomer specific
            informations for a group of Atoms.
            </summary>
        </member>
        <member name="F:NCDK.Silent.Monomer.monomerName">
            <summary>The name of this monomer (e.g. Trp42).</summary>
        </member>
        <member name="F:NCDK.Silent.Monomer.monomerType">
            <summary>The type of this monomer (e.g. TRP).</summary>
        </member>
        <member name="P:NCDK.Silent.Monomer.MonomerName">
            <summary>The name of this monomer (e.g. Trp42).</summary>
        </member>
        <member name="P:NCDK.Silent.Monomer.MonomerType">
            <summary>The type of this monomer (e.g. TRP).</summary>
        </member>
        <member name="T:NCDK.Silent.PDBAtom">
            <summary>
            Represents the idea of an atom as used in PDB files. It contains extra fields
            normally associated with atoms in such files.
            </summary>
        </member>
        <member name="M:NCDK.Silent.PDBAtom.#ctor(NCDK.IElement)">
            <summary>
            Constructs an IPDBAtom from a Element.
            </summary>
            <param name="element">IElement to copy information from</param>
        </member>
        <member name="M:NCDK.Silent.PDBAtom.#ctor(System.String)">
            <summary>
            Constructs an <see cref="T:NCDK.IPDBAtom"/> from a string containing an element symbol.
            </summary>
            <param name="symbol">The string describing the element for the PDBAtom</param>
        </member>
        <member name="M:NCDK.Silent.PDBAtom.#ctor(System.String,NCDK.Numerics.Vector3)">
            <summary>
            Constructs an <see cref="T:NCDK.IPDBAtom"/> from an Element and a Vector3.
            </summary>
            <param name="symbol">The symbol of the atom</param>
            <param name="coordinate">The 3D coordinates of the atom</param>
        </member>
        <member name="P:NCDK.Silent.PDBAtom.Record">
            <summary>
            one entire line from the PDB entry file which describe the IPDBAtom.
            It consists of 80 columns.
            </summary>
            <returns>a string with all information</returns>
        </member>
        <member name="P:NCDK.Silent.PDBAtom.TempFactor">
            <summary>
            The Temperature factor of this atom.
            </summary>
        </member>
        <member name="P:NCDK.Silent.PDBAtom.ResName">
            <summary>
            The Residue name of this atom.
            </summary>
        </member>
        <member name="P:NCDK.Silent.PDBAtom.ICode">
            <summary>
            The Code for insertion of residues of this atom.
            </summary>
        </member>
        <member name="P:NCDK.Silent.PDBAtom.Name">
            <summary>
            The Atom name of this atom.
            </summary>
        </member>
        <member name="P:NCDK.Silent.PDBAtom.ChainID">
            <summary>
            The Chain identifier of this atom.
            </summary>
        </member>
        <member name="P:NCDK.Silent.PDBAtom.AltLoc">
            <summary>
            The Alternate location indicator of this atom.
            </summary>
        </member>
        <member name="P:NCDK.Silent.PDBAtom.SegID">
            <summary>
            The Segment identifier, left-justified of this atom.
            </summary>
        </member>
        <member name="P:NCDK.Silent.PDBAtom.Serial">
            <summary>
            The Atom serial number of this atom.
            </summary>
        </member>
        <member name="P:NCDK.Silent.PDBAtom.ResSeq">
            <summary>
            The Residue sequence number of this atom.
            </summary>
        </member>
        <member name="P:NCDK.Silent.PDBAtom.Occupancy">
            <summary>
            The Occupancy of this atom.
            </summary>
        </member>
        <member name="M:NCDK.Silent.PDBAtom.ToString">
            <summary>
            Returns a one line string representation of this Atom.
            Methods is conform RFC #9.
            </summary>
            <returns>The string representation of this Atom</returns>
        </member>
        <member name="T:NCDK.Silent.PDBMonomer">
            <summary>
            Represents the idea of an monomer as used in PDB files. It contains extra fields
            normally associated with atoms in such files.
            </summary>
        </member>
        <member name="P:NCDK.Silent.PDBMonomer.ChainID">
            <summary>
            Denotes which chain in the PDB file this monomer is in.
            </summary>
        </member>
        <member name="P:NCDK.Silent.PDBMonomer.ResSeq">
            <summary>
            Denotes which residue sequence in the current chain that this monomer is in.
            </summary>
        </member>
        <member name="M:NCDK.Silent.PDBMonomer.ToString">
            <summary>
            Returns a one line string representation of this Atom.
            Methods is conform RFC #9.
            </summary>
            <returns>The string representation of this Atom</returns>
        </member>
        <member name="M:NCDK.Silent.PDBMonomer.Clone">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Silent.PDBPolymer">
            <summary>
            An entry in the PDB database. It is not just a regular protein, but the
            regular PDB mix of protein or protein complexes, ligands, water molecules
            and other species.
            </summary>
        </member>
        <member name="M:NCDK.Silent.PDBPolymer.#ctor">
            <summary>
            Constructs a new Polymer to store the <see cref="T:NCDK.IMonomer"/>s.
            </summary>
        </member>
        <member name="M:NCDK.Silent.PDBPolymer.Add(NCDK.IPDBAtom)">
            <summary>
            Adds the atom oAtom without specifying a <see cref="T:NCDK.IMonomer"/> or a Strand. Therefore the
            atom to this AtomContainer, but not to a certain Strand or <see cref="T:NCDK.IMonomer"/> (intended
            e.g. for HETATMs).
            </summary>
            <param name="oAtom">The <see cref="T:NCDK.IPDBAtom"/> to add</param>
        </member>
        <member name="M:NCDK.Silent.PDBPolymer.AddAtom(NCDK.IPDBAtom,NCDK.IMonomer)">
            <summary>
            Adds the atom oAtom to a specified Monomer. Additionally, it keeps
            record of the iCode.
            </summary>
            <param name="oAtom">The IPDBAtom to add</param>
            <param name="oMonomer">The monomer the atom belongs to</param>
        </member>
        <member name="M:NCDK.Silent.PDBPolymer.AddAtom(NCDK.IPDBAtom,NCDK.IMonomer,NCDK.IStrand)">
            <summary>
            Adds the IPDBAtom oAtom to a specified Monomer of a specified Strand.
            Additionally, it keeps record of the iCode.
            </summary>
            <param name="oAtom">The IPDBAtom to add</param>
            <param name="oMonomer">The monomer the atom belongs to</param>
            <param name="oStrand"></param>
        </member>
        <member name="M:NCDK.Silent.PDBPolymer.GetMonomerNamesInSequentialOrder">
            <summary>
            Returns the monomer names in the order in which they were added.
            </summary>
            <seealso cref="M:NCDK.IPolymer.GetMonomerNames"/>
        </member>
        <member name="M:NCDK.Silent.PDBPolymer.Clone">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Silent.PDBStrand">
            <summary>
            An entry in the PDB database. It is not just a regular protein, but the
            regular PDB mix of protein or protein complexes, ligands, water molecules
            and other species.
            </summary>
        </member>
        <member name="M:NCDK.Silent.PDBStrand.#ctor">
            <summary>
            Constructs a new Polymer to store the Monomers.
            </summary>
        </member>
        <member name="M:NCDK.Silent.PDBStrand.AddAtom(NCDK.IAtom,NCDK.IMonomer)">
             <summary>
             Adds the atom oAtom to a specified Monomer. Additionally, it keeps
             record of the iCode.
            
             <param name="oAtom">The atom to add</param>
             <param name="oMonomer">The monomer the atom belongs to</param>
             </summary>
        </member>
        <member name="M:NCDK.Silent.PDBStrand.GetMonomerNamesInSequentialOrder">
            <summary>
            Returns the monomer names in the order in which they were added.
            </summary>
            <seealso cref="M:NCDK.IPolymer.GetMonomerNames"/>
        </member>
        <member name="T:NCDK.Silent.PDBStructure">
            <summary>
            Holder for secundary protein structure elements. Lously modeled after
            the Jmol Structure.java.
            </summary>
        </member>
        <member name="P:NCDK.Silent.PDBStructure.StructureType">
            <summary>
            Structure Type of this structure.
            </summary>
        </member>
        <member name="P:NCDK.Silent.PDBStructure.StartChainID">
            <summary>
            start Chain identifier of this structure.
            </summary>
        </member>
        <member name="P:NCDK.Silent.PDBStructure.StartSequenceNumber">
            <summary>
            Start sequence number of this structure.
            </summary>
        </member>
        <member name="P:NCDK.Silent.PDBStructure.StartInsertionCode">
            <summary>
            Start Code for insertion of residues of this structure.
            </summary>
        </member>
        <member name="P:NCDK.Silent.PDBStructure.EndChainID">
            <summary>
            The ending Chain identifier of this structure.
            </summary>
        </member>
        <member name="P:NCDK.Silent.PDBStructure.EndSequenceNumber">
            <summary>
            The ending sequence number of this structure.
            </summary>
        </member>
        <member name="P:NCDK.Silent.PDBStructure.EndInsertionCode">
            <summary>
            The ending Code for insertion of residues of this structure.
            </summary>
        </member>
        <member name="T:NCDK.Silent.Polymer">
            <summary>
            Subclass of Molecule to store Polymer specific attributes that a Polymer has.
            </summary>
        </member>
        <member name="M:NCDK.Silent.Polymer.#ctor">
            <summary>
            Constructs a new Polymer to store the Monomers.
            </summary>
        </member>
        <member name="M:NCDK.Silent.Polymer.AddAtom(NCDK.IAtom,NCDK.IMonomer)">
            <summary>
            Adds the atom oAtom to a specified Monomer.
            </summary>
            <param name="oAtom">The atom to add</param>
            <param name="oMonomer">The monomer the atom belongs to</param>
        </member>
        <member name="M:NCDK.Silent.Polymer.GetMonomerMap">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Silent.Polymer.GetMonomer(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Silent.Polymer.GetMonomerNames">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Silent.Polymer.RemoveMonomer(System.String)">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Silent.PseudoAtom">
            <inheritdoc cref="T:NCDK.IPseudoAtom"/>
        </member>
        <member name="M:NCDK.Silent.PseudoAtom.#ctor">
            <summary>
            Constructs an empty PseudoAtom.
            </summary>
        </member>
        <member name="M:NCDK.Silent.PseudoAtom.#ctor(System.String)">
            <summary>
            Constructs an Atom from a String containing an element symbol.
            </summary>
            <param name="label">The String describing the PseudoAtom</param>
        </member>
        <member name="M:NCDK.Silent.PseudoAtom.#ctor(NCDK.IElement)">
            <summary>
            Constructs an <see cref="T:NCDK.Silent.PseudoAtom"/> from a <see cref="T:NCDK.IAtom"/>.
            </summary>
            <param name="element"><see cref="T:NCDK.IAtom"/> from which the <see cref="T:NCDK.Silent.PseudoAtom"/> is constructed</param>
        </member>
        <member name="M:NCDK.Silent.PseudoAtom.#ctor(System.String,NCDK.Numerics.Vector3)">
            <summary>
            Constructs a <see cref="T:NCDK.Silent.PseudoAtom"/> from an element name and a <see cref="T:NCDK.Numerics.Vector3"/>.
            </summary>
            <param name="label">The <see cref="T:System.String"/> describing the <see cref="T:NCDK.Silent.PseudoAtom"/></param>
            <param name="point3d">The 3D coordinates of the atom</param>
        </member>
        <member name="M:NCDK.Silent.PseudoAtom.#ctor(System.String,NCDK.Numerics.Vector2)">
            <summary>
            Constructs a <see cref="T:NCDK.Silent.PseudoAtom"/> from an element name and a <see cref="T:NCDK.Numerics.Vector2"/>.
            </summary>
            <param name="label">The <see cref="T:System.String"/> describing the <see cref="T:NCDK.Silent.PseudoAtom"/></param>
            <param name="point2d">The 2D coordinates of the atom</param>
        </member>
        <member name="P:NCDK.Silent.PseudoAtom.Label">
            <summary>
             The label of this <see cref="T:NCDK.Silent.PseudoAtom"/>.
            </summary>
        </member>
        <member name="P:NCDK.Silent.PseudoAtom.AttachPointNum">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.Silent.PseudoAtom.StereoParity">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Silent.Reaction">
            <inheritdoc cref="T:NCDK.IReaction"/>
        </member>
        <member name="P:NCDK.Silent.Reaction.Reactants">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.Silent.Reaction.Products">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.Silent.Reaction.Agents">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.Silent.Reaction.Mappings">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.Silent.Reaction.Direction">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Silent.Reaction.#ctor">
            <summary>
            Constructs an empty, forward reaction.
            </summary>
        </member>
        <member name="T:NCDK.Silent.ReactionScheme">
            <summary>
            Classes that : the definition of reaction to a scheme.
            This is designed to contain a set of reactions which are linked in
            some way but without hard coded semantics.
            </summary>
        </member>
        <member name="F:NCDK.Silent.ReactionScheme.reactionScheme">
            <summary>
            A List of reaction schemes
            </summary>
        </member>
        <member name="M:NCDK.Silent.ReactionScheme.#ctor">
            <summary>
            Constructs an empty ReactionScheme.
            </summary>
        </member>
        <member name="M:NCDK.Silent.ReactionScheme.Add(NCDK.IReactionScheme)">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.Silent.ReactionScheme.Schemes">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Silent.ReactionScheme.Remove(NCDK.IReactionScheme)">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.Silent.ReactionScheme.Reactions">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Silent.ReactionScheme.Clone(NCDK.CDKObjectMap)">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Silent.ReactionSet">
             <summary>
             A set of reactions, for example those taking part in a reaction.
             </summary>
             <example>
             To retrieve the reactions from the set, there are two options:
             <code>
             ReactionSet reactions = ...
             foreach (var reaction in reactions)
             {
                 //
             }
             </code>
            
             and
            
             <code>
             for (int i = 0; i &lt; reactionSet.Count; i++)
             {
                    IReaction reaction = reactionSet[i]; 
             }
             </code>
             </example>
        </member>
        <member name="F:NCDK.Silent.ReactionSet.reactions">
            <summary>
            Array of Reactions.
            </summary>
        </member>
        <member name="M:NCDK.Silent.ReactionSet.#ctor">
            <summary>
            Constructs an empty ReactionSet.
            </summary>
        </member>
        <member name="P:NCDK.Silent.ReactionSet.Item(System.Int32)">
            <summary>
            Returns the Reaction at position <paramref name="number"/> in the container.
            </summary>
            <param name="number">The position of the Reaction to be returned</param>
            <returns>The Reaction at position <paramref name="number"/></returns>
        </member>
        <member name="M:NCDK.Silent.ReactionSet.Add(NCDK.IReaction)">
            <summary>
            Adds an reaction to this container.
            </summary>
            <param name="reaction">The reaction to be added to this container</param>
        </member>
        <member name="M:NCDK.Silent.ReactionSet.RemoveAt(System.Int32)">
            <summary>
            Remove a reaction from this set.
            </summary>
            <param name="index">The position of the reaction to be removed.</param>
        </member>
        <member name="T:NCDK.Silent.Ring">
            <summary>
            Class representing a ring structure in a molecule.
            A ring is a linear sequence of
            N atoms interconnected to each other by covalent bonds,
            such that atom i (1 &lt; i &lt; N) is bonded to
            atom i-1 and atom i + 1 and atom 1 is bonded to atom N and atom 2.
            </summary>
        </member>
        <member name="M:NCDK.Silent.Ring.#ctor">
            <summary>
            Constructs an empty ring.
            </summary>
        </member>
        <member name="M:NCDK.Silent.Ring.#ctor(NCDK.IAtomContainer)">
            <summary>
            Constructs a ring from the atoms in an <see cref="T:NCDK.IAtomContainer"/> object.
            </summary>
            <param name="atomContainer">The <see cref="T:NCDK.IAtomContainer"/> object containing the atoms to form the ring</param>
        </member>
        <member name="M:NCDK.Silent.Ring.#ctor(System.Collections.Generic.IEnumerable{NCDK.IAtom},System.Collections.Generic.IEnumerable{NCDK.IBond})">
            <summary>
            Constructs a ring from the atoms and bonds.
            </summary>
            <param name="atoms">atoms</param>
            <param name="bonds">bonds</param>
        </member>
        <member name="M:NCDK.Silent.Ring.#ctor(System.Int32,System.String)">
            <summary>
            Constructs a ring that will have a certain number of atoms of the given elements.
            </summary>
            <param name="ringSize">The number of atoms and bonds the ring will have</param>
            <param name="elementSymbol">The element of the atoms the ring will have</param>
        </member>
        <member name="P:NCDK.Silent.Ring.RingSize">
            <summary>
            the number of atoms\edges in this ring.
            </summary>
        </member>
        <member name="M:NCDK.Silent.Ring.GetNextBond(NCDK.IBond,NCDK.IAtom)">
            <summary>
            Returns the next bond in order, relative to a given bond and atom.
            Example: Let the ring be composed of 0-1, 1-2, 2-3 and 3-0. A request getNextBond(1-2, 2)
            will return Bond 2-3.
            </summary>
            <param name="bond"> A bond for which an atom from a consecutive bond is sought</param>
            <param name="atom">A atom from the bond above to assign a search direction</param>
            <returns>The next bond in the order given by the above assignment</returns>
        </member>
        <member name="P:NCDK.Silent.Ring.BondOrderSum">
            <summary>
            The sum of all bond orders in the ring.
            </summary>
        </member>
        <member name="T:NCDK.Silent.RingSet">
            <summary>
            Maintains a set of Ring objects.
            </summary>
        </member>
        <member name="M:NCDK.Silent.RingSet.#ctor">
            <summary>
            The constructor.
            </summary>
        </member>
        <member name="M:NCDK.Silent.RingSet.GetRings(NCDK.IAtom)">
            <summary>
            Returns a vector of all rings that this atom is part of.
            </summary>
            <param name="atom">The atom to be checked</param>
            <returns>A vector of all rings that this bond is part of</returns>
        </member>
        <member name="M:NCDK.Silent.RingSet.GetRings(NCDK.IBond)">
            <summary>
            Returns a vector of all rings that this bond is part of.
            </summary>
            <param name="bond">The bond to be checked</param>
            <returns>A vector of all rings that this bond is part of</returns>
        </member>
        <member name="M:NCDK.Silent.RingSet.GetConnectedRings(NCDK.IRing)">
            <summary>
            Returns all the rings in the RingSet that share one or more atoms with a given ring.
            </summary>
            <param name="ring">A ring with which all return rings must share one or more atoms</param>
            <returns>All the rings that share one or more atoms with a given ring.</returns>
        </member>
        <member name="M:NCDK.Silent.RingSet.Add(NCDK.IRingSet)">
            <summary>
            Adds all rings of another RingSet if they are not already part of this ring set.
            
            If you want to add a single ring to the set use <see cref="M:NCDK.Silent.RingSet.Add(NCDK.IRingSet)"/> 
            </summary>
            <param name="ringSet">the ring set to be united with this one.</param>
        </member>
        <member name="M:NCDK.Silent.RingSet.Contains(NCDK.IAtom)">
            <summary>
            True, if at least one of the rings in the ringset contains the given atom.
            </summary>
            <param name="atom">Atom to check</param>
            <returns>true, if the ringset contains the atom</returns>
        </member>
        <member name="T:NCDK.Silent.SingleElectron">
            <summary>
            A Single Electron is an orbital which is occupied by only one electron.
            </summary>
            <example>
            A radical in CDK is represented by an AtomContainer that contains an Atom
            and a SingleElectron type ElectronContainer:
            <code>
            AtomContainer radical = new AtomContainer();
            Atom carbon = new Atom("C");
            carbon.ImplicitHydrogenCount = 3;
            radical.SingleElectrons.Add(new SingleElectron(carbon));
            </code>
            </example>
        </member>
        <member name="M:NCDK.Silent.SingleElectron.#ctor(NCDK.IAtom)">
            <summary>
            Constructs an single electron orbital on an Atom.
            </summary>
            <param name="atom">The atom to which the single electron belongs.</param>
        </member>
        <member name="M:NCDK.Silent.SingleElectron.#ctor">
            <summary>
            Constructs an single electron orbital with an associated Atom.
            </summary>
        </member>
        <member name="P:NCDK.Silent.SingleElectron.ElectronCount">
            <summary>
            Number of electron for this class is defined as one.
            </summary>
        </member>
        <member name="P:NCDK.Silent.SingleElectron.Atom">
            <summary>
            The associated Atom.
            </summary>
        </member>
        <member name="M:NCDK.Silent.SingleElectron.Contains(NCDK.IAtom)">
            <summary>
            Returns true if the given atom participates in this SingleElectron.
            </summary>
            <param name="atom">The atom to be tested if it participates in this bond</param>
            <returns>true if this SingleElectron is associated with the atom</returns>
        </member>
        <member name="T:NCDK.Silent.Strand">
            <summary>
            A Strand is an AtomContainer which stores additional strand specific
            informations for a group of Atoms.
            </summary>
        </member>
        <member name="P:NCDK.Silent.Strand.StrandName">
            <summary>
            The strand name.
            </summary>
        </member>
        <member name="P:NCDK.Silent.Strand.StrandType">
            <summary>
             The strand type.
            </summary>
        </member>
        <member name="M:NCDK.Silent.Strand.AddAtom(NCDK.IAtom)">
            <summary>
            Adds the atom oAtom without specifying a Monomer or a Strand. Therefore the
            atom gets added to a Monomer of type "Unknown" in a Strand of type  "Unknown".
            </summary>
            <param name="oAtom">The atom to add</param>
        </member>
        <member name="M:NCDK.Silent.Strand.AddAtom(NCDK.IAtom,NCDK.IMonomer)">
            <summary>
            Adds the atom oAtom to a specific Monomer.
            </summary>
            <param name="oAtom">The atom to add</param>
            <param name="oMonomer">The monomer the atom belongs to</param>
        </member>
        <member name="T:NCDK.Validate.AbstractValidator">
            <summary>
            Abstract validator that does nothing but provide all the methods that the ValidatorInterface requires.
            </summary>
        </member>
        <member name="T:NCDK.Validate.BasicValidator">
            <summary>
            Validator which tests a number of basic chemical semantics.
            </summary>
        </member>
        <member name="T:NCDK.Validate.CDKValidator">
            <summary>
            This Validator tests the internal data structures, and tries to detect inconsistencies in it.
            </summary>
        </member>
        <member name="T:NCDK.Validate.DictionaryValidator">
            <summary>
            Validates the existence of references to dictionaries.
            </summary>
        </member>
        <member name="T:NCDK.Validate.Geometry3DValidator">
            <summary>
            Validates the 3D geometry of the model.
            </summary>
        </member>
        <member name="T:NCDK.Validate.IValidator">
            <summary>
            Interface that Validators need to implement to be used in validation.
            </summary>
        </member>
        <member name="T:NCDK.Validate.ValidationReport">
            <summary>
            A report on validation of chemical semantics.
            </summary>
        </member>
        <member name="M:NCDK.Validate.ValidationReport.#ctor">
            <summary>
            Constructs a new empty <see cref="T:NCDK.Validate.ValidationReport"/>.
            </summary>
        </member>
        <member name="M:NCDK.Validate.ValidationReport.Add(NCDK.Validate.ValidationReport)">
            <summary>
            Merges the tests with the tests in this ValidationReport.
            </summary>
            <param name="report"></param>
        </member>
        <member name="P:NCDK.Validate.ValidationReport.Errors">
            <summary>
            Validation tests which gives serious errors.
            </summary>
        </member>
        <member name="P:NCDK.Validate.ValidationReport.Warnings">
            <summary>
            Validation tests which indicate a possible problem.
            </summary>
        </member>
        <member name="P:NCDK.Validate.ValidationReport.OKs">
            <summary>
            Validation tests which did not find a problem.
            </summary>
        </member>
        <member name="P:NCDK.Validate.ValidationReport.CDKErrors">
            <summary>
            CDK problems.
            </summary>
        </member>
        <member name="P:NCDK.Validate.ValidationReport.Count">
            <summary>
            The number of CDK errors.
            </summary>
        </member>
        <member name="T:NCDK.Validate.ValidationTest">
            <summary>
            Error found during sematical validation of a IChemObject.
            </summary>
            <seealso cref="T:NCDK.IChemObject"/>
        </member>
        <member name="P:NCDK.Validate.ValidationTest.Object">
            <summary>
            IChemObject which has the error.
            </summary>
        </member>
        <member name="P:NCDK.Validate.ValidationTest.Error">
            <summary>
            string representation of the found error.
            </summary>
        </member>
        <member name="P:NCDK.Validate.ValidationTest.Details">
            <summary>
            Multiline string with details on the error.
            </summary>
        </member>
        <member name="T:NCDK.Validate.ValidatorEngine">
            <summary>
            Engine that performs the validation by traversing the <see cref="T:NCDK.IChemObject"/> hierarchy. 
            </summary>
            <example>
            Basic use of the ValidatorEngine is:
            <code>
            ValidatorEngine engine = new ValidatorEngine();
            engine.Add(new BasicValidator());
            ValidationReport report = engine.ValidateMolecule(molecule);
            </code>
            </example>
        </member>
        <member name="T:NCDK.Validate.ProblemMarker">
            <summary>
            Tool to mark IChemObject's as having a problem. There are two levels:
            a problem, and a warning, to allow for different coloring by renderer's.
            </summary>
        </member>
        <member name="T:NCDK.Vibration">
            <summary>
            A molecular vibration composed of a set of atom vectors.
            The atom vectors represent forces acting on the atoms. 
            They are specified by <see cref="T:NCDK.Numerics.Vector3"/> containing the components of the vector.
            </summary>
        </member>
        <member name="P:NCDK.Vibration.Label">
            <summary>
            Label identifying this vibration. For example, the frequency in reciprocal centimetres could be used.
            </summary>
        </member>
        <member name="M:NCDK.Vibration.#ctor(System.String)">
            <summary>
            Create a vibration identified by the label.
            </summary>
            <param name="label">identification for this vibration</param>
        </member>
        <member name="T:NCDK.PhysicalConstants">
            <summary>
            An class providing predefined properties of physical constants.
            </summary>
        </member>
        <member name="F:NCDK.PhysicalConstants.MassProton">
            <summary>
            Mass of a proton.
            </summary>
        </member>
        <member name="F:NCDK.PhysicalConstants.MassElectron">
            <summary>
            Mass of an electron.
            </summary>
        </member>
        <member name="F:NCDK.PhysicalConstants.BohrToAngstrom">
            <summary>
            Factor for the conversion of Bohr's to √Öngstr√∂m's.
            </summary>
        </member>
        <member name="T:NCDK.SMSD.Algorithm">
            <summary>
            This class represents various algorithm type supported by SMSD.
            Presently SMSD supports 5 different kinds of algorithms:
            <ol>
            <item>0: default</item>
            <item>1: MCSPlus</item>
            <item>2: VFLibMCS</item>
            <item>3: CDKMCS</item>
            <item>4: SubStructure</item>
            <item>5: TurboSubStructure</item>
            </ol>
            </summary>
        </member>
        <member name="T:NCDK.SMSD.Algorithm.O">
            <summary>
            The <see cref="P:NCDK.SMSD.Algorithm.Ordinal"/> values of <see cref="T:NCDK.SMSD.Algorithm"/>.
            </summary>
            <seealso cref="T:NCDK.SMSD.Algorithm"/>
        </member>
        <member name="P:NCDK.SMSD.Algorithm.Ordinal">
            <summary>
            The ordinal of this enumeration constant. The list is in <see cref="T:NCDK.SMSD.Algorithm.O"/>.
            </summary>
            <seealso cref="T:NCDK.SMSD.Algorithm.O"/>
        </member>
        <member name="M:NCDK.SMSD.Algorithm.ToString">
            <inheritdoc/>
        </member>
        <member name="F:NCDK.SMSD.Algorithm.Default">
            <summary>
            Default SMSD algorithm.
            </summary>
        </member>
        <member name="F:NCDK.SMSD.Algorithm.MCSPlus">
            <summary>
            MCS Plus algorithm.
            </summary>
        </member>
        <member name="F:NCDK.SMSD.Algorithm.VFLibMCS">
            <summary>
            VF Lib based MCS algorithm.
            </summary>
        </member>
        <member name="F:NCDK.SMSD.Algorithm.CDKMCS">
            <summary>
            CDK UIT MCS.
            </summary>
        </member>
        <member name="F:NCDK.SMSD.Algorithm.SubStructure">
            <summary>
            Substructure search will return all maps.
            </summary>
        </member>
        <member name="F:NCDK.SMSD.Algorithm.TurboSubStructure">
            <summary>
            Substructure search will return first map.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithm.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.SMSD.Algorithm.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.SMSD.Algorithm.CompareTo(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.SMSD.Algorithm.CompareTo(NCDK.SMSD.Algorithm)">
            <inheritdoc/>
        </member>
        <member name="P:NCDK.SMSD.Algorithm.Type">
            <summary>
            type of algorithm.
            </summary>
        </member>
        <member name="P:NCDK.SMSD.Algorithm.Description">
            <summary>
            short description of the algorithm.
            </summary>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.Matchers.VFBondMatcher">
            <summary>
            Interface for the BondMatcher (bonds) in graph.
            </summary>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.Matchers.AtomMatcher">
            <summary>
            Interface for the AtomMatcher (atoms) in graph.
            </summary>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.Matchers.BondMatcher">
            <summary>
            Interface for the BondMatcher (bonds) in graph.
            </summary>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.Matchers.DefaultBondMatcher">
            <summary>
            Checks if a bond is matching between query and target molecules.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.Matchers.DefaultBondMatcher.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.Matchers.DefaultBondMatcher.#ctor(NCDK.IAtomContainer,NCDK.IBond,System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="queryMol">query Molecule</param>
            <param name="queryBond">query Molecule</param>
            <param name="shouldMatchBonds">bond match flag</param>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.Matchers.DefaultBondMatcher.#ctor(NCDK.Isomorphisms.Matchers.IQueryBond)">
            <summary>
            Constructor
            </summary>
            <param name="queryBond">query Molecule</param>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.Matchers.DefaultBondMatcher.Matches(NCDK.IAtomContainer,NCDK.IBond)">
            <inheritdoc/>
            <param name="targetContainer">target container</param>
            <param name="targetBond">target bond</param>
            <returns>true if bonds match</returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.Matchers.DefaultBondMatcher.IsBondTypeMatch(NCDK.IBond)">
            <summary>
            Return true if a bond is matched between query and target
            </summary>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.Matchers.DefaultMatcher">
            <summary>
            Checks if atom is matching between query and target molecules.
            </summary>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.Matchers.DefaultMCSPlusAtomMatcher">
            <summary>
            Checks if atom is matching between query and target molecules.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.Matchers.DefaultMCSPlusAtomMatcher.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.Matchers.DefaultMCSPlusAtomMatcher.#ctor(NCDK.IAtomContainer,NCDK.IAtom,System.Boolean)">
            <summary>
            Constructor
            <param name="queryContainer">query atom container</param>
            <param name="atom">query atom</param>
            <param name="shouldMatchBonds">bond matching flag</param>
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.Matchers.DefaultMCSPlusAtomMatcher.#ctor(NCDK.Isomorphisms.Matchers.IQueryAtom,NCDK.Isomorphisms.Matchers.IQueryAtomContainer)">
            <summary>
            Constructor
            </summary>
            <param name="smartQueryAtom">query atom</param>
            <param name="container"></param>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.Matchers.DefaultMCSPlusAtomMatcher.#ctor(NCDK.IAtomContainer,NCDK.IAtom,System.Int32,System.Boolean)">
            <summary>
            Constructor
            <param name="queryContainer">query atom container</param>
            <param name="template">query atom</param>
            <param name="blockedPositions">/// <param name="shouldMatchBonds">bond matching flag</param></param>
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.Matchers.DefaultMCSPlusAtomMatcher.SetMaximumNeighbors(System.Int32)">
             <summary>
            
             <param name="maximum">numbers of connected atoms allowed</param>
             </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.Matchers.DefaultMCSPlusAtomMatcher.Matches(NCDK.IAtomContainer,NCDK.IAtom)">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.Matchers.DefaultRGraphAtomMatcher">
            <summary>
            Checks if atom is matching between query and target molecules.
            </summary>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.Matchers.DefaultRGraphAtomMatcher.IsBondMatchFlag">
            <summary>
            <returns>the shouldMatchBonds</returns>
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.Matchers.DefaultRGraphAtomMatcher.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.Matchers.DefaultRGraphAtomMatcher.#ctor(NCDK.IAtomContainer,NCDK.IAtom,System.Boolean)">
            <summary>
            Constructor
            <param name="queryContainer">query atom container</param>
            <param name="atom">query atom</param>
            <param name="shouldMatchBonds">bond matching flag</param>
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.Matchers.DefaultRGraphAtomMatcher.#ctor(NCDK.IAtomContainer,NCDK.IAtom,System.Int32,System.Boolean)">
            <summary>
            Constructor
            <param name="queryContainer">query atom container</param>
            <param name="template">query atom</param>
            <param name="blockedPositions">/// <param name="shouldMatchBonds">bond matching flag</param></param>
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.Matchers.DefaultRGraphAtomMatcher.SetMaximumNeighbors(System.Int32)">
            <summary>
            
            </summary>
            <param name="maximum">numbers of connected atoms allowed</param>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.Matchers.DefaultVFAtomMatcher">
            <summary>
            Checks if atom is matching between query and target molecules.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.Matchers.DefaultVFAtomMatcher.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.Matchers.DefaultVFAtomMatcher.#ctor(NCDK.IAtomContainer,NCDK.IAtom,System.Boolean)">
            <summary>
            Constructor
            <param name="queryContainer">query atom container</param>
            <param name="atom">query atom</param>
            <param name="shouldMatchBonds">bond matching flag</param>
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.Matchers.DefaultVFAtomMatcher.#ctor(NCDK.Isomorphisms.Matchers.IQueryAtom,NCDK.Isomorphisms.Matchers.IQueryAtomContainer)">
            <summary>
            Constructor
            </summary>
            <param name="smartQueryAtom">query atom</param>
            <param name="container"></param>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.Matchers.DefaultVFAtomMatcher.#ctor(NCDK.IAtomContainer,NCDK.IAtom,System.Int32,System.Boolean)">
            <summary>
            Constructor
            <param name="queryContainer">query atom container</param>
            <param name="template">query atom</param>
            <param name="blockedPositions">/// <param name="shouldMatchBonds">bond matching flag</param></param>
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.Matchers.DefaultVFAtomMatcher.SetMaximumNeighbors(System.Int32)">
             <summary>
            
             <param name="maximum">numbers of connected atoms allowed</param>
             </summary>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.Matchers.DefaultVFBondMatcher">
            <summary>
            Checks if a bond is matching between query and target molecules.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.Matchers.DefaultVFBondMatcher.#ctor">
            <summary>
            Bond type flag
            Constructor
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.Matchers.DefaultVFBondMatcher.#ctor(NCDK.IAtomContainer,NCDK.IBond,System.Boolean)">
            <summary>
            Constructor
            <param name="queryMol">query Molecule</param>
            <param name="queryBond">query Molecule</param>
            <param name="shouldMatchBonds">bond match flag</param>
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.Matchers.DefaultVFBondMatcher.#ctor(NCDK.Isomorphisms.Matchers.IQueryBond)">
            <summary>
            Constructor
            <param name="queryBond">query Molecule</param>
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.Matchers.DefaultVFBondMatcher.Matches(NCDK.SMSD.Algorithms.VFLib.Builder.TargetProperties,NCDK.IBond)">
            <inheritdoc/>
            <param name="targetConatiner">target container</param>
            <param name="targetBond">target bond</param>
            <returns>true if bonds match</returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.Matchers.DefaultVFBondMatcher.IsBondTypeMatch(NCDK.IBond)">
            <summary>
            Return true if a bond is matched between query and target
            </summary>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.Matchers.VFAtomMatcher">
            <summary>
            Interface for the AtomMatcher (atoms) in graph.
            </summary>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.MCSPluses.BKKCKCF">
            <summary>
            This class implements Bron-Kerbosch clique detection algorithm as it is
            described in [F. Cazals, vertexOfCurrentClique. Karande: An Algorithm for reporting maximal c-cliques;
            processedVertex.Comp. Sc. (2005); vol 349; pp. 484-490]
            
            BronKerboschCazalsKarandeKochCliqueFinder.java
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.MCSPluses.BKKCKCF.#ctor(System.Collections.Generic.IList{System.Int32},System.Collections.Generic.IList{System.Int32},System.Collections.Generic.IList{System.Int32})">
            <summary>
            Creates index new instance of Bron Kerbosch Cazals Karande Koch Clique Finder
            This class implements Bron-Kerbosch clique detection algorithm as it is
            described in [F. Cazals, vertexOfCurrentClique. Karande: An Algorithm for reporting maximal c-cliques;
            processedVertex.Comp. Sc. (2005); vol 349; pp.
            484-490]
            </summary>
            <param name="compGraphNodesOrg"></param>
            <param name="cEdgesOrg">C-Edges set of allowed edges</param>
            <param name="dEdgesOrg">D-Edges set of prohibited edges</param>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.MCSPluses.BKKCKCF.Init">
            <summary>
            Call the wrapper for ENUMERATE_CLIQUES
            </summary>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.MCSPluses.ExactMapping">
            <summary>
            This class handles MCS between two identical molecules.
            Hence they generate am MCS where all atoms are mapped.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.MCSPluses.ExactMapping.ExtractCliqueMapping(System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Extract atom mapping from the cliques and stores it in an <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.MCSPluses.ExactMapping.ExtractMapping(System.Collections.Generic.IList{System.Collections.Generic.IList{System.Int32}},System.Collections.Generic.IList{System.Int32},System.Collections.Generic.IList{System.Int32})">
            <summary>
            extract atom mapping from the clique List and print it on the screen
            </summary>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.MCSPluses.GenerateCompatibilityGraph">
            <summary>
            This class generates compatibility graph between query and target molecule.
            It also markes edges in the compatibility graph as c-edges or d-edges.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.MCSPluses.GenerateCompatibilityGraph.#ctor">
            <summary>
            Default constructor added
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.MCSPluses.GenerateCompatibilityGraph.#ctor(NCDK.IAtomContainer,NCDK.IAtomContainer,System.Boolean)">
            <summary>
            Generates a compatibility graph between two molecules
            </summary>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.MCSPluses.GenerateCompatibilityGraph.CompatibilityGraphNodes">
            <summary>
            Generate Compatibility Graph Nodes
            </summary>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.MCSPluses.GenerateCompatibilityGraph.CompatibilityGraph">
            <summary>
            Generate Compatibility Graph Nodes Bond Insensitive
            </summary>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.MCSPluses.GenerateCompatibilityGraph.CompatibilityGraphNodesIfCEdgeIsZero">
            <summary>
            compGraphNodesCZero is used to build up of the edges of the compatibility graph
            </summary>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.MCSPluses.GenerateCompatibilityGraph.CompatibilityGraphCEdgeZero">
            <summary>
            compatibilityGraphCEdgeZero is used to
            build up of the edges of the
            compatibility graph BIS
            </summary>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.MCSPluses.GenerateCompatibilityGraph.IsMatchBond">
            <summary>
             the shouldMatchBonds
            </summary>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.MCSPluses.MCSPlus">
            <summary>
            This class handles MCS plus algorithm which is a combination of
            c-clique algorithm and McGregor algorithm.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.MCSPluses.MCSPlus.#ctor">
            <summary>
            Default constructor added
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.MCSPluses.MCSPlus.GetTimeOut">
            <summary>
            the timeout
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.MCSPluses.MCSPlus.GetTimeManager">
            <summary>
            the timeManager
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.MCSPluses.MCSPlus.SetTimeManager(NCDK.SMSD.Tools.TimeManager)">
            <summary>
            </summary>
            <param name="aTimeManager">the timeManager to set</param>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.MCSPluses.MCSPlusHandler">
            <summary>
            This class acts as a handler class for MCSPlus algorithm.
            </summary>
            <seealso cref="T:NCDK.SMSD.Algorithms.MCSPluses.MCSPlus"/>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.MCSPluses.MCSPlusHandler.#ctor">
            <summary>
            Constructor for the MCS Plus algorithm class
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.MCSPluses.MCSPlusHandler.SearchMCS(System.Boolean)">
            <summary>
            Function is called by the main program and serves as a starting point for the comparison procedure.
            </summary>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.VFLib.Builder.EdgeBuilder">
            <summary>
            Class for building/storing edges (bonds) in the graph with bond
            query capabilities.
            </summary>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.VFLib.Builder.NodeBuilder">
            <summary>
            Class for building/storing nodes (atoms) in the graph with atom
            query capabilities.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.Builder.NodeBuilder.#ctor(NCDK.SMSD.Algorithms.Matchers.VFAtomMatcher)">
            <summary>
            Construct a node for a query atom
            <param name="matcher"></param>
            </summary>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.VFLib.Builder.TargetProperties">
            <summary>
            Class for building/storing nodes (atoms) in the graph with atom
            query capabilities.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.Builder.TargetProperties.CountNeighbors(NCDK.IAtom)">
            <summary>
            </summary>
            <returns>the connectedTargetAtomCountMap</returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.Builder.TargetProperties.GetNeighbors(NCDK.IAtom)">
            <summary>
            </summary>
            <returns>the connected Target Atom List</returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.Builder.TargetProperties.GetBond(NCDK.IAtom,NCDK.IAtom)">
            <summary>
            </summary>
            <returns>the map</returns>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.VFLib.Builder.TargetProperties.AtomCount">
            <summary>
            atom count
            </summary>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.VFLib.Builder.VFQueryBuilder">
            <summary>
            Class for parsing and generating query graph.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.Builder.VFQueryBuilder.#ctor">
            <summary>
            Constructor for VF Query Builder
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.Builder.VFQueryBuilder.GetNode(NCDK.IAtom)">
            <summary>
            Return a node for a given atom else return null
            </summary>
            <param name="atom"></param>
            <returns>Node in the graph for a given atom</returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.Builder.VFQueryBuilder.AddNode(NCDK.SMSD.Algorithms.Matchers.VFAtomMatcher,NCDK.IAtom)">
            <summary>
            Add and return a node for a query atom
            </summary>
            <returns>added Node</returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.Builder.VFQueryBuilder.Connect(NCDK.SMSD.Algorithms.VFLib.INode,NCDK.SMSD.Algorithms.VFLib.INode,NCDK.SMSD.Algorithms.Matchers.VFBondMatcher)">
            <summary>
            Construct and return an edge for a given query and target node
            </summary>
            <returns>connected edges</returns>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.VFLib.INode">
            <summary>
            Interface for the Node (atomss) in graph.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.INode.CountNeighbors">
            <summary>
            Returns Neighbors count.
            <returns>Neighbors count.</returns>
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.INode.Neighbors">
            <summary>
            Returns neighbors.
            <returns>Iterable INode.</returns>
            </summary>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.VFLib.INode.AtomMatcher">
            <summary>
            Returns Query Atom.
            <returns>Query Atom.</returns>
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.INode.GetEdges">
            <summary>
            Returns List of Edges.
            <returns>edges.</returns>
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.INode.AddEdge(NCDK.SMSD.Algorithms.VFLib.Builder.EdgeBuilder)">
            <summary>
            Adds edge to the edge list.
            <param name="edge">add an edge.</param>
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.INode.AddNeighbor(NCDK.SMSD.Algorithms.VFLib.Builder.NodeBuilder)">
            <summary>
            Adds neighbor to the Neighbors List.
            <param name="node">add a node.</param>
            </summary>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.VFLib.VFlibMCSHandler">
             <summary>
             This class should be used to find MCS between query
             graph and target graph.
            
             First the algorithm runs VF lib <see cref="T:NCDK.SMSD.Algorithms.VFLib.Map.VFMCSMapper"/>
             and reports MCS between
             run query and target graphs. Then these solutions are extended
             using McGregor <see cref="T:NCDK.SMSD.Algorithms.McGregors.McGregor"/>
             algorithm where ever required.
             </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.VFlibMCSHandler.#ctor">
            <summary>
            Constructor for an extended VF Algorithm for the MCS search
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.VFlibMCSHandler.Set(NCDK.SMSD.Tools.MolHandler,NCDK.SMSD.Tools.MolHandler)">
            <summary>
            Set the VFLib MCS software
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.VFlibMCSHandler.Set(NCDK.Isomorphisms.Matchers.IQueryAtomContainer,NCDK.IAtomContainer)">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.VFLib.IEdge">
            <summary>
            Interface for the Edges (bonds) in graph.
            </summary>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.VFLib.IEdge.Source">
            <summary>
            Returns source Node.
            </summary>
            <returns>source node.</returns>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.VFLib.IEdge.Target">
            <summary>
            Returns target Node.
            </summary>
            <returns>target Node.</returns>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.VFLib.IEdge.BondMatcher">
            <summary>
            Returns bond matcher.
            </summary>
            <returns>Query Bond.</returns>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.VFLib.IMapper">
            <summary>
            Interface for the mappings (mapped objects).
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.IMapper.HasMap(NCDK.IAtomContainer)">
            <summary>
            checks if a map exits for a molecule.
            </summary>
            <param name="molecule">molecule</param>
            <returns>true/false.</returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.IMapper.CountMaps(NCDK.IAtomContainer)">
            <summary>
            Returns solution map count.
            </summary>
            <param name="target">target molecule.</param>
            <returns>map count.</returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.IMapper.GetMaps(NCDK.IAtomContainer)">
            <summary>
            Returns all solution map.
            </summary>
            <param name="target">molecule.</param>
            <returns>get maps.</returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.IMapper.GetFirstMap(NCDK.IAtomContainer)">
            <summary>
            Returns first solution map.
            </summary>
            <param name="target">molecule.</param>
            <returns>get first map.</returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.IMapper.HasMap(NCDK.SMSD.Algorithms.VFLib.Builder.TargetProperties)">
            <summary>
            checks if a map exits for a molecule.
            </summary>
            <param name="molecule">molecule</param>
            <returns>true/false.</returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.IMapper.CountMaps(NCDK.SMSD.Algorithms.VFLib.Builder.TargetProperties)">
            <summary>
            Returns solution map count.
            </summary>
            <param name="target">target molecule.</param>
            <returns>map count.</returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.IMapper.GetMaps(NCDK.SMSD.Algorithms.VFLib.Builder.TargetProperties)">
            <summary>
            Returns all solution map.
            </summary>
            <param name="target">molecule.</param>
            <returns>get maps.</returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.IMapper.GetFirstMap(NCDK.SMSD.Algorithms.VFLib.Builder.TargetProperties)">
            <summary>
            Returns first solution map.
            </summary>
            <param name="target">molecule.</param>
            <returns>get first map.</returns>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.VFLib.IQuery">
            <summary>
            Interface for the query molecule/graph.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.IQuery.Nodes">
            <summary>
            Returns nodes of the query.
            </summary>
            <returns>node Iterable.</returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.IQuery.GetNode(System.Int32)">
            <summary>
            Returns a node of the query mol at a given position.
            </summary>
            <param name="index">at position.</param>
            <returns>node.</returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.IQuery.Edges">
            <summary>
            Returns edges of the query.
            </summary>
            <returns>edge Iterable.</returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.IQuery.GetEdge(System.Int32)">
            <summary>
            Returns an edge of the query mol at a given position.
            </summary>
            <param name="index">at position.</param>
            <returns>edge</returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.IQuery.GetAtom(NCDK.SMSD.Algorithms.VFLib.INode)">
            <summary>
            Returns an atom associated with this node.
            </summary>
            <param name="node">get Atom of this node.</param>
            <returns>atom of this node</returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.IQuery.GetEdge(NCDK.SMSD.Algorithms.VFLib.INode,NCDK.SMSD.Algorithms.VFLib.INode)">
            <summary>
            Returns an edge associated between two nodes.
            </summary>
            <param name="source">get an between source.</param>
            <param name="target">and target.</param>
            <returns>IEdge egde between source and target.</returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.IQuery.CountEdges">
            <summary>
            Returns edge count.
            </summary>
            <returns>edge count.</returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.IQuery.CountNodes">
            <summary>
            Returns node count.
            </summary>
            <returns>node count.</returns>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.VFLib.IQueryCompiler">
            <summary>
            Interface for the query graph generator.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.IQueryCompiler.Compile">
            <summary>
            Parse and build a query graph from the query moleucle.
            </summary>
            <returns>compile the query molecule and build the graph.</returns>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.VFLib.IState">
            <summary>
            Interface for the storing the states of the mapping in the VF algorithm.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.IState.GetMap">
            <summary>
            Returns the current mapping of query atoms onto target atoms.
            This map is shared among all states obtained through nextState.
            </summary>
            <returns>the current mapping of query atoms onto target atoms</returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.IState.HasNextCandidate">
            <summary>
            Returns true if another candidate match can be found or
            false otherwise.
            </summary>
            <returns>true if another candidate mapping can be found or
            false otherwise.</returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.IState.NextCandidate">
            <summary>
            Returns the next candidate match.
            </summary>
            <returns>the next candidate match.</returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.IState.IsMatchFeasible(NCDK.SMSD.Algorithms.VFLib.Map.Match)">
            <summary>
            Returns true if the given match will work with the current
            map, or false otherwise.
            </summary>
            <param name="match">the match to consider</param>
            <returns>true if the given match will work with the current
            map, or false otherwise.</returns>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.VFLib.IState.IsGoal">
            <summary>
            Returns true if all atoms in the query molecule have been
            mapped.
            </summary>
            <returns>true if all atoms in the query molecule have been
            mapped.</returns>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.VFLib.IState.IsDead">
            <summary>
            Returns true if no match will come from this IState.
            </summary>
            <returns>true if no match will come from this IState</returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.IState.NextState(NCDK.SMSD.Algorithms.VFLib.Map.Match)">
            <summary>
            Returns a state in which the atoms in match have been
            added to the current mapping.
            </summary>
            <param name="match">the match to consider.</param>
            <returns>a state in which the atoms in match have been
            added to the current mapping.</returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.IState.BackTrack">
            <summary>
            Returns this IState's atom map to its original condition.
            </summary>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.VFLib.Map.Match">
            <summary>
            Holds matching query and target nodes.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.Map.Match.#ctor(NCDK.SMSD.Algorithms.VFLib.INode,NCDK.IAtom)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.VFLib.Map.Match.QueryNode">
            <summary>
            query node
            </summary>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.VFLib.Map.Match.TargetAtom">
            <summary>
            Target Atom
            </summary>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.VFLib.Map.VFMapper">
            <summary>
            This class finds MCS between query and target molecules
            using VF2 algorithm.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.Map.VFMapper.GetTimeOut">
            <summary>
            <returns>the timeout</returns>
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.Map.VFMapper.GetTimeManager">
            <summary>
            <returns>the timeManager</returns>
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.Map.VFMapper.SetTimeManager(NCDK.SMSD.Tools.TimeManager)">
            <summary>
            </summary>
            <param name="aTimeManager">the timeManager to set</param>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.Map.VFMapper.HasMap(NCDK.IAtomContainer)">
            <inheritdoc/>
            <param name="targetMolecule">targetMolecule graph</param>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.Map.VFMapper.HasMap(NCDK.SMSD.Algorithms.VFLib.Builder.TargetProperties)">
            <inheritdoc/>
            <param name="targetMolecule">targetMolecule graph</param>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.VFLib.Map.VFMCSMapper">
            <summary>
            This class finds MCS between query and target molecules
            using VF2 algorithm.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.Map.VFMCSMapper.GetTimeOut">
            <summary>
            <returns>the timeout</returns>
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.Map.VFMCSMapper.HasMap(NCDK.IAtomContainer)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.Map.VFMCSMapper.HasMap(NCDK.SMSD.Algorithms.VFLib.Builder.TargetProperties)">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.VFLib.Map.VFState">
            <summary>
            This class finds mapping states between query and target
            molecules.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.Map.VFState.#ctor(NCDK.SMSD.Algorithms.VFLib.IQuery,NCDK.SMSD.Algorithms.VFLib.Builder.TargetProperties)">
            <summary>
            Initialise the VFState with query and target
            </summary>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.VFLib.Query.QueryCompiler">
            <summary>
            This class creates an template for MCS/substructure query.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.Query.QueryCompiler.#ctor(NCDK.IAtomContainer,System.Boolean)">
            <summary>
            Construct query object from the molecule
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.Query.QueryCompiler.#ctor(NCDK.Isomorphisms.Matchers.IQueryAtomContainer)">
            <summary>
            Construct query object from the molecule
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.Query.QueryCompiler.SetMolecule(NCDK.IAtomContainer)">
            <summary>
            Set Molecule
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.Query.QueryCompiler.SetQueryMolecule(NCDK.Isomorphisms.Matchers.IQueryAtomContainer)">
            <summary>
            Set Molecule
            </summary>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.VFLib.Query.QueryCompiler.Molecule">
            <summary>
            Return molecule
            <returns>Atom Container</returns>
            </summary>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.VFLib.Query.QueryCompiler.IsBondMatchFlag">
            <summary>
            <returns>the shouldMatchBonds</returns>
            </summary>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.VFLib.VFlibSubStructureHandler">
            <summary>
            This is an ultra fast method to report if query
            is a substructure for target molecule. If this case is true
            then it returns only all mapping.
            </summary>
            <remarks>
            <para>
            This is much faster than <see cref="T:NCDK.SMSD.Algorithms.VFLib.VFlibMCSHandler"/> class
            as it only reports first match and backtracks.
            </para>
            <para>
            This class should only be used to report if a query
            graph is a substructure of the target graph.
            </para>
            </remarks>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.VFlibSubStructureHandler.#ctor">
            <summary>
            Constructor for an extended VF Algorithm for the MCS search
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.VFlibSubStructureHandler.Set(NCDK.SMSD.Tools.MolHandler,NCDK.SMSD.Tools.MolHandler)">
            <summary>
            Set the VFLib MCS software
            </summary>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.VFLib.VFlibTurboHandler">
            <summary>
            This is an ultra fast method to report if query
            is a substructure for target molecule. If this case is true
            then it returns only one mapping.
            </summary>
            <remarks>
            <para>
            This is much faster than <see cref="T:NCDK.SMSD.Algorithms.VFLib.VFlibMCSHandler"/> class
            as it only reports first match and backtracks.
            </para>
            <para>
            This class should only be used to report if a query
            graph is a substructure of the target graph.
            </para>
            </remarks>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.VFlibTurboHandler.#ctor">
            <summary>
            Constructor for an extended VF Algorithm for the MCS search
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.VFlibTurboHandler.Set(NCDK.SMSD.Tools.MolHandler,NCDK.SMSD.Tools.MolHandler)">
            <summary> 
            Set the VFLib MCS software
            </summary>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.McGregors.McGregor">
            <summary>
            Class which reports MCS solutions based on the McGregor algorithm
            published in 1982.
            </summary>
            <remarks>
             <para>The SMSD algorithm is described in this paper.
            please refer Rahman <i>et.al. 2009</i>
             <token>cdk-cite-SMSD2009</token>.
             </para></remarks>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.McGregors.McGregor.#ctor(NCDK.IAtomContainer,NCDK.IAtomContainer,System.Collections.Generic.IList{System.Collections.Generic.IList{System.Int32}},System.Boolean)">
            <summary>
            Constructor for the McGregor algorithm.
            </summary>
            <param name="source"></param>
            <param name="target"></param>
            <param name="mappings"></param>
            <param name="shouldMatchBonds"></param>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.McGregors.McGregor.#ctor(NCDK.Isomorphisms.Matchers.IQueryAtomContainer,NCDK.IAtomContainer,System.Collections.Generic.IList{System.Collections.Generic.IList{System.Int32}})">
            <summary>
            Constructor for the McGregor algorithm.
            <param name="source"></param>
            <param name="target"></param>
            <param name="mappings"></param>
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.McGregors.McGregor.StartMcGregorIteration(System.Int32,System.Collections.Generic.IDictionary{System.Int32,System.Int32})">
            <summary>
            Start McGregor search and extend the mappings if possible.
            </summary>
            <param name="largestMappingSize"></param>
            <param name="presentMapping"></param>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.McGregors.McGregor.StartMcGregorIteration(System.Int32,System.Collections.Generic.IList{System.Int32},System.Collections.Generic.IList{System.Int32})">
            <summary>
            Start McGregor search and extend the mappings if possible.
            </summary>
            <param name="largestMappingSize"></param>
            <param name="cliqueVector"></param>
            <param name="compGraphNodes"></param>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.McGregors.McGregor.Mappings">
            <summary>
            Returns computed mappings.
            <returns>mappings</returns>
            </summary>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.McGregors.McGregor.MCSSize">
            <summary>
            Returns MCS size.
            <returns>MCS size</returns>
            </summary>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.McGregors.McGregor.IsNewMatrix">
            <summary>
            Checks if its a new Matrix.
            </summary>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.McGregors.McGregor.IsBondMatch">
            <summary>
            Should bonds match
            </summary>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.McGregors.McGregorChecks">
            <summary>
            Class to perform check/methods for McGregor class.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.McGregors.McGregorChecks.RemoveRedundantArcs(System.Int32,System.Int32,System.Collections.Generic.IList{System.Int32},NCDK.SMSD.Algorithms.McGregors.McgregorHelper)">
            <summary>
            The function is called in function partsearch. The function is given a temporary matrix and a position (row/column)
            within this matrix. First the function sets all entries to zero, which can be exlcuded in respect to the current
            atom by atom matching. After this the function replaces all entries in the same row and column of the current
            position by zeros. Only the entry of the current position is set to one.
            Return value "count_arcsleft" counts the number of arcs, which are still in the matrix.
            </summary>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.McGregors.McgregorHelper">
            <summary>
            Helper Class for McGregor algorithm.
            </summary>
            <remarks>
            The second part of the program extents the mapping by the McGregor algorithm in case,
            that not all atoms of molecule A and molecule B are mapped by the clique approach.
            </remarks>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.McGregors.McgregorHelper.#ctor(System.Boolean,System.Int32,System.Collections.Generic.IList{System.Int32},System.Int32,System.Int32,System.Collections.Generic.IList{System.Int32},System.Collections.Generic.IList{System.Int32},System.Collections.Generic.IList{System.String},System.Collections.Generic.IList{System.String},System.Int32,System.Int32,System.Collections.Generic.List{System.Int32},System.Collections.Generic.IList{System.Int32},System.Collections.Generic.IList{System.String},System.Collections.Generic.IList{System.String})">
            <summary>
            Stores the variables
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.McGregors.McgregorHelper.GetCBondSetA">
            <summary>
            <returns>the cBondSetA</returns>
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.McGregors.McgregorHelper.GetCBondSetB">
            <summary>
            <returns>the cBondSetB</returns>
            </summary>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.McGregors.McgregorHelper.IsMappingCheckFlag">
            <summary>
            <returns>the mappingCheckFlag</returns>
            </summary>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.McGregors.McgregorHelper.MappedAtomCount">
            <summary>
            <returns>the mappedAtomCount</returns>
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.McGregors.McgregorHelper.GetMappedAtomsOrg">
            <summary>
            <returns>the mappedAtomsOrg</returns>
            </summary>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.McGregors.McgregorHelper.NeighborBondNumA">
            <summary>
            <returns>the neighborBondNumA</returns>
            </summary>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.McGregors.McgregorHelper.NeighborBondNumB">
            <summary>
            <returns>the neighborBondNumB</returns>
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.McGregors.McgregorHelper.GetIBondNeighborAtomsA">
            <summary>
            <returns>the iBondNeighborAtomsA</returns>
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.McGregors.McgregorHelper.GetIBondNeighborAtomsB">
            <summary>
            <returns>the iBondNeighborAtomsB</returns>
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.McGregors.McgregorHelper.GetCBondNeighborsA">
            <summary>
            <returns>the cBondNeighborsA</returns>
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.McGregors.McgregorHelper.GetCBondNeighborsB">
            <summary>
            <returns>the cBondNeighborsB</returns>
            </summary>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.McGregors.McgregorHelper.SetNumA">
            <summary>
            <returns>the setNumA</returns>
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.McGregors.McgregorHelper.GetIBondSetA">
            <summary>
            <returns>the iBondSetA</returns>
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.McGregors.McgregorHelper.GetIBondSetB">
            <summary>
            <returns>the iBondSetB</returns>
            </summary>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.McGregors.QueryProcessor">
            <summary>
            Class to handle mappings of query molecule.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.McGregors.QueryProcessor.#ctor(System.Collections.Generic.List{System.String},System.Collections.Generic.List{System.String},System.String[],System.Int32,System.Int32,System.Collections.Generic.List{System.Int32},System.Collections.Generic.List{System.String},System.Int32,System.Collections.Generic.List{System.Int32},System.Collections.Generic.List{System.String})">
            <summary>
            Query molecule
            </summary>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.McGregors.QueryProcessor.CTab1">
             <summary>
            
             <returns>cTabQuery copy</returns>
             </summary>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.McGregors.QueryProcessor.CTab2">
             <summary>
            
             <returns>cTabTarget Copy</returns>
             </summary>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.McGregors.QueryProcessor.NeighborBondNumA">
            <summary>
            number of remaining molecule A bonds after the clique search,
            which are neighbors of the MCS
            </summary>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.McGregors.QueryProcessor.BondNumA">
            <summary>
            number of remaining molecule A bonds after the clique search, 
            which aren't neighbors
            </summary>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.McGregors.TargetProcessor">
            <summary>
            Class to handle mappings of target molecule based on the query.
            </summary>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.McGregors.TargetProcessor.NeighborBondNumB">
            <summary>
            number of remaining molecule A bonds after the clique search,
            which are neighbors of the MCS
            </summary>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.McGregors.TargetProcessor.BondNumB">
            <summary>
            number of remaining molecule A bonds after the clique search,
            which aren't neighbors
            </summary>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.RGraph.CDKMCS">
             <summary>
              This class implements atom multipurpose structure comparison tool.
              It allows to find maximal common substructure, find the
              mapping of atom substructure in another structure, and the mapping of
              two isomorphic structures.
             </summary>
             <remarks>
              <para>Structure comparison may be associated to bondA1 constraints
              (mandatory bonds, e.graphContainer. scaffolds, reaction cores,...) on each source graph.
              The constraint flexibility allows atom number of interesting queries.
              The substructure analysis relies on the CDKRGraph generic class (see: CDKRGraph)
              This class implements the link between the CDKRGraph model and the
              the CDK model in this way the CDKRGraph remains independant and may be used
              in other contexts.</para>
            
              <para>This algorithm derives from the algorithm described in
              <token>cdk-cite-HAN90</token> and modified in the thesis of T. Hanser <token>cdk-cite-HAN93</token>.</para>
            
              <para>With the <see cref="M:NCDK.SMSD.Algorithms.RGraph.CDKMCS.IsSubgraph(NCDK.IAtomContainer,NCDK.IAtomContainer,System.Boolean)" /> method, the second, and only the second
              argument <b>may</b> be atom <see cref="T:NCDK.Isomorphisms.Matchers.IQueryAtomContainer" />, which allows one to do MQL like queries.
              The first IAtomContainer must never be an <see cref="T:NCDK.Isomorphisms.Matchers.IQueryAtomContainer" />.
             <code>            SmilesParser sp = new SmilesParser(Default.ChemObjectBuilder.Instance);
            IAtomContainer atomContainer = sp.ParseSmiles("CC(=O)OC(=O)C"); // acetic acid anhydride
            IAtomContainer SMILESquery = sp.ParseSmiles("CC"); // acetic acid anhydride
            IQueryAtomContainer query = QueryAtomContainerCreator.CreateBasicQueryContainer(SMILESquery);
            bool isSubstructure = CDKMCS.IsSubgraph(atomContainer, query, true);
</code>
             </para>
             <note type="warning">
                As atom result of the adjacency perception used in this algorithm
                there is atom single limitation : cyclopropane and isobutane are seen as isomorph
                This is due to the fact that these two compounds are the only ones where
                each bondA1 is connected two each other bondA1 (bonds are fully conected)
                with the same number of bonds and still they have different structures
                The algotihm could be easily enhanced with atom simple atom mapping manager
                to provide an atom level overlap definition that would reveal this case.
                We decided not to penalize the whole procedure because of one single
                exception query. Furthermore isomorphism may be discarded since  the number of atoms are
                not the same (3 != 4) and in most case this will be already
                screened out by atom fingerprint based filtering.
                It is possible to add atom special treatment for this special query.
                Be reminded that this algorithm matches bonds only.
             </note>
             </remarks>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraph.CDKMCS.IsIsomorph(NCDK.IAtomContainer,NCDK.IAtomContainer,System.Boolean)">
            <summary>
            Tests if sourceGraph and targetGraph are isomorph.
            </summary>
            <param name="sourceGraph">first molecule. Must not be an IQueryAtomContainer.</param>
            <param name="targetGraph">second molecule. May be an IQueryAtomContainer.</param>
            <param name="shouldMatchBonds"></param>
            <returns>true if the 2 molecule are isomorph</returns>
            <exception cref="T:NCDK.CDKException">if the first molecule is an instance of IQueryAtomContainer</exception>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraph.CDKMCS.GetIsomorphMap(NCDK.IAtomContainer,NCDK.IAtomContainer,System.Boolean)">
            <summary>
            Returns the first isomorph mapping found or null.
            </summary>
            <param name="sourceGraph">first molecule. Must not be an IQueryAtomContainer.</param>
            <param name="targetGraph">second molecule. May be an IQueryAtomContainer.</param>
            <param name="shouldMatchBonds"></param>
            <returns>the first isomorph mapping found projected of sourceGraph. This is atom List of CDKRMap objects containing Ids of matching bonds.</returns>
            <exception cref="T:NCDK.CDKException"></exception>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraph.CDKMCS.GetIsomorphAtomsMap(NCDK.IAtomContainer,NCDK.IAtomContainer,System.Boolean)">
            <summary>
            Returns the first isomorph 'atom mapping' found for targetGraph in sourceGraph.
            </summary>
            <param name="sourceGraph">first molecule. Must not be an IQueryAtomContainer.</param>
            <param name="targetGraph">second molecule. May be an IQueryAtomContainer.</param>
            <param name="shouldMatchBonds"></param>
            <returns>the first isomorph atom mapping found projected on sourceGraph.</returns>
            This is atom List of CDKRMap objects containing Ids of matching atoms.
            <exception cref="T:NCDK.CDKException">if the first molecules is not an instance of <see cref="T:NCDK.Isomorphisms.Matchers.IQueryAtomContainer"/></exception>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraph.CDKMCS.GetIsomorphMaps(NCDK.IAtomContainer,NCDK.IAtomContainer,System.Boolean)">
            <summary>
            Returns all the isomorph 'mappings' found between two
            atom containers.
            </summary>
            <param name="sourceGraph">first molecule. Must not be an IQueryAtomContainer.</param>
            <param name="targetGraph">second molecule. May be an IQueryAtomContainer.</param>
            <param name="shouldMatchBonds"></param>
            <returns>the list of all the 'mappings'</returns>
            <exception cref="T:NCDK.CDKException"></exception>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraph.CDKMCS.GetSubgraphMaps(NCDK.IAtomContainer,NCDK.IAtomContainer,System.Boolean)">
            <summary>
            Returns all the subgraph 'bondA1 mappings' found for targetGraph in sourceGraph.
            This is an ArrayList of ArrayLists of CDKRMap objects.
            </summary>
            <param name="sourceGraph">first molecule. Must not be an IQueryAtomContainer.</param>
            <param name="targetGraph">second molecule. May be an IQueryAtomContainer.</param>
            <param name="shouldMatchBonds"></param>
            <returns>the list of all the 'mappings' found projected of sourceGraph</returns>
            <exception cref="T:NCDK.CDKException"></exception>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraph.CDKMCS.GetSubgraphMap(NCDK.IAtomContainer,NCDK.IAtomContainer,System.Boolean)">
            <summary>
            Returns the first subgraph 'bondA1 mapping' found for targetGraph in sourceGraph.
            </summary>
            <param name="sourceGraph">first molecule. Must not be an IQueryAtomContainer.</param>
            <param name="targetGraph">second molecule. May be an IQueryAtomContainer.</param>
            <param name="shouldMatchBonds"></param>
            <returns>the first subgraph bondA1 mapping found projected on sourceGraph. This is atom List of CDKRMap objects containing Ids of matching bonds.</returns>
            <exception cref="T:NCDK.CDKException"></exception>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraph.CDKMCS.GetSubgraphAtomsMaps(NCDK.IAtomContainer,NCDK.IAtomContainer,System.Boolean)">
            <summary>
            Returns all subgraph 'atom mappings' found for targetGraph in sourceGraph.
            This is an ArrayList of ArrayLists of CDKRMap objects.
            </summary>
            <param name="sourceGraph">first molecule. Must not be an IQueryAtomContainer.</param>
            <param name="targetGraph">second molecule. May be an IQueryAtomContainer.</param>
            <param name="shouldMatchBonds"></param>
            <returns>all subgraph atom mappings found projected on sourceGraph. This is atom
                        List of CDKRMap objects containing Ids of matching atoms.</returns>
            <exception cref="T:NCDK.CDKException"></exception>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraph.CDKMCS.GetSubgraphAtomsMap(NCDK.IAtomContainer,NCDK.IAtomContainer,System.Boolean)">
            <summary>
            Returns the first subgraph 'atom mapping' found for targetGraph in sourceGraph.
            </summary>
            <param name="sourceGraph">first molecule. Must not be an IQueryAtomContainer.</param>
            <param name="targetGraph">second molecule. May be an IQueryAtomContainer.</param>
            <param name="shouldMatchBonds"></param>
            <returns>the first subgraph atom mapping found projected on sourceGraph.
                       This is atom List of CDKRMap objects containing Ids of matching atoms.</returns>
            <exception cref="T:NCDK.CDKException"></exception>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraph.CDKMCS.IsSubgraph(NCDK.IAtomContainer,NCDK.IAtomContainer,System.Boolean)">
            <summary>
            Tests if targetGraph atom subgraph of sourceGraph.
            </summary>
            <param name="sourceGraph">first molecule. Must not be an IQueryAtomContainer.</param>
            <param name="targetGraph">second molecule. May be an IQueryAtomContainer.</param>
            <param name="shouldMatchBonds"></param>
            <returns>true if targetGraph atom subgraph on sourceGraph</returns>
            <exception cref="T:NCDK.CDKException"></exception>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraph.CDKMCS.GetOverlaps(NCDK.IAtomContainer,NCDK.IAtomContainer,System.Boolean)">
            <summary>
            Returns all the maximal common substructure between 2 atom containers.
            </summary>
            <param name="sourceGraph">first molecule. Must not be an IQueryAtomContainer.</param>
            <param name="targetGraph">second molecule. May be an IQueryAtomContainer.</param>
            <param name="shouldMatchBonds"></param>
            <returns>the list of all the maximal common substructure
                        found projected of sourceGraph (list of <see cref="T:NCDK.IAtomContainer"/>)</returns>
            <exception cref="T:NCDK.CDKException"></exception>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraph.CDKMCS.GetBitSet(NCDK.IAtomContainer)">
             <summary>
             Transforms an AtomContainer into atom BitArray (which's size = number of bondA1
             in the atomContainer, all the bit are set to true).
            
             <param name="atomContainer">AtomContainer to transform</param>
             <returns>The bitSet</returns>
             </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraph.CDKMCS.BuildRGraph(NCDK.IAtomContainer,NCDK.IAtomContainer,System.Boolean)">
            <summary>
            Builds the CDKRGraph ( resolution graph ), from two atomContainer
            (description of the two molecules to compare)
            This is the interface point between the CDK model and
            the generic MCSS algorithm based on the RGRaph.
            </summary>
            <param name="sourceGraph">Description of the first molecule</param>
            <param name="targetGraph">Description of the second molecule</param>
            <param name="shouldMatchBonds"></param>
            <returns>the rGraph</returns>
            <exception cref="T:NCDK.CDKException"></exception>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraph.CDKMCS.Search(NCDK.IAtomContainer,NCDK.IAtomContainer,System.Collections.BitArray,System.Collections.BitArray,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            General Rgraph parsing method (usually not used directly)
            This method is the entry point for the recursive search
            adapted to the atom container input.
            </summary>
            <param name="sourceGraph">first molecule. Must not be an IQueryAtomContainer.</param>
            <param name="targetGraph">second molecule. May be an IQueryAtomContainer.</param>
            <param name="sourceBitSet">initial condition ( bonds from sourceGraph that must be contains in the solution )</param>
            <param name="targetBitSet">initial condition ( bonds from targetGraph that must be contains in the solution )</param>
            <param name="findAllStructure">if false stop at the first structure found</param>
            <param name="findAllMap">if true search all the 'mappings' for one same structure</param>
            <param name="shouldMatchBonds"></param>
            <returns>atom List of Lists of CDKRMap objects that represent the search solutions</returns>
            <exception cref="T:NCDK.CDKException"></exception>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraph.CDKMCS.Project(System.Collections.Generic.IList{NCDK.SMSD.Algorithms.RGraph.CDKRMap},NCDK.IAtomContainer,System.Int32)">
            <summary>
            Projects atom list of CDKRMap on atom molecule.
            </summary>
            <param name="rMapList">the list to project</param>
            <param name="graph">the molecule on which project</param>
            <param name="key">the key in the CDKRMap of the molecule graph</param>
            <returns>an AtomContainer</returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraph.CDKMCS.ProjectList(System.Collections.Generic.IList{System.Collections.Generic.IList{NCDK.SMSD.Algorithms.RGraph.CDKRMap}},NCDK.IAtomContainer,System.Int32)">
            <summary>
            Projects atom list of RMapsList on atom molecule.
            </summary>
            <param name="rMapsList">list of RMapsList to project</param>
            <param name="graph">the molecule on which project</param>
            <param name="key">the key in the CDKRMap of the molecule graph</param>
            <returns>atom list of AtomContainer</returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraph.CDKMCS.GetMaximum(System.Collections.Generic.IList{NCDK.IAtomContainer},System.Boolean)">
            <summary>
            Removes all redundant solution.
            </summary>
            <param name="graphList">the list of structure to clean</param>
            <returns>the list cleaned</returns>
            <exception cref="T:NCDK.CDKException">if there is atom problem in obtaining subgraphs</exception>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraph.CDKMCS.CheckSingleAtomCases(NCDK.IAtomContainer,NCDK.IAtomContainer)">
            <summary>
             Checks for single atom cases before doing subgraph/isomorphism search
            </summary>
            <param name="sourceGraph">AtomContainer to match on. Must not be an IQueryAtomContainer.</param>
            <param name="targetGraph">AtomContainer as query. May be an IQueryAtomContainer.</param>
            <returns>List of List of CDKRMap objects for the Atoms (not Bonds!), null if no single atom case</returns>
            <exception cref="T:NCDK.CDKException">if the first molecule is an instance of IQueryAtomContainer</exception>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraph.CDKMCS.MakeAtomsMapsOfBondsMaps(System.Collections.Generic.IList{System.Collections.Generic.IList{NCDK.SMSD.Algorithms.RGraph.CDKRMap}},NCDK.IAtomContainer,NCDK.IAtomContainer)">
            <summary>
             This makes maps of matching atoms out of atom maps of matching bonds as produced by the Get(Subgraph|Ismorphism)Maps methods.
            </summary>
            <param name="list">The list produced by the getMap method.</param>
            <param name="sourceGraph">The first atom container. Must not be atom IQueryAtomContainer.</param>
            <param name="targetGraph">The second one (first and second as in getMap). May be an QueryAtomContaienr.</param>
            <returns>A Vector of Vectors of CDKRMap objects of matching Atoms.</returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraph.CDKMCS.MakeAtomsMapOfBondsMap(System.Collections.Generic.IList{NCDK.SMSD.Algorithms.RGraph.CDKRMap},NCDK.IAtomContainer,NCDK.IAtomContainer)">
            <summary>
             This makes atom map of matching atoms out of atom map of matching bonds as produced by the Get(Subgraph|Ismorphism)Map methods.
            </summary>
            <param name="list">The list produced by the getMap method.</param>
            <param name="sourceGraph">first molecule. Must not be an IQueryAtomContainer.</param>
            <param name="targetGraph">second molecule. May be an IQueryAtomContainer.</param>
            <returns>The mapping found projected on sourceGraph. This is atom List of CDKRMap objects containing Ids of matching atoms.</returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraph.CDKMCS.NodeConstructor(NCDK.SMSD.Algorithms.RGraph.CDKRGraph,NCDK.IAtomContainer,NCDK.IAtomContainer,System.Boolean)">
            <summary>
             Builds  the nodes of the CDKRGraph ( resolution graph ), from
             two atom containers (description of the two molecules to compare)
            </summary>
            <param name="graph">the target CDKRGraph</param>
            <param name="ac1">first molecule. Must not be an IQueryAtomContainer.</param>
            <param name="ac2">second molecule. May be an IQueryAtomContainer.</param>
            <exception cref="T:NCDK.CDKException">if it takes too long to identify overlaps</exception>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraph.CDKMCS.ArcConstructor(NCDK.SMSD.Algorithms.RGraph.CDKRGraph,NCDK.IAtomContainer,NCDK.IAtomContainer)">
            <summary>
             Build edges of the RGraphs
             This method create the edge of the CDKRGraph and
             calculates the incompatibility and neighbourhood
             relationships between CDKRGraph nodes.
            </summary>
            <param name="graph">the rGraph</param>
            <param name="ac1">first molecule. Must not be an IQueryAtomContainer.</param>
            <param name="ac2">second molecule. May be an IQueryAtomContainer.</param>
            <exception cref="T:NCDK.CDKException">if it takes too long to get the overlaps</exception>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraph.CDKMCS.HasCommonAtom(NCDK.IBond,NCDK.IBond)">
            <summary>
            Determines if two bonds have at least one atom in common.
            </summary>
            <param name="bondA">first bondA1</param>
            <param name="bondB">second bondA1</param>
            <returns>the symbol of the common atom or "" if
                       the 2 bonds have no common atom</returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraph.CDKMCS.GetCommonSymbol(NCDK.IBond,NCDK.IBond)">
            <summary>
             Determines if 2 bondA1 have 1 atom in common and returns the common symbol
            </summary>
            <param name="bondA">first bondA1</param>
            <param name="bondB">second bondA1</param>
            <returns>the symbol of the common atom or "" if
                       the 2 bonds have no common atom</returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraph.CDKMCS.QueryAdjacency(NCDK.IBond,NCDK.IBond,NCDK.IBond,NCDK.IBond)">
            <summary>
             Determines if 2 bondA1 have 1 atom in common if second is atom query AtomContainer
            </summary>
            <param name="bondA1">first bondA1</param>
            <param name="bondB1">second bondA1</param>
            <returns>the symbol of the common atom or "" if
                       the 2 bonds have no common atom</returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraph.CDKMCS.QueryAdjacencyAndOrder(NCDK.IBond,NCDK.IBond,NCDK.IBond,NCDK.IBond)">
            <summary>
             Determines if 2 bondA1 have 1 atom in common if second is atom query AtomContainer
             and wheter the order of the atoms is correct (atoms match).
            </summary>
            <param name="bond1">first bondA1</param>
            <param name="bond2">second bondA1</param>
            <param name="queryBond1">first query bondA1</param>
            <param name="queryBond2">second query bondA1</param>
            <returns>the symbol of the common atom or "" if the 2 bonds have no common atom</returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraph.CDKMCS.TestSubgraphHeuristics(NCDK.IAtomContainer,NCDK.IAtomContainer)">
            <summary>
             Checks some simple heuristics for whether the subgraph query can
             realistically be atom subgraph of the supergraph. If, for example, the
             number of nitrogen atoms in the query is larger than that of the supergraph
             it cannot be part of it.
            </summary>
            <param name="ac1">the supergraph to be checked. Must not be an IQueryAtomContainer.</param>
            <param name="ac2">the subgraph to be tested for. May be an IQueryAtomContainer.</param>
            <returns>true if the subgraph ac2 has atom chance to be atom subgraph of ac1</returns>
            <exception cref="T:NCDK.CDKException">if the first molecule is an instance of IQueryAtomContainer</exception>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraph.CDKMCS.GetTimeOut">
            <summary></summary>
            <returns>the timeout</returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraph.CDKMCS.GetTimeManager">
            <summary></summary>
            <returns>the time manager</returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraph.CDKMCS.SetTimeManager(NCDK.SMSD.Tools.TimeManager)">
            <summary>
            </summary>
            <param name="aTimeManager">the time manager to set</param>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.RGraph.CDKMCSHandler">
            <summary>
            This class acts as a handler class for <see cref="T:NCDK.SMSD.Algorithms.RGraph.CDKMCS"/> algorithm.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraph.CDKMCSHandler.#ctor">
            <summary>
            Creates a new instance of MappingHandler
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraph.CDKMCSHandler.GetUncommon(NCDK.IAtomContainer,NCDK.IAtomContainer,System.Boolean)">
            <summary>
            </summary>
            <param name="mol"></param>
            <param name="mcss"></param>
            <param name="shouldMatchBonds"></param>
            <returns>IMolecule Set</returns>
            <exception cref="T:NCDK.CDKException"></exception>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.RGraph.CDKRGraph">
            <summary>
            This class implements the Resolution Graph (CDKRGraph).
            The CDKRGraph is a graph based representation of the search problem.
            An CDKRGraph is constructed from the two compared graphs (G1 and G2).
            Each vertex (node) in the CDKRGraph represents a possible association
            from an edge in G1 with an edge in G2. Thus two compatible bonds
            in two molecular graphs are represented by a vertex in the CDKRGraph.
            Each edge in the CDKRGraph corresponds to a common adjacency relationship
            between the 2 couple of compatible edges associated to the 2 CDKRGraph nodes
            forming this edge.
            </summary>
            <remarks>
            <para>Example:
            <pre>
               G1 : C-C=O  and G2 : C-C-C=0
                    1 2 3           1 2 3 4
            </pre>
            </para>
            <para>The resulting CDKRGraph(G1,G2) will contain 3 nodes:
            <list type="bullet">
               <item>Node sourceBitSet : association between bond C-C :  1-2 in G1 and 1-2 in G2</item>
               <item>Node targetBitSet : association between bond C-C :  1-2 in G1 and 2-3 in G2</item>
               <item>Node C : association between bond C=0 :  2-3 in G1 and 3-4 in G2</item>
             </list>   
             The CDKRGraph will also contain one edge representing the
             adjacency between node targetBitSet and C  that is : bonds 1-2 and 2-3 in G1
             and bonds 2-3 and 3-4 in G2.
            </para>
             <para>Once the CDKRGraph has been built from the two compared graphs
             maxIterator becomes a very interesting tool to perform all kinds of
             structural search (isomorphism, substructure search, maximal common
             substructure,....).
            </para>
             <para>The  search may be constrained by mandatory elements (e.g. bonds that
             have to be present in the mapped common substructures).
            </para>
             <para>Performing a query on an CDKRGraph requires simply to set the constrains
             (if any) and to invoke the parsing method (Parse())
            </para>
             <para>The CDKRGraph has been designed to be a generic tool. It may be constructed
             from any kind of source graphs, thus maxIterator is not restricted to a chemical
             context.
            </para>
             <para>The CDKRGraph model is indendant from the CDK model and the link between
             both model is performed by the RTools class. In this way the CDKRGraph
             class may be reused in other graph context (conceptual graphs,....)
            </para>
            <note type="important">
            This implementation of the algorithm has not been
                                 optimized for speed at this stage. It has been
                                 written with the goal to clearly retrace the
                                 principle of the underlined search method. There is
                                 room for optimization in many ways including the
                                 the algorithm itself.
            </note>
             <para>This algorithm derives from the algorithm described in
             <token>cdk-cite-HAN90</token> and modified in the thesis of T. Hanser <token>cdk-cite-HAN93</token>.</para>
            </remarks>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraph.CDKRGraph.#ctor">
            <summary>
            Constructor for the CDKRGraph object and creates an empty CDKRGraph.
            </summary>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.RGraph.CDKRGraph.FirstGraphSize">
            <summary>
            the size of the first of the two compared graphs.
            </summary>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.RGraph.CDKRGraph.SecondGraphSize">
            <summary>
            the size of the second of the two compared graphs.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraph.CDKRGraph.Clear">
            <summary>
            Reinitialisation of the TGraph.
            </summary>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.RGraph.CDKRGraph.Graph">
            <summary>
            an CDKRGraph is a list of CDKRGraph nodes each node keeping track of its neighbors.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraph.CDKRGraph.AddNode(NCDK.SMSD.Algorithms.RGraph.CDKRNode)">
            <summary>
             Adds a new node to the CDKRGraph.
            <param name="newNode">The node to add to the graph</param>
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraph.CDKRGraph.Parse(System.Collections.BitArray,System.Collections.BitArray,System.Boolean,System.Boolean,NCDK.SMSD.Tools.TimeManager)">
            <summary>
             Parsing of the CDKRGraph. This is the main method
             to perform a query. Given the constrains sourceBitSet and targetBitSet
             defining mandatory elements in G1 and G2 and given
             the search options, this method builds an initial set
             of starting nodes (targetBitSet) and parses recursively the
             CDKRGraph to find a list of solution according to
             these parameters.
            </summary>
            <param name="sourceBitSet">constrain on the graph G1</param>
            <param name="targetBitSet">constrain on the graph G2</param>
            <param name="findAllStructure">true if we want all results to be generated</param>
            <param name="findAllMap">true is we want all possible 'mappings'</param>
            <param name="timeManager"></param>
            <exception cref="T:NCDK.CDKException"></exception>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraph.CDKRGraph.ParseRec(System.Collections.BitArray,System.Collections.BitArray,System.Collections.BitArray)">
            <summary>
             Parsing of the CDKRGraph. This is the recursive method
             to perform a query. The method will recursively
             parse the CDKRGraph thru connected nodes and visiting the
             CDKRGraph using allowed adjacency relationship.
            </summary>
            <param name="traversed">node already parsed</param>
            <param name="extension">possible extension node (allowed neighbors)</param>
            <param name="forbidden">node forbidden (set of node incompatible with the current solution)</param>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraph.CDKRGraph.Solution(System.Collections.BitArray)">
             <summary>
             Checks if a potential solution is a real one
             (not included in a previous solution)
              and add this solution to the solution list
             in case of success.
            
             <param name="traversed">new potential solution</param>
             </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraph.CDKRGraph.MustContinue(System.Collections.BitArray)">
            <summary>
             Determine if there are potential solution remaining.
            <param name="potentialNode">set of remaining potential nodes</param>
            <returns>true if maxIterator is worse to continue the search</returns>
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraph.CDKRGraph.BuildB(System.Collections.BitArray,System.Collections.BitArray)">
            <summary>
             Builds the initial extension set. This is the
             set of node that may be used as seed for the
             CDKRGraph parsing. This set depends on the constrains
             defined by the user.
            </summary>
            <param name="sourceBitSet">constraint in the graph G1</param>
            <param name="targetBitSet">constraint in the graph G2</param>
            <returns></returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraph.CDKRGraph.BitSetToRMap(System.Collections.BitArray)">
             <summary>
              Converts a CDKRGraph bitset (set of CDKRNode)
             to a list of CDKRMap that represents the
             mapping between to substructures in G1 and G2
             (the projection of the CDKRGraph bitset on G1
             and G2).
            
             <param name="set">the BitArray</param>
             <returns>the CDKRMap list</returns>
             </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraph.CDKRGraph.SetAllStructure(System.Boolean)">
            <summary>
             Sets the 'AllStructres' option. If true
            all possible solutions will be generated. If false
            the search will stop as soon as a solution is found.
            (e.g. when we just want to know if a G2 is
             a substructure of G1 or not).
            </summary>
            <param name="findAllStructure"></param>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraph.CDKRGraph.SetAllMap(System.Boolean)">
            <summary>
             Sets the 'finAllMap' option. If true
            all possible 'mappings' will be generated. If false
            the search will keep only one 'mapping' per structure
            association.
            </summary>
            <param name="findAllMap"></param>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraph.CDKRGraph.SetMaxIteration(System.Int32)">
            <summary>
            Sets the maxIteration for the CDKRGraph parsing. If set to -1,
            then no iteration maximum is taken into account.
            </summary>
            <param name="maxIterator">The new maxIteration value</param>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraph.CDKRGraph.ToString">
            <summary>
            Returns a string representation of the CDKRGraph.
            </summary>
            <returns>a string representation of the CDKRGraph.</returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraph.CDKRGraph.ProjectG1(System.Collections.BitArray)">
            <summary>
             Projects a CDKRGraph bitset on the source graph G1.
            </summary>
            <param name="set">CDKRGraph BitArray to project</param>
            <returns>The associate BitArray in G1</returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraph.CDKRGraph.ProjectG2(System.Collections.BitArray)">
            <summary>
             Projects a CDKRGraph bitset on the source graph G2.
            </summary>
            <param name="set">CDKRGraph BitArray to project</param>
            <returns>The associate BitArray in G2</returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraph.CDKRGraph.IsContainedIn(System.Collections.BitArray,System.Collections.BitArray)">
            <summary>
             Test if set sourceBitSet is contained in  set targetBitSet.
            </summary>
            <param name="sourceBitSet">a bitSet</param>
            <param name="targetBitSet">a bitSet</param>
            <returns>true if  sourceBitSet is contained in  targetBitSet</returns>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.RGraph.CDKRGraph.IsFindAllStructure">
            <summary>
            flag to define if we want to get all possible 'structures'
            </summary>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.RGraph.CDKRGraph.Solutions">
            <summary>
            The solution list
            </summary>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.RGraph.CDKRGraph.MaxIteration">
            <summary>
            maximal number of iterations before search break
            </summary>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.RGraph.CDKRGraph.IsFindAllMap">
            <summary>
            flag to define if we want to get all possible 'mappings'
            </summary>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.RGraph.CDKRGraph.IsStop">
            <summary>
            if true is a search has to be stopped
            </summary>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.RGraph.CDKRMap">
            <summary>
             An CDKRMap implements the association between an edge (bond) in G1 and an edge
             (bond) in G2, G1 and G2 being the compared graphs in a RGraph context.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraph.CDKRMap.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructor for the CDKRMap
            </summary>
            <param name="id1">number of the edge (bond) in the graphe 1</param>
            <param name="id2">number of the edge (bond) in the graphe 2</param>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.RGraph.CDKRMap.Id1">
            <summary>
            the id1 attribute of the CDKRMap object
            </summary>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.RGraph.CDKRMap.Id2">
            <summary>
            the id2 attribute of the CDKRMap object
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraph.CDKRMap.Equals(System.Object)">
             <summary>
              The equals method.
            
             <param name="obj">The object to compare.</param>
             <returns>true=if both ids equal, else false.</returns>
             </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraph.CDKRMap.GetHashCode">
            <summary>
            Returns a hash code for object comparison.
            <returns>Returns a hash code for object comparison.</returns>
            </summary>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.RGraph.CDKRMapHandler">
            <summary>
            This algorithm derives from the algorithm described in
            [Tonnelier, C. and Jauffret, Ph. and Hanser, Th. and Jauffret, Ph. and Kaufmann, G.,
            Machine Learning of generic reactions:
            3. An efficient algorithm for maximal common substructure determination,
            Tetrahedron Comput. Methodol., 1990, 3:351-358] and modified in the thesis of
            T. Hanser [Unknown BibTeXML type: HAN93].
            </summary>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.RGraph.CDKRMapHandler.Source">
            <summary>
            Returns source molecule
            </summary>
            <returns>the source</returns>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.RGraph.CDKRMapHandler.Target">
            <summary>
            Returns target molecule
            </summary>
            <returns>the target</returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraph.CDKRMapHandler.CalculateOverlapsAndReduce(NCDK.IAtomContainer,NCDK.IAtomContainer,System.Boolean)">
            <summary>
            This function calculates all the possible combinations of MCS
            </summary>
            <param name="molecule1"></param>
            <param name="molecule2"></param>
            <param name="shouldMatchBonds"></param>
            <exception cref="T:NCDK.CDKException"></exception>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraph.CDKRMapHandler.CalculateOverlapsAndReduceExactMatch(NCDK.IAtomContainer,NCDK.IAtomContainer,System.Boolean)">
            <summary>
            This function calculates only one solution (exact) because we are looking at the
            molecules which are exactly same in terms of the bonds and atoms determined by the
            Fingerprint
            </summary>
            <param name="molecule1"></param>
            <param name="molecule2"></param>
            <param name="shouldMatchBonds"></param>
            <exception cref="T:NCDK.CDKException"></exception>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraph.CDKRMapHandler.CalculateSubGraphs(NCDK.IAtomContainer,NCDK.IAtomContainer,System.Boolean)">
            <summary>
            This function calculates only one solution (exact) because we are looking at the
            molecules which are exactly same in terms of the bonds and atoms determined by the
            Fingerprint
            </summary>
            <param name="molecule1"></param>
            <param name="molecule2"></param>
            <param name="shouldMatchBonds"></param>
            <exception cref="T:NCDK.CDKException"></exception>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraph.CDKRMapHandler.CalculateIsomorphs(NCDK.IAtomContainer,NCDK.IAtomContainer,System.Boolean)">
            <summary>
            This function calculates only one solution (exact) because we are looking at the
            molecules which are exactly same in terms of the bonds and atoms determined by the
            Fingerprint
            </summary>
            <param name="molecule1"></param>
            <param name="molecule2"></param>
            <param name="shouldMatchBonds"></param>
            <exception cref="T:NCDK.CDKException"></exception>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraph.CDKRMapHandler.MakeAtomsMapOfBondsMap(System.Collections.Generic.IList{NCDK.SMSD.Algorithms.RGraph.CDKRMap},NCDK.IAtomContainer,NCDK.IAtomContainer)">
            <summary>
             This makes sourceAtom map of matching atoms out of sourceAtom map of matching bonds as produced by the Get(Subgraph|Ismorphism)Map methods.
            </summary>
            <param name="rMapList">The list produced by the getMap method.</param>
            <param name="graph1">first molecule. Must not be an IQueryAtomContainer.</param>
            <param name="graph2">second molecule. May be an IQueryAtomContainer.</param>
            <returns>The mapping found projected on graph1. This is sourceAtom List of CDKRMap objects containing Ids of matching atoms.</returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraph.CDKRMapHandler.MakeAtomsMapOfBondsMapSingleBond(System.Collections.Generic.IList{NCDK.SMSD.Algorithms.RGraph.CDKRMap},NCDK.IAtomContainer,NCDK.IAtomContainer)">
            <summary>
             This makes atom map of matching atoms out of atom map of matching bonds as produced by the Get(Subgraph|Ismorphism)Map methods.
             Added by Asad since CDK one doesn't pick up the correct changes
            </summary>
            <param name="list">The list produced by the getMap method.</param>
            <param name="sourceGraph">first molecule. Must not be an IQueryAtomContainer.</param>
            <param name="targetGraph">second molecule. May be an IQueryAtomContainer.</param>
            <returns>The mapping found projected on sourceGraph. This is atom List of CDKRMap objects containing Ids of matching atoms.</returns>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.RGraph.CDKRMapHandler.Mappings">
            <summary>
            mapping solutions
            </summary>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.RGraph.CDKRMapHandler.IsTimedOut">
            <summary>
            true if a time out occurred else false
            </summary>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.RGraph.CDKRNode">
            <summary>
             Node of the resolution graphe (RGraph) An CDKRNode represents an association
             betwwen two edges of the source graphs G1 and G2 that are compared. Two
             edges may be associated if they have at least one common feature. The
             association is defined outside this class. The node keeps tracks of the ID
             of the mapped edges (in an CDKRMap), of its neighbours in the RGraph it belongs
             to and of the set of incompatible nodes (nodes that may not be along with
             this node in the same solution)
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraph.CDKRNode.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructor for the RNode object
            </summary>
            <param name="id1">number of the bond in the graphe 1</param>
            <param name="id2">number of the bond in the graphe 2</param>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.RGraph.CDKRNode.Extension">
            <summary>
            the extension attribute of the RNode object
            </summary>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.RGraph.CDKRNode.Forbidden">
            <summary>
            the forbidden attribute of the RNode object
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraph.CDKRNode.ToString">
            <summary>
            Returns a string representation of the RNode
            </summary>
            <returns>the string representation of the RNode</returns>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.RGraph.CDKRNode.RMap">
            <summary>
            resolution map/graph
            </summary>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.RGraph.CDKSubGraphHandler">
            <summary>
            This class acts as a handler class for <see cref="T:NCDK.SMSD.Algorithms.RGraph.CDKMCS"/> algorithm.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraph.CDKSubGraphHandler.#ctor">
            <summary>
            Creates a new instance of MappingHandler
            </summary>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.Single.SingleMapping">
            <summary>
            This class handles single atom mapping.
            Either query and/or target molecule with single atom is mapped by this class.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.Single.SingleMapping.#ctor">
            <summary>
            Default
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.Single.SingleMapping.GetOverLaps(NCDK.IAtomContainer,NCDK.IAtomContainer,System.Boolean)">
            <summary>
            Returns single mapping solutions.
            </summary>
            <returns>Mappings</returns>
            <exception cref="T:NCDK.CDKException"></exception>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.Single.SingleMapping.GetOverLaps(NCDK.Isomorphisms.Matchers.IQueryAtomContainer,NCDK.IAtomContainer,System.Boolean)">
            <summary>
            Returns single mapping solutions.
            </summary>
            <exception cref="T:NCDK.CDKException"></exception>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.Single.SingleMappingHandler">
            <summary>
            This is a handler class for single atom mapping <see cref="T:NCDK.SMSD.Algorithms.Single.SingleMapping"/>.
            </summary>
        </member>
        <member name="T:NCDK.SMSD.Filters.PostFilter">
            <summary>
            Class that cleans redundant mappings from the solution set.
            <list type="bullet">
            <item>1: Stereo match, bond type, ring etc,</item>
            <item>2: Fragment size,</item>
            <item>3: Bond breaking energy</item>
            </list> 
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Filters.PostFilter.Filter(System.Collections.Generic.IList{System.Collections.Generic.IList{System.Int32}})">
            <summary>
            Creates a new instance of Post Filter and removes
            redundant Mapping(s).
            </summary>
            <param name="mappings"></param>
            <returns>Filtered non-redundant mappings</returns>
        </member>
        <member name="T:NCDK.SMSD.Filters.ChemicalFilters">
            <summary>
            Class that ranks MCS final solution according to the chemical rules.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Filters.ChemicalFilters.#ctor(System.Collections.Generic.List{System.Collections.Generic.IDictionary{System.Int32,System.Int32}},System.Collections.Generic.List{System.Collections.Generic.IDictionary{NCDK.IAtom,NCDK.IAtom}},System.Collections.Generic.IDictionary{System.Int32,System.Int32},System.Collections.Generic.IDictionary{NCDK.IAtom,NCDK.IAtom},NCDK.IAtomContainer,NCDK.IAtomContainer)">
             <summary>
             This class has all the three chemical filters supported by the SMSD.
             i.e ring matches, bond energy etc
            
             <list type="bullet">
             <item>a: Bond energy,</item>
             <item>b: Fragment count,</item>
             <item>c: Stereo matches</item>
             </list> 
             </summary>
        </member>
        <member name="M:NCDK.SMSD.Filters.ChemicalFilters.SortResultsByStereoAndBondMatch">
            <summary>
            Sort MCS solution by stereo and bond type matches.
            </summary>
            <exception cref="T:NCDK.CDKException"></exception>
        </member>
        <member name="M:NCDK.SMSD.Filters.ChemicalFilters.SortResultsByFragments">
            <summary>
            Sort solution by ascending order of the fragment count.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Filters.ChemicalFilters.SortResultsByEnergies">
            <summary>
            Sort MCS solution by bond breaking energy.
            </summary>
            <exception cref="T:NCDK.CDKException"></exception>
        </member>
        <member name="M:NCDK.SMSD.Filters.ChemicalFilters.GetSortedEnergy">
            <summary>
            Return sorted energy in ascending order.
            <returns>sorted bond breaking energy</returns>
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Filters.ChemicalFilters.GetSortedFragment">
            <summary>
            Return sorted fragment in ascending order of the size.
            <returns>sorted fragment count</returns>
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Filters.ChemicalFilters.GetStereoMatches">
            <summary>
            Return Stereo matches in descending order.
            <returns>sorted stereo matches</returns>
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Filters.ChemicalFilters.ConvertOrder(System.Double)">
            <summary>
            Get bond order value as <see cref="T:NCDK.BondOrder"/>
            </summary>
            <param name="srcOrder">numerical bond order</param>
            <returns>the bond order type for the given numerical bond order</returns>
        </member>
        <member name="M:NCDK.SMSD.Filters.ChemicalFilters.ConvertBondOrder(NCDK.IBond)">
            <summary>
            Get bond order value as <see cref="T:System.Int32"/> value.
            </summary>
            <param name="bond">The <see cref="T:NCDK.IBond"/> for which the order is returned.</param>
            <returns>1 for a single bond, 2 for a double bond, 3 for a triple bond, 4 for a quadruple bond,
                         and 0 for any other bond type.</returns>
        </member>
        <member name="M:NCDK.SMSD.Filters.ChemicalFilters.ConvertBondStereo(NCDK.IBond)">
            <summary>
            Get stereo value as integer
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Filters.ChemicalFilters.ConvertStereo(System.Int32)">
            <summary>
            Get stereo value as Stereo enum
            </summary>
        </member>
        <member name="T:NCDK.SMSD.IMCSBase">
            <summary>
            Interface that holds basic core interface for all MCS algorithm.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.IMCSBase.Set(NCDK.SMSD.Tools.MolHandler,NCDK.SMSD.Tools.MolHandler)">
            <summary>
            Initialise the query and target molecule.
            </summary>
            <param name="source">source molecule</param>
            <param name="target">target molecule</param>
            <exception cref="T:NCDK.CDKException"></exception>
        </member>
        <member name="M:NCDK.SMSD.IMCSBase.Set(NCDK.Isomorphisms.Matchers.IQueryAtomContainer,NCDK.IAtomContainer)">
            <summary>
            Initialise the query and target molecule.
            </summary>
            <param name="source">source molecule</param>
            <param name="target">target molecule</param>
            <exception cref="T:NCDK.CDKException"></exception>
        </member>
        <member name="M:NCDK.SMSD.IMCSBase.GetAllAtomMapping">
            <summary>
            Returns all plausible mappings between query and target molecules.
            Each map in the list has atom-atom equivalence of the mappings
            between query and target molecule i.e. map.Key for the query
            and map.Value for the target molecule
            </summary>
            <returns>All possible MCS atom Mappings</returns>
        </member>
        <member name="M:NCDK.SMSD.IMCSBase.GetAllMapping">
            <summary>
            Returns all plausible mappings between query and target molecules.
            Each map in the list has atom-atom equivalence index of the mappings
            between query and target molecule i.e. map.Key for the query
            and map.Value for the target molecule
            </summary>
            <returns>All possible MCS Mapping Index</returns>
        </member>
        <member name="M:NCDK.SMSD.IMCSBase.GetFirstAtomMapping">
            <summary>
            Returns one of the best matches with atoms mapped.
            </summary>
            <returns>Best Atom Mapping</returns>
        </member>
        <member name="M:NCDK.SMSD.IMCSBase.GetFirstMapping">
            <summary>
            Returns one of the best matches with atom indexes mapped.
            </summary>
            <returns>Best Mapping Index</returns>
        </member>
        <member name="T:NCDK.SMSD.Tools.TimeManager">
            <summary>
            Class that handles execution time of the MCS search.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Tools.TimeManager.#ctor">
            <summary>
            Constructor for storing execution time
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Tools.TimeManager.GetElapsedTimeInHours">
            <summary>
            Returns Elapsed Time In Hours
            <returns>Elapsed Time In Hours</returns>
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Tools.TimeManager.GetElapsedTimeInMinutes">
            <summary>
            Returns Elapsed Time In Minutes
            <returns>Elapsed Time In Minutes</returns>
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Tools.TimeManager.GetElapsedTimeInSeconds">
            <summary>
            Return Elapsed Time In Seconds
            <returns>Elapsed Time In Seconds</returns>
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Tools.TimeManager.GetElapsedTimeInMilliSeconds">
            <summary>
            Returns Elapsed Time In Mill Seconds
            <returns>Elapsed Time In Mill Seconds</returns>
            </summary>
        </member>
        <member name="T:NCDK.SMSD.Tools.BondEnergies">
             <summary>
             Class that stores bond breaking/formation energy between two atoms.
             </summary>
             <remarks>
             Reference: Huheey, pps. A-21 to A-34; T.L. Cottrell,
             "The Strengths of Chemical Bonds," 2nd ed., Butterworths, London, 1958;
             B. deB. Darwent, "National Standard Reference Data Series,
             "National Bureau of Standards, No. 31, Washington, DC, 1970;
             S.W. Benson, J. Chem. Educ., 42, 502 (1965).
            
             Common Bond Energies (D) and Bond Lengths (r)
            
             Hydrogen
             Bond    D(kJ/mol) r(pm)
            
             H-H    432    74
             H-B    389    119
             H-C    411    109
             H-Si    318    148
             H-Ge    288    153
             H-Sn    251    170
             H-N    386    101
             H-P    322    144
             H-As    247    152
             H-O    459    96
             H-S    363    134
             H-Se    276    146
             H-Te    238    170
             H-F    565    92
             H-Cl    428    127
             H-Br    362    141
             H-I    295    161
            
            
             Group 13
             Bond    D(kJ/mol) r(pm)
             B-B    293
             B-O    536
             B-F    613
             B-Cl    456    175
             B-Br    377
            
            
             Group 14
             Bond    D(kJ/mol) r(pm)
             C-C    346    154
             C=C    602    134
             C#C    835    120
             C-Si    318    185
             C-Ge    238    195
             C-Sn    192    216
             C-Pb    130    230
             C-N    305    147
             C=N    615    129
             C#N    887    116
             C-P    264    184
             C-O    358    143
             C=O    799    120
             C#O    1072    113
             C-B    356
             C-S    272    182
             C=S    573    160
             C-F    485    135
             C-Cl    327    177
             C-Br    285    194
             C-I    213    214
            
            
             Group 14
             Bond    D(kJ/mol) r(pm)
             Si-Si    222    233
             Si-N    355
             Si-O    452    163
             Si-S    293    200
             Si-F    565    160
             Si-Cl    381    202
             Si-Br    310    215
             Si-I    234    243
             Ge-Ge    188    241
             Ge-N    257
             Ge-F    470    168
             Ge-Cl    349    210
             Ge-Br    276    230
             Ge-I    212
             Sn-F    414
             Sn-Cl    323    233
             Sn-Br    273    250
             Sn-I    205    270
             Pb-F    331
             Pb-Cl    243    242
             Pb-Br    201
             Pb-I    142    279
            
            
             Group 15
             Bond    D(kJ/mol) r(pm)
             N-N    167    145
             N=N    418    125
             N#N    942    110
             N-O    201    140
             N=O    607    121
             N-F    283    136
             N-Cl    313    175
             P-P    201    221
             P-O    335    163
             P=O    544    150
             P=S    335    186
             P-F    490    154
             P-Cl    326    203
             P-Br    264
             P-I    184
             As-As    146    243
             As-O    301    178
             As-F    484    171
             As-Cl    322    216
             As-Br    458    233
             As-I    200    254
             Sb-Sb    121
             Sb-F    440
             Sb-Cl (SbCl5)    248
             Sb-Cl (SbCl3)    315    232
            
             Group 16
             Bond    D(kJ/mol) r(pm)
             O-O    142    148
             O=O    494    121
             O-F    190    142
             S=O    522    143
             S-S (S8)    226    205
             S=S    425    149
             S-F    284    156
             S-Cl    255    207
             Se-Se    172
             Se=Se    272    215
            
             Group 17
             Bond    D(kJ/mol) r(pm))
             F-F    155    142
             Cl-Cl    240    199
             Br-Br    190    228
             I-I    148    267
             At-At    116
             I-O    201
             I-F    273    191
             I-Cl    208    232
             I-Br    175
            
             Group 18
             Bond    D(kJ/mol) r(pm)
             Kr-F (KrF2)    50    190
             Xe-O    84    175
             Xe-F    130    195
             </remarks>
        </member>
        <member name="P:NCDK.SMSD.Tools.BondEnergies.Instance">
            <summary>
            Singleton pattern instance for the Bond Energy class
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Tools.BondEnergies.GetEnergies(NCDK.IAtom,NCDK.IAtom,NCDK.BondOrder)">
            <summary>
            Returns bond energy for a bond type, given atoms and bond type
            <param name="sourceAtom">First bondEnergy</param>
            <param name="targetAtom">Second bondEnergy</param>
            <param name="bondOrder">(single, double etc)</param>
            <returns>bond energy</returns>
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Tools.BondEnergies.GetEnergies(System.String,System.String,NCDK.BondOrder)">
            <summary>
            Returns bond energy for a bond type, given atoms and bond type
            <param name="sourceAtom">First bondEnergy</param>
            <param name="targetAtom">Second bondEnergy</param>
            <param name="bondOrder">(single, double etc)</param>
            <returns>bond energy</returns>
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Tools.BondEnergies.GetEnergies(NCDK.IBond)">
            <summary>
            Returns bond energy for a bond type, given atoms and bond type
            <param name="bond">(single, double etc)</param>
            <returns>bond energy</returns>
            </summary>
        </member>
        <member name="T:NCDK.SMSD.Tools.ExtAtomContainerManipulator">
            <summary>
            Class that handles some customised features for SMSD atom containers.
            <para>This is an extension of CDK AtomContainer.
            Some part of this code was taken from CDK source code and modified.</para>
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Tools.ExtAtomContainerManipulator.MakeDeepCopy(NCDK.IAtomContainer)">
            <summary>
            Retrurns deep copy of the molecule
            </summary>
            <param name="container"></param>
            <returns>deep copy of the mol</returns>
        </member>
        <member name="M:NCDK.SMSD.Tools.ExtAtomContainerManipulator.AromatizeMolecule(NCDK.IAtomContainer)">
            <summary>
            This function finds rings and uses aromaticity detection code to
            aromatize the molecule.
            </summary>
            <param name="mol">input molecule</param>
        </member>
        <member name="M:NCDK.SMSD.Tools.ExtAtomContainerManipulator.GetExplicitHydrogenCount(NCDK.IAtomContainer,NCDK.IAtom)">
            <summary>
            Returns The number of explicit hydrogens for a given IAtom.
            </summary>
            <param name="atomContainer"></param>
            <param name="atom"></param>
            <returns>The number of explicit hydrogens on the given IAtom.</returns>
        </member>
        <member name="M:NCDK.SMSD.Tools.ExtAtomContainerManipulator.GetImplicitHydrogenCount(NCDK.IAtom)">
            <summary>
            Returns The number of Implicit Hydrogen Count for a given IAtom.
            </summary>
            <param name="atom"></param>
            <returns>Implicit Hydrogen Count</returns>
        </member>
        <member name="M:NCDK.SMSD.Tools.ExtAtomContainerManipulator.GetHydrogenCount(NCDK.IAtomContainer,NCDK.IAtom)">
            <summary>
            The summed implicit + explicit hydrogens of the given IAtom.
            </summary>
            <param name="atomContainer"></param>
            <param name="atom"></param>
            <returns>The summed implicit + explicit hydrogens of the given IAtom.</returns>
        </member>
        <member name="M:NCDK.SMSD.Tools.ExtAtomContainerManipulator.RemoveHydrogensExceptSingleAndPreserveAtomID(NCDK.IAtomContainer)">
            <summary>
            Returns IAtomContainer without Hydrogen. If an AtomContainer has atom single atom which
            is atom Hydrogen then its not removed.
            </summary>
            <param name="atomContainer"></param>
            <returns>IAtomContainer without Hydrogen. If an AtomContainer has atom single atom which is atom Hydrogen then its not removed.</returns>
        </member>
        <member name="M:NCDK.SMSD.Tools.ExtAtomContainerManipulator.ConvertExplicitToImplicitHydrogens(NCDK.IAtomContainer)">
            <summary>
            Returns IAtomContainer without Hydrogen. If an AtomContainer has atom single atom which
            is atom Hydrogen then its not removed.
            </summary>
            <param name="atomContainer"></param>
            <returns>IAtomContainer without Hydrogen. If an AtomContainer has atom single atom which is atom Hydrogen then its not removed.</returns>
        </member>
        <member name="M:NCDK.SMSD.Tools.ExtAtomContainerManipulator.PercieveAtomTypesAndConfigureAtoms(NCDK.IAtomContainer)">
            <summary>
            Convenience method to perceive atom types for all <see cref="T:NCDK.IAtom"/>s in the
            <see cref="T:NCDK.IAtomContainer"/>, using the <see cref="T:NCDK.AtomTypes.CDKAtomTypeMatcher"/>. If the
            matcher finds atom matching atom type, the <see cref="T:NCDK.IAtom"/> will be configured
            to have the same properties as the <see cref="T:NCDK.IAtomType"/>. If no matching atom
            type is found, no configuration is performed.
            </summary>
            <param name="container"></param>
            <exception cref="T:NCDK.CDKException"></exception>
        </member>
        <member name="T:NCDK.SMSD.Tools.MoleculeSanityCheck">
            <summary>
            Class that cleans a molecule before MCS search.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Tools.MoleculeSanityCheck.CheckAndCleanMolecule(NCDK.IAtomContainer)">
            <summary>
            Modules for cleaning a molecule
            </summary>
            <param name="molecule"></param>
            <returns>cleaned AtomContainer</returns>
        </member>
        <member name="M:NCDK.SMSD.Tools.MoleculeSanityCheck.Configure(NCDK.IAtomContainer)">
            <summary>
            Fixes Aromaticity of the molecule
            i.e. need to find rings and aromaticity again since added H's
            <param name="mol"></param>
            </summary>
        </member>
        <member name="T:NCDK.SMSD.Tools.MolHandler">
            <summary>
            Class that handles molecules for MCS search.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Tools.MolHandler.#ctor(System.String,System.Boolean,System.Boolean)">
            <summary>
            Creates a new instance of MolHandler
            </summary>
            <param name="molFile">atomContainer file name</param>
        </member>
        <member name="M:NCDK.SMSD.Tools.MolHandler.#ctor(NCDK.IAtomContainer,System.Boolean,System.Boolean)">
            <summary>
            Creates a new instance of MolHandler
            <param name="container">Molecule AtomContainer</param>
            </summary>
        </member>
        <member name="P:NCDK.SMSD.Tools.MolHandler.Molecule">
            <summary>
            Returns the modified container
            <returns>get processed / modified container</returns>
            </summary>
        </member>
        <member name="P:NCDK.SMSD.Tools.MolHandler.RemoveHydrogenFlag">
            <summary>
            Returns true if hydrogens were made implicit else return false
            <returns>true if remove H else false</returns>
            </summary>
        </member>
        <member name="T:NCDK.SMSD.Global.TimeOut">
            <summary>
            Class that manages MCS timeout.
            </summary>
        </member>
        <member name="P:NCDK.SMSD.Global.TimeOut.Instance">
            <summary>
            Get Instance of the timeout. This starts the timeout counter.
            </summary>
            <returns>Instance</returns>
        </member>
        <member name="P:NCDK.SMSD.Global.TimeOut.Time">
            <summary>
            cutoff value for time out.
            -1 for infinite and 0.23 for 23 seconds.
            </summary>
        </member>
        <member name="P:NCDK.SMSD.Global.TimeOut.Enabled">
            <summary>
            true if timeout occures else false
            </summary>
        </member>
        <member name="T:NCDK.SMSD.Helper.BinaryTree">
            <summary>
            Class to construct a Binary tree for McGregor search.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Helper.BinaryTree.#ctor(System.Int32)">
            <summary>
            Creates a new instance of BinaryTree.
            </summary>
            <param name="value">node value</param>
        </member>
        <member name="P:NCDK.SMSD.Helper.BinaryTree.Value">
            <summary>
            The value of the current node
            </summary>
        </member>
        <member name="P:NCDK.SMSD.Helper.BinaryTree.Equal">
            <summary>
            equal node
            </summary>
        </member>
        <member name="P:NCDK.SMSD.Helper.BinaryTree.NotEqual">
            <summary>
            not equal node
            </summary>
        </member>
        <member name="T:NCDK.SMSD.Helper.BondEnergy">
            <summary>
            Helper class defining the energy for a bond type. The bond
            type is defined as to element symbols and a bond order.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Helper.BondEnergy.#ctor(System.String,System.String,NCDK.BondOrder,System.Int32)">
             <summary>
             Creates a new bond energy for the given elements and
             bond order.
            
             <param name="symbol1">element symbol for the first atom</param>
             <param name="symbol2">element symbol for the second atom</param>
             <param name="order">bond order</param>
             <param name="energy">energy for this bond type</param>
             </summary>
        </member>
        <member name="P:NCDK.SMSD.Helper.BondEnergy.SymbolFirstAtom">
             <summary>
             Returns the element symbol of the first atom.
            
             <returns>the element symbol as <see cref="T:System.String"/></returns>
             </summary>
        </member>
        <member name="P:NCDK.SMSD.Helper.BondEnergy.SymbolSecondAtom">
             <summary>
             Returns the element symbol of the second atom.
            
             <returns>the element symbol as <see cref="T:System.String"/></returns>
             </summary>
        </member>
        <member name="P:NCDK.SMSD.Helper.BondEnergy.BondOrder">
             <summary>
             Returns the bond order for this bond type energy.
            
             <returns>the bond order of the bond type as <see cref="T:NCDK.BondOrder"/></returns>
             </summary>
        </member>
        <member name="P:NCDK.SMSD.Helper.BondEnergy.Energy">
            <summary>
            Returns the energy for this bond type.
            </summary>
            <returns>the bond energy as integer.</returns>
        </member>
        <member name="T:NCDK.SMSD.Helper.FinalMappings">
            <summary>
            Class that stores raw Mapping(s) after each algorithm is executed.
            </summary>
        </member>
        <member name="P:NCDK.SMSD.Helper.FinalMappings.Instance">
            <summary>
            Stores mapping solutions
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Helper.FinalMappings.Set(System.Collections.Generic.IList{System.Collections.Generic.IDictionary{System.Int32,System.Int32}})">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="list">list of mappings</param>
        </member>
        <member name="P:NCDK.SMSD.Helper.FinalMappings.Count">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.SMSD.Helper.LabelContainer">
            <summary>
            Class that handles atoms and assignes an integer lable to them.
            </summary>
        </member>
        <member name="P:NCDK.SMSD.Helper.LabelContainer.Instance">
            <summary>
            Create ids from atom labels
            </summary>
            <returns>instance of this object</returns>
        </member>
        <member name="M:NCDK.SMSD.Helper.LabelContainer.Add(System.String)">
            <summary>
            Add label if its not present
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Helper.LabelContainer.GetLabelID(System.String)">
            <summary>
            Returns label ID
            </summary>
            <param name="label"></param>
            <returns>labelID</returns>
        </member>
        <member name="M:NCDK.SMSD.Helper.LabelContainer.GetLabel(System.Int32)">
            <summary>
            Returns Label of a given ID
            </summary>
            <param name="labelID"></param>
            <returns>label</returns>
        </member>
        <member name="P:NCDK.SMSD.Helper.LabelContainer.Count">
            <summary>
            Returns label count
            </summary>
            <returns>size of the labels</returns>
        </member>
        <member name="T:NCDK.SMSD.AbstractMCS">
            <summary>
            Interface for all MCS algorithms.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.AbstractMCS.Init(NCDK.IAtomContainer,NCDK.IAtomContainer,System.Boolean,System.Boolean)">
            <summary>
            initialize query and target molecules.
            </summary>
            <param name="source">query mol</param>
            <param name="target">target mol</param>
            <param name="removeHydrogen">true if remove H (implicit) before mapping</param>
            <param name="cleanAndConfigureMolecule">eg: percieveAtomTypesAndConfigureAtoms, detect aromaticity etc</param>
             <exception cref="T:NCDK.CDKException"></exception>
        </member>
        <member name="M:NCDK.SMSD.AbstractMCS.Init(NCDK.Isomorphisms.Matchers.IQueryAtomContainer,NCDK.IAtomContainer)">
            <summary>
            initialize query and target molecules.
            </summary>
            <remarks>
            Note: Here its assumed that hydrogens are implicit
            and user has called these two methods
            percieveAtomTypesAndConfigureAtoms and CDKAromicityDetector
            before initializing calling this method.
            </remarks>
            <param name="source">query mol</param>
            <param name="target">target mol</param>
            <exception cref="T:NCDK.CDKException"></exception>
        </member>
        <member name="M:NCDK.SMSD.AbstractMCS.SetChemFilters(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            initialize query and target molecules.
            </summary>
            <param name="stereoFilter">set true to rank the solutions as per stereo matches</param>
            <param name="fragmentFilter">set true to return matches with minimum fragments</param>
            <param name="energyFilter">set true to return matches with minimum bond changes based on the bond breaking energy</param>
        </member>
        <member name="M:NCDK.SMSD.AbstractMCS.GetEnergyScore(System.Int32)">
            <summary>
            Returns summation energy score of the disorder if the MCS is removed
            from the target and query graph. Amongst the solutions, a solution
            with lowest energy score is preferred.
            </summary>
            <param name="key">Index of the mapping solution</param>
            <returns>Total bond breaking energy required to remove the mapped part</returns>
        </member>
        <member name="M:NCDK.SMSD.AbstractMCS.GetFragmentSize(System.Int32)">
            <summary>
            Returns number of fragment generated in the solution space,
            if the MCS is removed from the target and query graph.
            Amongst the solutions, a solution with lowest fragment size
            is preferred.
            </summary>
            <param name="key">Index of the mapping solution</param>
            <returns>Fragment Count(s) generated after removing the mapped parts</returns>
        </member>
        <member name="P:NCDK.SMSD.AbstractMCS.ProductMolecule">
            <summary>
            Modified target molecule on which mapping was performed.
            </summary>
        </member>
        <member name="P:NCDK.SMSD.AbstractMCS.ReactantMolecule">
            <summary>
            Modified query molecule on which mapping was performed.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.AbstractMCS.GetStereoScore(System.Int32)">
            <summary>
            Returns a number which denotes the quality of the mcs.
            A solution with highest stereo score is preferred over other
            scores.
            </summary>
            <param name="key">Index of the mapping solution</param>
            <returns>true if no stereo mismatch occurs
            else false if stereo mismatch occurs</returns>
        </member>
        <member name="M:NCDK.SMSD.AbstractMCS.IsStereoMisMatch">
            <summary>
            Returns true if mols have different stereo
            chemistry else false if no stereo mismatch.
            </summary>
            <returns>true if mols have different stereo</returns>
            chemistry else false if no stereo mismatch.
            true if stereo mismatch occurs
            else true if stereo mismatch occurs.
        </member>
        <member name="M:NCDK.SMSD.AbstractMCS.IsSubgraph">
            <summary>
            Checks if query is a subgraph of the target.
            Returns true if query is a subgraph of target else false
            </summary>
            <returns>true if query molecule is a subgraph of the target molecule</returns>
        </member>
        <member name="M:NCDK.SMSD.AbstractMCS.GetTanimotoSimilarity">
            <summary>
            Returns Tanimoto similarity between query and target molecules
            (Score is between 0-min and 1-max).
            </summary>
            <returns>Tanimoto Similarity between 0 and 1</returns>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NCDK.SMSD.AbstractMCS.GetEuclideanDistance">
            <summary>
            Returns Euclidean Distance between query and target molecule.
            <returns>Euclidean Distance (lower the score, better the match)</returns>
            </summary>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NCDK.SMSD.AbstractMCS.GetAllAtomMapping">
            <summary>
            Returns all plausible mappings between query and target molecules
            Each map in the list has atom-atom equivalence of the mappings
            between query and target molecule i.e. map.Key for the query
            and map.Value for the target molecule.
            </summary>
            <returns>All possible MCS atom Mappings</returns>
        </member>
        <member name="M:NCDK.SMSD.AbstractMCS.GetAllMapping">
            <summary>
            Returns all plausible mappings between query and target molecules
            Each map in the list has atom-atom equivalence index of the mappings
            between query and target molecule i.e. map.Key for the query
            and map.Value for the target molecule.
            </summary>
            <returns>All possible MCS Mapping Index</returns>
        </member>
        <member name="M:NCDK.SMSD.AbstractMCS.GetFirstAtomMapping">
            <summary>
            Returns one of the best matches with atoms mapped.
            </summary>
            <returns>Best Atom Mapping</returns>
        </member>
        <member name="M:NCDK.SMSD.AbstractMCS.GetFirstMapping">
            <summary>
            Returns one of the best matches with atom indexes mapped.
            </summary>
            <returns>Best Mapping Index</returns>
        </member>
        <member name="P:NCDK.SMSD.AbstractMCS.BondSensitiveTimeOut">
            <summary>
            timeout in mins (default 0.10 min) for bond sensitive searches
            </summary>
        </member>
        <member name="P:NCDK.SMSD.AbstractMCS.BondInSensitiveTimeOut">
            <summary>
            timeout in mins (default 1.00 min) for bond insensitive searches
            </summary>
        </member>
        <member name="T:NCDK.SMSD.AbstractMCSAlgorithm">
            <summary>
            Interface for MCS search algorithm.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.AbstractMCSAlgorithm.SearchMCS(System.Boolean)">
            <summary>
            Initialise the MCS search algorithm. Each MCS algorithm should contain
            this method.
            </summary>
            <param name="shouldMatchBonds">bond match</param>
        </member>
        <member name="T:NCDK.SMSD.AbstractSubGraph">
            <summary>
            Interface class for reporting only substructure searches.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.AbstractSubGraph.IsSubgraph(System.Boolean)">
            <summary>
            Initialise the Subgraph search algorithm. Each Subgraph algorithm
            should contain this method.
            </summary>
            <returns>true if Query/reactant is a subgraph of Target/product else false</returns>
        </member>
        <member name="T:NCDK.SMSD.IFinalMapping">
            <summary>
            Interface for mappings.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.IFinalMapping.Add(System.Collections.Generic.IDictionary{System.Int32,System.Int32})">
            <summary>
            Adds mapping to the mapping list
            </summary>
            <param name="mapping">List of all MCS mapping between a given
            reactant and product</param>
        </member>
        <member name="M:NCDK.SMSD.IFinalMapping.Set(System.Collections.Generic.IList{System.Collections.Generic.IDictionary{System.Int32,System.Int32}})">
            <summary>
            Sets mapping list
            <param name="list">List of all MCS mapping between a given
            reactant and product</param>
            </summary>
        </member>
        <member name="M:NCDK.SMSD.IFinalMapping.Clear">
            <summary>
            clear the mapping
            </summary>
        </member>
        <member name="M:NCDK.SMSD.IFinalMapping.GetFinalMapping">
            <summary>
            Returns the stored mappings
            </summary>
            <returns>get of MCS mapping List</returns>
        </member>
        <member name="P:NCDK.SMSD.IFinalMapping.Count">
            <summary>
            Returns number of stored mappings
            </summary>
            <returns>size of the mapping</returns>
        </member>
        <member name="T:NCDK.SMSD.Isomorphism">
             <summary>
              This class implements the Isomorphism- a multipurpose structure comparison tool.
             </summary>
             <remarks>
             <para>
             It allows users to, i) find the maximal common Substructure(s) (MCS);
             ii) perform the mapping of a substructure in another structure, and;
             iii) map two isomorphic structures.</para>
             <para>It also comes with various published algorithms. The user is free to
             choose his favorite algorithm to perform MCS or substructure search.
             For example 0: Isomorphism algorithm, 1: MCSPlus, 2: VFLibMCS, 3: CDKMCS, 4:
             Substructure</para>
            
             <para>It also has a set of robust chemical filters (i.e. bond energy, fragment
             count, stereo &amp; bond match) to sort the reported MCS solutions in a chemically
             relevant manner. Each comparison can be made with or without using the bond
             sensitive mode and with implicit or explicit hydrogens.</para>
            
             <para>If you are using <b>Isomorphism, please cite Rahman <i>et.al. 2009</i></b>
             <token>cdk-cite-SMSD2009</token>. The Isomorphism algorithm is described in this paper.
             </para>
             </remarks>
             <example>
             <para>An example for <b>Substructure search</b>:</para>
             <code>                SmilesParser sp = new SmilesParser(Default.ChemObjectBuilder.Instance);
                // Benzene
                IAtomContainer A1 = sp.ParseSmiles("C1=CC=CC=C1");
                // Napthalene
                IAtomContainer A2 = sp.ParseSmiles("C1=CC2=C(C=C1)C=CC=C2");
                //Turbo mode search
                //Bond Sensitive is set true
                Isomorphism comparison = new Isomorphism(Algorithm.SubStructure, true);
                // set molecules, remove hydrogens, clean and configure molecule
                comparison.Init(A1, A2, true, true);
                // set chemical filter true
                comparison.SetChemFilters(false, false, false);
                if (comparison.IsSubgraph())
                {
                    //Get similarity score
                    Console.Out.WriteLine("Tanimoto coefficient:  " + comparison.GetTanimotoSimilarity());
                    Console.Out.WriteLine("A1 is a subgraph of A2:  " + comparison.IsSubgraph());
                    //Get Modified AtomContainer
                    IAtomContainer Mol1 = comparison.ReactantMolecule;
                    IAtomContainer Mol2 = comparison.ProductMolecule;
                    // Print the mapping between molecules
                    Console.Out.WriteLine(" Mappings: ");
                    foreach (var mapping in comparison.GetFirstMapping())
                    {
                        Console.Out.WriteLine((mapping.Key + 1) + " " + (mapping.Value + 1));

                        IAtom eAtom = Mol1.Atoms[mapping.Key];
                        IAtom pAtom = Mol2.Atoms[mapping.Value];
                        Console.Out.WriteLine(eAtom.Symbol + " " + pAtom.Symbol);
                    }
                    Console.Out.WriteLine("");
                }
</code>
             <para>An example for <b>MCS search</b>:</para>
             <code>                SmilesParser sp = new SmilesParser(Default.ChemObjectBuilder.Instance);
                // Benzene
                IAtomContainer A1 = sp.ParseSmiles("C1=CC=CC=C1");
                // Napthalene
                IAtomContainer A2 = sp.ParseSmiles("C1=CC2=C(C=C1)C=CC=C2");
                //{ 0: Default Isomorphism Algorithm, 1: MCSPlus Algorithm, 2: VFLibMCS Algorithm, 3: CDKMCS Algorithm}
                //Bond Sensitive is set true
                Isomorphism comparison = new Isomorphism(Algorithm.Default, true);
                // set molecules, remove hydrogens, clean and configure molecule
                comparison.Init(A1, A2, true, true);
                // set chemical filter true
                comparison.SetChemFilters(true, true, true);

                //Get similarity score
                Console.Out.WriteLine("Tanimoto coefficient:  " + comparison.GetTanimotoSimilarity());
                Console.Out.WriteLine("A1 is a subgraph of A2:  " + comparison.IsSubgraph());
                //Get Modified AtomContainer
                IAtomContainer Mol1 = comparison.ReactantMolecule;
                IAtomContainer Mol2 = comparison.ProductMolecule;
                // Print the mapping between molecules
                Console.Out.WriteLine(" Mappings: ");
                foreach (var mapping in comparison.GetFirstMapping())
                {
                    Console.Out.WriteLine((mapping.Key + 1) + " " + (mapping.Value + 1));

                    IAtom eAtom = Mol1.Atoms[mapping.Key];
                    IAtom pAtom = Mol2.Atoms[mapping.Value];
                    Console.Out.WriteLine(eAtom.Symbol + " " + pAtom.Symbol);
                }
                Console.Out.WriteLine("");
</code>
             </example>
        </member>
        <member name="M:NCDK.SMSD.Isomorphism.#ctor(NCDK.SMSD.Algorithm,System.Boolean)">
            <summary>
            This is the algorithm factory and entry port for all the MCS algorithm in the Isomorphism
            supported algorithm <see cref="T:NCDK.SMSD.Algorithm"/> types:
            <list type="bullet">
            <item>0: Default,</item>
            <item>1: MCSPlus,</item>
            <item>2: VFLibMCS,</item>
            <item>3: CDKMCS,</item>
            <item>4: SubStructure</item>
            </list> 
            </summary>
            <param name="algorithmType"><see cref="T:NCDK.SMSD.Algorithm"/></param>
            <param name="bondTypeFlag"></param>
        </member>
        <member name="M:NCDK.SMSD.Isomorphism.MakeBondMapsOfAtomMaps(NCDK.IAtomContainer,NCDK.IAtomContainer,System.Collections.Generic.List{System.Collections.Generic.IDictionary{NCDK.IAtom,NCDK.IAtom}})">
            <summary>
            Returns bond maps between source and target molecules based on the atoms
            <param name="ac1">source molecule</param>
            <param name="ac2">target molecule</param>
            <param name="mappings">mappings between source and target molecule atoms</param>
            <returns>bond maps between source and target molecules based on the atoms</returns>
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Isomorphism.MakeBondMapOfAtomMap(NCDK.IAtomContainer,NCDK.IAtomContainer,System.Collections.Generic.IDictionary{NCDK.IAtom,NCDK.IAtom})">
             <summary>
            
             Returns bond map between source and target molecules based on the atoms
             <param name="ac1">source molecule</param>
             <param name="ac2">target molecule</param>
             <param name="mapping">mappings between source and target molecule atoms</param>
             <returns>bond map between source and target molecules based on the atoms</returns>
             </summary>
        </member>
        <member name="M:NCDK.SMSD.Isomorphism.Init(System.String,System.String,System.Boolean,System.Boolean)">
            <summary>
            Initialize the query and targetAtomCount mol via mol files
            </summary>
            <param name="sourceMolFileName">source mol file name</param>
            <param name="targetMolFileName">target mol file name</param>
            <param name="removeHydrogen">set true to make hydrogens implicit before search</param>
            <param name="cleanAndConfigureMolecule"> eg: percieveAtomTypesAndConfigureAtoms, detect aromaticity etc</param>
        </member>
        <member name="P:NCDK.SMSD.Isomorphism.BondSensitiveTimeOut">
            <summary>
            <inheritdoc/> (default 0.15 min)
            </summary>
        </member>
        <member name="P:NCDK.SMSD.Isomorphism.BondInSensitiveTimeOut">
            <summary>
            <inheritdoc/> (default 1.00 min)
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Isomorphism.SetFirstBondMap(System.Collections.Generic.IDictionary{NCDK.IBond,NCDK.IBond})">
            <summary>
            
            </summary>
            <param name="firstBondMCS">The firstBondMCS to set</param>
        </member>
        <member name="F:NCDK.SMSD.Labelling.AbstractReactionLabeller.fixAtomMappingCastType">
            <summary>
            A nasty hack necessary to get around a bug in the CDK
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Labelling.AbstractReactionLabeller.CloneAndSortMappings(NCDK.IReaction,NCDK.IReaction,System.Collections.Generic.IDictionary{NCDK.IAtomContainer,System.Int32[]})">
            <summary>
            Clone and Sort the mappings based on the order of the first object
            in the mapping (which is assumed to be the reactant).
            </summary>
            <param name="reaction"></param>
        </member>
        <member name="M:NCDK.SMSD.Labelling.ICanonicalReactionLabeller.GetCanonicalReaction(NCDK.IReaction)">
            <summary>
            Convert a reaction into a canonical form by canonizing each of the
            structures in the reaction in turn.
            </summary>
            <param name="reaction">the <see cref="T:NCDK.IReaction"/> to be processed</param>
            <returns>the canonical <see cref="T:NCDK.IReaction"/></returns>
        </member>
        <member name="T:NCDK.SMSD.Labelling.Permutor">
            <summary>
            General permutation generator, that uses orderly generation by ranking and
            unranking. The basic idea is that all permutations of length N can be ordered
            (lexicographically) like:
            <pre>
            0 [0, 1, 2]
            1 [0, 2, 1]
            2 [1, 0, 2]
            ...
            </pre>
            where the number to the left of each permutation is the <i>rank</i> - really
            just the index in this ordered list. The list is created on demand, by a
            process called <i>unranking</i> where the rank is converted to the
            permutation that appears at that point in the list.
            </summary>
            <remarks>
            <para>The algorithms used are from the book "Combinatorial Generation :
            Algorithms, Generation, and Search" (or C.A.G.E.S.) by D.L. Kreher and D.R.
            Stinson</para>
            </remarks>
        </member>
        <member name="F:NCDK.SMSD.Labelling.Permutor.currentRank">
            <summary>
            The current rank of the permutation to use
            </summary>
        </member>
        <member name="F:NCDK.SMSD.Labelling.Permutor.maxRank">
            <summary>
            The maximum rank possible, given the size
            </summary>
        </member>
        <member name="F:NCDK.SMSD.Labelling.Permutor.size">
            <summary>
            The number of objects to permute
            </summary>
        </member>
        <member name="F:NCDK.SMSD.Labelling.Permutor.random">
            <summary>
            For accessing part of the permutation space
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Labelling.Permutor.#ctor(System.Int32)">
            <summary>
            Create a permutor that will generate permutations of numbers up to 
            <paramref name="size"/>.
            </summary>
            <param name="size">the size of the permutations to generate</param>
        </member>
        <member name="P:NCDK.SMSD.Labelling.Permutor.Rank">
            <summary>
            the permutation to use, given its rank.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Labelling.Permutor.SetPermutation(System.Int32[])">
            <summary>
            Set the currently used permutation.
            </summary>
            <param name="permutation">the permutation to use, as an int array</param>
        </member>
        <member name="M:NCDK.SMSD.Labelling.Permutor.GetRandomNextPermutation">
            <summary>
            Randomly skip ahead in the list of permutations.
            </summary>
            <returns>a permutation in the range (current, N!)</returns>
        </member>
        <member name="M:NCDK.SMSD.Labelling.Permutor.GetNextPermutation">
            <summary>
            Get the next permutation in the list.
            </summary>
            <returns>the next permutation</returns>
        </member>
        <member name="M:NCDK.SMSD.Labelling.Permutor.GetCurrentPermutation">
            <summary>
            Get the permutation that is currently being used.
            </summary>
            <returns>the permutation as an int array</returns>
        </member>
        <member name="M:NCDK.SMSD.Labelling.Permutor.CalculateMaxRank">
            <summary>
            Calculate the max possible rank for permutations of N numbers.
            </summary>
            <returns>the maximum number of permutations</returns>
        </member>
        <member name="M:NCDK.SMSD.Labelling.Permutor.RankPermutationLexicographically(System.Int32[])">
            <summary>
            Convert a permutation (in the form of an int array) into a 'rank' - which
            is just a single number that is the order of the permutation in a lexico-
            graphically ordered list.
            </summary>
            <param name="permutation">the permutation to use</param>
            <returns>the rank as a number</returns>
        </member>
        <member name="M:NCDK.SMSD.Labelling.Permutor.UnrankPermutationLexicographically(System.Int32,System.Int32)">
            <summary>
            Performs the opposite to the rank method, producing the permutation that
            has the order <paramref name="rank"/> in the lexicographically ordered list.
            </summary>
            <remarks>
            As an implementation note, the algorithm assumes that the permutation is
            in the form [1,...N] not the more usual [0,...N-1] for a list of size N.
            This is why there is the final step of 'shifting' the permutation. The
            shift also reduces the numbers by one to make them array indices.
            </remarks>
            <param name="rank">the order of the permutation to generate</param>
            <param name="size">the length/size of the permutation</param>
            <returns>a permutation as an int array</returns>
        </member>
        <member name="T:NCDK.SMSD.Ring.HanserRingFinder">
             <summary>
             Finds the Set of all Rings. This is an implementation of the algorithm
             published in <token>cdk-cite-HAN96</token>. Some of the comments refer to pseudo code
             fragments listed in this article. The concept is that a regular molecular
             graph is first converted into a path graph (refer PathGraph.java),
             i.e. a graph where the edges are actually paths. This can list several
             nodes that are implicitly connecting the two nodes between the path
             is formed (refer PathEdge.java).
            
             The paths that join source and sink node are step by step fused and the joined
             nodes are deleted from the path graph (collapsed path). What remains is a graph
             of paths that have the same start and endpoint and are thus rings (source=sink=ring).
             </summary>
        </member>
        <member name="M:NCDK.SMSD.Ring.HanserRingFinder.FindRings(NCDK.IAtomContainer)">
            <summary>
            Returns a collection of rings.
            </summary>
            <param name="molecule"></param>
            <returns>a <see cref="T:System.Collections.Generic.IEnumerable`1"/> of <see cref="T:System.Collections.Generic.IList`1"/>s containing one ring each</returns>
            <seealso cref="M:NCDK.SMSD.Ring.RingFinder.FindRings(NCDK.IAtomContainer)"/>
        </member>
        <member name="M:NCDK.SMSD.Ring.HanserRingFinder.GetRingSet(NCDK.IAtomContainer)">
            <summary>
            Returns Ring set based on Hanser Ring Finding method
            <param name="molecule"></param>
            </summary>
            <returns>report collected the rings</returns>
            <seealso cref="M:NCDK.SMSD.Ring.RingFinder.GetRingSet(NCDK.IAtomContainer)"/>
        </member>
        <member name="M:NCDK.SMSD.Ring.RingFinder.FindRings(NCDK.IAtomContainer)">
            <summary>
            Returns Collection of atoms in Rings based on Hanser Ring Finding method
            <param name="molecule"></param>
            <returns>report collected the rings</returns>
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Ring.RingFinder.GetRingSet(NCDK.IAtomContainer)">
            <summary>
            Returns CDK object Ring set based on Hanser Ring Finding method
            </summary>
            <param name="molecule"></param>
            <returns>report collected the rings</returns>
            <exception cref="T:NCDK.CDKException"></exception>
        </member>
        <member name="T:NCDK.Stereo.Projection">
            <summary>
            Stereochemistry projection types. 
            </summary>
        </member>
        <member name="T:NCDK.Stereo.Projection.O">
            <summary>
            The <see cref="P:NCDK.Stereo.Projection.Ordinal"/> values of <see cref="T:NCDK.Stereo.Projection"/>.
            </summary>
            <seealso cref="T:NCDK.Stereo.Projection"/>
        </member>
        <member name="P:NCDK.Stereo.Projection.Ordinal">
            <summary>
            The ordinal of this enumeration constant. The list is in <see cref="T:NCDK.Stereo.Projection.O"/>.
            </summary>
            <seealso cref="T:NCDK.Stereo.Projection.O"/>
        </member>
        <member name="M:NCDK.Stereo.Projection.ToString">
            <inheritdoc/>
        </member>
        <member name="F:NCDK.Stereo.Projection.Fischer">
            <summary>
            Fischer projections are used for linear chain-form carbohydrates. They are drawn vertically with all atoms at right angles around stereocenters.
            </summary>
        </member>
        <member name="F:NCDK.Stereo.Projection.Haworth">
            <summary>
            Haworth projection are used to depict ring-form carbohydrates. The ring may be of size 5, 6, or 7 (rarer). Here the ring is flat and the substituents connected to stereocenters are drawn directly above or below the plane of the ring.
            </summary>
        </member>
        <member name="F:NCDK.Stereo.Projection.Chair">
            <summary>
            Projection of the low energy conformation (chair) of a cyclohexane. Used for carbohydrates.
            </summary>
        </member>
        <member name="M:NCDK.Stereo.Projection.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Stereo.Projection.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Stereo.Projection.CompareTo(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Stereo.Projection.CompareTo(NCDK.Stereo.Projection)">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Stereo.TetrahedralChirality">
            <summary>
            Stereochemistry specification for quadrivalent atoms. See <see cref="T:NCDK.ITetrahedralChirality"/> for
            further details.
            </summary>
            <seealso cref="T:NCDK.ITetrahedralChirality"/>
        </member>
        <member name="M:NCDK.Stereo.TetrahedralChirality.#ctor(NCDK.IAtom,System.Collections.Generic.IEnumerable{NCDK.IAtom},NCDK.TetrahedralStereo)">
            <summary>
            Constructor to create a new <see cref="T:NCDK.ITetrahedralChirality"/> implementation instance.
            </summary>
            <param name="chiralAtom">The chiral <see cref="T:NCDK.IAtom"/>.</param>
            <param name="ligandAtoms">The ligand atoms around the chiral atom.</param>
            <param name="chirality">The <see cref="P:NCDK.Stereo.TetrahedralChirality.Stereo"/> chirality.</param>
        </member>
        <member name="P:NCDK.Stereo.TetrahedralChirality.Ligands">
            <summary>
            An array of ligand atoms around the chiral atom.
            </summary>
        </member>
        <member name="P:NCDK.Stereo.TetrahedralChirality.ChiralAtom">
            <summary>
            Atom that is the chirality center.
            </summary>
        </member>
        <member name="P:NCDK.Stereo.TetrahedralChirality.Stereo">
            <summary>
            Defines the stereochemistry around the chiral atom. The value depends on the order of ligand atoms.
            </summary>
        </member>
        <member name="T:NCDK.Stereo.DoubleBondStereochemistry">
            <summary>
            Stereochemistry specification for double bonds. See <see cref="T:NCDK.IDoubleBondStereochemistry"/> for
            further details.
            </summary>
            <seealso cref="T:NCDK.IDoubleBondStereochemistry"/>
        </member>
        <member name="M:NCDK.Stereo.DoubleBondStereochemistry.#ctor(NCDK.IBond,System.Collections.Generic.IEnumerable{NCDK.IBond},NCDK.DoubleBondConformation)">
            <summary>
            Creates a new double bond stereo chemistry. The path of length three is defined by
            <c>ligandBonds[0]</c>, <c>stereoBonds</c>, and <c>ligandBonds[1]</c>.
            </summary>
        </member>
        <member name="T:NCDK.Stereo.CyclicCarbohydrateRecognition">
            <summary>
            Recognise stereochemistry of Haworth, Chair, and Boat (not yet implemented)
            projections. These projections are a common way of depicting closed-chain
            (furanose and pyranose) carbohydrates and require special treatment to
            interpret stereo conformation. 
            <para>
            The methods used are described by <token>cdk-cite-batchelor13</token>. 
            </para>
            </summary>
            <seealso href="http://en.wikipedia.org/wiki/Haworth_projection">Haworth projection (Wikipedia)</seealso>
            <seealso href="http://en.wikipedia.org/wiki/Chair_conformation">Chair conformation (Wikipedia)</seealso>
        </member>
        <member name="F:NCDK.Stereo.CyclicCarbohydrateRecognition.CardinalityThreshold">
            <summary>
            The threshold at which to snap bonds to the cardinal direction. The
            threshold allows bonds slightly of absolute directions to be interpreted.
            The tested vector is of unit length and so the threshold is simply the
            angle (in radians).
            </summary>
        </member>
        <member name="M:NCDK.Stereo.CyclicCarbohydrateRecognition.#ctor(NCDK.IAtomContainer,System.Int32[][],NCDK.Graphs.GraphUtil.EdgeToBondMap,NCDK.Stereo.Stereocenters)">
            <summary>
            Required information to recognise stereochemistry.
            </summary>
            <param name="container">input structure</param>
            <param name="graph">adjacency list representation</param>
            <param name="bonds">edge to bond index</param>
            <param name="stereocenters">location and type of asymmetries</param>
        </member>
        <member name="M:NCDK.Stereo.CyclicCarbohydrateRecognition.Recognise(System.Collections.Generic.ICollection{NCDK.Stereo.Projection})">
            <summary>
            Recognise the cyclic carbohydrate projections.
            </summary>
            <param name="projections">the types of projections to recognise</param>
            <returns>recognised stereocenters</returns>
        </member>
        <member name="M:NCDK.Stereo.CyclicCarbohydrateRecognition.GetTurns(NCDK.Numerics.Vector2[])">
            <summary>
            Determine the turns in the polygon formed of the provided coordinates.
            </summary>
            <param name="points">polygon points</param>
            <returns>array of turns (left, right) or null if a parallel line was found</returns>
        </member>
        <member name="M:NCDK.Stereo.CyclicCarbohydrateRecognition.AssignSubstituents(System.Int32[],System.Int32[],System.Int32[],NCDK.Stereo.CyclicCarbohydrateRecognition.WoundProjection,NCDK.Numerics.Vector2)">
            <summary>
            Given a projected cycle, assign the exocyclic substituents to being above
            of below the projection. For Haworth projections, the substituents must
            be directly up or down (within some threshold).
            </summary>
            <param name="cycle">vertices that form a cycle</param>
            <param name="above">vertices that will be above the cycle (filled by method)</param>
            <param name="below">vertices that will be below the cycle (filled by method)</param>
            <param name="projection">the type of projection</param>
            <param name="horizontalXy">offset from the horizontal axis</param>
            <returns>assignment okay (true), not okay (false)</returns>
        </member>
        <member name="M:NCDK.Stereo.CyclicCarbohydrateRecognition.NewTetrahedralCenters(System.Int32[],System.Int32[],System.Int32[],NCDK.Stereo.CyclicCarbohydrateRecognition.WoundProjection)">
            <summary>
            Create the tetrahedral stereocenters for the provided cycle.
            </summary>
            <param name="cycle">vertices in projected cycle</param>
            <param name="above">vertices above the cycle</param>
            <param name="below">vertices below the cycle</param>
            <param name="type">type of projection</param>
            <returns>zero of more stereocenters</returns>
        </member>
        <member name="M:NCDK.Stereo.CyclicCarbohydrateRecognition.CoordinatesOfCycle(System.Int32[],NCDK.IAtomContainer)">
            <summary>
            Obtain the coordinates of atoms in a cycle.
            </summary>
            <param name="cycle">vertices that form a cycles</param>
            <param name="container">structure representation</param>
            <returns>coordinates of the cycle</returns>
        </member>
        <member name="M:NCDK.Stereo.CyclicCarbohydrateRecognition.Filter(System.Int32[],System.Int32,System.Int32)">
            <summary>
            Filter an array, excluding two provided values. These values must be
            present in the input.
            </summary>
            <param name="org">input array</param>
            <param name="skip1">skip this item</param>
            <param name="skip2">skip this item also</param>
            <returns>array without skip1 and skip2</returns>
        </member>
        <member name="M:NCDK.Stereo.CyclicCarbohydrateRecognition.ObtainDirection(NCDK.Numerics.Vector2,NCDK.Numerics.Vector2,NCDK.Numerics.Vector2,System.Boolean)">
            <summary>
            Obtain the direction of a substituent relative to the center location. In
            a Haworth projection the substituent must be directly above or below
            (with threshold) the center.
            </summary>
            <param name="centerXy">location of center</param>
            <param name="substituentXy">location fo substituent</param>
            <param name="horizontalXy">horizontal offset, x > 0</param>
            <param name="haworth">is Haworth project (substituent must be directly up or down)</param>
            <returns>the direction (up, down, other)</returns>
        </member>
        <member name="M:NCDK.Stereo.CyclicCarbohydrateRecognition.CheckHaworthAlignment(NCDK.Numerics.Vector2[])">
            <summary>
            Ensures at least one cyclic bond is horizontal.
            </summary>
            <param name="points">the points of atoms in the ring</param>
            <returns>whether the Haworth alignment is correct</returns>
        </member>
        <member name="M:NCDK.Stereo.CyclicCarbohydrateRecognition.HorizontalOffset(NCDK.Numerics.Vector2[],NCDK.Stereo.CyclicCarbohydrateRecognition.Turns[],NCDK.Stereo.Projection)">
            <summary>
            Determine the horizontal offset of the projection. This allows
            projections that are drawn at angle to be correctly interpreted. 
            Currently only projections of chair conformations are considered.
            </summary>
            <param name="points">points of the cycle</param>
            <param name="turns">the turns in the cycle (left/right)</param>
            <param name="projection">the type of projection</param>
            <returns>the horizontal offset</returns>
        </member>
        <member name="M:NCDK.Stereo.CyclicCarbohydrateRecognition.ChairCenterOffset(NCDK.Stereo.CyclicCarbohydrateRecognition.Turns[])">
            <summary>
            Determines the center index offset for the chair projection. The center
            index is that of the two atoms with opposite turns (fewest). For, LLRLLR
            the two centers are R and the index is 2 (first is in position 2). 
            </summary>
            <param name="turns">calculated turns in the chair projection</param>
            <returns>the offset</returns>
        </member>
        <member name="M:NCDK.Stereo.CyclicCarbohydrateRecognition.IsPlanarSigmaBond(NCDK.IBond)">
            <summary>
            Helper method determines if a bond is defined (not null) and whether it
            is a sigma (single) bond with no stereo attribute (wedge/hatch).
            </summary>
            <param name="bond">the bond to test</param>
            <returns>the bond is a planar sigma bond</returns>
        </member>
        <member name="T:NCDK.Stereo.CyclicCarbohydrateRecognition.Direction">
            <summary>
            Direction of substituent relative to ring atom.
            </summary>
        </member>
        <member name="T:NCDK.Stereo.CyclicCarbohydrateRecognition.Turns">
            <summary>
            Turns, recorded when walking around the cycle.
            </summary>
        </member>
        <member name="T:NCDK.Stereo.CyclicCarbohydrateRecognition.WoundProjection">
            <summary>
            Pairing of Projection + Winding. The wound projection is determined
            from an array of turns.
            </summary>
        </member>
        <member name="T:NCDK.Stereo.ExtendedTetrahedral">
            <summary>
            Extended tetrahedral configuration. Defines the winding configuration in
            a system with an even number of cumulated pi bonds. Examples include,
            (R)-laballenic acid (CHEBI:38401) and (S)-laballenic acid (CHEBI:38402).
            </summary>
            <remarks>
            <para>
            The extended tetrahedral stereochemistry can be represented and handled the
            same as normal tetrahedral stereochemistry. However the handling of the
            neighbours is subtly different. To assist in the description here are how
            atoms are referred to.
            </para>
            <pre>
            p0           p2     p&lt;i&gt;: periphals
             \          /       t&lt;i&gt;: terminals
              t0 = f = t1       f:    focus
             /          \
            p1           p3
            </pre>
            <para>
            The data structure stores, the central 'focus' atom and the four peripheral
            atoms. The peripheral atoms are stored in a single array, <c>{p0, p1,
            p2, p3}</c>, the first two and last two entries should be attached to the same
            terminal atom (t0 or t1). For convenience the terminal atoms can be found with
            <see cref="M:NCDK.Stereo.ExtendedTetrahedral.FindTerminalAtoms(NCDK.IAtomContainer)"/> .
            </para>
            <pre>
            p0           p2          p0   p2
             \          /              \ /
              t0 = f = t1       -->     c       c: t0/f/t1
             /          \              / \
            p1           p3           p1  p3
            </pre>
            <para>
            The configuration treats the focus and terminal atoms as a single atom, the
            neighbours <c>{p1, p2, p3}</c> then proceeded either clockwise or
            anti-clockwise when the centre (t0/f/t1) is viewed from the first peripheral
            atom <c>p0</c>.
            </para>
            <para>
            If any of the peripherals are implicit hydrogen atoms, then the terminal atom
            to which the hydrogen is attached can be used as a placeholder.
            </para>
            </remarks>
        </member>
        <member name="M:NCDK.Stereo.ExtendedTetrahedral.#ctor(NCDK.IAtom,NCDK.IAtom[],NCDK.TetrahedralStereo)">
            <summary>
            Create an extended tetrahedral stereo element for the provided 'focus'
            and 'peripherals' in the given 'winding'. See class documentation an
            annotated storage description.
            </summary>
            <param name="focus">the central cumulated atom</param>
            <param name="peripherals">atoms attached to the terminal atoms</param>
            <param name="winding">the configuration</param>
        </member>
        <member name="P:NCDK.Stereo.ExtendedTetrahedral.Focus">
            <summary>
            The central atom in the cumulated system.
            </summary>
            <returns>the focus</returns>
        </member>
        <member name="P:NCDK.Stereo.ExtendedTetrahedral.Peripherals">
            <summary>
            The neighbouring peripherals atoms, these are attached to the terminal
            atoms in the cumulated system.
            </summary>
            <returns>the peripheral atoms</returns>
        </member>
        <member name="P:NCDK.Stereo.ExtendedTetrahedral.Winding">
            <summary>
            The winding of the peripherals, when viewed from the first atom.
            </summary>
            <returns>winding configuration</returns>
        </member>
        <member name="M:NCDK.Stereo.ExtendedTetrahedral.FindTerminalAtoms(NCDK.IAtomContainer,NCDK.IAtom)">
            <summary>
            Helper method to locate two terminal atoms in a container for a given
            focus.
            </summary>
            <param name="container">structure representation</param>
            <param name="focus">cumulated atom</param>
            <returns>the terminal atoms (unordered)</returns>
        </member>
        <member name="M:NCDK.Stereo.ExtendedTetrahedral.FindTerminalAtoms(NCDK.IAtomContainer)">
            <summary>
            Helper method to locate two terminal atoms in a container for this
            extended tetrahedral element. The atoms are ordered such that the first
            index is attached to the first two peripheral atoms and the second index
            is attached to the second two peripheral atoms.
            </summary>
            <param name="container">structure representation</param>
            <returns>the terminal atoms (ordered)</returns>
        </member>
        <member name="P:NCDK.Stereo.ExtendedTetrahedral.Builder">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Stereo.FischerRecognition">
            <summary>
            Recognize the configuration of tetrahedral stereocenters depicted as
            Fischer projection. Fischer projection is a convenient means of depicting
            3D geometry commonly used in depicting carbohydrates. 
            </summary>
            <remarks>
            <para>
            Fischer projection depicts tetrahedral stereocenters as though they were 
            coplanar with the four substituents at cardinal directions (up,right,down, 
            and left). The horizontal bonds (right and left) are interpreted as pointing
            out of the plane towards the viewer; They are not depicted with non-planar
            wedge bonds.</para>
            <para>
            This class provides the recognition of Fischer projections. Each asymmetric
            carbon is checked as to whether it's 2D depiction is coplanar with cardinal
            directions. All of these bonds must be planar (i.e. not wedge or hatch) and
            sigma bonds. In a hydrogen suppressed representation, one of the left or 
            right bonds (to the implied hydrogen) may be omitted but can be correctly
            interpreted.</para>
            </remarks>
            <seealso href="http://en.wikipedia.org/wiki/Fischer_projection">Fischer projection (Wikipedia)</seealso>
        </member>
        <member name="F:NCDK.Stereo.FischerRecognition.CARDINALITY_THRESHOLD">
            <summary>
            The threshold at which to snap bonds to the cardinal direction. The
            threshold allows bonds slightly of absolute directions to be interpreted.
            The tested vector is of unit length and so the threshold is simply the
            angle (in radians).
            </summary>
        </member>
        <member name="F:NCDK.Stereo.FischerRecognition.NORTH">
            <summary>Cardinal direction, North index.</summary>
        </member>
        <member name="F:NCDK.Stereo.FischerRecognition.EAST">
            <summary>Cardinal direction, East index.</summary>
        </member>
        <member name="F:NCDK.Stereo.FischerRecognition.SOUTH">
            <summary>Cardinal direction, South index.</summary>
        </member>
        <member name="F:NCDK.Stereo.FischerRecognition.WEST">
            <summary>Cardinal direction, West index.</summary>
        </member>
        <member name="M:NCDK.Stereo.FischerRecognition.#ctor(NCDK.IAtomContainer,System.Int32[][],NCDK.Graphs.GraphUtil.EdgeToBondMap,NCDK.Stereo.Stereocenters)">
             <summary>
             Required information to recognise stereochemistry.
            
             <param name="container">input structure</param>
             <param name="graph">adjacency list representation</param>
             <param name="bonds">edge to bond index</param>
             <param name="stereocenters">location and type of asymmetries</param>
             </summary>
        </member>
        <member name="M:NCDK.Stereo.FischerRecognition.Recognise(System.Collections.Generic.ICollection{NCDK.Stereo.Projection})">
             <summary>
             Recognise the tetrahedral stereochemistry in the provided structure.
            
             <param name="projections">allowed projection types</param>
             <returns>zero of more stereo elements</returns>
             </summary>
        </member>
        <member name="M:NCDK.Stereo.FischerRecognition.NewTetrahedralCenter(NCDK.IAtom,NCDK.IBond[])">
            <summary>
            Create a new tetrahedral stereocenter of the given focus and neighboring
            bonds. This is an internal method and is presumed the atom can support
            tetrahedral stereochemistry and it has three or four explicit neighbors. 
            
            The stereo element is only created if the local arrangement looks like
            a Fischer projection. 
            
            <param name="focus">central atom</param>
            <param name="bonds">adjacent bonds</param>
            <returns>a stereo element, or null if one could not be created</returns>
            </summary>
        </member>
        <member name="M:NCDK.Stereo.FischerRecognition.CardinalBonds(NCDK.IAtom,NCDK.IBond[])">
             <summary>
             Arrange the bonds adjacent to an atom (focus) in cardinal direction. The
             cardinal directions are that of a compass. Bonds are checked as to
             whether they are horizontal or vertical within a predefined threshold.
            
             <param name="focus">an atom</param>
             <param name="bonds">bonds adjacent to the atom</param>
             <returns>array of bonds organised (N,E,S,W), or null if a bond was found</returns>
             that exceeded the threshold
             </summary>
        </member>
        <member name="M:NCDK.Stereo.FischerRecognition.IsTerminal(NCDK.IAtom,System.Collections.Generic.IDictionary{NCDK.IAtom,System.Int32})">
             <summary>
             Is the atom terminal having only one connection.
            
             <param name="atom">an atom</param>
             <param name="atomToIndex">a map of atoms to index</param>
             <returns>the atom is terminal</returns>
             </summary>
        </member>
        <member name="M:NCDK.Stereo.FischerRecognition.IsPlanarSigmaBond(NCDK.IBond)">
            <summary>
            Helper method determines if a bond is defined (not null) and whether
            it is a sigma (single) bond with no stereo attribute (wedge/hatch).
            
            <param name="bond">the bond to test</param>
            <returns>the bond is a planar sigma bond</returns>
            </summary>
        </member>
        <member name="M:NCDK.Stereo.FischerRecognition.Neighbors(System.Int32,System.Int32[][],NCDK.Graphs.GraphUtil.EdgeToBondMap)">
             <summary>
             Helper method to obtain the neighbouring bonds from an adjacency list
             graph and edge->bond map.
            
             <param name="v">vertex</param>
             <param name="g">graph (adj list)</param>
             <param name="bondMap">map of edges to bonds</param>
             <returns>neighboring bonds</returns>
             </summary>
        </member>
        <member name="T:NCDK.Stereo.Stereocenters">
            <summary>
            Find atoms which can support stereo chemistry based on the connectivity.
            Stereocenters are classified as <i>True</i> when they have constitutionally
            different ligands and <i>Para</i> ("resemble") stereo centers with
            constitutionally identical ligands. Some examples of para-centers
            are listed below. Non and potential stereogenic atoms are also indicated. The
            method partially implements the rules described by <token>cdk-cite-Razinger93</token>.
            Para centers are identified in isolated rings (more common) but are not
            currently found in fused systems (e.g. decalin), spiro linked 'assemblages'
            or acyclic interdependent centers. 
            </summary>
            <remarks>
            <para><b>Accepted Stereo Atoms</b></para>
            <para>
            This atoms accepted as being potentially stereogenic are those defined
            in the InChI Technical Manual <token>cdk-cite-InChITechManual</token>. These are: 
            </para>
            <para>
            <b>Tetrahedral Stereochemistry:</b>
            <list type="bullet">
                <item>Carbon - 4 valent, 4 sigma bonds</item>
                <item>Silicon - 4 valent, 4 sigma bonds</item>
                <item>Germanium - 4 valent, 4 sigma bonds</item>
                <item>Tin - 4 valent, 4 sigma bonds</item>
                <item>Nitrogen cation - 4 valent,4 sigma bonds</item>
                <item>Phosphorus cation - 4 valent, 4 sigma bonds</item>
                <item>Arsenic cation - 4 valent, 4 sigma bonds</item>
                <item>Boron anion - 4 valent, 4 sigma bonds</item>
                <item>Nitrogen - 5 valent, 3 sigma and 1 pi bond</item>
                <item>Phosphorus - 5 valent, 3 sigma and 1 pi bond</item>
                <item>Sulphur - 4 valent, 2 sigma and 1 pi bond</item>
                <item>Sulphur - 6 valent, 2 sigma and 2 pi bonds</item>
                <item>Sulphur Cation - 3 valent, 3 sigma bonds</item>
                <item>Sulphur cation - 5 valent, 3 sigma and 1 pi bond</item>
                <item>Selenium - 4 valent, 2 sigma and 1 pi bond</item>
                <item>Selenium - 6 valent, 2 sigma and 2 pi bonds</item>
                <item>Selenium Cation - 3 valent, 3 sigma bonds</item>
                <item>Selenium cation - 5 valent, 3 sigma and 1 pi bond</item>
                <item>Nitrogen - 3 valent, 3 sigma bonds and in a 3 member ring</item>
            </list>
            </para>
            <para>
            <i>N, P, As, S or Se are not stereogenic if they have a terminal H neighbor
            or if they have 2 neighbors of the same element (O, S, Se, Te, N) which
            have at least one hydrogen. Consider: <pre>P(O)(=O)(OC)OCCC</pre>. Phosphines and
            arsines are always stereogenic regardless of H neighbors</i>
            </para>
            <para>
            <b>Double Bond Stereochemistry:</b>
            The following atoms can appear at either end of a double bond.
            <list type="bullet">
                <item>Carbon - 4 valent, 2 sigma and 1 pi bond</item>
                <item>Silicon - 4 valent, 2 sigma and 1 pi bond</item>
                <item>Germanium - 4 valent, 2 sigma and 1 pi bond</item>
                <item>Nitrogen - 3 valent, 1 sigma and 1 pi bond</item>
                <item>Nitrogen cation - 4 valent, 2 sigma and 1 pi bond</item>
            </list>
            </para>
            <para>
            <b>Examples of Para Stereocenters</b>
            <list type="bullet"> 
            <item>inositol - has 9 stereo isomers, <pre>O[C@H]1[C@H](O)[C@@H](O)[C@H](O)[C@H](O)[C@@H]1O myo-inositol</pre></item> 
            <item>decalin - has 2 stereo isomers, <pre>C1CC[C@H]2CCCC[C@H]2C1</pre> (not currently identified)</item> 
            <item>spiro/double-bond linked ring - <pre>InChI=1/C14H24/c1-11-3-7-13(8-4-11)14-9-5-12(2)6-10-14/h11-12H,3-10H2,1-2H3/b14-13-/t11-,12-</pre> (not currently identified)</item> 
            <item>An example of a para-center not in a cycle <pre>C[C@@H](O)[C@H](C)[C@H](C)O</pre> (not currently identified)</item>
            </list>
            </para>
            <para>
            It should be noted that para-centers may not actually have a configuration. A
            simple example of this is seen that by changing the configuration of one
            center in <pre>C[C@@H](O)[C@H:1](C)[C@H](C)O</pre> removes the central
            configuration as the ligands are now equivalent <pre>C[C@@H](O)[CH:1]](C)[C@@H](C)O</pre>
            </para>
            </remarks>
        </member>
        <member name="F:NCDK.Stereo.Stereocenters.container">
            <summary>native CDK structure representation.</summary>
        </member>
        <member name="F:NCDK.Stereo.Stereocenters.g">
            <summary>adjacency list representation for fast traversal.</summary>
        </member>
        <member name="F:NCDK.Stereo.Stereocenters.bondMap">
            <summary>lookup bonds by the index of their atoms.</summary>
        </member>
        <member name="F:NCDK.Stereo.Stereocenters.stereocenters">
            <summary>the type of stereo center - indexed by atom.</summary>
        </member>
        <member name="F:NCDK.Stereo.Stereocenters.elements">
            <summary>the stereo elements - indexed by atom.</summary>
        </member>
        <member name="F:NCDK.Stereo.Stereocenters.ringSearch">
            <summary>basic cycle information (i.e. is atom/bond cyclic) and cycle systems.</summary>
        </member>
        <member name="M:NCDK.Stereo.Stereocenters.Of(NCDK.IAtomContainer)">
            <summary>
            Determine the stereocenter atoms in the provided container based on connectivity.
            </summary>
            <example>
            <code>            IAtomContainer container = someContainer;
            Stereocenters centers = Stereocenters.Of(container);
            for (int i = 0; i &lt; container.Atoms.Count; i++)
            {
                if (centers.IsStereocenter(i))
                {

                }
            }
</code>
            </example>
            <param name="container">input container</param>
            <returns>the stereocenters</returns>
        </member>
        <member name="M:NCDK.Stereo.Stereocenters.#ctor(NCDK.IAtomContainer,System.Int32[][],NCDK.Graphs.GraphUtil.EdgeToBondMap)">
            <summary>
            Create a perception method for the provided container, graph
            representation and bond map.
            </summary>
            <param name="container">native CDK structure representation</param>
            <param name="graph">graph representation (adjacency list)</param>
            <param name="bondMap">fast lookup bonds by atom index</param>
        </member>
        <member name="M:NCDK.Stereo.Stereocenters.ElementType(System.Int32)">
            <summary>
            Obtain the type of stereo element support for atom at index <paramref name="v"/>.
            Supported elements types are:
            <list type="bullet"> 
            <item><see cref="F:NCDK.Stereo.Stereocenters.CoordinateTypes.Bicoordinate"/> - an central atom involved in a cumulated system (not yet supported)</item> 
            <item><see cref="F:NCDK.Stereo.Stereocenters.CoordinateTypes.Tricoordinate"/> - an atom at one end of a geometric (double-bond) stereo bond or cumulated system.</item>
            <item><see cref="F:NCDK.Stereo.Stereocenters.CoordinateTypes.Tetracoordinate"/> - a tetrahedral atom (could also be square planar in future)</item>
            <item><see cref="F:NCDK.Stereo.Stereocenters.CoordinateTypes.None"/> - the atom is not a (supported) stereo element type.</item>
            </list>
            </summary>
            <param name="v">atom index (vertex)</param>
            <returns>the type of element</returns>
        </member>
        <member name="M:NCDK.Stereo.Stereocenters.IsStereocenter(System.Int32)">
            <summary>
            Is the atom be a stereocenter (i.e. <see cref="F:NCDK.Stereo.Stereocenters.CenterTypes.True"/> or <see cref="F:NCDK.Stereo.Stereocenters.CenterTypes.Para"/>).
            </summary>
            <param name="v">atom index (vertex)</param>
            <returns>the atom at index <paramref name="v"/> is a stereocenter</returns>
        </member>
        <member name="M:NCDK.Stereo.Stereocenters.StereocenterType(System.Int32)">
            <summary>
            Determine the type of stereocenter is the atom at index <paramref name="v"/>.
            <list type="bullet"> 
            <item><see cref="F:NCDK.Stereo.Stereocenters.CenterTypes.True"/> - the atom has constitutionally different neighbors</item> 
            <item><see cref="F:NCDK.Stereo.Stereocenters.CenterTypes.Para"/> - the atom resembles a stereo centre but has constitutionally equivalent neighbors
            (e.g. inositol, decalin). The stereocenter depends on the configuration of one or more stereocenters.</item> 
            <item><see cref="F:NCDK.Stereo.Stereocenters.CenterTypes.Potential"/> - the atom can supported stereo chemistry but has not be shown ot be a true or para center.</item> 
            <item><see cref="F:NCDK.Stereo.Stereocenters.CenterTypes.Non"/> - the atom is not a stereocenter (e.g. methane).</item>
            </list>
            </summary>
            <param name="v">atom index.</param>
            <returns>the type of stereocenter</returns>
        </member>
        <member name="M:NCDK.Stereo.Stereocenters.CreateElements">
            <summary>
            Create <see cref="T:NCDK.Stereo.Stereocenters.StereoElement"/>
            instance for atoms which support stereochemistry. Each new element is
            considered a potential stereo center - any atoms which have not been
            assigned an element are non stereo centers.
            </summary>
            <returns>the number of elements created</returns>
        </member>
        <member name="M:NCDK.Stereo.Stereocenters.LabelTrueCenters(System.Int32[])">
            <summary>
            Labels true stereocenters where all neighbors are constitutionally
            different. Potential stereocenters where all constitutionally equivalent
            neighbors are terminal (consider [C@H](C)(C)N) are also eliminated.
            </summary>
            <param name="symmetry">symmetry classes of the atoms</param>
        </member>
        <member name="M:NCDK.Stereo.Stereocenters.LabelIsolatedPara(System.Int32[])">
            <summary>
            Labels para stereocenter in isolated rings. Any elements which are now
            known to not be stereo centers are also eliminated.
            </summary>
            <param name="symmetry">the symmetry classes of each atom</param>
        </member>
        <member name="M:NCDK.Stereo.Stereocenters.SupportedType(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Determine the type of stereo chemistry (if any) which could be supported
            by the atom at index 'i'. The rules used to define the types of
            stereochemistry are encoded from the InChI Technical Manual.
            </summary>
            <param name="i">atom index</param>
            <param name="v">valence</param>
            <param name="h">hydrogen</param>
            <param name="x">connectivity</param>
            <returns>type of stereo chemistry</returns>
        </member>
        <member name="M:NCDK.Stereo.Stereocenters.VerifyTerminalHCount(System.Int32)">
            <summary>
            Verify that there are is not 2 terminal heavy atoms (of the same element)
            which have a hydrogen count > 0. This follows the InChI specification
            that - An atom or positive ion N, P, As, S, or Se is not treated as
            stereogenic if it has (a) A terminal H atom neighbor or (b) At least two
            terminal neighbors, XHm and XHn, (n+m>0) connected by any kind of bond,
            where X is O, S, Se, Te, or N. This avoids the issue that under
            Cahn-Ingold-Prelog (or canonicalisation) the oxygens in 'P(=O)(O)(*)*'
            would not be found to be equivalent and a parity/winding would be
            assigned.
            </summary>
            <param name="v">the vertex (atom index) to check</param>
            <returns>the atom does not have > 2 terminal neighbors with a combined hydrogen count of > 0</returns>
        </member>
        <member name="M:NCDK.Stereo.Stereocenters.IndexNeighbor(NCDK.IAtom)">
            <summary>
            Index the atom by element to a number between 0-5. This allows us to
            quickly count up neighbors we need to and the ignore those we don't
            (defaults to 0).
            </summary>
            <param name="atom">an atom to get the element index of</param>
            <returns>the element index</returns>
        </member>
        <member name="M:NCDK.Stereo.Stereocenters.InThreeMemberRing(System.Int32)">
            <summary>
            Check if the atom at index <paramref name="v"/> is a member of a small ring
            (n=3). This is the only time a 3 valent nitrogen is allowed by InChI to
            be potentially stereogenic.
            </summary>
            <param name="v">atom index</param>
            <returns>the atom is a member of a 3 member ring</returns>
        </member>
        <member name="M:NCDK.Stereo.Stereocenters.GetAtomicNumber(NCDK.IAtom)">
            <summary>
            Safely obtain the atomic number of an atom. If the atom has undefined
            atomic number and is not a pseudo-atom it is considered an error. Pseudo
            atoms with undefined atomic number default to 0.
            </summary>
            <param name="a">an atom</param>
            <returns>the atomic number of the atom</returns>
        </member>
        <member name="M:NCDK.Stereo.Stereocenters.Charge(NCDK.IAtom)">
            <summary>
            Safely obtain the formal charge on an atom. If the atom had undefined
            formal charge it is considered as neutral (0).
            </summary>
            <param name="a">an atom</param>
            <returns>the formal charge</returns>
        </member>
        <member name="M:NCDK.Stereo.Stereocenters.ToIntArray(System.Int64[])">
            <summary>
            Convert an array of long (64-bit) values to an array of (32-bit)
            integrals.
            </summary>
            <param name="org">the original array of values</param>
            <returns>the array cast to int values</returns>
        </member>
        <member name="T:NCDK.Stereo.Stereocenters.CenterTypes">
            <summary>Defines the type of a stereocenter.</summary>
        </member>
        <member name="F:NCDK.Stereo.Stereocenters.CenterTypes.True">
            <summary>Atom is a true stereo-centre.</summary>
        </member>
        <member name="F:NCDK.Stereo.Stereocenters.CenterTypes.Para">
            <summary>Atom resembles a stereo-centre (para).</summary>
        </member>
        <member name="F:NCDK.Stereo.Stereocenters.CenterTypes.Potential">
            <summary>Atom is a potential stereo-centre</summary>
        </member>
        <member name="F:NCDK.Stereo.Stereocenters.CenterTypes.Non">
            <summary>Non stereo-centre.</summary>
        </member>
        <member name="F:NCDK.Stereo.Stereocenters.CoordinateTypes.Bicoordinate">
            <summary>An atom within a cumulated system. (not yet supported)</summary>
        </member>
        <member name="F:NCDK.Stereo.Stereocenters.CoordinateTypes.Tricoordinate">
            <summary>
            A potentially stereogenic atom with 3 neighbors - one atom in a
            geometric centres or cumulated system (allene, cumulene).
            </summary>
        </member>
        <member name="F:NCDK.Stereo.Stereocenters.CoordinateTypes.Tetracoordinate">
            <summary>
            A potentially stereogenic atom with 4 neighbors - tetrahedral
            centres.
            </summary>
        </member>
        <member name="F:NCDK.Stereo.Stereocenters.CoordinateTypes.None">
            <summary>A non-stereogenic atom.</summary>
        </member>
        <member name="T:NCDK.Stereo.Stereocenters.StereoElement">
            <summary>
            Internal stereo element representation. We need to define the sides of a
            double bond separately and want to avoid reflection (is) by using
            a type parameter. We also store the neighbors we need to check for
            equivalence directly.
            </summary>
        </member>
        <member name="T:NCDK.Stereo.Stereocenters.Bicoordinate">
            <summary>Represents a tetrahedral stereocenter with 2 neighbors.</summary>
        </member>
        <member name="T:NCDK.Stereo.Stereocenters.Tetracoordinate">
            <summary>Represents a tetrahedral stereocenter with 3 or 4 neighbors.</summary>
        </member>
        <member name="T:NCDK.Stereo.Stereocenters.Tricoordinate">
            <summary>
            Represents one end of a double bond. The element only stores non-double
            bonded neighbors and also indexes it's <see cref="F:NCDK.Stereo.Stereocenters.Tricoordinate.other"/> end.
            </summary>
        </member>
        <member name="M:NCDK.Stereo.Stereocenters.Tricoordinate.#ctor(System.Int32,System.Int32,System.Int32[])">
            <summary>
            Create a tri-coordinate atom for one end of a double bond. Two
            elements need to be created which reference each other.
            </summary>
            <param name="v">the focus of this end</param>
            <param name="w">the double bonded other end of the element</param>
            <param name="neighbors">the neighbors of v</param>
        </member>
        <member name="T:NCDK.Stereo.StereoElementFactory">
             <summary>
             Create stereo elements for a structure with 2D and 3D coordinates. The
             factory does not verify whether atoms can or cannot support stereochemistry -
             for this functionality use <see cref="T:NCDK.Stereo.Stereocenters" />. The factory will not create
             stereo elements if there is missing information (wedge/hatch bonds, undefined
             coordinates) or the layout indicates unspecified configuration.
            
             Stereocenters specified with inverse down (hatch) bond style are created if
             the configuration is unambiguous and the bond does not connect to another
             stereocenter.
             </summary>
             <example>
             <code>                IAtomContainer container = someMolecule;
                StereoElementFactory stereo = StereoElementFactory.Using2DCoordinates(container).InterpretProjections(Projection.Haworth);

                // set the elements replacing any existing elements (recommended)
                container.SetStereoElements(stereo.CreateAll());

                // adding elements individually is no recommended as the AtomContainer
                // does not check for duplicate or contradicting elements
                foreach (var element in stereo.CreateAll())
                    container.StereoElements.Add(element); // bad, there may already be elements
</code>
             </example>
             <seealso cref="T:NCDK.Stereo.Stereocenters" />
        </member>
        <member name="F:NCDK.Stereo.StereoElementFactory.container">
            <summary>Native CDK structure representation.</summary>
        </member>
        <member name="F:NCDK.Stereo.StereoElementFactory.graph">
            <summary>Adjacency list graph representation.</summary>
        </member>
        <member name="F:NCDK.Stereo.StereoElementFactory.bondMap">
            <summary>A bond map for fast access to bond labels between two atom indices.</summary>
        </member>
        <member name="M:NCDK.Stereo.StereoElementFactory.#ctor(NCDK.IAtomContainer,System.Int32[][],NCDK.Graphs.GraphUtil.EdgeToBondMap)">
            <summary>
            Internal constructor.
            </summary>
            <param name="container">an atom container</param>
            <param name="graph">adjacency list representation</param>
            <param name="bondMap">lookup bonds by atom index</param>
        </member>
        <member name="M:NCDK.Stereo.StereoElementFactory.CreateAll">
            <summary>
            Creates all stereo elements found by <see cref="T:NCDK.Stereo.Stereocenters"/> using the or
            2D/3D coordinates to specify the configuration (clockwise/anticlockwise).
            Currently only <see cref="T:NCDK.ITetrahedralChirality"/> and <see cref="T:NCDK.IDoubleBondStereochemistry"/> 
            elements are created..
            </summary>
            <returns>a list of stereo elements</returns>
        </member>
        <member name="M:NCDK.Stereo.StereoElementFactory.CreateTetrahedral(System.Int32,NCDK.Stereo.Stereocenters)">
            <summary>
            Create a tetrahedral element for the atom at index <paramref name="v" />. If a
            tetrahedral element could not be created then null is returned. An
            element can not be created if, one or more atoms was missing coordinates,
            the atom has an unspecified (wavy) bond, the atom is no non-planar bonds
            (i.e. up/down, wedge/hatch). The method does not check if tetrahedral
            chirality is supported - for this functionality use <see cref="T:NCDK.Stereo.Stereocenters" />.
            </summary>
            <example>
            <code>                StereoElementFactory factory = someFactory; // 2D/3D
                IAtomContainer container = someMolecule; // container

                for (int v = 0; v &lt; container.Atoms.Count; v++)
                {
                    // ... verify v is a stereo atom ...
                    ITetrahedralChirality element = factory.CreateTetrahedral(v, null);
                    if (element != null)
                        container.StereoElements.Add(element);
                }
</code>
            </example>
            <param name="v">atom index (vertex)</param>
            <returns>a new stereo element</returns>
        </member>
        <member name="M:NCDK.Stereo.StereoElementFactory.CreateTetrahedral(NCDK.IAtom,NCDK.Stereo.Stereocenters)">
            <summary>
            Create a tetrahedral element for the atom. If a tetrahedral element could
            not be created then null is returned. An element can not be created if,
            one or more atoms was missing coordinates, the atom has an unspecified
            (wavy) bond, the atom is no non-planar bonds (i.e. up/down, wedge/hatch).
            The method does not check if tetrahedral chirality is supported - for
            this functionality use <see cref="T:NCDK.Stereo.Stereocenters" />.
            </summary>
            <example>
            <code>                StereoElementFactory factory = someFactory; // 2D/3D
                IAtomContainer container = someMolecule; // container

                foreach (var atom in container.Atoms)
                {
                    // ... verify atom is a stereo atom ...
                    ITetrahedralChirality element = factory.CreateTetrahedral(atom, null);
                    if (element != null)
                        container.StereoElements.Add(element);
                }
</code>
            </example>
            <param name="atom">atom</param>
            <returns>a new stereo element</returns>
        </member>
        <member name="M:NCDK.Stereo.StereoElementFactory.CreateGeometric(System.Int32,System.Int32,NCDK.Stereo.Stereocenters)">
            <summary>
            Create a geometric element (double-bond stereochemistry) for the provided
            atom indices. If the configuration could not be created a null element is
            returned. There is no configuration is the coordinates do not indicate a
            configuration, there were undefined coordinates or an unspecified bond
            label. The method does not check if double bond stereo is supported - for
            this functionality use <see cref="T:NCDK.Stereo.Stereocenters"/>.
            </summary>
            <param name="u">an atom index</param>
            <param name="v">an atom pi bonded 'v'</param>
            <returns>a new stereo element</returns>
        </member>
        <member name="M:NCDK.Stereo.StereoElementFactory.CreateGeometric(NCDK.IBond,NCDK.Stereo.Stereocenters)">
            <summary>
            Create a geometric element (double-bond stereochemistry) for the provided
            double bond. If the configuration could not be created a null element is
            returned. There is no configuration is the coordinates do not indicate a
            configuration, there were undefined coordinates or an unspecified bond
            label. The method does not check if double bond stereo is supported - for
            this functionality use <see cref="T:NCDK.Stereo.Stereocenters" />.
            </summary>
            <example>
            <code>                StereoElementFactory factory = someFactory; // 2D/3D
                IAtomContainer container = someMolecule; // container

                foreach (var bond in container.Bonds)
                {
                    if (bond.Order != BondOrder.Double)
                        continue;
                    // ... verify bond is a stereo bond...
                    IDoubleBondStereochemistry element = factory.CreateGeometric(bond, null);
                    if (element != null)
                        container.StereoElements.Add(element);
                }
</code>
            </example>
            <param name="bond">the bond to create a configuration for</param>
            <returns>a new stereo element</returns>
        </member>
        <member name="M:NCDK.Stereo.StereoElementFactory.CreateExtendedTetrahedral(System.Int32,NCDK.Stereo.Stereocenters)">
            <summary>
            Create an extended tetrahedral element for the atom at index <paramref name="v" />.
            If an extended  tetrahedral element could not be created then null is
            returned. An element can not be created if, one or more atoms was
            missing coordinates, the atom has an unspecified (wavy) bond, the atom
            is no non-planar bonds (i.e. up/down, wedge/hatch). The method does not
            check if tetrahedral chirality is supported - for this functionality
            use <see cref="T:NCDK.Stereo.Stereocenters" />.
            </summary>
            <example>
            <code>                StereoElementFactory factory = someFactory; // 2D/3D
                IAtomContainer container = someMolecule; // container

                for (int v = 0; v &lt; container.Atoms.Count; v++)
                {
                    // ... verify v is a stereo atom ...
                    ExtendedTetrahedral element = factory.CreateExtendedTetrahedral(v, null);
                    if (element != null)
                        container.StereoElements.Add(element);
                }
</code>
            </example>
            <param name="v">atom index (vertex)</param>
            <returns>a new stereo element</returns>
        </member>
        <member name="M:NCDK.Stereo.StereoElementFactory.InterpretProjections(NCDK.Stereo.Projection[])">
            <summary>
            Indicate that stereochemistry drawn as a certain projection should be
            interpreted. 
            </summary>
            <example>
            <code>                StereoElementFactory factory =
                    StereoElementFactory.Using2DCoordinates(container)
                        .InterpretProjections(Projection.Fischer, Projection.Haworth);
</code>
            </example>
            <param name="projections">types of projection</param>
            <returns>self</returns>
            <seealso cref="T:NCDK.Stereo.Projection" />
        </member>
        <member name="M:NCDK.Stereo.StereoElementFactory.Using2DCoordinates(NCDK.IAtomContainer)">
            <summary>
            Create a stereo element factory for creating stereo elements using 2D
            coordinates and depiction labels (up/down, wedge/hatch).
            </summary>
            <param name="container">the structure to create the factory for</param>
            <returns>the factory instance</returns>
        </member>
        <member name="M:NCDK.Stereo.StereoElementFactory.Using3DCoordinates(NCDK.IAtomContainer)">
            <summary>
            Create a stereo element factory for creating stereo elements using 3D
            coordinates and depiction labels (up/down, wedge/hatch).
            </summary>
            <param name="container">the structure to create the factory for</param>
            <returns>the factory instance</returns>
        </member>
        <member name="T:NCDK.Stereo.StereoElementFactory.StereoElementFactory2D">
            <summary>Create stereo-elements from 2D coordinates.</summary>
        </member>
        <member name="F:NCDK.Stereo.StereoElementFactory.StereoElementFactory2D.Threshold">
            <summary>
            Threshold at which the determinant is considered too small (unspecified
            by coordinates).
            </summary>
        </member>
        <member name="M:NCDK.Stereo.StereoElementFactory.StereoElementFactory2D.#ctor(NCDK.IAtomContainer,System.Int32[][],NCDK.Graphs.GraphUtil.EdgeToBondMap)">
            <summary>
            Create a new stereo-element factory for the specified structure.
            </summary>
            <param name="container">native CDK structure representation</param>
            <param name="graph">adjacency list representation</param>
            <param name="bondMap">fast bond lookup from atom indices</param>
        </member>
        <member name="M:NCDK.Stereo.StereoElementFactory.StereoElementFactory2D.CreateTetrahedral(NCDK.IAtom,NCDK.Stereo.Stereocenters)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Stereo.StereoElementFactory.StereoElementFactory2D.CreateGeometric(NCDK.IBond,NCDK.Stereo.Stereocenters)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Stereo.StereoElementFactory.StereoElementFactory2D.CreateTetrahedral(System.Int32,NCDK.Stereo.Stereocenters)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Stereo.StereoElementFactory.StereoElementFactory2D.CreateGeometric(System.Int32,System.Int32,NCDK.Stereo.Stereocenters)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Stereo.StereoElementFactory.StereoElementFactory2D.CreateExtendedTetrahedral(System.Int32,NCDK.Stereo.Stereocenters)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Stereo.StereoElementFactory.StereoElementFactory2D.IsUnspecified(NCDK.IBond)">
            <summary>
            Is the provided bond have an unspecified stereo label.
            </summary>
            <param name="bond">a bond</param>
            <returns>the bond has unspecified stereochemistry</returns>
        </member>
        <member name="M:NCDK.Stereo.StereoElementFactory.StereoElementFactory2D.Parity(NCDK.IAtom[])">
            <summary>
            Parity computation for one side of a double bond in a geometric center.
            </summary>
            <param name="atoms">atoms around the double bonded atom, 0: substituent, 1:
                         other substituent (or focus), 2: double bonded atom</param>
            <returns>the parity of the atoms</returns>
        </member>
        <member name="M:NCDK.Stereo.StereoElementFactory.StereoElementFactory2D.Parity(NCDK.IAtom,NCDK.IAtom[],System.Int32[])">
            <summary>
            Parity computation for 2D tetrahedral stereocenters.
            </summary>
            <param name="atoms">the atoms surrounding the central focus atom</param>
            <param name="elevations">the elevations of each atom</param>
            <returns>the parity (winding)</returns>
        </member>
        <member name="M:NCDK.Stereo.StereoElementFactory.StereoElementFactory2D.ToUnitVector(NCDK.Numerics.Vector2,NCDK.Numerics.Vector2)">
            <summary>
            Obtain the unit vector between two points.
            </summary>
            <param name="from">the base of the vector</param>
            <param name="to">the point of the vector</param>
            <returns>the unit vector</returns>
        </member>
        <member name="M:NCDK.Stereo.StereoElementFactory.StereoElementFactory2D.Parity(NCDK.Numerics.Vector2[],System.Int32[])">
            <summary>
            Compute the signed volume of the tetrahedron from the planar points
            and elevations.
            </summary>
            <param name="coordinates">locations in the plane</param>
            <param name="elevations">elevations above/below the plane</param>
            <returns>the determinant (signed volume of tetrahedron)</returns>
        </member>
        <member name="M:NCDK.Stereo.StereoElementFactory.StereoElementFactory2D.Det(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>3x3 determinant helper for a constant third column</summary>
        </member>
        <member name="M:NCDK.Stereo.StereoElementFactory.StereoElementFactory2D.MoveToBack(System.Int32[],System.Int32)">
            <summary>
            Utility find the specified value, <paramref name="v"/>, in the array of values,
            <paramref name="vs"/> and moves it to the back.
            </summary>
            <param name="vs">an array of values (containing v)</param>
            <param name="v">a value</param>
        </member>
        <member name="M:NCDK.Stereo.StereoElementFactory.StereoElementFactory2D.ElevationOf(NCDK.IAtom,NCDK.IBond)">
            <summary>
            Obtain the elevation of an atom connected to the <paramref name="focus"/> by the
            specified <paramref name="bond"/>.
            </summary>
            <param name="focus">a focus of stereochemistry</param>
            <param name="bond">a bond connecting the focus to a substituent</param>
            <returns>the elevation of the connected atom, +1 above, -1 below, 0 planar</returns>
        </member>
        <member name="T:NCDK.Stereo.StereoElementFactory.StereoElementFactory3D">
            <summary>Create stereo-elements from 3D coordinates.</summary>
        </member>
        <member name="M:NCDK.Stereo.StereoElementFactory.StereoElementFactory3D.#ctor(NCDK.IAtomContainer,System.Int32[][],NCDK.Graphs.GraphUtil.EdgeToBondMap)">
            <summary>
            Create a new stereo-element factory for the specified structure.
            </summary>
            <param name="container">native CDK structure representation</param>
            <param name="graph">adjacency list representation</param>
            <param name="bondMap">fast bond lookup from atom indices</param>
        </member>
        <member name="M:NCDK.Stereo.StereoElementFactory.StereoElementFactory3D.CreateTetrahedral(NCDK.IAtom,NCDK.Stereo.Stereocenters)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Stereo.StereoElementFactory.StereoElementFactory3D.CreateGeometric(NCDK.IBond,NCDK.Stereo.Stereocenters)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Stereo.StereoElementFactory.StereoElementFactory3D.CreateTetrahedral(System.Int32,NCDK.Stereo.Stereocenters)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Stereo.StereoElementFactory.StereoElementFactory3D.CreateGeometric(System.Int32,System.Int32,NCDK.Stereo.Stereocenters)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Stereo.StereoElementFactory.StereoElementFactory3D.CreateExtendedTetrahedral(System.Int32,NCDK.Stereo.Stereocenters)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Stereo.StereoElementFactory.StereoElementFactory3D.Det(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>3x3 determinant helper for a constant third column</summary>
        </member>
        <member name="M:NCDK.Stereo.StereoElementFactory.StereoElementFactory3D.Parity(NCDK.Numerics.Vector3,NCDK.Numerics.Vector3,NCDK.Numerics.Vector3,NCDK.Numerics.Vector3)">
            <summary>
            Parity computation for one side of a double bond in a geometric center.
            The method needs the 3D coordinates of the double bond atoms (first 2
            arguments) and the coordinates of two substituents (one at each end).
            </summary>
            <param name="u">an atom double bonded to v</param>
            <param name="v">an atom double bonded to u</param>
            <param name="x">an atom sigma bonded to u</param>
            <param name="w">an atom sigma bonded to v</param>
            <returns>the parity of the atoms</returns>
        </member>
        <member name="M:NCDK.Stereo.StereoElementFactory.StereoElementFactory3D.Parity(NCDK.IAtom[])">
            <summary>
            Parity computation for 3D tetrahedral stereocenters.
            </summary>
            <param name="atoms">the atoms surrounding the central focus atom</param>
            <returns>the parity (winding)</returns>
        </member>
        <member name="M:NCDK.Stereo.StereoElementFactory.StereoElementFactory3D.ToVector(NCDK.Numerics.Vector3,NCDK.Numerics.Vector3)">
            <summary>
            Create a vector by specifying the source and destination coordinates.
            </summary>
            <param name="src">start point of the vector</param>
            <param name="dest">end point of the vector</param>
            <returns>a new vector</returns>
        </member>
        <member name="M:NCDK.Stereo.StereoElementFactory.StereoElementFactory3D.Dot(System.Double[],System.Double[])">
            <summary>
            Dot product of two 3D coordinates
            </summary>
            <param name="u">either 3D coordinates</param>
            <param name="v">other 3D coordinates</param>
            <returns>the dot-product</returns>
        </member>
        <member name="M:NCDK.Stereo.StereoElementFactory.StereoElementFactory3D.CrossProduct(System.Double[],System.Double[])">
            <summary>
            Cross product of two 3D coordinates
            </summary>
            <param name="u">either 3D coordinates</param>
            <param name="v">other 3D coordinates</param>
            <returns>the cross-product</returns>
        </member>
        <member name="T:NCDK.Stereo.StereoTool">
            <summary>
            Methods to determine or check the stereo class of a set of atoms.
            </summary>
            <remarks>
            Some of these methods were adapted from Jmol's smiles search package.
            </remarks>
        </member>
        <member name="T:NCDK.Stereo.StereoTool.StereoClasses">
            <summary>
            Currently unused, but intended for the StereoTool to indicate what it
            'means' by an assignment of some atoms to a class.
            </summary>
        </member>
        <member name="T:NCDK.Stereo.StereoTool.TetrahedralSigns">
            <summary>
            The handedness of a tetrahedron, in terms of the point-plane distance
            of three of the corners, compared to the fourth.
            </summary>
        </member>
        <member name="F:NCDK.Stereo.StereoTool.TetrahedralSigns.Plus">
            <summary>
            Indices a positive point-plane distance
            </summary>
        </member>
        <member name="F:NCDK.Stereo.StereoTool.TetrahedralSigns.Minus">
            <summary>
            A negative point-plane distance
            </summary>
        </member>
        <member name="T:NCDK.Stereo.StereoTool.SquarePlanarShape">
            <summary>
            The shape that four atoms take in a plane.
            </summary>
        </member>
        <member name="F:NCDK.Stereo.StereoTool.MaxAxisAngle">
            <summary>
            The maximum angle in radians for two lines to be 'diaxial'.
            Where 0.95 is about 172 degrees.
            </summary>
        </member>
        <member name="F:NCDK.Stereo.StereoTool.MinColinarNormal">
            <summary>
            The maximum tolerance for the normal calculated during colinearity.
            </summary>
        </member>
        <member name="M:NCDK.Stereo.StereoTool.IsSquarePlanar(NCDK.IAtom,NCDK.IAtom,NCDK.IAtom,NCDK.IAtom)">
            <summary>
            Checks these four atoms for square planarity.
            </summary>
            <param name="atomA">an atom in the plane</param>
            <param name="atomB">an atom in the plane</param>
            <param name="atomC">an atom in the plane</param>
            <param name="atomD">an atom in the plane</param>
            <returns>true if all the atoms are in the same plane</returns>
        </member>
        <member name="M:NCDK.Stereo.StereoTool.GetSquarePlanarShape(NCDK.IAtom,NCDK.IAtom,NCDK.IAtom,NCDK.IAtom)">
             <summary>
             <para>Given four atoms (assumed to be in the same plane), returns the
             arrangement of those atoms in that plane.</para>
            
             <para>The 'shapes' returned represent arrangements that look a little like
             the characters 'U', '4', and 'Z'.</para>
             </summary>
             <param name="atomA">an atom in the plane</param>
             <param name="atomB">an atom in the plane</param>
             <param name="atomC">an atom in the plane</param>
             <param name="atomD">an atom in the plane</param>
             <returns>the shape (U/4/Z)</returns>
        </member>
        <member name="M:NCDK.Stereo.StereoTool.AllCoplanar(NCDK.Numerics.Vector3,NCDK.Numerics.Vector3,NCDK.Numerics.Vector3[])">
            <summary>
            Check that all the points in the list are coplanar (in the same plane)
            as the plane defined by the planeNormal and the pointInPlane.
            </summary>
            <param name="planeNormal">the normal to the plane</param>
            <param name="pointInPlane">any point know to be in the plane</param>
            <param name="points">an array of points to test</param>
            <returns>false if any of the points is not in the plane</returns>
        </member>
        <member name="M:NCDK.Stereo.StereoTool.IsOctahedral(NCDK.IAtom,NCDK.IAtom,NCDK.IAtom,NCDK.IAtom,NCDK.IAtom,NCDK.IAtom,NCDK.IAtom)">
            <summary>
            Checks these 7 atoms to see if they are at the points of an octahedron.
            </summary>
            <param name="atomA">one of the axial atoms</param>
            <param name="atomB">the central atom</param>
            <param name="atomC">one of the equatorial atoms</param>
            <param name="atomD">one of the equatorial atoms</param>
            <param name="atomE">one of the equatorial atoms</param>
            <param name="atomF">one of the equatorial atoms</param>
            <param name="atomG">the other axial atom</param>
            <returns>true if the geometry is octahedral</returns>
        </member>
        <member name="M:NCDK.Stereo.StereoTool.IsTrigonalBipyramidal(NCDK.IAtom,NCDK.IAtom,NCDK.IAtom,NCDK.IAtom,NCDK.IAtom,NCDK.IAtom)">
            <summary>
            Checks these 6 atoms to see if they form a trigonal-bipyramidal shape.
            </summary>
            <param name="atomA">one of the axial atoms</param>
            <param name="atomB">the central atom</param>
            <param name="atomC">one of the equatorial atoms</param>
            <param name="atomD">one of the equatorial atoms</param>
            <param name="atomE">one of the equatorial atoms</param>
            <param name="atomF">the other axial atom</param>
            <returns>true if the geometry is trigonal-bipyramidal</returns>
        </member>
        <member name="M:NCDK.Stereo.StereoTool.GetStereo(NCDK.IAtom,NCDK.IAtom,NCDK.IAtom,NCDK.IAtom)">
            <summary>
            Take four atoms, and return <see cref="F:NCDK.TetrahedralStereo.Clockwise"/> or <see cref="F:NCDK.TetrahedralStereo.AntiClockwise"/>.
            The first atom is the one pointing towards the observer.
            </summary>
            <param name="atom1">the atom pointing towards the observer</param>
            <param name="atom2">the second atom (points away)</param>
            <param name="atom3">the third atom (points away)</param>
            <param name="atom4">the fourth atom (points away)</param>
            <returns>clockwise or anticlockwise</returns>
        </member>
        <member name="M:NCDK.Stereo.StereoTool.GetHandedness(NCDK.IAtom,NCDK.IAtom,NCDK.IAtom,NCDK.IAtom)">
            <summary>
            Gets the tetrahedral handedness of four atoms - three of which form the
            'base' of the tetrahedron, and the other the apex. Note that it assumes
            a right-handed coordinate system, and that the points {A,B,C} are in
            a counter-clockwise order in the plane they share.
            </summary>
            <param name="baseAtomA">the first atom in the base of the tetrahedron</param>
            <param name="baseAtomB">the second atom in the base of the tetrahedron</param>
            <param name="baseAtomC">the third atom in the base of the tetrahedron</param>
            <param name="apexAtom">the atom in the point of the tetrahedron</param>
            <returns>the sign of the tetrahedron</returns>
        </member>
        <member name="M:NCDK.Stereo.StereoTool.IsColinear(NCDK.Numerics.Vector3,NCDK.Numerics.Vector3,NCDK.Numerics.Vector3)">
            <summary>
            Checks the three supplied points to see if they fall on the same line.
            It does this by finding the normal to an arbitrary pair of lines between
            the points (in fact, A-B and A-C) and checking that its length is 0.
            </summary>
            <param name="ptA"></param>
            <param name="ptB"></param>
            <param name="ptC"></param>
            <returns>true if the tree points are on a straight line</returns>
        </member>
        <member name="M:NCDK.Stereo.StereoTool.SignedDistanceToPlane(NCDK.Numerics.Vector3,NCDK.Numerics.Vector3,NCDK.Numerics.Vector3)">
            <summary>
            Given a normalized normal for a plane, any point in that plane, and
            a point, will return the distance between the plane and that point.
            </summary>
            <param name="planeNormal">the normalized plane normal</param>
            <param name="pointInPlane">an arbitrary point in that plane</param>
            <param name="point">the point to measure</param>
            <returns>the signed distance to the plane</returns>
        </member>
        <member name="M:NCDK.Stereo.StereoTool.GetNormal(NCDK.Numerics.Vector3,NCDK.Numerics.Vector3,NCDK.Numerics.Vector3)">
            <summary>
            Given three points (A, B, C), makes the vectors A-B and A-C, and makes
            the cross product of these two vectors; this has the effect of making a
            third vector at right angles to AB and AC.
            </summary>
            <remarks>
            <note type="note">
            The returned normal is normalized; that is, it has been divided by its length.</note></remarks>
            <param name="ptA">the 'middle' point</param>
            <param name="ptB">one of the end points</param>
            <param name="ptC">one of the end points</param>
            <returns>the vector at right angles to AB and AC</returns>
        </member>
        <member name="T:NCDK.TetrahedralStereo">
            <summary>
            Enumeration that defines the two possible chiralities for this stereochemistry type.
            </summary>
        </member>
        <member name="T:NCDK.TetrahedralStereo.O">
            <summary>
            The <see cref="P:NCDK.TetrahedralStereo.Ordinal"/> values of <see cref="T:NCDK.TetrahedralStereo"/>.
            </summary>
            <seealso cref="T:NCDK.TetrahedralStereo"/>
        </member>
        <member name="P:NCDK.TetrahedralStereo.Ordinal">
            <summary>
            The ordinal of this enumeration constant. The list is in <see cref="T:NCDK.TetrahedralStereo.O"/>.
            </summary>
            <seealso cref="T:NCDK.TetrahedralStereo.O"/>
        </member>
        <member name="M:NCDK.TetrahedralStereo.ToString">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.TetrahedralStereo.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.TetrahedralStereo.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.TetrahedralStereo.CompareTo(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.TetrahedralStereo.CompareTo(NCDK.TetrahedralStereo)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.TetrahedralStereo.Invert">
            <summary>
            Invert this conformation,
            Invert(clockwise) = anti_clockwise, Invert(anti_clockwise) = clockwise.
            </summary>
            <returns> the inverse conformation</returns>
        </member>
        <member name="T:NCDK.ConformerContainer">
            <summary>
            A memory-efficient data structure to store conformers for a single molecule.
            </summary>
            <remarks>
            Since all the conformers for a given molecule only differ in their 3D coordinates
            this data structure stores a single <see cref="T:NCDK.IAtomContainer" /> containing the atom and bond
            details and a List of 3D coordinate sets, each element being the set of 3D coordinates
            for a given conformer.
            </remarks>
            <example>
            The class behaves in many ways as a <see cref="T:System.Collections.Generic.IList`1" /> of <see cref="T:NCDK.IAtomContainer" /> object, though a few methods are not
            implemented. Though it is possible to add conformers by hand, this data structure is
            probably best used in combination with <see cref="T:NCDK.IO.Iterator.IEnumerableMDLConformerReader" /> as
            <code>            var reader = new IEnumerableMDLConformerReader(
                new FileStream(filename, FileMode.Open),
                Default.ChemObjectBuilder.Instance);
            foreach (ConformerContainer cc in reader)
            {
                foreach (var conformer in cc)
                {
                    // do something with each conformer
                }
            }
</code>
            </example>
            <seealso cref="T:NCDK.IO.Iterator.IEnumerableMDLConformerReader" />
        </member>
        <member name="M:NCDK.ConformerContainer.#ctor(NCDK.IAtomContainer)">
            <summary>
            Create a ConformerContainer object from a single molecule object.
            <para>
            Using this constructor, the resultant conformer container will
            contain a single conformer. More conformers can be added using the
            <see cref="M:NCDK.ConformerContainer.Add(NCDK.IAtomContainer)"/> method.
            </para>
            </summary>
            <remarks>
            <note type="note">
            The constructor will use the title of the input molecule
            when adding new molecules as conformers. That is, the title of any molecule
            to be added as a conformer should match the title of the input molecule.
            </note>
            </remarks>
            <param name="atomContainer">The base molecule (or first conformer).</param>
        </member>
        <member name="M:NCDK.ConformerContainer.#ctor(NCDK.IAtomContainer[])">
            <summary>
            Create a ConformerContainer from an array of molecules.
            </summary>
            <remarks>
            This constructor can be used when you have an array of conformers of a given
            molecule. Note that this constructor will assume that all molecules in the
            input array will have the same title.
            </remarks>
            <param name="atomContainers">The array of conformers</param>
        </member>
        <member name="P:NCDK.ConformerContainer.Title">
            <summary>
            The title of the conformers.
            </summary>
            <remarks>
            <note type="note">All conformers for a given molecule will have the same title.</note>
            </remarks>
        </member>
        <member name="P:NCDK.ConformerContainer.Count">
            <summary>
            The number of conformers stored.
            </summary>
        </member>
        <member name="M:NCDK.ConformerContainer.IsEmpty">
            <summary>
            Checks whether any conformers are stored or not.
            </summary>
        </member>
        <member name="M:NCDK.ConformerContainer.Contains(NCDK.IAtomContainer)">
            <summary>
            Checks to see whether the specified conformer is currently stored.
            </summary>
            <remarks>
            This method first checks whether the title of the supplied molecule
            matches the stored title. If not, it returns false. If the title matches
            it then checks all the coordinates to see whether they match. If all
            coordinates match it returns true else false.
            </remarks>
            <param name="o">The <see cref="T:NCDK.IAtomContainer"/> to check for</param>
            <returns>true if it is present, false otherwise</returns>
        </member>
        <member name="M:NCDK.ConformerContainer.ToArray">
            <summary>
            Returns the conformers in the form of an array of <see cref="T:NCDK.IAtomContainer"/>s.
            <para>
            Beware that if you have a large number of conformers you may run out
            memory during construction of the array since <see cref="T:NCDK.IAtomContainer"/>'s are not
            light weight objects!
            </para>
            </summary>
            <returns>The conformers as an array of individual <see cref="T:NCDK.IAtomContainer"/>s.</returns>
        </member>
        <member name="M:NCDK.ConformerContainer.Add(NCDK.IAtomContainer)">
            <summary>
            Add a conformer to the end of the list.
            <para>
            This method allows you to add a <see cref="T:NCDK.IAtomContainer"/> object as another conformer.
            Before adding it ensures that the title of specific object matches the
            stored title for these conformers. It will also check that the number of
            atoms in the specified molecule match the number of atoms in the current set
            of conformers.
            </para>
            <para>
            This method will not check for duplicate conformers.
            </para>
            </summary>
            <param name="atomContainer">The new conformer to add.</param>
        </member>
        <member name="M:NCDK.ConformerContainer.Remove(NCDK.IAtomContainer)">
            <summary>
            Remove the specified conformer.
            </summary>
            <param name="atomContainer">The conformer to remove (should be castable to <see cref="T:NCDK.IAtomContainer"/>)</param>
            <returns>true if the specified conformer was present and removed, false if not found</returns>
        </member>
        <member name="M:NCDK.ConformerContainer.Clear">
            <summary>
            Get rid of all the conformers but keeps atom and bond information.
            </summary>
        </member>
        <member name="P:NCDK.ConformerContainer.Item(System.Int32)">
            <summary>
            The conformer at a specified position.
            </summary>
            <param name="i">The position of the requested conformer</param>
        </member>
        <member name="M:NCDK.ConformerContainer.RemoveAt(System.Int32)">
            <summary>
            Removes the conformer at the specified position.
            </summary>
            <param name="i">The position in the list to remove</param>
        </member>
        <member name="M:NCDK.ConformerContainer.IndexOf(NCDK.IAtomContainer)">
            <summary>
            Returns the lowest index at which the specific <see cref="T:NCDK.IAtomContainer"/> appears in the list or -1 if is not found.
            <para>
            A given <see cref="T:NCDK.IAtomContainer"/> will occur in the list if the title matches the stored title for
            the conformers in this container and if the coordinates for each atom in the specified molecule
            are equal to the coordinates of the corresponding atoms in a conformer.
            </para>
            </summary>
            <param name="atomContainer">The <see cref="T:NCDK.IAtomContainer"/> whose presence is being tested</param>
            <returns>The index where o was found</returns>
        </member>
        <member name="M:NCDK.ConformerContainer.LastIndexOf(NCDK.IAtomContainer)">
            <summary>
            Returns the highest index at which the specific <see cref="T:NCDK.IAtomContainer"/> appears in the list or -1 if is not found.
            <para>
            A given <see cref="T:NCDK.IAtomContainer"/> will occur in the list if the title matches the stored title for
            the conformers in this container and if the coordinates for each atom in the specified molecule
            are equal to the coordinates of the corresponding atoms in a conformer.
            </para>
            </summary>
            <param name="o">The <see cref="T:NCDK.IAtomContainer"/> whose presence is being tested</param>
            <returns>The index where o was found</returns>
        </member>
        <member name="T:NCDK.IAtom">
            <summary>
            Represents the idea of an chemical atom.
            </summary>
        </member>
        <member name="P:NCDK.IAtom.Charge">
            <summary>
            The partial charge of this atom.
            </summary>
        </member>
        <member name="P:NCDK.IAtom.ImplicitHydrogenCount">
            <summary>
            The implicit hydrogen count of this atom.
            </summary>
        </member>
        <member name="P:NCDK.IAtom.Point2D">
            <summary>
            A point specifying the location of this atom in a 2D space.
            </summary>
        </member>
        <member name="P:NCDK.IAtom.Point3D">
            <summary>
            A point specifying the location of this atom in 3D space.
            </summary>
        </member>
        <member name="P:NCDK.IAtom.FractionalPoint3D">
            <summary>
            A point specifying the location of this atom in a Crystal unit cell.
            </summary>
        </member>
        <member name="P:NCDK.IAtom.StereoParity">
            <summary>
            The stereo parity of this atom. It uses the predefined values found in CDKConstants.
            </summary>
        </member>
        <member name="P:NCDK.IAtom.IsSingleOrDouble">
            <summary>
            A way for the Smiles parser to indicate that this atom was written with a lower case letter, e.g. 'c' rather than 'C'.
            </summary>
        </member>
        <member name="T:NCDK.IMolecularEntity">
            <summary>
            <see cref="T:NCDK.IAtomType"/> or <see cref="T:NCDK.IBond"/>.
            </summary>
        </member>
        <member name="P:NCDK.IMolecularEntity.IsAromatic">
            <summary>
            This object is part of an aromatic system. 
            </summary>
        </member>
        <member name="P:NCDK.IMolecularEntity.IsInRing">
            <summary>
            It is part of a ring.
            </summary>
        </member>
        <member name="P:NCDK.IMolecularEntity.IsAliphatic">
            <summary>
            It is part of an aliphatic chain.
            </summary>
        </member>
        <member name="T:NCDK.IAtomType">
            <summary>
            The base class for atom types.
            Atom types are typically used to describe the
            behaviour of an atom of a particular element in different environment like
            sp<sup>3</sup> hybridized carbon C3, etc., in some molecular modelling
            applications.
            </summary>
        </member>
        <member name="P:NCDK.IAtomType.AtomTypeName">
            <summary>
            AtomTypeID value. 
            </summary>
            <value><see langword="null"/>if unset.</value>
        </member>
        <member name="P:NCDK.IAtomType.MaxBondOrder">
            <summary>
            MaxBondOrder attribute of the AtomType object.
            </summary>
        </member>
        <member name="P:NCDK.IAtomType.BondOrderSum">
            <summary>
            the exact bond order sum attribute of the AtomType object.
            </summary>
        </member>
        <member name="P:NCDK.IAtomType.FormalCharge">
            <summary>
            the formal charge of this atom.
            </summary>
        </member>
        <member name="P:NCDK.IAtomType.FormalNeighbourCount">
            <summary>
            the formal neighbour count of this atom.
            </summary>
        </member>
        <member name="P:NCDK.IAtomType.Hybridization">
            <summary>
            the hybridization of this atom.
            </summary>
        </member>
        <member name="P:NCDK.IAtomType.CovalentRadius">
            <summary>
            the covalent radius for this AtomType.
            </summary>
        </member>
        <member name="P:NCDK.IAtomType.IsHydrogenBondDonor">
            <summary>
            <see langword="true"/> if the atom is an hydrogen bond donor. 
            </summary>
        </member>
        <member name="P:NCDK.IAtomType.IsHydrogenBondAcceptor">
            <summary>
            <see langword="true"/> if the atom is an hydrogen bond acceptor. 
            </summary>
        </member>
        <member name="P:NCDK.IAtomType.IsReactiveCenter">
            <summary>
            set if a chemobject has reactive center. It is used for example in reaction.
            </summary>
        </member>
        <member name="T:NCDK.IIsotope">
            <summary>
            Used to store and retrieve data of a particular isotope.
            </summary>
        </member>
        <member name="P:NCDK.IIsotope.NaturalAbundance">
            <summary>
            The natural abundance attribute of the <see cref="T:NCDK.IIsotope"/> object.
            </summary>
        </member>
        <member name="P:NCDK.IIsotope.ExactMass">
            <summary>
            The exact mass attribute of the <see cref="T:NCDK.IIsotope"/> object.
            </summary>
        </member>
        <member name="P:NCDK.IIsotope.MassNumber">
            <summary>
            the atomic mass of this element.
            </summary>
            <value><see langword="null"/> when unconfigured.</value>
        </member>
        <member name="T:NCDK.IElement">
            <summary>
            Implements the idea of an element in the periodic table.
            </summary>
        </member>
        <member name="P:NCDK.IElement.AtomicNumber">
            <summary>
            Returns the atomic number of this element.
            </summary>
        </member>
        <member name="P:NCDK.IElement.Symbol">
            <summary>
            Returns the element symbol of this element.
            </summary>
        </member>
        <member name="T:NCDK.ICDKObject">
            <summary>
            The base class for all data objects in this CDK.
            </summary>
        </member>
        <member name="P:NCDK.ICDKObject.Builder">
            <summary>
            <see cref="T:NCDK.IChemObjectBuilder"/> for the data classes that extend this class.
            </summary>
            <value>The <see cref="T:NCDK.IChemObjectBuilder"/> matching this <see cref="T:NCDK.ICDKObject"/></value>
        </member>
        <member name="M:NCDK.ICDKObject.Clone(NCDK.CDKObjectMap)">
            <summary>
            A deep clone of this object.
            </summary>
            <param name="map">A map of the original atoms/bonds to the cloned atoms/bonds.</param>
            <returns>Object the clone of this object.</returns>
        </member>
        <member name="T:NCDK.CDKObjectMap">
            <summary>
            A mapping of the original atoms/bonds to the cloned atoms/bonds.
            </summary>
        </member>
        <member name="P:NCDK.CDKObjectMap.AtomMap">
            <summary>
            A map of <see cref="T:NCDK.IAtom"/>s. 
            </summary>
        </member>
        <member name="P:NCDK.CDKObjectMap.BondMap">
            <summary>
            A map of <see cref="T:NCDK.IBond"/>s. 
            </summary>
        </member>
        <member name="T:NCDK.IAdductFormula">
            <summary>
            Class defining an adduct object in a MolecularFormula. 
            It maintains a list of list IMolecularFormula.
            Examples: [C2H4O2+Na]+
            </summary>
        </member>
        <member name="M:NCDK.IAdductFormula.GetCount(NCDK.IIsotope)">
            <summary>
             Checks a set of Nodes for the occurrence of the isotope in the
             adduct formula from a particular isotope. It returns 0 if the does not exist.
            </summary>
            <param name="isotope">The IIsotope to look for</param>
            <returns>The occurrence of this isotope in this adduct</returns>
            <seealso cref="P:NCDK.IAdductFormula.IsotopeCount"/>
        </member>
        <member name="P:NCDK.IAdductFormula.IsotopeCount">
            <summary>
             Checks a set of Nodes for the number of different isotopes in the
             adduct formula.
            </summary>
            <returns>The the number of different isotopes in this adduct formula</returns>
            <seealso cref="M:NCDK.IAdductFormula.GetCount(NCDK.IIsotope)"/>
        </member>
        <member name="M:NCDK.IAdductFormula.GetIsotopes">
            <summary>
             An IEnumerator for looping over all isotopes in this adduct formula.
            </summary>
        </member>
        <member name="P:NCDK.IAdductFormula.Charge">
            <summary>
             The partial charge of this Adduct. If the charge
             has not been set the return value is double.NaN.
            </summary>
        </member>
        <member name="M:NCDK.IAdductFormula.Contains(NCDK.IIsotope)">
            <summary>
             True, if the AdductFormula contains the given IIsotope object.
            </summary>
            <param name="isotope">The IIsotope this AdductFormula is searched for</param>
            <returns>True, if the AdductFormula contains the given isotope object</returns>
        </member>
        <member name="T:NCDK.IAminoAcid">
            <summary>
            A AminoAcid is Monomer which stores additional amino acid specific informations, like the N-terminus atom.
            </summary>
        </member>
        <member name="P:NCDK.IAminoAcid.NTerminus">
            <summary>
            The N-terminus atom.
            </summary>
        </member>
        <member name="P:NCDK.IAminoAcid.CTerminus">
            <summary>
            The C-terminus atom.
            </summary>
        </member>
        <member name="M:NCDK.IAminoAcid.AddNTerminus(NCDK.IAtom)">
            <summary>
            Add an Atom and makes it the N-terminus atom.
            </summary>
            <param name="atom">The Atom that is the N-terminus</param>
        </member>
        <member name="M:NCDK.IAminoAcid.AddCTerminus(NCDK.IAtom)">
            <summary>
            Add an Atom and makes it the C-terminus atom.
            </summary>
            <param name="atom">The Atom that is the C-terminus</param>
        </member>
        <member name="T:NCDK.IAtomContainer">
            <summary>
            Base class for all chemical objects that maintain a list of Atoms and
            ElectronContainers.
            </summary>
            <example>
            Looping over all <see cref="T:NCDK.IBond" />s in the <see cref="T:NCDK.IAtomContainer" /> is typically done like:
            <example>
            <code>            foreach (var bond in atomContainer.Bonds)
            {
                // do something
            }
</code>
            </example>
            </example>
        </member>
        <member name="M:NCDK.IAtomContainer.SetAtoms(System.Collections.Generic.IEnumerable{NCDK.IAtom})">
            <summary>
            Sets the array of atoms of this AtomContainer.
            </summary>
            <param name="atoms">The array of atoms to be assigned to this AtomContainer</param>
            <seealso cref="P:NCDK.IAtomContainer.Atoms"/>
        </member>
        <member name="M:NCDK.IAtomContainer.SetBonds(System.Collections.Generic.IEnumerable{NCDK.IBond})">
            <summary>
            Sets the array of bonds of this AtomContainer.
            </summary>
            <param name="bonds">The array of bonds to be assigned to this AtomContainer</param>
            <seealso cref="P:NCDK.IAtomContainer.Bonds"/>
        </member>
        <member name="M:NCDK.IAtomContainer.SetAtom(System.Int32,NCDK.IAtom)">
            <summary>
            Set the atom at <paramref name="index"/>, the index must have an existing atom
            and therefore be in the range 0 ÔøΩÔøΩ idx &lt; mol.Atoms.Count.
            </summary>
            <param name="index">The index of the atom to be set.</param>
            <param name="atom">The atom to be stored at position <paramref name="index"/></param>
            <exception cref="T:System.ArgumentOutOfRangeException">index is out of bounds</exception>
            <exception cref="T:System.ArgumentException">the atom could not be set</exception>
            <seealso cref="P:NCDK.IAtomContainer.Atoms"/>
        </member>
        <member name="P:NCDK.IAtomContainer.Atoms">
            <summary>
            The atoms in this container.
            </summary>
            <seealso cref="M:NCDK.IAtomContainer.SetAtoms(System.Collections.Generic.IEnumerable{NCDK.IAtom})"/>
        </member>
        <member name="P:NCDK.IAtomContainer.Bonds">
            <summary>
            The bonds in this container.
            </summary>
            <seealso cref="M:NCDK.IAtomContainer.SetBonds(System.Collections.Generic.IEnumerable{NCDK.IBond})"/>
        </member>
        <member name="P:NCDK.IAtomContainer.LonePairs">
            <summary>
            The lone pairs in this container.
            </summary>
        </member>
        <member name="P:NCDK.IAtomContainer.SingleElectrons">
            <summary>
            The single electrons in this container.
            </summary>
        </member>
        <member name="P:NCDK.IAtomContainer.StereoElements">
            <summary>
            A stereo element to this container.
            </summary>
        </member>
        <member name="M:NCDK.IAtomContainer.SetStereoElements(System.Collections.Generic.IEnumerable{NCDK.IStereoElement})">
            <summary>
            Set the stereo elements - this will replace the existing instance with a new instance.
            </summary>
            <param name="elements"></param>
        </member>
        <member name="P:NCDK.IAtomContainer.IsSingleOrDouble">
            <summary>
            One or several of the bonds have <see cref="P:NCDK.IBond.IsSingleOrDouble"/> raised (which may indicate aromaticity).
            </summary>
        </member>
        <member name="P:NCDK.IAtomContainer.IsAromatic">
            <summary>
            This object is part of an aromatic system. 
            </summary>
        </member>
        <member name="M:NCDK.IAtomContainer.GetElectronContainers">
            <summary>
            Returns <see cref="T:NCDK.IElectronContainer"/>s in the container.
            </summary>
            <returns><see cref="T:NCDK.IElectronContainer"/>s in the container.</returns>
            <seealso cref="M:NCDK.IAtomContainer.AddElectronContainer(NCDK.IElectronContainer)"/> 
        </member>
        <member name="M:NCDK.IAtomContainer.GetBond(NCDK.IAtom,NCDK.IAtom)">
            <summary>
            Returns the bond that connects the two given atoms.
            </summary>
            <param name="atom1">The first atom</param>
            <param name="atom2">The second atom</param>
            <returns>The <see cref="T:NCDK.IBond"/> that connects between <paramref name="atom1"/> and <paramref name="atom2"/></returns>
        </member>
        <member name="M:NCDK.IAtomContainer.GetConnectedAtoms(NCDK.IAtom)">
            <summary>
            Returns the atoms connected to the specified atom by
            a bond.
            </summary>
            <param name="atom">the atom</param>
            <returns>connected atoms</returns>
        </member>
        <member name="M:NCDK.IAtomContainer.GetConnectedBonds(NCDK.IAtom)">
            <summary>
            Returns the bonds connected to the specified atom.
            </summary>
            <param name="atom">the atom</param>
            <returns>connected bonds</returns>
        </member>
        <member name="M:NCDK.IAtomContainer.GetConnectedLonePairs(NCDK.IAtom)">
            <summary>
            Returns the lone pairs connected to the specified atom.
            </summary>
            <param name="atom">the atom</param>
            <returns>connected lone pairs</returns>
        </member>
        <member name="M:NCDK.IAtomContainer.GetConnectedSingleElectrons(NCDK.IAtom)">
            <summary>
            Returns the electron containers (bonds, radicals, and lone pairs )
            connected to the specified atom.
            </summary>
            <param name="atom">the atom</param>
            <returns>connected lone pairs</returns>
        </member>
        <member name="M:NCDK.IAtomContainer.GetConnectedElectronContainers(NCDK.IAtom)">
            <summary>
            Returns the electron containers (bonds, radicals, and lone pairs )
            connected to the specified atom.
            </summary>
            <param name="atom">the atom</param>
            <returns>connected lone pairs</returns>
        </member>
        <member name="M:NCDK.IAtomContainer.GetBondOrderSum(NCDK.IAtom)">
            <summary>
            Returns the sum of the bond orders for a given Atom.
            </summary>
            <param name="atom">The atom</param>
            <returns>The number of bond orders for this <paramref name="atom"/></returns>
        </member>
        <member name="M:NCDK.IAtomContainer.GetMaximumBondOrder(NCDK.IAtom)">
            <summary>
            Returns the maximum bond order that this atom currently has in the context
            of this AtomContainer.  If the atom has no bonds
            but does have implicit hydrogens the minimum bond order is
            <see cref="F:NCDK.BondOrder.Single"/>, otherwise the bond is unset
            <see cref="F:NCDK.BondOrder.Unset"/>.
            </summary>
            <param name="atom">The atom</param>
            <returns>The maximum bond order that this atom currently has</returns>
        </member>
        <member name="M:NCDK.IAtomContainer.GetMinimumBondOrder(NCDK.IAtom)">
            <summary>
            Returns the minimum bond order that this atom currently has
            in the context of this AtomContainer. If the atom has no bonds
            but does have implicit hydrogens the minimum bond order is
            <see cref="F:NCDK.BondOrder.Single"/>, otherwise the bond is unset
            <see cref="F:NCDK.BondOrder.Unset"/>.
            </summary>
            <param name="atom">The atom</param>
            <returns>The minimum bond order that this atom currently has</returns>
        </member>
        <member name="M:NCDK.IAtomContainer.Add(NCDK.IAtomContainer)">
            <summary>
             Adds all atoms and electron containers of a given <paramref name="atomContainer"/> to this container.
            </summary>
            <param name="atomContainer">The <see cref="T:NCDK.IAtomContainer"/> to be added</param>
        </member>
        <member name="M:NCDK.IAtomContainer.AddElectronContainer(NCDK.IElectronContainer)">
            <summary>
            Adds a <see cref="T:NCDK.IElectronContainer"/> to this <see cref="T:NCDK.IAtomContainer"/>.
            </summary>
            <param name="electronContainer">The <see cref="T:NCDK.IElectronContainer"/> to added to this container</param>
        </member>
        <member name="M:NCDK.IAtomContainer.Remove(NCDK.IAtomContainer)">
            <summary>
            Removes all atoms and electronContainers of a given atomcontainer from this container.
            </summary>
            <param name="atomContainer">The atomcontainer to be removed</param>
        </member>
        <member name="M:NCDK.IAtomContainer.RemoveElectronContainer(NCDK.IElectronContainer)">
            <summary>
            Removes this ElectronContainer from this container.
            </summary>
            <param name="electronContainer">The electronContainer to be removed</param>
        </member>
        <member name="M:NCDK.IAtomContainer.RemoveAtom(NCDK.IAtom)">
            <summary>
            Safely remove an atom from the container.
            </summary>
            <remarks>
            <para>
            Removes a single atom from the container updating all internal
            state to be consistent. All bonds connected to the atom will be
            deleted as well as all stereo elements. If multiple atoms/bonds are
            being deleted they should be gathered into a single transaction
            and removed with <see cref="M:NCDK.IAtomContainer.Remove(NCDK.IAtomContainer)"/>.
            </para>
            <para>
            If you are removing hydrogens one of the
            utility methods (e.g. <see cref="M:NCDK.Tools.Manipulator.AtomContainerManipulator.RemoveHydrogens(NCDK.IAtomContainer)"/>)
            is preferable.
            </para>
            </remarks>
            <param name="atom">the atom to be removed</param>
        </member>
        <member name="M:NCDK.IAtomContainer.RemoveAtomAndConnectedElectronContainers(NCDK.IAtom)">
            <summary>
            Safely remove an atom from the container.
            </summary>
            <seealso cref="M:NCDK.IAtomContainer.RemoveAtom(NCDK.IAtom)"/>
        </member>
        <member name="M:NCDK.IAtomContainer.RemoveAllElements">
            <summary>
            Removes all atoms, bonds and stereo elements from this container.
            </summary>
        </member>
        <member name="M:NCDK.IAtomContainer.RemoveAllElectronContainers">
            <summary>
            Removes electronContainers from this container.
            </summary>
        </member>
        <member name="M:NCDK.IAtomContainer.RemoveAllBonds">
            <summary>
            Removes all Bonds from this container.
            </summary>
        </member>
        <member name="M:NCDK.IAtomContainer.AddBond(NCDK.IAtom,NCDK.IAtom,NCDK.BondOrder,NCDK.BondStereo)">
            <summary>
            Adds a bond to this container.
            </summary>
            <param name="atom1">the first atom</param>
            <param name="atom2">the second atom</param>
            <param name="order">bond order</param>
            <param name="stereo">Stereochemical orientation</param>
        </member>
        <member name="M:NCDK.IAtomContainer.AddBond(NCDK.IAtom,NCDK.IAtom,NCDK.BondOrder)">
            <summary>
            Adds a bond to this container.
            </summary>
            <param name="atom1">the first atom</param>
            <param name="atom2">the second atom</param>
            <param name="order">bond order</param>
        </member>
        <member name="M:NCDK.IAtomContainer.RemoveBond(NCDK.IAtom,NCDK.IAtom)">
            <summary>
            Removes the bond that connects the two given atoms.
            </summary>
            <param name="atom1">The first atom</param>
            <param name="atom2">The second atom</param>
            <returns>The bond that connects the two atoms</returns>
        </member>
        <member name="M:NCDK.IAtomContainer.AddLonePairTo(NCDK.IAtom)">
            <summary>
            Adds a <see cref="T:NCDK.ILonePair"/> to this <see cref="T:NCDK.IAtom"/>.
            </summary>
            <param name="atom">The atom to which the <see cref="T:NCDK.ILonePair"/> is added</param>
        </member>
        <member name="M:NCDK.IAtomContainer.AddSingleElectronTo(NCDK.IAtom)">
            <summary>
            Adds a <see cref="T:NCDK.ISingleElectron"/> to this <see cref="T:NCDK.IAtom"/>.
            </summary>
            <param name="atom">The atom to which the <see cref="T:NCDK.ISingleElectron"/> is added</param>
        </member>
        <member name="M:NCDK.IAtomContainer.Contains(NCDK.IAtom)">
            <summary>
            <see langword="true"/>, if the <see cref="T:NCDK.IAtomContainer"/> contains the given atom object.
            </summary>
            <param name="atom">the atom this <see cref="T:NCDK.IAtomContainer"/> is searched for</param>
            <returns><see langword="true"/>, if the <see cref="T:NCDK.IAtomContainer"/> contains the given atom object</returns>
        </member>
        <member name="M:NCDK.IAtomContainer.Contains(NCDK.IBond)">
            <summary>
            <see langword="true"/>, if the <see cref="T:NCDK.IAtomContainer"/> contains the given bond object.
            </summary>
            <param name="bond">the bond this AtomContainer is searched for</param>
            <returns><see langword="true"/>, if the <see cref="T:NCDK.IAtomContainer"/> contains the given bond object</returns>
        </member>
        <member name="M:NCDK.IAtomContainer.Contains(NCDK.ILonePair)">
            <summary>
            <see langword="true"/>, if the <see cref="T:NCDK.IAtomContainer"/> contains the given <see cref="T:NCDK.ILonePair"/> object.
            </summary>
            <param name="lonePair">the <see cref="T:NCDK.ILonePair"/> this <see cref="T:NCDK.IAtomContainer"/> is searched for</param>
            <returns><see langword="true"/>, if the <see cref="T:NCDK.IAtomContainer"/> contains the given <see cref="T:NCDK.ILonePair"/> object</returns>
        </member>
        <member name="M:NCDK.IAtomContainer.Contains(NCDK.ISingleElectron)">
            <summary>
            <see langword="true"/>, if the <see cref="T:NCDK.IAtomContainer"/> contains the given <see cref="T:NCDK.ISingleElectron"/> object.
            </summary>
            <param name="singleElectron">the <see cref="T:NCDK.ISingleElectron"/> this <see cref="T:NCDK.IAtomContainer"/> is searched for</param>
            <returns><see langword="true"/>, if the <see cref="T:NCDK.IAtomContainer"/> contains the given <see cref="T:NCDK.ISingleElectron"/> object</returns>
        </member>
        <member name="M:NCDK.IAtomContainer.Contains(NCDK.IElectronContainer)">
            <summary>
            <see langword="true"/>, if the <see cref="T:NCDK.IAtomContainer"/> contains the given <see cref="T:NCDK.IElectronContainer"/> object.
            </summary>
            <param name="electronContainer">the <see cref="T:NCDK.IElectronContainer"/> this <see cref="T:NCDK.IAtomContainer"/> is searched for</param>
            <returns><see langword="true"/>, if the <see cref="T:NCDK.IAtomContainer"/> contains the given <see cref="T:NCDK.IElectronContainer"/> object</returns>
        </member>
        <member name="M:NCDK.IAtomContainer.IsEmpty">
            <summary>
            Indicates whether this container is empty. The container is considered empty if
            there are no atoms. Bonds are not checked as a graph with no vertexes can not
            have edges.
            </summary>
            <returns>whether the container is empty</returns>
        </member>
        <member name="T:NCDK.IChemObjectSet`1">
            <summary>
            A generic set of <see cref="T:NCDK.IAtomContainer"/>s.
            </summary>
            <typeparam name="T">Type of element.</typeparam>
        </member>
        <member name="M:NCDK.IChemObjectSet`1.SetMultiplier(`0,System.Nullable{System.Double})">
            <summary>
            Sets the coefficient of a <see cref="T:NCDK.IAtomContainer"/> to a given value.
            </summary>
            <param name="container">The <see cref="T:NCDK.IAtomContainer"/> for which the multiplier is set</param>
            <param name="multiplier">The new multiplier for the <see cref="T:NCDK.IAtomContainer"/></param>
            <seealso cref="M:NCDK.IChemObjectSet`1.GetMultiplier(`0)"/>
        </member>
        <member name="M:NCDK.IChemObjectSet`1.Add(`0,System.Nullable{System.Double})">
            <summary>
            Adds an <paramref name="atomContainer"/> to this container with the given multiplier.
            </summary>
            <param name="atomContainer">The <paramref name="atomContainer"/> to be added to this container</param>
            <param name="multiplier">The multiplier of this atomContainer</param>
        </member>
        <member name="M:NCDK.IChemObjectSet`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Adds all <see cref="T:NCDK.IAtomContainer"/> in the <paramref name="atomContainerSet"/> to this container.
            </summary>
            <param name="atomContainerSet"><see cref="T:NCDK.IAtomContainer"/>s to add.</param>
        </member>
        <member name="M:NCDK.IChemObjectSet`1.GetMultiplier(`0)">
            <summary>
            Returns the multiplier of the given <see cref="T:NCDK.IAtomContainer"/>.
            </summary>
            <param name="container">The <see cref="T:NCDK.IAtomContainer"/> for which the multiplier is given</param>
            <returns>-1, if the given molecule is not a container in this set</returns>
        </member>
        <member name="M:NCDK.IChemObjectSet`1.Sort(System.Collections.Generic.IComparer{`0})">
            <summary>
            Sort the <see cref="T:NCDK.IAtomContainer"/>s using a provided <see cref="T:System.Collections.Generic.IComparer`1"/> .
            </summary>
            <param name="comparator">defines the sorting method</param>
        </member>
        <member name="M:NCDK.IChemObjectSet`1.SetMultiplier(System.Int32,System.Nullable{System.Double})">
            <summary>
            Sets the coefficient of a <see cref="T:NCDK.IAtomContainer"/> to a given value.
            </summary>
            <param name="position">The position of the <see cref="T:NCDK.IAtomContainer"/> for which the multiplier is set in [0,..]</param>
            <param name="multiplier">The new multiplier for the <see cref="T:NCDK.IAtomContainer"/> at <paramref name="position"/></param>
            <seealso cref="M:NCDK.IChemObjectSet`1.GetMultiplier(System.Int32)"/>
        </member>
        <member name="M:NCDK.IChemObjectSet`1.GetMultipliers">
            <summary>
            Returns an array of double with the stoichiometric coefficients
            of the products.
            </summary>
            <returns>The multipliers for the AtomContainer's in this set</returns>
            <seealso cref="M:NCDK.IChemObjectSet`1.SetMultipliers(System.Collections.Generic.IEnumerable{System.Nullable{System.Double}})"/>
        </member>
        <member name="M:NCDK.IChemObjectSet`1.SetMultipliers(System.Collections.Generic.IEnumerable{System.Nullable{System.Double}})">
            <summary>
            Sets the multipliers of the <see cref="T:NCDK.IAtomContainer"/>s.
            </summary>
            <param name="multipliers">The new multipliers for the <see cref="T:NCDK.IAtomContainer"/>s in this set</param>
            <returns>true if multipliers have been set.</returns>
            <seealso cref="M:NCDK.IChemObjectSet`1.GetMultipliers"/>
        </member>
        <member name="M:NCDK.IChemObjectSet`1.GetMultiplier(System.Int32)">
            <summary>
            Returns the multiplier of the given AtomContainer.
            </summary>
            <param name="number">The <see cref="T:NCDK.IAtomContainer"/> for which the multiplier is given</param>
            <returns>-1, if the given molecule is not a container in this set</returns>
            <seealso cref="M:NCDK.IChemObjectSet`1.SetMultiplier(System.Int32,System.Nullable{System.Double})"/>
        </member>
        <member name="M:NCDK.IChemObjectSet`1.IsEmpty">
            <summary>
            Returns <see langword="true"/> if this <see cref="T:NCDK.IAtomContainerSet"/> is empty.
            </summary>
            <returns>a boolean indicating if this ring set no atom containers</returns>
        </member>
        <member name="T:NCDK.IBioPolymer">
            <summary>
            A BioPolymer is a subclass of a Polymer which is supposed to store
            additional informations about the Polymer which are connected to BioPolymers.
            </summary>
        </member>
        <member name="M:NCDK.IBioPolymer.AddAtom(NCDK.IAtom,NCDK.IStrand)">
            <summary>
            Adds the atom oAtom to a specified Strand, whereas the Monomer is unspecified. Hence
            the atom will be added to a Monomer of type Unknown in the specified Strand.
            </summary>
            <param name="oAtom">The atom to add</param>
            <param name="oStrand">The strand the atom belongs to</param>
        </member>
        <member name="M:NCDK.IBioPolymer.AddAtom(NCDK.IAtom,NCDK.IMonomer,NCDK.IStrand)">
            <summary>
            Adds the atom to a specified Strand and a specified Monomer.
            </summary>
            <param name="oAtom">The atom to add</param>
            <param name="oMonomer">The monomer the atom belongs to</param>
            <param name="oStrand">The strand the atom belongs to</param>
        </member>
        <member name="M:NCDK.IBioPolymer.GetMonomer(System.String,System.String)">
            <summary>
            Retrieve a <see cref="T:NCDK.IMonomer"/> object by specifying its name.
            You have to specify the strand to enable
            monomers with the same name in different strands. There is at least one such case: every
            strand contains a monomer called "".
            </summary>
            <param name="monName">The name of the monomer to look for</param>
            <param name="strandName">The name of the strand to look for</param>
            <returns>The Monomer object which was asked for</returns>
        </member>
        <member name="M:NCDK.IBioPolymer.GetStrandMap">
            <summary>
            Map containing the strands in the Polymer.
            </summary>
            <returns><see cref="T:System.Collections.Generic.IDictionary`2"/> containing the strands in the Polymer</returns>
        </member>
        <member name="M:NCDK.IBioPolymer.GetStrand(System.String)">
            <summary>
            Retrieve a Monomer object by specifying its name.
            </summary>
            <param name="cName">The name of the monomer to look for</param>
            <returns>The Monomer object which was asked for</returns>
        </member>
        <member name="M:NCDK.IBioPolymer.GetStrandNames">
            <summary>
            Returns a collection of the names of all <see cref="T:NCDK.IStrand"/>s in this <see cref="T:NCDK.IBioPolymer"/>.
            </summary>
            <returns><see cref="T:System.Collections.Generic.IEnumerable`1"/> of all the strand names.</returns>
        </member>
        <member name="M:NCDK.IBioPolymer.RemoveStrand(System.String)">
            <summary>
            Removes a particular strand, specified by its name.
            </summary>
            <param name="name">The name of the strand to remove</param>
        </member>
        <member name="T:NCDK.IBond">
            <summary>
            Implements the concept of a covalent bond between two or more atoms. A bond is
            considered to be a number of electrons connecting two ore more atoms.
            type filter text
            </summary>
        </member>
        <member name="P:NCDK.IBond.Atoms">
            <summary>
            Atoms making up this bond.
            </summary>
        </member>
        <member name="M:NCDK.IBond.SetAtoms(System.Collections.Generic.IEnumerable{NCDK.IAtom})">
            <summary>
            Sets atoms making up this bond.
            </summary>
            <param name="atoms">Atoms that forms this bond</param>
        </member>
        <member name="P:NCDK.IBond.Begin">
            <summary>
            The begin (or first) atom of the bond.
            </summary>
            <returns>the begin atom</returns>
        </member>
        <member name="P:NCDK.IBond.End">
            <summary>
            The end (or second) atom of the bond.
            </summary>
            <returns>the end atom</returns>
        </member>
        <member name="M:NCDK.IBond.GetConnectedAtom(NCDK.IAtom)">
            <summary>
            Returns the other atom in the bond, the atom is connected to the given atom. This
            method is only correct for two-centre bonds, for n-centre bonds the behaviour is undefined
            and the more correct <see cref="M:NCDK.IBond.GetConnectedAtoms(NCDK.IAtom)"/> should be used.
            </summary>
            <example>
            <code>IAtom beg = bond.getBegin();
            IAtom end = bond.getEnd();
            // bond.getConnectedAtom(beg) == end
            // bond.getConnectedAtom(end) == beg
            </code>
            </example>
            <param name="atom">The atom the bond partner is searched of</param>
            <returns>the connected atom or null if the given atom is not part of the bond</returns>
        </member>
        <member name="M:NCDK.IBond.GetOther(NCDK.IAtom)">
            <summary>
            Returns the other atom in the bond, the atom is connected to the given atom.This
            method is only correct for two-centre bonds, for n-centre bonds the behaviour is undefined
            and the more correct <see cref="M:NCDK.IBond.GetConnectedAtoms(NCDK.IAtom)"/> should be used.
            </summary>
            <example>
            <code>IAtom beg = bond.getBegin();
            IAtom end = bond.getEnd();
            // bond.getOther(beg) == end
            // bond.getOther(end) == beg
            </code>
            </example>
            <param name="atom">The atom the bond partner is searched of</param>
            <returns>the connected atom or null if the given atom is not part of the bond</returns>
        </member>
        <member name="M:NCDK.IBond.GetConnectedAtoms(NCDK.IAtom)">
            <summary>
            Returns all the atoms in the bond connected to the given atom.
            </summary>
            <param name="atom">The atoms the bond partner is searched of</param>
            <returns>the connected atoms or <see langword="null"/> if the given atom is not part of the bond</returns>
        </member>
        <member name="M:NCDK.IBond.Contains(NCDK.IAtom)">
            <summary>
            Returns true if the given atom participates in this bond.
            </summary>
            <param name="atom">The atom to be tested if it participates in this bond</param>
            <returns>true if the atom participates in this bond</returns>
        </member>
        <member name="P:NCDK.IBond.Order">
            <summary>
            The bond order of this bond.
            </summary>
        </member>
        <member name="P:NCDK.IBond.Stereo">
            <summary>
            The stereo descriptor for this bond.
            </summary>
        </member>
        <member name="P:NCDK.IBond.Geometric2DCenter">
            <summary>
            The geometric 2D center of the bond.
            </summary>
        </member>
        <member name="P:NCDK.IBond.Geometric3DCenter">
            <summary>
            The geometric 3D center of the bond.
            </summary>
        </member>
        <member name="M:NCDK.IBond.IsConnectedTo(NCDK.IBond)">
            <summary>
            Checks whether a bond is connected to another one. This can only be true if the bonds have an Atom in common.
            </summary>
            <param name="bond">The bond which is checked to be connect with this one</param>
            <returns><see langword="true"/>, if the bonds share an atom, otherwise <see langword="false"/></returns>
        </member>
        <member name="P:NCDK.IBond.IsSingleOrDouble">
            <summary>
            It's unclear whether the bond is a single or double bond.
            </summary>
        </member>
        <member name="P:NCDK.IBond.IsReactiveCenter">
            <summary>
            It has reactive center. It is used for example in reaction.
            </summary>
        </member>
        <member name="T:NCDK.IChemFile">
            <summary>
            An <see cref="T:NCDK.IChemObject"/> containing a number of ChemSequences. This is supposed to be the
            top level container, which can contain all the concepts stored in a chemical document
            </summary>
        </member>
        <member name="T:NCDK.IChemModel">
            <summary>
            An object containing multiple MoleculeSet and
            the other lower level concepts like rings, sequences,
            fragments, etc.
            </summary>
        </member>
        <member name="P:NCDK.IChemModel.MoleculeSet">
            <summary>
            The <see cref="T:NCDK.IChemObjectSet`1"/> of this <see cref="T:NCDK.IChemModel"/>.
            </summary>
        </member>
        <member name="P:NCDK.IChemModel.RingSet">
            <summary>
            The <see cref="T:NCDK.IRingSet"/> of this <see cref="T:NCDK.IChemModel"/>.
            </summary>
        </member>
        <member name="P:NCDK.IChemModel.Crystal">
            <summary>
            The <see cref="T:NCDK.ICrystal"/> of this <see cref="T:NCDK.IChemModel"/>.
            </summary>
        </member>
        <member name="P:NCDK.IChemModel.ReactionSet">
            <summary>
            The <see cref="T:NCDK.IReactionSet"/> of this <see cref="T:NCDK.IChemModel"/>.
            </summary>
        </member>
        <member name="M:NCDK.IChemModel.IsEmpty">
            <summary>
            Returns true if this <see cref="T:NCDK.IChemModel"/> is empty.
            </summary>
            <returns>a boolean indicating if this model has no content</returns>
        </member>
        <member name="T:NCDK.IChemSequence">
            <summary>
            A sequence of ChemModels, which can, for example, be used to
            store the course of a reaction.Each state of the reaction would be
            stored in one ChemModel.
            </summary>
        </member>
        <member name="T:NCDK.ICrystal">
            <summary>
            Class representing a molecular crystal.
            The crystal is described with molecules in fractional
            coordinates and three cell axes: a,b and c.
            The crystal is designed to store only the asymetric atoms.
            Though this is not enforced, it is assumed by all methods.
            </summary>
        </member>
        <member name="P:NCDK.ICrystal.A">
            <summary>the A unit cell axes in carthesian coordinates in a eucledian space.</summary>
        </member>
        <member name="P:NCDK.ICrystal.B">
            <summary>the B unit cell axes in carthesian coordinates in a eucledian space.</summary>
        </member>
        <member name="P:NCDK.ICrystal.C">
            <summary>the C unit cell axes in carthesian coordinates in a eucledian space.</summary>
        </member>
        <member name="P:NCDK.ICrystal.SpaceGroup">
            <summary>the space group of this crystal.</summary>
        </member>
        <member name="P:NCDK.ICrystal.Z">
            <summary>the number of asymmetric parts in the unit cell.</summary>
        </member>
        <member name="T:NCDK.IDoubleBondStereochemistry">
            <summary>
            Stereochemistry specification for double bond stereochemistry. The data model defines the double
            atoms and two ligands attached to those two atoms, linearly connected with the double bond in the
            middle. The IBonds that define the stereo element are defined as an array where the bonds
            are sorted according to the linear connectivity.Thus, the first and third bonds are the two
            bonds attached on either side of the double bond, and the second bond is the double bond.
            The stereo annotation then indicates if the ligand atoms are in the cis position
            (Conformation.Together) or in the trans position (Conformation.Opposite), matching the
            orientation of the methyls in but-2-ene respectively as <i>Z</i> and <i>E</i>.
            </summary>
        </member>
        <member name="P:NCDK.IDoubleBondStereochemistry.Bonds">
            <summary>
            An array of ligand bonds around the double bond.
            </summary>
            <value>an array of two <see cref="T:NCDK.IBond"/>s.</value>
        </member>
        <member name="P:NCDK.IDoubleBondStereochemistry.StereoBond">
            <summary>
            <see cref="T:NCDK.IBond"/> that is the stereo center.
            </summary>
        </member>
        <member name="P:NCDK.IDoubleBondStereochemistry.Stereo">
            <summary>
            Defines the stereochemistry around the double bond.
            </summary>
            <value>The <see cref="T:NCDK.DoubleBondConformation"/> for this stereo element.</value>
        </member>
        <member name="T:NCDK.IElectronContainer">
            <summary>
            Base class for entities containing electrons, like bonds, orbitals, lone-pairs.
            </summary>
        </member>
        <member name="P:NCDK.IElectronContainer.ElectronCount">
            <summary>
            The number of electrons in this electron container.
            </summary>
        </member>
        <member name="T:NCDK.IFragmentAtom">
            <summary>
            Class to represent an IPseudoAtom which embeds an IAtomContainer. Very much
            like the MDL molfile Group concept.
            </summary>
        </member>
        <member name="P:NCDK.IFragmentAtom.IsExpanded">
            <summary>
            Helper method to indicate that the method should be drawn fully, and not
            just the abbreviated form.
            </summary>
            <value><see langword="true"/> if the full structure should be drawn</value>
        </member>
        <member name="P:NCDK.IFragmentAtom.Fragment">
            <summary>
            The fully expanded form as an <see cref="T:NCDK.IAtomContainer"/>  object
            </summary>
        </member>
        <member name="T:NCDK.ILonePair">
            <summary>
            A LonePair is an orbital primarily located with one Atom, containing two electrons.
            </summary>
        </member>
        <member name="P:NCDK.ILonePair.Atom">
            <summary>
             The associated <see cref="T:NCDK.IAtom"/>.
            </summary>
        </member>
        <member name="M:NCDK.ILonePair.Contains(NCDK.IAtom)">
            <summary>
            Returns <see langword="true"/> if the given atom participates in this lone pair.
            </summary>
            <param name="atom">The atom to be tested if it participates in this bond</param>
            <returns><see langword="true"/> if this lone pair is associated with the atom</returns>
        </member>
        <member name="T:NCDK.IMapping">
            <summary>
            Represents a mapping of two atoms.
            </summary>
        </member>
        <member name="P:NCDK.IMapping.Item(System.Int32)">
            <summary>
            Retrieve the first or second of the related <see cref="T:NCDK.IChemObject"/>s.
            </summary>
            <param name="index">The position of the <see cref="T:NCDK.IChemObject"/>.</param>
            <returns>The <see cref="T:NCDK.IChemObject"/> to retrieve.</returns>
        </member>
        <member name="M:NCDK.IMapping.GetRelatedChemObjects">
            <summary>
            Returns an <see cref="T:System.Collections.Generic.IEnumerable`1"/> to the two <see cref="T:NCDK.IChemObject"/>.
            </summary>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> to two <see cref="T:NCDK.IChemObject"/>s that define the mapping</returns>
        </member>
        <member name="T:NCDK.IMolecularFormulaSet">
            <summary>
            Class defining a molecular formula object. It maintains a list of list <see cref="T:NCDK.IMolecularFormula"/>.
            </summary>
            <remarks>
            Examples:
            <list type="bullet">
            <item>[C5H5]-</item>
            <item>C6H6</item>
            <item><sup>12</sup>C<sub>5</sub><sup>13</sup>CH<sub>6</sub></item>
            </list>
            </remarks>
        </member>
        <member name="M:NCDK.IMolecularFormulaSet.AddRange(System.Collections.Generic.IEnumerable{NCDK.IMolecularFormula})">
            <summary>
            Adds all molecular formulas in the <see cref="T:System.Collections.Generic.IEnumerable`1"/> of <see cref="T:NCDK.IMolecularFormula"/> to this <see cref="T:NCDK.IChemObject"/>.
            </summary>
            <param name="collection"></param>
        </member>
        <member name="T:NCDK.IMonomer">
            <summary>
            A <see cref="T:NCDK.IMonomer"/> is an <see cref="T:NCDK.IAtomContainer"/> which stores additional monomer specific informations for a group of atoms.
            </summary>
        </member>
        <member name="P:NCDK.IMonomer.MonomerName">
            <summary>
            The name of the Monomer object.
            </summary>
        </member>
        <member name="P:NCDK.IMonomer.MonomerType">
            <summary>
            The type of the Monomer object.
            </summary>
        </member>
        <member name="T:NCDK.IPDBAtom">
            <summary>
            A PDBAtom is a subclass of a Atom which is supposed to store additional informations about the Atom.
            </summary>
        </member>
        <member name="P:NCDK.IPDBAtom.TempFactor">
            <summary>
            the Temperature factor of this atom
            </summary>
        </member>
        <member name="P:NCDK.IPDBAtom.ResName">
            <summary>
            the Residue name of this atom
            </summary>
        </member>
        <member name="P:NCDK.IPDBAtom.ICode">
            <summary>
            the Code for insertion of residues of this atom
            </summary>
        </member>
        <member name="P:NCDK.IPDBAtom.Name">
            <summary>
            The Atom name of this atom.
            </summary>
        </member>
        <member name="P:NCDK.IPDBAtom.ChainID">
            <summary>
            the Chain identifier of this atom
            </summary>
        </member>
        <member name="P:NCDK.IPDBAtom.AltLoc">
            <summary>
            the Alternate location indicator of this atom
            </summary>
        </member>
        <member name="P:NCDK.IPDBAtom.SegID">
            <summary>
            the Segment identifier, left-justified of this atom
            </summary>
        </member>
        <member name="P:NCDK.IPDBAtom.Serial">
            <summary>
            the Atom serial number of this atom
            </summary>
        </member>
        <member name="P:NCDK.IPDBAtom.ResSeq">
            <summary>
            the Residue sequence number of this atom
            </summary>
        </member>
        <member name="P:NCDK.IPDBAtom.Oxt">
            <summary>
            true if this atom is a PDB OXT atom.
            </summary>
        </member>
        <member name="P:NCDK.IPDBAtom.HetAtom">
            <summary>
            true if the atom is a heteroatom, otherwise false
            </summary>
        </member>
        <member name="P:NCDK.IPDBAtom.Occupancy">
            <summary>
            the Occupancy of this atom
            </summary>
        </member>
        <member name="T:NCDK.IPDBMonomer">
            <summary>
            Represents the idea of an protein monomer as found in PDB files.
            </summary>
        </member>
        <member name="P:NCDK.IPDBMonomer.ICode">
            <summary>
            the I code of this monomer
            </summary>
        </member>
        <member name="P:NCDK.IPDBMonomer.ChainID">
            <summary>
            the Chain ID of this monomer
            </summary>
        </member>
        <member name="P:NCDK.IPDBMonomer.ResSeq">
            <summary>
            the sequence identifier of this monomer
            </summary>
        </member>
        <member name="T:NCDK.IPDBPolymer">
            <summary>
            A PDBPolymer is a subclass of a BioPolymer which is supposed to store
            additional informations about the BioPolymer which are connected to BioPolymers.
            </summary>
        </member>
        <member name="M:NCDK.IPDBPolymer.Add(NCDK.IPDBAtom)">
            <summary>
            Adds the atom oAtom without specifying a Monomer or a Strand. Therefore the
            atom to this AtomContainer, but not to a certain Strand or Monomer (intended
            e.g. for HETATMs).
            </summary>
            <param name="oAtom">The atom to add</param>
        </member>
        <member name="M:NCDK.IPDBPolymer.AddAtom(NCDK.IPDBAtom,NCDK.IMonomer,NCDK.IStrand)">
            <summary>
            Adds the atom to a specified Strand and a specified Monomer.
            </summary>
            <param name="oAtom">The atom to add</param>
            <param name="oMonomer">The monomer the atom belongs to</param>
            <param name="oStrand">The strand the atom belongs to</param>
        </member>
        <member name="M:NCDK.IPDBPolymer.Add(NCDK.IPDBStructure)">
            <summary>
            Adds the PDBStructure structure a this PDBPolymer.
            </summary>
            <param name="structure">The PDBStructure to add</param>
        </member>
        <member name="M:NCDK.IPDBPolymer.GetStructures">
            <summary>
            Returns a Collection containing the PDBStructure in the PDBPolymer.
            </summary>
            <returns>Collection containing the PDBStructure in the PDBPolymer</returns>
        </member>
        <member name="T:NCDK.IPDBStructure">
            <summary>
            Represents the idea of an chemical structure.
            </summary>
        </member>
        <member name="P:NCDK.IPDBStructure.EndChainID">
            <summary>
            the ending Chain identifier of this structure
            </summary>
        </member>
        <member name="P:NCDK.IPDBStructure.EndInsertionCode">
            <summary>
            the ending Code for insertion of residues of this structure
            </summary>
        </member>
        <member name="P:NCDK.IPDBStructure.EndSequenceNumber">
            <summary>
            the ending sequence number of this structure
            </summary>
        </member>
        <member name="P:NCDK.IPDBStructure.StartChainID">
            <summary>
            the start Chain identifier of this structure
            </summary>
        </member>
        <member name="P:NCDK.IPDBStructure.StartInsertionCode">
            <summary>
            the start Code for insertion of residues of this structure
            </summary>
        </member>
        <member name="P:NCDK.IPDBStructure.StartSequenceNumber">
            <summary>
            the start sequence number of this structure
            </summary>
        </member>
        <member name="P:NCDK.IPDBStructure.StructureType">
            <summary>
            the Structure Type of this structure
            </summary>
        </member>
        <member name="T:NCDK.IPolymer">
            <summary>
            Subclass of Molecule to store Polymer specific attributes that a Polymer has.
            </summary>
        </member>
        <member name="M:NCDK.IPolymer.AddAtom(NCDK.IAtom,NCDK.IMonomer)">
            <summary>
            Adds the atom oAtom to a specified Monomer.
            </summary>
            <param name="oAtom">The atom to add</param>
            <param name="oMonomer">The monomer the atom belongs to</param>
        </member>
        <member name="M:NCDK.IPolymer.GetMonomerMap">
            <summary>
            Returns the monomers present in the <see cref="T:NCDK.IPolymer"/>.
            </summary>
            <returns><see cref="T:System.Collections.Generic.IEnumerable`1"/> of <see cref="T:System.Collections.Generic.KeyValuePair`2"/> of monomers present in the <see cref="T:NCDK.IPolymer"/>.</returns>
        </member>
        <member name="M:NCDK.IPolymer.GetMonomer(System.String)">
            <summary>
            Retrieve a Monomer object by specifying its name.
            </summary>
            <param name="name">The name of the monomer to look for</param>
            <returns>The <see cref="T:NCDK.IMonomer"/> object which was asked for</returns>
        </member>
        <member name="M:NCDK.IPolymer.GetMonomerNames">
            <summary>
            Returns <see cref="T:System.Collections.Generic.IEnumerable`1"/> of the names of all <see cref="T:NCDK.IMonomer"/>s in this polymer.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NCDK.IPolymer.RemoveMonomer(System.String)">
            <summary>
            Removes a particular monomer, specified by its name.
            </summary>
            <param name="name">The name of the monomer to be removed</param>
        </member>
        <member name="T:NCDK.IPseudoAtom">
            <summary>
            Represents the idea of a non-chemical atom-like entity, like Me, R, X, Phe, His, etc.
            <para>This should be replaced by the mechanism explained in RFC #8.</para>
            </summary>
            <seealso cref="T:NCDK.IAtom"/>
        </member>
        <member name="P:NCDK.IPseudoAtom.Label">
            <summary>
            The label of this <see cref="T:NCDK.IPseudoAtom"/>.
            </summary>
        </member>
        <member name="P:NCDK.IPseudoAtom.AttachPointNum">
            <summary>
            The attachment point number.
            </summary>
            <value>The default, 0, indicates this atom is not an attachment point.</value>
        </member>
        <member name="T:NCDK.IReaction">
            <summary>
            Represents the idea of a chemical reaction. The reaction consists of
            a set of reactants and a set of products.
            
            <para>The class mostly represents abstract reactions, such as 2D diagrams,
            and is not intended to represent reaction trajectories.Such can better
            be represented with a ChemSequence.</para>
            </summary>
        </member>
        <member name="P:NCDK.IReaction.Reactants">
            <summary>
            The reactants in this reaction.
            </summary>
        </member>
        <member name="P:NCDK.IReaction.Products">
            <summary>
            The products in this reaction.
            </summary>
        </member>
        <member name="P:NCDK.IReaction.Agents">
            <summary>
            The agents in this reaction.
            </summary>
        </member>
        <member name="P:NCDK.IReaction.Direction">
            <summary>
            The <see cref="T:NCDK.ReactionDirections"/> of the reaction.
            </summary>
        </member>
        <member name="P:NCDK.IReaction.Mappings">
            <summary>
            Returns the mappings between the reactant and the product side.
            </summary>
        </member>
        <member name="T:NCDK.IReactionSet">
            <summary>
            A set of reactions, for example those taking part in a reaction.
            </summary>
        </member>
        <member name="M:NCDK.IReactionSet.IsEmpty">
            <summary>
            Returns true if this IReactionSet is empty.
            </summary>
            <returns>a boolean indicating if this ring set no reactions</returns>
        </member>
        <member name="T:NCDK.IRing">
            <summary>
            Class representing a ring structure in a molecule.
            A ring is a linear sequence of
            N atoms interconnected to each other by covalent bonds,
            such that atom i (1 &lt; i &lt; N) is bonded to
            atom i-1 and atom i+1 and atom 1 is bonded to atom N and atom 2.
            </summary>
        </member>
        <member name="P:NCDK.IRing.RingSize">
            <summary>
            The number of atoms/bonds in this ring.
            </summary>
        </member>
        <member name="M:NCDK.IRing.GetNextBond(NCDK.IBond,NCDK.IAtom)">
            <summary>
            Returns the next bond in order, relative to a given bond and atom.
            Example: Let the ring be composed of 0-1, 1-2, 2-3 and 3-0.
            A request GetNextBond(1-2, 2) will return Bond 2-3.
            </summary>
            <param name="bond">A bond for which an atom from a consecutive bond is sought</param>
            <param name="atom">A atom from the bond above to assign a search direction</param>
            <returns>The next bond in the order given by the above assignment</returns>
        </member>
        <member name="P:NCDK.IRing.BondOrderSum">
            <summary>
            The sum of all bond orders in the ring.
            </summary>
        </member>
        <member name="T:NCDK.IRingSet">
            <summary>
            Maintains a set of Ring objects.
            </summary>
        </member>
        <member name="M:NCDK.IRingSet.GetRings(NCDK.IBond)">
            <summary>
            all rings that this bond is part of.
            </summary>
            <param name="bond">The bond to be checked</param>
            <returns>all rings that this bond is part of</returns>
        </member>
        <member name="M:NCDK.IRingSet.GetRings(NCDK.IAtom)">
            <summary>
            all rings that this atom is part of.
            </summary>
            <param name="atom">The atom to be checked</param>
            <returns>all rings that this bond is part of</returns>
        </member>
        <member name="M:NCDK.IRingSet.GetConnectedRings(NCDK.IRing)">
            <summary>
            Returns all the rings in the RingSet that share
            one or more atoms with a given ring.
            </summary>
            <param name="ring">A ring with which all return rings must share one or more atoms</param>
            <returns>All the rings that share one or more atoms with a given ring.</returns>
        </member>
        <member name="M:NCDK.IRingSet.Add(NCDK.IRingSet)">
            <summary>
            Adds all rings of another RingSet if they are not allready part of this ring set.
            If you want to add a single ring to the set use Add(IAtomContainer)
            </summary>
            <param name="ringSet">the ring set to be united with this one.</param>
        </member>
        <member name="M:NCDK.IRingSet.Contains(NCDK.IAtom)">
            <summary>
            True, if at least one of the rings in the ringset contains the given atom.
            </summary>
            <param name="atom">Atom to check</param>
            <returns>true, if the ringset contains the atom</returns>
        </member>
        <member name="T:NCDK.ISingleElectron">
            <summary>
            A single electron is an orbital which is occupied by only one electron.
            </summary>
            <example>
            A radical in CDK is represented by an <see cref="T:NCDK.IAtomContainer" /> that contains an <see cref="T:NCDK.IAtom" />  
            and a <see cref="T:NCDK.ISingleElectron" /> type <see cref="T:NCDK.IElectronContainer" />:
            <code>                AtomContainer radical = new AtomContainer();
                Atom carbon = new Atom("C");
                carbon.ImplicitHydrogenCount = 3;
                radical.AddElectronContainer(new SingleElectron(carbon));
</code>
            </example>
        </member>
        <member name="P:NCDK.ISingleElectron.Atom">
            <summary>
            The associated <see cref="T:NCDK.IAtom"/>.
            </summary>
        </member>
        <member name="M:NCDK.ISingleElectron.Contains(NCDK.IAtom)">
            <summary>
            Returns <see langword="true"/> if the given atom participates in this <see cref="T:NCDK.ISingleElectron"/>.
            </summary>
            <param name="atom">The atom to be tested if it participates in this bond</param>
            <returns><see langword="true"/> if this <see cref="T:NCDK.ISingleElectron"/> is associated with the atom</returns>
        </member>
        <member name="T:NCDK.IStereoElement">
            <summary>
            Represents the concept of a stereo element in the molecule. Stereo elements can be
            that of quadrivalent atoms, cis/trans isomerism around double bonds, but also include
            axial and helical stereochemistry.
            </summary>
        </member>
        <member name="M:NCDK.IStereoElement.Contains(NCDK.IAtom)">
            <summary>
            Does the stereo element contain the provided atom.
            </summary>
            <param name="atom">an atom to test membership</param>
            <returns>whether the atom is present</returns>
        </member>
        <member name="T:NCDK.IStrand">
            <summary>
            A Strand is an AtomContainer which stores additional strand specific informations for a group of Atoms.
            </summary>
        </member>
        <member name="M:NCDK.IStrand.AddAtom(NCDK.IAtom)">
            <summary>
            Adds the atom <paramref name="oAtom"/> without specifying a <see cref="T:NCDK.IMonomer"/> or a <see cref="T:NCDK.IStrand"/>. 
            Therefore the atom gets added to a <see cref="T:NCDK.IMonomer"/> of type "Unknown" in a Strand of type "Unknown".
            </summary>
            <param name="oAtom">The atom to add</param>
        </member>
        <member name="M:NCDK.IStrand.AddAtom(NCDK.IAtom,NCDK.IMonomer)">
            <summary>
            Adds the atom <paramref name="oAtom"/> to a specified <paramref name="oMonomer"/>.
            </summary>
            <param name="oAtom">The atom to add</param>
            <param name="oMonomer">The monomer the atom belongs to</param>
        </member>
        <member name="M:NCDK.IStrand.GetMonomerMap">
            <summary>
            Returns the monomers in this strand.
            </summary>
            <returns>Map containing the monomers in the strand.</returns>
        </member>
        <member name="M:NCDK.IStrand.GetMonomer(System.String)">
            <summary>
            Retrieve a <see cref="T:NCDK.IMonomer"/> object by specifying its name.
            </summary>
            <param name="name">The name of the monomer to look for</param>
            <returns>The Monomer object which was asked for</returns>
        </member>
        <member name="M:NCDK.IStrand.GetMonomerNames">
            <summary>
            Returns a <see cref="T:System.Collections.Generic.IEnumerable`1"/> of the names of all <see cref="T:NCDK.IMonomer"/>s in this polymer.
            </summary>
            <returns>a <see cref="T:System.Collections.Generic.IEnumerable`1"/> of all the monomer names.</returns>
        </member>
        <member name="M:NCDK.IStrand.RemoveMonomer(System.String)">
            <summary>
            Removes a particular monomer, specified by its name.
            </summary>
            <param name="name">The name of the monomer to remove</param>
        </member>
        <member name="T:NCDK.ISubstance">
            <summary>    
            A chemical substance that consists of one or more chemical structures.
            Examples uses include that of a racemic mixture, a drug composition, and
            a nanomaterial with impurities.
            </summary>
        </member>
        <member name="T:NCDK.ITetrahedralChirality">
            <summary>
            Stereochemistry specification for quadrivalent atoms. The data model defines the central, chiral <see cref="T:NCDK.IAtom"/>,
            and its four ligand <see cref="T:NCDK.IAtom"/>s, directly bonded to the chiral atom via an <see cref="T:NCDK.IBond"/>. The ordering of the
            four ligands is important, and defines together with the <see cref="T:NCDK.TetrahedralStereo"/> to spatial geometry around the chiral atom.
            The first ligand points towards to observer, and the three other ligands point away from the observer; the
            <see cref="T:NCDK.TetrahedralStereo"/> then defines the order of the second, third, and fourth ligand to be clockwise or anti-clockwise.
            <para>
            If the tetrahedral centre has an implicit hydrogen or lone pair then the
            chiral atom is also stored as one of the ligands. This serves as a
            placeholder to indicate where the implicit hydrogen or lone pair would be.
            </para>
            </summary>
        </member>
        <member name="P:NCDK.ITetrahedralChirality.Ligands">
            <summary>
            Returns an array of ligand atoms around the chiral atom. If the chiral
            centre has an implicit hydrogen or lone pair one of the ligands will be
            the chiral atom (<see cref="P:NCDK.ITetrahedralChirality.ChiralAtom"/>).
            </summary>
            <value>an array of four <see cref="T:NCDK.IAtom"/>s.</value>
        </member>
        <member name="F:NCDK.CDKConstants.STEREO_ATOM_PARITY_PLUS">
            <summary>A positive atom parity.</summary>
        </member>
        <member name="F:NCDK.CDKConstants.STEREO_ATOM_PARITY_MINUS">
            <summary>A negative atom parity.</summary>
        </member>
        <member name="F:NCDK.CDKConstants.STEREO_ATOM_PARITY_UNDEFINED">
            <summary>A undefined atom parity.</summary>
        </member>
        <member name="F:NCDK.CDKPropertyName.NMRShift_Carbon">
            <summary>
            Carbon NMR shift constant for use as a key in the
            <see cref="T:NCDK.IChemObject"/>.physicalProperties hashtable.
            </summary>
            <seealso cref="T:NCDK.Default.ChemObject"/>
        </member>
        <member name="F:NCDK.CDKPropertyName.NMRShift_Hydrogen">
            <summary>
            Hydrogen NMR shift constant for use as a key in the
            <see cref="T:NCDK.IChemObject"/>.physicalProperties hashtable.
            </summary>
            <seealso cref="T:NCDK.Default.ChemObject"/>
        </member>
        <member name="F:NCDK.CDKPropertyName.NMRShift_Nitrogen">
            <summary>
            Nitrogen NMR shift constant for use as a key in the
            <see cref="T:NCDK.IChemObject"/>.physicalProperties hashtable.
            </summary>
            <seealso cref="T:NCDK.Default.ChemObject"/>
        </member>
        <member name="F:NCDK.CDKPropertyName.NMRShift_Phosphorus">
            <summary>Phosphorus NMR shift constant for use as a key in the
            <see cref="T:NCDK.IChemObject"/>.physicalProperties hashtable.</summary>
            <seealso cref="T:NCDK.Default.ChemObject"/>
        </member>
        <member name="F:NCDK.CDKPropertyName.NMRShift_Fluorine">
            <summary> Fluorine NMR shift constant for use as a key in the
            <see cref="T:NCDK.IChemObject"/>.physicalProperties hashtable.</summary>
            <seealso cref="T:NCDK.Default.ChemObject"/>
        </member>
        <member name="F:NCDK.CDKPropertyName.NMRShift_Deuterium">
            <summary>Deuterium NMR shift constant for use as a key in the
            <see cref="T:NCDK.IChemObject"/>.physicalProperties hashtable.</summary>
            <seealso cref="T:NCDK.Default.ChemObject"/>
        </member>
        <member name="F:NCDK.CDKPropertyName.CIP_Descriptor">
            <summary> 
            Property key to store the CIP descriptor label for an atom / bond. The
            label is a string.
            </summary>
        </member>
        <member name="F:NCDK.CDKPropertyName.Title">
            <summary>The title for a <see cref="T:NCDK.IChemObject"/>.</summary>
        </member>
        <member name="F:NCDK.CDKPropertyName.Remark">
            <summary>A remark for a <see cref="T:NCDK.IChemObject"/>.</summary>
        </member>
        <member name="F:NCDK.CDKPropertyName.Comment">
            <summary>A string comment.</summary>
        </member>
        <member name="F:NCDK.CDKPropertyName.Names">
            <summary>A List of names.</summary>
        </member>
        <member name="F:NCDK.CDKPropertyName.Annotations">
            <summary>A List of annotation remarks.</summary>
        </member>
        <member name="F:NCDK.CDKPropertyName.Description">
            <summary>A description for a IChemObject.</summary>
        </member>
        <member name="F:NCDK.CDKPropertyName.SMILES">
            <summary>The Daylight SMILES.</summary>
        </member>
        <member name="F:NCDK.CDKPropertyName.InChI">
            <summary>The IUPAC International Chemical Identifier.</summary>
        </member>
        <member name="F:NCDK.CDKPropertyName.Formula">
            <summary>The Molecular Formula Identifier.</summary>
        </member>
        <member name="F:NCDK.CDKPropertyName.AutoNomName">
            <summary>The IUPAC compatible name generated with AutoNom.</summary>
        </member>
        <member name="F:NCDK.CDKPropertyName.BeilsteinRN">
            <summary>The Beilstein Registry Number.</summary>
        </member>
        <member name="F:NCDK.CDKPropertyName.CasRN">
            <summary>The CAS Registry Number.</summary>
        </member>
        <member name="F:NCDK.CDKPropertyName.AllRings">
            <summary>A set of all rings computed for this molecule.</summary>
        </member>
        <member name="F:NCDK.CDKPropertyName.SmallestRings">
            <summary>A smallest set of smallest rings computed for this molecule.</summary>
        </member>
        <member name="F:NCDK.CDKPropertyName.EssentialRings">
            <summary>The essential rings computed for this molecule.
             The concept of Essential Rings is defined in
             SSSRFinder
            </summary>
        </member>
        <member name="F:NCDK.CDKPropertyName.RelevantRings">
            <summary>The relevant rings computed for this molecule.
             The concept of relevant Rings is defined in
             SSSRFinder
            </summary>
        </member>
        <member name="F:NCDK.CDKPropertyName.ReactionRole">
            <summary>
            Property used for reactions when converted to/from molecules. It defines what role and atom
            has an a reaction.
            
            Used in. ReactionManipulator.toMolecule and ReactionManipulator.toReaction.
            </summary>
        </member>
        <member name="F:NCDK.CDKPropertyName.ReactionGroup">
            <summary>
            Property used for reactions when converted to/from molecules. It defines fragment grouping, for example
            when handling ionic components.
            
            Used in. ReactionManipulator.toMolecule and ReactionManipulator.toReaction.
            </summary>
        </member>
        <member name="F:NCDK.CDKPropertyName.RingSizes">
            <summary>
            This property will contain an List of Integers. Each
            element of the list indicates the size of the ring the given
            atom belongs to (if it is a ring atom at all).
            </summary>
        </member>
        <member name="F:NCDK.CDKPropertyName.RingConnections">
            <summary>
            This property indicates how many ring bonds are connected to
            the given atom.
            </summary>
        </member>
        <member name="F:NCDK.CDKPropertyName.TotalConnections">
            <summary>
            This property indicate how many bond are present on the atom.
            </summary>
        </member>
        <member name="F:NCDK.CDKPropertyName.TotalHCount">
            <summary>
            Hydrogen count
            </summary>
        </member>
        <member name="F:NCDK.CDKPropertyName.IsotropicShielding">
            <summary>The Isotropic Shielding, usually calculated by
            a quantum chemistry program like Gaussian.
            This is a property used for calculating NMR chemical
            shifts by subtracting the value from the
            isotropic shielding value of a standard (e.g. TMS).
            </summary>
        </member>
        <member name="F:NCDK.CDKPropertyName.RestH">
            <summary>
            A property to indicate IsRestH being true or false. IsRestH is a term
            used in RGroup queries: "if this property is applied ('on'), sites labelled
            with Rgroup rrr may only be substituted with a member of the Rgroup or with H"
            </summary>
        </member>
        <member name="F:NCDK.CDKPropertyName.ACDLabsAtomLabel">
            <summary>
            Atom number/label that can be applied using the Manual Numbering 
            Tool in ACD/ChemSketch.
            </summary>
        </member>
        <member name="F:NCDK.CDKPropertyName.CtabSgroups">
            <summary>
            Key to store/fetch CTab Sgroups from Molfiles. Important! - Use at your own risk,
            property is transitive and may be removed in future with a more specific accessor.
            </summary>
        </member>
        <member name="F:NCDK.CDKPropertyName.ReactionConditions">
            <summary>
            Property for reaction objects where the conditions of reactions can be placed.
            </summary>
        </member>
        <member name="F:NCDK.CDKPropertyName.PartOfRingOfSize">
            <summary>Used as property key for indicating the ring size of a certain atom type.</summary>
        </member>
        <member name="F:NCDK.CDKPropertyName.ChemicalGroupConstant">
            <summary>Used as property key for indicating the chemical group of a certain atom type.</summary>
        </member>
        <member name="F:NCDK.CDKPropertyName.SphericalMatcher">
            <summary>Used as property key for indicating the HOSE code for a certain atom type.</summary>
        </member>
        <member name="F:NCDK.CDKPropertyName.PiBondCount">
            <summary>Used as property key for indicating the HOSE code for a certain atom type.</summary>
        </member>
        <member name="F:NCDK.CDKPropertyName.LonePairCount">
            <summary>Used as property key for indicating the HOSE code for a certain atom type.</summary>
        </member>
        <member name="F:NCDK.CDKPropertyName.SingleElectronCount">
            <summary>Used as property key for indicating the number of single electrons on the atom type.</summary>
        </member>
        <member name="F:NCDK.CDKPropertyName.Color">
            <summary>pack the RGB color space components into a single int.</summary>
        </member>
        <member name="T:NCDK.CDKException">
            <summary>
            Exception that is thrown by CDK classes when some problem has occurred.
            </summary>
        </member>
        <member name="M:NCDK.CDKException.#ctor(System.String)">
            <summary>
            Constructs a new CDKException with the given message.
            </summary>
            <param name="message">for the constructed exception</param>
        </member>
        <member name="M:NCDK.CDKException.#ctor(System.String,System.Exception)">
            <summary>
            Constructs a new <see cref="T:NCDK.CDKException"/> with the given message and the <see cref="T:System.Exception"/> as cause.
            </summary>
            <param name="message">for the constructed exception</param>
            <param name="innerException">the <see cref="T:System.Exception"/> that triggered this <see cref="T:NCDK.CDKException"/></param>
        </member>
        <member name="T:NCDK.NoSuchAtomException">
            <summary>
            Exception that is thrown when an Atom is requested or required that  does not exist in the relevant environment.
            </summary>
        </member>
        <member name="M:NCDK.NoSuchAtomException.#ctor(System.String)">
            <summary>
            Constructs a new <see cref="T:NCDK.NoSuchAtomException"/> with the given message.
            </summary>
            <param name="message">for the constructed exception</param>
        </member>
        <member name="T:NCDK.NoSuchAtomTypeException">
            <summary>
            Exception that may be thrown when an atom type is looked up or perceived but no such atom type was found.
            </summary>
        </member>
        <member name="T:NCDK.ReactionDirections">
            <summary>
            Permissible reaction directions.
            </summary>
        </member>
        <member name="F:NCDK.ReactionDirections.Forward">
            <summary>Reaction equilibrium which is (almost) fully on the product side. Often denoted with a forward arrow.</summary>
        </member>
        <member name="F:NCDK.ReactionDirections.Backward">
            <summary>Reaction equilibrium which is (almost) fully on the reactant side. Often denoted with a backward arrow.</summary>
        </member>
        <member name="F:NCDK.ReactionDirections.Bidirectional">
            <summary>Reaction equilibrium state. Often denoted by a double arrow.</summary>
        </member>
        <member name="T:NCDK.Tools.Manipulator.BondManipulator">
            <summary>
            Class with convenience methods that provide methods to manipulate 
            <see cref="T:NCDK.IAtomContainer"/>'s <see cref="T:NCDK.IBond"/>. 
            </summary>
            <example>
            <code>
            AtomContainerManipulator.ReplaceAtomByAtom(container, atom1, atom2);
            </code>
            will replace the Atom in the AtomContainer, but in all the ElectronContainer's
            it participates too.
            </example>
        </member>
        <member name="M:NCDK.Tools.Manipulator.BondManipulator.GetAtomArray(NCDK.IBond)">
            <summary>
            Constructs an array of Atom objects from Bond.
            </summary>
        </member>
        <member name="M:NCDK.Tools.Manipulator.BondManipulator.IsLowerOrder(NCDK.BondOrder,NCDK.BondOrder)">
            <summary>
            Returns true if the first bond has a lower bond order than the second bond.
            It returns false if the bond order is equal, and if the order of the first
            bond is larger than that of the second. Also returns false if either bond
            order is unset.
            </summary>
            <param name="first">The first bond order object</param>
            <param name="second">The second bond order object</param>
            <returns>true if the first bond order is lower than the second one, false otherwise</returns>
            <seealso cref="M:NCDK.Tools.Manipulator.BondManipulator.IsHigherOrder(NCDK.BondOrder,NCDK.BondOrder)"/>
        </member>
        <member name="M:NCDK.Tools.Manipulator.BondManipulator.IsHigherOrder(NCDK.BondOrder,NCDK.BondOrder)">
            <summary>
            Returns true if the first bond has a higher bond order than the second bond.
            It returns false if the bond order is equal, and if the order of the first
            bond is lower than that of the second. Also returns false if either bond
            order is unset.
            </summary>
            <param name="first">The first bond order object</param>
            <param name="second">The second bond order object</param>
            <returns>true if the first bond order is higher than the second one, false otherwise</returns>
            <seealso cref="M:NCDK.Tools.Manipulator.BondManipulator.IsLowerOrder(NCDK.BondOrder,NCDK.BondOrder)"/>
        </member>
        <member name="M:NCDK.Tools.Manipulator.BondManipulator.IncreaseBondOrder(NCDK.BondOrder)">
            <summary>
            Returns the BondOrder one higher. Does not increase the bond order
            beyond the Quadruple bond order.
            </summary>
            <param name="oldOrder">the old order</param>
            <returns>The incremented bond order</returns>
            <seealso cref="M:NCDK.Tools.Manipulator.BondManipulator.IncreaseBondOrder(NCDK.IBond)"/>
            <seealso cref="M:NCDK.Tools.Manipulator.BondManipulator.DecreaseBondOrder(NCDK.BondOrder)"/>
            <seealso cref="M:NCDK.Tools.Manipulator.BondManipulator.DecreaseBondOrder(NCDK.IBond)"/>
        </member>
        <member name="M:NCDK.Tools.Manipulator.BondManipulator.IncreaseBondOrder(NCDK.IBond)">
            <summary>
            Increment the bond order of this bond.
            </summary>
            <param name="bond">The bond whose order is to be incremented</param>
            <seealso cref="M:NCDK.Tools.Manipulator.BondManipulator.IncreaseBondOrder(NCDK.BondOrder)"/>
            <seealso cref="M:NCDK.Tools.Manipulator.BondManipulator.DecreaseBondOrder(NCDK.BondOrder)"/>
            <seealso cref="M:NCDK.Tools.Manipulator.BondManipulator.DecreaseBondOrder(NCDK.IBond)"/>
        </member>
        <member name="M:NCDK.Tools.Manipulator.BondManipulator.DecreaseBondOrder(NCDK.BondOrder)">
            <summary>
            Returns the BondOrder one lower. Does not decrease the bond order
            lower the Quadruple bond order.
            </summary>
            <param name="oldOrder">the old order</param>
            <returns>the decremented order</returns>
            <seealso cref="M:NCDK.Tools.Manipulator.BondManipulator.DecreaseBondOrder(NCDK.IBond)"/>
            <seealso cref="M:NCDK.Tools.Manipulator.BondManipulator.IncreaseBondOrder(NCDK.BondOrder)"/>
            <seealso cref="M:NCDK.Tools.Manipulator.BondManipulator.IncreaseBondOrder(NCDK.BondOrder)"/>
        </member>
        <member name="M:NCDK.Tools.Manipulator.BondManipulator.DecreaseBondOrder(NCDK.IBond)">
            <summary>
            Decrease the order of a bond.
            </summary>
            <param name="bond">The bond in question</param>
            <seealso cref="M:NCDK.Tools.Manipulator.BondManipulator.DecreaseBondOrder(NCDK.BondOrder)"/>
            <seealso cref="M:NCDK.Tools.Manipulator.BondManipulator.IncreaseBondOrder(NCDK.BondOrder)"/>
            <seealso cref="M:NCDK.Tools.Manipulator.BondManipulator.IncreaseBondOrder(NCDK.BondOrder)"/>
        </member>
        <member name="M:NCDK.Tools.Manipulator.BondManipulator.CreateBondOrder(System.Double)">
            <summary>
            Convenience method to convert a double into an BondOrder.
            Returns <see cref="F:NCDK.BondOrder.Unset"/> if the bond order is not 1.0, 2.0, 3.0 and 4.0.
            </summary>
            <param name="bondOrder">The numerical bond order</param>
            <returns>An instance of <see cref="T:NCDK.BondOrder"/></returns>
            <seealso cref="M:NCDK.Tools.Manipulator.BondManipulator.DestroyBondOrder(NCDK.BondOrder)"/>
        </member>
        <member name="M:NCDK.Tools.Manipulator.BondManipulator.DestroyBondOrder(NCDK.BondOrder)">
             <summary>
             Convert a <see cref="T:NCDK.BondOrder"/> to a numeric value.
            
             Single, double, triple and quadruple bonds are converted to 1.0, 2.0, 3.0
             and 4.0 respectively.
             </summary>
             <param name="bondOrder">The bond order object</param>
             <returns>The numeric value</returns>
             <seealso cref="M:NCDK.Tools.Manipulator.BondManipulator.CreateBondOrder(System.Double)"/>
        </member>
        <member name="M:NCDK.Tools.Manipulator.BondManipulator.GetMaximumBondOrder(System.Collections.Generic.IEnumerable{NCDK.IBond})">
            <summary>
            Returns the maximum bond order for a List of bonds, given an iterator to the list.
            <param name="bonds">An iterator for the list of bonds</param>
            <returns>The maximum bond order found</returns>
            </summary>
            <seealso cref="M:NCDK.Tools.Manipulator.BondManipulator.GetMaximumBondOrder(System.Collections.Generic.IEnumerable{NCDK.IBond})"/>
        </member>
        <member name="M:NCDK.Tools.Manipulator.BondManipulator.GetMaximumBondOrder(NCDK.IBond,NCDK.IBond)">
            <summary>
            Returns the maximum bond order for the two bonds.
            </summary>
            <param name="firstBond">first bond to compare</param>
            <param name="secondBond">second bond to compare</param>
            <returns>The maximum bond order found</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.BondManipulator.GetMaximumBondOrder(NCDK.BondOrder,NCDK.BondOrder)">
            <summary>
            Returns the maximum bond order for the two bond orders.
            </summary>
            <param name="firstOrder">first bond order to compare</param>
            <param name="secondOrder">second bond order to compare</param>
            <returns>The maximum bond order found</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.BondManipulator.GetMinimumBondOrder(System.Collections.Generic.IEnumerable{NCDK.IBond})">
            <summary>
            Returns the minimum bond order for a List of bonds, given an iterator
            to the list.
            </summary>
            <param name="bonds">An iterator for the list of bonds</param>
            <returns>The minimum bond order found</returns>
            <seealso cref="M:NCDK.Tools.Manipulator.BondManipulator.GetMinimumBondOrder(System.Collections.Generic.IEnumerable{NCDK.IBond})"/>
        </member>
        <member name="M:NCDK.Tools.Manipulator.BondManipulator.GetSingleBondEquivalentSum(System.Collections.Generic.IEnumerable{NCDK.IBond})">
            <summary>
            Get the single bond equivalent (SBE) of a list of bonds, given an iterator to the list.
            </summary>
            <param name="bonds">An iterator to the list of bonds</param>
            <returns>The SBE sum</returns>
        </member>
        <member name="T:NCDK.Tools.Manipulator.AminoAcidManipulator">
            <summary>
            Class with convenience methods that provide methods to manipulate
            AminoAcid's.
            </summary>
        </member>
        <member name="M:NCDK.Tools.Manipulator.AminoAcidManipulator.RemoveAcidicOxygen(NCDK.IAminoAcid)">
            <summary>
            Removes the singly bonded oxygen from the acid group of the AminoAcid.
            </summary>
            <param name="acid">AminoAcid from which to remove the oxygen</param>
            <exception cref="T:NCDK.CDKException">when the C-terminus is not defined for the given AminoAcid</exception>
        </member>
        <member name="M:NCDK.Tools.Manipulator.AminoAcidManipulator.AddAcidicOxygen(NCDK.IAminoAcid)">
            <summary>
            Adds the singly bonded oxygen from the acid group of the AminoAcid.
            </summary>
            <param name="acid">AminoAcid to which to add the oxygen</param>
            <exception cref="T:NCDK.CDKException">when the C-terminus is not defined for the given AminoAcid</exception>
        </member>
        <member name="T:NCDK.Tools.Manipulator.AtomContainerComparator`1">
             <summary>
            <para> Compares two IAtomContainers for order with the following criteria with decreasing priority:
             <list type="number">
               <item>Compare atom count</item>
               <item>Compare molecular weight (heavy atoms only)</item>
               <item>Compare bond count</item>
               <item>Compare sum of bond orders (heavy atoms only)</item>
             </list>
             </para>
             <para>If no difference can be found with the above criteria, the IAtomContainers are
             considered equal.</para>
             </summary>
        </member>
        <member name="M:NCDK.Tools.Manipulator.AtomContainerComparator`1.#ctor">
            <summary>Creates a new instance of AtomContainerComparator</summary>
        </member>
        <member name="M:NCDK.Tools.Manipulator.AtomContainerComparator`1.Compare(`0,`0)">
            <summary>
            <para>Compares two IAtomContainers for order with the following criteria
            with decreasing priority:
            <list type="number">
            <item>Compare atom count</item>
            <item>Compare molecular weight (heavy atoms only)</item>
            <item>Compare bond count</item>
            <item>Compare sum of bond orders (heavy atoms only)</item>
            </list> 
            </para>
            <para>If no difference can be
            found with the above criteria, the IAtomContainers are considered
            equal.</para> 
            <para>Returns a negative integer, zero, or a positive integer as
            the first argument is less than, equal to, or greater than the
            second.</para>
            </summary>
            <para>This method is null safe.</para>
            <param name="o1">the first IAtomContainer</param>
            <param name="o2">the second IAtomContainer</param>
            <returns>a negative integer, zero, or a positive integer as the first
            argument is less than, equal to, or greater than the second.</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.AtomContainerComparator`1.GetMolecularWeight(`0)">
            <summary>
            Returns the molecular weight (exact mass) of the major isotopes
            of all heavy atoms of the given IAtomContainer.
            </summary>
            <param name="atomContainer">an IAtomContainer to calculate the mocular weight for</param>
            <exception cref="T:NCDK.CDKException">if an error occurs with the IsotopeFactory</exception>
            <returns>the molecularweight (exact mass) of the major isotopes
                    of all heavy atoms of the given IAtomContainer</returns>
        </member>
        <member name="T:NCDK.Tools.Manipulator.AtomContainerComparatorBy2DCenter`1">
            <summary>
            Compares two IAtomContainers based on their 2D position.
            Implemented specifically to be used in JChemPaint.
            </summary>
        </member>
        <member name="M:NCDK.Tools.Manipulator.AtomContainerComparatorBy2DCenter`1.Compare(`0,`0)">
            <summary>
            Compare two AtomContainers based on their 2D position.
            </summary>
        </member>
        <member name="F:NCDK.Tools.Manipulator.AtomContainerComparatorBy2DCenter`1.Maximum">
            <summary>
            maximum point to use when an null container is provided (sorts null to end)
            </summary>
        </member>
        <member name="T:NCDK.Tools.Manipulator.AtomContainerManipulator">
            <summary>
            Class with convenience methods that provide methods to manipulate
            AtomContainer's. 
            </summary>
            <example>
            For example:
            <code>                AtomContainerManipulator.ReplaceAtomByAtom(container, atom1, atom2);
</code>
            will replace the Atom in the AtomContainer, but in all the ElectronContainer's
            it participates too.
            </example>
        </member>
        <member name="M:NCDK.Tools.Manipulator.AtomContainerManipulator.ExtractSubstructure(NCDK.IAtomContainer,System.Int32[])">
            <summary>
            Extract a substructure from an atom container, in the form of a new
            cloned atom container with only the atoms with indices in atomIndices and
            bonds that connect these atoms.
            </summary>
            <remarks>
            Note that this may result in a disconnected atom container.
            </remarks>
            <param name="atomContainer">the source container to extract from</param>
            <param name="atomIndices">the indices of the substructure</param>
            <returns>a cloned atom container with a substructure of the source</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.AtomContainerManipulator.GetAtomById(NCDK.IAtomContainer,System.String)">
            <summary>
            Returns an atom in an atomcontainer identified by id
            </summary>
            <param name="ac">The AtomContainer to search in</param>
            <param name="id">The id to search for</param>
            <returns>An atom having id id</returns>
            <exception cref="T:NCDK.CDKException">There is no such atom</exception>
        </member>
        <member name="M:NCDK.Tools.Manipulator.AtomContainerManipulator.ReplaceAtomByAtom(NCDK.IAtomContainer,NCDK.IAtom,NCDK.IAtom)">
            <summary>
            Substitute one atom in a container for another adjusting bonds, single electrons, lone pairs, and stereochemistry
            as required.
            </summary>
            <param name="container">the container to replace the atom of</param>
            <param name="oldAtom">the atom to replace</param>
            <param name="newAtom">the atom to insert</param>
            <returns>whether replacement was made</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.AtomContainerManipulator.GetTotalCharge(NCDK.IAtomContainer)">
            <summary>
            Get the summed charge of all atoms in an AtomContainer
            </summary>
            <param name="atomContainer">The IAtomContainer to manipulate</param>
            <returns>The summed charges of all atoms in this AtomContainer.</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.AtomContainerManipulator.GetTotalExactMass(NCDK.IAtomContainer)">
            <summary>
            Get the summed exact mass of all atoms in an AtomContainer. It
            requires isotope information for all atoms to be set. Either set
            this information using the <see cref="T:NCDK.Config.IsotopeFactory"/>, or use the
            <see cref="M:NCDK.Tools.Manipulator.MolecularFormulaManipulator.GetMajorIsotopeMass(NCDK.IMolecularFormula)"/> 
            method, after converting the <see cref="T:NCDK.IAtomContainer"/> to a
            <see cref="T:NCDK.IMolecularFormula"/> with the <see cref="T:NCDK.Tools.Manipulator.MolecularFormulaManipulator"/>.
            </summary>
            <param name="atomContainer">The IAtomContainer to manipulate</param>
            <returns>The summed exact mass of all atoms in this AtomContainer.</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.AtomContainerManipulator.GetNaturalExactMass(NCDK.IAtomContainer)">
            <summary>
            Returns the molecular mass of the IAtomContainer. For the calculation it
            uses the masses of the isotope mixture using natural abundances.
            </summary>
            <param name="atomContainer"></param>
        </member>
        <member name="M:NCDK.Tools.Manipulator.AtomContainerManipulator.GetTotalNaturalAbundance(NCDK.IAtomContainer)">
            <summary>
            Get the summed natural abundance of all atoms in an AtomContainer
            </summary>
            <param name="atomContainer">The IAtomContainer to manipulate</param>
            <returns>The summed natural abundance of all atoms in this AtomContainer.</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.AtomContainerManipulator.GetTotalFormalCharge(NCDK.IAtomContainer)">
            <summary>
            Get the total formal charge on a molecule.
            </summary>
            <param name="atomContainer">the atom container to consider</param>
            <returns>The summed formal charges of all atoms in this AtomContainer.</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.AtomContainerManipulator.GetTotalNegativeFormalCharge(NCDK.IAtomContainer)">
            <summary>
            Get the total formal negative charge on a molecule.
            </summary>
            <param name="atomContainer">the atom container to consider</param>
            <returns>The summed negative formal charges of all atoms in this AtomContainer.</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.AtomContainerManipulator.GetTotalPositiveFormalCharge(NCDK.IAtomContainer)">
            <summary>
            Get the total positive formal charge on a molecule.
            </summary>
            <param name="atomContainer">the atom container to consider</param>
            <returns>The summed positive formal charges of all atoms in this AtomContainer.</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.AtomContainerManipulator.GetTotalHydrogenCount(NCDK.IAtomContainer)">
            <summary>
            Counts the number of hydrogens on the provided IAtomContainer. As this
            method will sum all implicit hydrogens on each atom it is important to
            ensure the atoms have already been perceived (and thus have an implicit
            hydrogen count) (see. <see cref="M:NCDK.Tools.Manipulator.AtomContainerManipulator.PercieveAtomTypesAndConfigureAtoms(NCDK.IAtomContainer)"/>).
            </summary>
            <param name="container">the container to count the hydrogens on</param>
            <returns>the total number of hydrogens</returns>
            <seealso cref="P:NCDK.IAtom.ImplicitHydrogenCount"/>
            <seealso cref="M:NCDK.Tools.Manipulator.AtomContainerManipulator.PercieveAtomTypesAndConfigureAtoms(NCDK.IAtomContainer)"/>
            <exception cref="T:System.ArgumentNullException">if the provided container was null</exception>
        </member>
        <member name="M:NCDK.Tools.Manipulator.AtomContainerManipulator.GetImplicitHydrogenCount(NCDK.IAtomContainer)">
            <summary>
            Counts the number of implicit hydrogens on the provided IAtomContainer.
            As this method will sum all implicit hydrogens on each atom it is
            important to ensure the atoms have already been perceived (and thus have
            an implicit hydrogen count) (see. <see cref="M:NCDK.Tools.Manipulator.AtomContainerManipulator.PercieveAtomTypesAndConfigureAtoms(NCDK.IAtomContainer)"/>.
            </summary>
            <param name="container">the container to count the implicit hydrogens on</param>
            <returns>the total number of implicit hydrogens</returns>
            <seealso cref="P:NCDK.IAtom.ImplicitHydrogenCount"/>
            <seealso cref="M:NCDK.Tools.Manipulator.AtomContainerManipulator.PercieveAtomTypesAndConfigureAtoms(NCDK.IAtomContainer)"/>
            <exception cref="T:System.ArgumentNullException">if the provided container was null</exception>
        </member>
        <member name="M:NCDK.Tools.Manipulator.AtomContainerManipulator.CountExplicitHydrogens(NCDK.IAtomContainer,NCDK.IAtom)">
            <summary>
            Count explicit hydrogens.
            </summary>
            <param name="atomContainer">the atom container to consider</param>
            <returns>The number of explicit hydrogens on the given IAtom.</returns>
            <exception cref="T:System.ArgumentNullException">if the provided container was null</exception>
        </member>
        <member name="M:NCDK.Tools.Manipulator.AtomContainerManipulator.ConvertImplicitToExplicitHydrogens(NCDK.IAtomContainer)">
            <summary>
            Adds explicit hydrogens (without coordinates) to the IAtomContainer,
            equaling the number of set implicit hydrogens.
            </summary>
            <param name="atomContainer">the atom container to consider</param>
        </member>
        <member name="M:NCDK.Tools.Manipulator.AtomContainerManipulator.CountHydrogens(NCDK.IAtomContainer,NCDK.IAtom)">
            <returns>The summed implicit + explicit hydrogens of the given IAtom.</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.AtomContainerManipulator.RemoveNonChiralHydrogens(NCDK.IAtomContainer)">
            <summary>
            Produces an AtomContainer without explicit non stereo-relevant Hs but with H count from one with Hs.
            The new molecule is a deep copy.
            </summary>
            <param name="org">The AtomContainer from which to remove the hydrogens</param>
            <returns>The molecule without non stereo-relevant Hs.</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.AtomContainerManipulator.CopyAndSuppressedHydrogens(NCDK.IAtomContainer)">
            <summary>
            Copy the input container and suppress any explicit hydrogens. Only
            hydrogens that can be represented as a hydrogen count value on the atom
            are suppressed. If a copy is not needed please use <see cref="M:NCDK.Tools.Manipulator.AtomContainerManipulator.SuppressHydrogens(NCDK.IAtomContainer)"/>.
            </summary>
            <param name="org">the container from which to remove hydrogens</param>
            <returns>a copy of the input with suppressed hydrogens</returns>
            <seealso cref="M:NCDK.Tools.Manipulator.AtomContainerManipulator.SuppressHydrogens(NCDK.IAtomContainer)"/>
        </member>
        <member name="M:NCDK.Tools.Manipulator.AtomContainerManipulator.SuppressHydrogens(NCDK.IAtomContainer)">
            <summary>
            Suppress any explicit hydrogens in the provided container. Only hydrogens
            that can be represented as a hydrogen count value on the atom are
            suppressed. The container is updated and no elements are copied, please
            use either <see cref="M:NCDK.Tools.Manipulator.AtomContainerManipulator.CopyAndSuppressedHydrogens(NCDK.IAtomContainer)"/> if you would to preserve
            the old instance.
            </summary>
            <param name="org">the container from which to remove hydrogens</param>
            <returns>the input for convenience</returns>
            <seealso cref="M:NCDK.Tools.Manipulator.AtomContainerManipulator.CopyAndSuppressedHydrogens(NCDK.IAtomContainer)"/>
        </member>
        <member name="M:NCDK.Tools.Manipulator.AtomContainerManipulator.RemoveHydrogens(NCDK.IAtomContainer)">
            <summary>
            Create an copy of the <paramref name="org"/> structure with explicit hydrogens
            removed. Stereochemistry is updated but up and down bonds in a depiction
            may need to be recalculated (see. StructureDiagramGenerator).
            </summary>
            <param name="org">The AtomContainer from which to remove the hydrogens</param>
            <returns>The molecule without hydrogens.</returns>
            <seealso cref="M:NCDK.Tools.Manipulator.AtomContainerManipulator.CopyAndSuppressedHydrogens(NCDK.IAtomContainer)"/>
        </member>
        <member name="M:NCDK.Tools.Manipulator.AtomContainerManipulator.SuppressibleHydrogen(NCDK.IAtomContainer,NCDK.IAtom)">
            <summary>
            Is the <paramref name="atom"/> a suppressible hydrogen and can be represented as
            implicit. A hydrogen is suppressible if it is not an ion, not the major
            isotope (i.e. it is a deuterium or tritium atom) and is not molecular
            hydrogen.
            </summary>
            <param name="container">the structure</param>
            <param name="atom">an atom in the structure</param>
            <returns>the atom is a hydrogen and it can be suppressed (implicit)</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.AtomContainerManipulator.IncrementImplHydrogenCount(NCDK.IAtom)">
            <summary>
            Increment the implicit hydrogen count of the provided atom. If the atom
            was a non-pseudo atom and had an unset hydrogen count an exception is
            thrown.
            </summary>
            <param name="atom">an atom to increment the hydrogen count of</param>
        </member>
        <member name="M:NCDK.Tools.Manipulator.AtomContainerManipulator.SuppressibleHydrogen(NCDK.IAtomContainer,System.Int32[][],NCDK.Graphs.GraphUtil.EdgeToBondMap,System.Int32)">
            <summary>
            Is the 'atom' a suppressible hydrogen and can be represented as
            implicit. A hydrogen is suppressible if it is not an ion, not the major
            isotope (i.e. it is a deuterium or tritium atom) and is not molecular
            hydrogen.
            </summary>
            <param name="container">the structure</param>
            <param name="graph">adjacent list representation</param>
            <param name="v">vertex (atom index)</param>
            <returns>the atom is a hydrogen and it can be suppressed (implicit)</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.AtomContainerManipulator.FindOther(NCDK.IAtomContainer,NCDK.IAtom,NCDK.IAtom,NCDK.IAtom)">
            <summary>
            Finds an neighbor connected to <paramref name="atom"/> which is not <paramref name="exclude1"/>
            or <paramref name="exclude2"/>. If no neighbor exists - null is returned.
            </summary>
            <param name="container">structure</param>
            <param name="atom">atom to find a neighbor of</param>
            <param name="exclude1">the neighbor should not be this atom</param>
            <param name="exclude2">the neighbor should also not be this atom</param>
            <returns>a neighbor of 'atom', null if not found</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.AtomContainerManipulator.RemoveHydrogensPreserveMultiplyBonded(NCDK.IAtomContainer)">
            <summary>
            Produces an AtomContainer without explicit Hs but with H count from one with Hs.
            Hs bonded to more than one heavy atom are preserved.  The new molecule is a deep copy.
            </summary>
            <returns>The mol without Hs.</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.AtomContainerManipulator.RemoveHydrogens(NCDK.IAtomContainer,System.Collections.Generic.List{NCDK.IAtom})">
            <summary>
            Produces an AtomContainer without explicit Hs (except those listed) but with H count from one with Hs.
            The new molecule is a deep copy.
            </summary>
            <param name="preserve">a list of H atoms to preserve.</param>
            <returns>The mol without Hs.</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.AtomContainerManipulator.SetAtomProperties(NCDK.IAtomContainer,System.String,System.Object)">
            <summary>
            Sets a property on all <see cref="T:NCDK.IAtom"/>s in the given container.
            </summary>
        </member>
        <member name="M:NCDK.Tools.Manipulator.AtomContainerManipulator.UnregIsterElectronContainerListeners(NCDK.IAtomContainer)">
            <summary>
             A method to remove ElectronContainerListeners.
             ElectronContainerListeners are used to detect changes
             in ElectronContainers (like bonds) and to notifiy
             registered Listeners in the event of a change.
             If an object looses interest in such changes, it should
             unregister with this AtomContainer in order to improve
             performance of this class.
            </summary>
        </member>
        <member name="M:NCDK.Tools.Manipulator.AtomContainerManipulator.UnregIsterAtomListeners(NCDK.IAtomContainer)">
            <summary>
             A method to remove AtomListeners.
             AtomListeners are used to detect changes
             in Atom objects within this AtomContainer and to notifiy
             registered Listeners in the event of a change.
             If an object looses interest in such changes, it should
             unregister with this AtomContainer in order to improve
             performance of this class.
            </summary>
        </member>
        <member name="M:NCDK.Tools.Manipulator.AtomContainerManipulator.GetIntersection(NCDK.IAtomContainer,NCDK.IAtomContainer)">
            <summary>
            Compares this AtomContainer with another given AtomContainer and returns
            the Intersection between them.
            </summary>
            <remarks>
            <b>Important Note</b> : This is not the maximum common substructure.
            </remarks>
            <param name="container1">an AtomContainer object</param>
            <param name="container2">an AtomContainer object</param>
            <returns>An AtomContainer containing the intersection between <paramref name="container1"/> and <paramref name="container2"/></returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.AtomContainerManipulator.GetAtomArray(NCDK.IAtomContainer)">
            <summary>
            Constructs an array of Atom objects from an AtomContainer.
            </summary>
            <param name="container">The original AtomContainer.</param>
            <returns>The array of Atom objects.</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.AtomContainerManipulator.GetAtomArray(System.Collections.Generic.IEnumerable{NCDK.IAtom})">
            <summary>
            Constructs an array of Atom objects from a List of Atom objects.
            </summary>
            <param name="list">The original List.</param>
            <returns>The array of Atom objects.</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.AtomContainerManipulator.GetBondArray(NCDK.IAtomContainer)">
            <summary>
            Constructs an array of Bond objects from an AtomContainer.
            </summary>
            <param name="container">The original AtomContainer.</param>
            <returns>The array of Bond objects.</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.AtomContainerManipulator.GetBondArray(System.Collections.Generic.IEnumerable{NCDK.IBond})">
            <summary>
            Constructs an array of Atom objects from a List of Atom objects.
            </summary>
            <param name="list">The original List.</param>
            <returns>The array of Atom objects.</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.AtomContainerManipulator.GetElectronContainerArray(NCDK.IAtomContainer)">
            <summary>
            Constructs an array of Bond objects from an AtomContainer.
            </summary>
            <param name="container">The original AtomContainer.</param>
            <returns>The array of Bond objects.</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.AtomContainerManipulator.GetElectronContainerArray(System.Collections.Generic.IEnumerable{NCDK.IElectronContainer})">
            <summary>
            Constructs an array of Atom objects from a List of Atom objects.
            </summary>
            <param name="list">The original List.</param>
            <returns>The array of Atom objects.</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.AtomContainerManipulator.PercieveAtomTypesAndConfigureAtoms(NCDK.IAtomContainer)">
            <summary>
            Convenience method to perceive atom types for all <see cref="T:NCDK.IAtom"/>s in the
            <see cref="T:NCDK.IAtomContainer"/>, using the <see cref="T:NCDK.AtomTypes.CDKAtomTypeMatcher"/>.If the
            matcher finds a matching atom type, the <see cref="T:NCDK.IAtom"/> will be configured
            to have the same properties as the <see cref="T:NCDK.IAtomType"/>. If no matching atom
            type is found, no configuration is performed.
            <b>This method overwrites existing values.</b>
            </summary>
            <param name="container"></param>
        </member>
        <member name="M:NCDK.Tools.Manipulator.AtomContainerManipulator.PercieveAtomTypesAndConfigureUnsetProperties(NCDK.IAtomContainer)">
            <summary>
            Convenience method to perceive atom types for all <see cref="T:NCDK.IAtom"/>s in the
            <see cref="T:NCDK.IAtomContainer"/>, using the <see cref="T:NCDK.AtomTypes.CDKAtomTypeMatcher"/>. If the
            matcher finds a matching atom type, the <see cref="T:NCDK.IAtom"/> will be configured
            to have the same properties as the <see cref="T:NCDK.IAtomType"/>. If no matching atom
            type is found, no configuration is performed.
            <b>This method overwrites existing values.</b>
            </summary>
        </member>
        <member name="M:NCDK.Tools.Manipulator.AtomContainerManipulator.ClearAtomConfigurations(NCDK.IAtomContainer)">
            <summary>
            This method will reset all atom configuration to unset.
            </summary>
            <remarks>
            This method is the reverse of <see cref="M:NCDK.Tools.Manipulator.AtomContainerManipulator.PercieveAtomTypesAndConfigureAtoms(NCDK.IAtomContainer)"/> 
            and after a call to this method all atoms will be "unconfigured".
            <note type="note">
            Note that it is not a complete reversal of <see cref="M:NCDK.Tools.Manipulator.AtomContainerManipulator.PercieveAtomTypesAndConfigureAtoms(NCDK.IAtomContainer)"/> 
            since the atomic symbol of the atoms remains unchanged. Also, all the flags that were set
            by the configuration method (such as <see cref="P:NCDK.IAtomType.IsHydrogenBondAcceptor"/> or <see cref="P:NCDK.IMolecularEntity.IsAromatic"/>) will be set to False.
            </note>
            </remarks>
            <param name="container">The molecule, whose atoms are to be unconfigured</param>
            <seealso cref="M:NCDK.Tools.Manipulator.AtomContainerManipulator.PercieveAtomTypesAndConfigureAtoms(NCDK.IAtomContainer)"/>
        </member>
        <member name="M:NCDK.Tools.Manipulator.AtomContainerManipulator.GetSingleBondEquivalentSum(NCDK.IAtomContainer)">
            <summary>
            Returns the sum of bond orders, where a single bond counts as one
            <i>single bond equivalent</i>, a double as two, etc.
            </summary>
        </member>
        <member name="M:NCDK.Tools.Manipulator.AtomContainerManipulator.GetHeavyAtoms(NCDK.IAtomContainer)">
            <summary>
            Returns a set of nodes excluding all the hydrogens.
            </summary>
            <returns>The heavyAtoms value</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.AtomContainerManipulator.CreateAllCarbonAllSingleNonAromaticBondAtomContainer(NCDK.IAtomContainer)">
            <summary>
            Generates a cloned atomcontainer with all atoms being carbon, all bonds
            being single non-aromatic
            </summary>
            <param name="atomContainer">The input atomcontainer</param>
            <returns>The new atomcontainer</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.AtomContainerManipulator.Anonymise(NCDK.IAtomContainer)">
            <summary>
            Anonymise the provided container to single-bonded carbon atoms. No
            information other then the connectivity from the original container is
            retrained.
            </summary>
            <param name="src">an atom container</param>
            <returns>anonymised container</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.AtomContainerManipulator.Skeleton(NCDK.IAtomContainer)">
            <summary>
            Create a skeleton copy of the provided structure. The skeleton copy is
            similar to an anonymous copy (<see cref="M:NCDK.Tools.Manipulator.AtomContainerManipulator.Anonymise(NCDK.IAtomContainer)"/>) except that atom
            elements are preserved. All bonds are converted to single bonds and a
            'clean' atom is created for the input elements. The 'clean' atom has
            unset charge, mass, and hydrogen count.
            </summary>
            <param name="src">input structure</param>
            <returns>the skeleton copy</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.AtomContainerManipulator.GetBondOrderSum(NCDK.IAtomContainer,NCDK.IAtom)">
            <summary>
            Returns the sum of the bond order equivalents for a given IAtom. It
            considers single bonds as 1.0, double bonds as 2.0, triple bonds as 3.0,
            and quadruple bonds as 4.0.
            </summary>
            <param name="atom">The atom for which to calculate the bond order sum</param>
            <returns>The number of bond order equivalents for this atom</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.AtomContainerManipulator.SetSingleOrDoubleFlags(NCDK.IAtomContainer)">
            <summary>
            Assigns <see cref="P:NCDK.IBond.IsSingleOrDouble" /> to the bonds of
            a container. The single or double flag indicates uncertainty of bond
            order and in this case is assigned to all aromatic bonds (and atoms)
            which occur in rings. If any such bonds are found the flag is also set
            on the container.
            </summary>
            <example>
            <code>            SmilesParser parser = new SmilesParser(Default.ChemObjectBuilder.Instance);
            parser.IsPreservingAromaticity = true;

            IAtomContainer biphenyl = parser.ParseSmiles("c1cccc(c1)c1ccccc1");

            AtomContainerManipulator.SetSingleOrDoubleFlags(biphenyl);
</code>
            </example>
            <param name="ac">container to which the flags are assigned</param>
            <returns>the input for convenience</returns>
        </member>
        <member name="T:NCDK.Tools.Manipulator.AtomContainerSetManipulator">
            <summary>
            </summary>
            <seealso cref="T:NCDK.Tools.Manipulator.ChemModelManipulator"/>
        </member>
        <member name="M:NCDK.Tools.Manipulator.AtomContainerSetManipulator.GetAllAtomContainers``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns all the AtomContainer's of a MoleculeSet.
            </summary>
            <param name="set">The collection of IAtomContainer objects</param>
            <returns>A list of individual IAtomContainer's</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.AtomContainerSetManipulator.GetTotalCharge(NCDK.IChemObjectSet{NCDK.IAtomContainer})">
            <summary>
            </summary>
            <param name="set">The collection of IAtomContainer objects</param>
            <returns>The summed charges of all atoms in this set.</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.AtomContainerSetManipulator.GetTotalFormalCharge(NCDK.IChemObjectSet{NCDK.IAtomContainer})">
            <summary>
            </summary>
            <param name="set">The collection of IAtomContainer objects</param>
            <returns>The summed formal charges of all atoms in this set.</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.AtomContainerSetManipulator.GetTotalHydrogenCount(System.Collections.Generic.IEnumerable{NCDK.IAtomContainer})">
            <summary>
            </summary>
            <param name="set">The collection of IAtomContainer objects</param>
            <returns>The summed implicit hydrogens of all atoms in this set.</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.AtomContainerSetManipulator.GetAllChemObjects(NCDK.IChemObjectSet{NCDK.IAtomContainer})">
            <summary>
            Does not recursively return the contents of the AtomContainer.
            </summary>
            <param name="set">The collection of IAtomContainer objects</param>
            <returns>a list of individual ChemObject's</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.AtomContainerSetManipulator.Sort``1(NCDK.IChemObjectSet{``0})">
            <summary>
            <para>Sorts the IAtomContainers in the given IAtomContainerSet by the following
            criteria with decreasing priority:</para>
            <list type="bullet">
              <item>Compare atom count</item>
              <item>Compare molecular weight (heavy atoms only)</item>
              <item>Compare bond count</item>
              <item>Compare sum of bond orders (heavy atoms only)</item>
            </list>
            <para>If no difference can be found with the above criteria, the IAtomContainers are
            considered equal.</para>
            </summary>
            <param name="atomContainerSet">The collection of IAtomContainer objects</param>
        </member>
        <member name="M:NCDK.Tools.Manipulator.AtomContainerSetManipulator.ContainsByID(System.Collections.Generic.IEnumerable{NCDK.IAtomContainer},System.String)">
            <summary>
            Tells if an AtomContainerSet contains at least one AtomContainer with the
            same ID as atomContainer. Note this checks Id for equality, not pointers.
            </summary>
            <param name="id">The IAtomContainer to look for</param>
            <param name="atomContainerSet">The collection of IAtomContainer objects</param>
        </member>
        <member name="T:NCDK.Tools.Manipulator.AtomTypeManipulator">
            <summary>
            Class with utilities for the <see cref="T:NCDK.IAtomType"/> class.
            </summary>
        </member>
        <member name="M:NCDK.Tools.Manipulator.AtomTypeManipulator.Configure(NCDK.IAtom,NCDK.IAtomType)">
            <summary>
            Method that assign properties to an atom given a particular atomType.
            An <see cref="T:System.ArgumentException"/> is thrown if the given <see cref="T:NCDK.IAtomType"/>
            is null. <b>This method overwrites non-null values.</b>
            </summary>
            <param name="atom">Atom to configure</param>
            <param name="atomType">AtomType. Must not be null.</param>
        </member>
        <member name="M:NCDK.Tools.Manipulator.AtomTypeManipulator.ConfigureUnsetProperties(NCDK.IAtom,NCDK.IAtomType)">
            <summary>
            Method that assign properties to an atom given a particular atomType.
            <b>This method only sets null values.</b>
            </summary>
            <param name="atom">Atom to configure</param>
            <param name="atomType">AtomType. Must not be null.</param>
            <exception cref="T:System.ArgumentException">if the given <see cref="T:NCDK.IAtomType"/> is null.</exception>
        </member>
        <member name="T:NCDK.Tools.Manipulator.ChemFileManipulator">
            <summary>
            Class with convenience methods that provide methods from
            methods from ChemObjects within the ChemFile.
            </summary>
            <seealso cref="M:NCDK.IAtomContainer.RemoveAtomAndConnectedElectronContainers(NCDK.IAtom)"/>
        </member>
        <member name="M:NCDK.Tools.Manipulator.ChemFileManipulator.GetAtomCount(NCDK.IChemFile)">
            <summary>
            Get the total number of atoms inside an IChemFile.
            </summary>
            <param name="file">The IChemFile object.</param>
            <returns>The number of Atom object inside.</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.ChemFileManipulator.GetBondCount(NCDK.IChemFile)">
            <summary>
            Get the total number of bonds inside an IChemFile.
            </summary>
            <param name="file">The IChemFile object.</param>
            <returns>The number of Bond object inside.</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.ChemFileManipulator.GetAllChemObjects(NCDK.IChemFile)">
            <summary>
            Returns a List of all IChemObject inside a ChemFile.
            </summary>
            <returns>A list of all ChemObjects</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.ChemFileManipulator.GetAllAtomContainers(NCDK.IChemFile)">
            <summary>
            Returns all the AtomContainer's of a ChemFile.
            </summary>
        </member>
        <member name="M:NCDK.Tools.Manipulator.ChemFileManipulator.GetAllChemModels(NCDK.IChemFile)">
            <summary>
            Get a list of all ChemModels inside an IChemFile.
            </summary>
            <param name="file">The IChemFile object.</param>
            <returns>The List of IChemModel objects inside.</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.ChemFileManipulator.GetAllReactions(NCDK.IChemFile)">
            <summary>
            Get a list of all IReaction inside an IChemFile.
            </summary>
            <param name="file">The IChemFile object.</param>
            <returns>The List of IReaction objects inside.</returns>
        </member>
        <member name="T:NCDK.Tools.Manipulator.ChemModelManipulator">
            <summary>
            Class with convenience methods that provide methods from
            methods from ChemObjects within the ChemModel. For example:
            <code>
            ChemModelManipulator.RemoveAtom(chemModel, atom);
            </code>
            will find the Atom in the model by traversing the ChemModel's
            MoleculeSet, Crystal and ReactionSet fields and remove
            it with the <see cref="M:NCDK.IAtomContainer.RemoveAtom(NCDK.IAtom)"/> method.
            </summary>
            <seealso cref="M:NCDK.IAtomContainer.RemoveAtom(NCDK.IAtom)"/>
        </member>
        <member name="M:NCDK.Tools.Manipulator.ChemModelManipulator.GetAtomCount(NCDK.IChemModel)">
            <summary>
            Get the total number of atoms inside an IChemModel.
            </summary>
            <param name="chemModel">The IChemModel object.</param>
            <returns>The number of Atom object inside.</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.ChemModelManipulator.GetBondCount(NCDK.IChemModel)">
            <summary>
            Get the total number of bonds inside an IChemModel.
            </summary>
            <param name="chemModel">The IChemModel object.</param>
            <returns>The number of Bond object inside.</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.ChemModelManipulator.RemoveAtomAndConnectedElectronContainers(NCDK.IChemModel,NCDK.IAtom)">
            <summary>
            Remove an Atom and the connected ElectronContainers from all AtomContainers
            inside an IChemModel.
            </summary>
            <param name="chemModel">The IChemModel object.</param>
            <param name="atom">The Atom object to remove.</param>
        </member>
        <member name="M:NCDK.Tools.Manipulator.ChemModelManipulator.RemoveElectronContainer(NCDK.IChemModel,NCDK.IElectronContainer)">
            <summary>
            Remove an ElectronContainer from all AtomContainers
            inside an IChemModel.
            </summary>
            <param name="chemModel">The IChemModel object.</param>
            <param name="electrons">The ElectronContainer to remove.</param>
        </member>
        <member name="M:NCDK.Tools.Manipulator.ChemModelManipulator.CreateNewMolecule(NCDK.IChemModel)">
            <summary>
            Adds a new Molecule to the MoleculeSet inside a given ChemModel.
            Creates a MoleculeSet if none is contained.
            </summary>
            <param name="chemModel">The ChemModel object.</param>
            <returns>The created Molecule object.</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.ChemModelManipulator.NewChemModel(NCDK.IAtomContainer)">
            <summary>
            Create a new ChemModel containing an IAtomContainer. It will create an
            <see cref="T:NCDK.IAtomContainer"/> from the passed IAtomContainer when needed, which may cause
            information loss.
            </summary>
            <param name="atomContainer">The AtomContainer to have inside the ChemModel.</param>
            <returns>The new IChemModel object.</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.ChemModelManipulator.GetRelevantAtomContainer(NCDK.IChemModel,NCDK.IAtom)">
            <summary>
            This badly named methods tries to determine which AtomContainer in the
            ChemModel is best suited to contain added Atom's and Bond's.
            </summary>
        </member>
        <member name="M:NCDK.Tools.Manipulator.ChemModelManipulator.GetRelevantAtomContainer(NCDK.IChemModel,NCDK.IBond)">
            <summary>
            Retrieves the first IAtomContainer containing a given IBond from an
            IChemModel.
            </summary>
            <param name="chemModel">The IChemModel object.</param>
            <param name="bond">The IBond object to search.</param>
            <returns>The IAtomContainer object found, null if none is found.</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.ChemModelManipulator.GetRelevantReaction(NCDK.IChemModel,NCDK.IAtom)">
            <summary>
            Retrieves the first IReaction containing a given IAtom from an
            IChemModel.
            </summary>
            <param name="chemModel">The IChemModel object.</param>
            <param name="atom">The IAtom object to search.</param>
            <returns>The IAtomContainer object found, null if none is found.</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.ChemModelManipulator.GetAllAtomContainers(NCDK.IChemModel)">
            <summary>
            Returns all the AtomContainer's of a ChemModel.
            </summary>
        </member>
        <member name="M:NCDK.Tools.Manipulator.ChemModelManipulator.SetAtomProperties(NCDK.IChemModel,System.String,System.Object)">
            <summary>
            Sets the AtomProperties of all Atoms inside an IChemModel.
            </summary>
            <param name="chemModel">The IChemModel object.</param>
            <param name="propKey">The key of the property.</param>
            <param name="propVal">The value of the property.</param>
        </member>
        <member name="M:NCDK.Tools.Manipulator.ChemModelManipulator.GetAllChemObjects(NCDK.IChemModel)">
            <summary>
            Retrieve a List of all ChemObject objects within an IChemModel.
            </summary>
            <param name="chemModel">The IChemModel object.</param>
            <returns>A List of all ChemObjects inside.</returns>
        </member>
        <member name="T:NCDK.Tools.Manipulator.ChemSequenceManipulator">
            <summary>
            Class with convenience methods that provide methods from
            methods from ChemObjects within the ChemSequence.
            </summary>
            <seealso cref="M:NCDK.IAtomContainer.RemoveAtomAndConnectedElectronContainers(NCDK.IAtom)"/>
        </member>
        <member name="M:NCDK.Tools.Manipulator.ChemSequenceManipulator.GetAtomCount(NCDK.IChemSequence)">
            <summary>
            Get the total number of atoms inside an IChemSequence.
            </summary>
            <param name="sequence">The IChemSequence object.</param>
            <returns>The number of Atom objects inside.</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.ChemSequenceManipulator.GetBondCount(NCDK.IChemSequence)">
             <summary>
             Get the total number of bonds inside an IChemSequence.
            
             <param name="sequence">The IChemSequence object.</param>
             <returns>The number of Bond objects inside.</returns>
             </summary>
        </member>
        <member name="M:NCDK.Tools.Manipulator.ChemSequenceManipulator.GetAllAtomContainers(NCDK.IChemSequence)">
            <summary>
            Returns all the AtomContainer's of a ChemSequence.
            </summary>
        </member>
        <member name="M:NCDK.Tools.Manipulator.ChemSequenceManipulator.GetAllChemObjects(NCDK.IChemSequence)">
            <summary>
            Returns a List of all IChemObject inside a ChemSequence.
            </summary>
            <returns>A List of all ChemObjects.</returns>
        </member>
        <member name="T:NCDK.Tools.Manipulator.MoleculeSetManipulator">
            <summary>
            </summary>
            <seealso cref="T:NCDK.Tools.Manipulator.ChemModelManipulator"/>
        </member>
        <member name="M:NCDK.Tools.Manipulator.MoleculeSetManipulator.GetAllAtomContainers(System.Collections.Generic.IEnumerable{NCDK.IAtomContainer})">
            <summary>
            Returns all the AtomContainer's of a MoleculeSet.
            </summary>
            <param name="set">The collection of IAtomContainer objects</param>
            <returns>a list containing individual IAtomContainer's</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.MoleculeSetManipulator.GetTotalCharge(NCDK.IChemObjectSet{NCDK.IAtomContainer})">
            <summary>
            </summary>
            <param name="set">The collection of IAtomContainer objects</param>
            <seealso cref="T:NCDK.Tools.Manipulator.AtomContainerSetManipulator"/>
            <returns>The total charge on the collection of molecules</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.MoleculeSetManipulator.GetTotalFormalCharge(NCDK.IChemObjectSet{NCDK.IAtomContainer})">
            <summary>
            </summary>
            <param name="set">The collection of IAtomContainer objects</param>
            <seealso cref="T:NCDK.Tools.Manipulator.AtomContainerSetManipulator"/>
            <returns>The total formal charge on the collection of molecules</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.MoleculeSetManipulator.GetTotalHydrogenCount(NCDK.IChemObjectSet{NCDK.IAtomContainer})">
            <summary>
            </summary>
            <param name="set">The collection of IAtomContainer objects</param>
            <seealso cref="T:NCDK.Tools.Manipulator.AtomContainerSetManipulator"/>
            <returns>the total implicit hydrogen count on the collection of molecules</returns>
        </member>
        <member name="T:NCDK.Tools.Manipulator.ReactionManipulator">
            <summary>
            </summary>
            <seealso cref="T:NCDK.Tools.Manipulator.ChemModelManipulator"/>
        </member>
        <member name="M:NCDK.Tools.Manipulator.ReactionManipulator.GetAllMolecules(NCDK.IReaction)">
            <summary>
            Get all molecule of a <see cref="T:NCDK.IReaction"/>: reactants + products.
            </summary>
            <param name="reaction">The IReaction</param>
            <returns>All molecules</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.ReactionManipulator.GetAllProducts(NCDK.IReaction)">
            <summary>
            Get all products of a <see cref="T:NCDK.IReaction"/>
            </summary>
            <param name="reaction">The reaction</param>
            <returns>Molecules</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.ReactionManipulator.GetAllReactants(NCDK.IReaction)">
            <summary>
            get all reactants of a IReaction
            </summary>
            <param name="reaction">The IReaction</param>
            <returns>Molecules</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.ReactionManipulator.Reverse(NCDK.IReaction)">
            <summary>
            Returns a new Reaction object which is the reverse of the given
            Reaction.
            </summary>
            <param name="reaction">the reaction being considered</param>
            <returns>the reverse reaction</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.ReactionManipulator.GetAllAtomContainers(NCDK.IReaction)">
            <summary>
            Returns all the AtomContainer's of a Reaction.
            </summary>
            <param name="reaction">The reaction being considered</param>
            <returns>a list of the IAtomContainer objects comprising the reaction</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.ReactionManipulator.GetMappedChemObject(NCDK.IReaction,NCDK.IChemObject)">
            <summary>
            Get the IAtom which is mapped
            </summary>
            <param name="reaction">The IReaction which contains the mapping</param>
            <param name="chemObject">The IChemObject which will be searched its mapped IChemObject</param>
            <returns>The mapped IChemObject</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.ReactionManipulator.AssignRoleAndGrp(NCDK.IAtomContainer,NCDK.ReactionRoles,System.Int32)">
            <summary>
            Assigns a reaction role and group id to all atoms in a molecule.
            </summary>
            <param name="mol">molecule</param>
            <param name="role">role to assign</param>
            <param name="grpId">group id</param>
        </member>
        <member name="M:NCDK.Tools.Manipulator.ReactionManipulator.ToMolecule(NCDK.IReaction)">
            <summary>
            <p>Converts a reaction to an 'inlined' reaction stored as a molecule. All
            reactants, agents, products are added to the molecule as disconnected
            components with atoms flagged as to their role <see cref="T:NCDK.ReactionRoles"/> and
            component group.</p>
            <p>
            The inlined reaction, stored in a molecule can be converted back to an explicit
            reaction with <see cref="M:NCDK.Tools.Manipulator.ReactionManipulator.ToReaction(NCDK.IAtomContainer)"/>. Data stored on the individual components (e.g.
            titles is lost in the conversion).
            </p>
            </summary>
            <param name="rxn">reaction to convert</param>
            <returns>inlined reaction stored in a molecule</returns>
            <seealso cref="M:NCDK.Tools.Manipulator.ReactionManipulator.ToReaction(NCDK.IAtomContainer)"/>
        </member>
        <member name="M:NCDK.Tools.Manipulator.ReactionManipulator.ToReaction(NCDK.IAtomContainer)">
            <summary>
            <p>Converts an 'inlined' reaction stored in a molecule back to a reaction.</p>
            </summary>
            <param name="mol">molecule to convert</param>
            <returns>reaction</returns>
            <seealso cref="M:NCDK.Tools.Manipulator.ReactionManipulator.ToMolecule(NCDK.IReaction)"/>
        </member>
        <member name="T:NCDK.Tools.Manipulator.ReactionManipulator.IntTuple">
            <summary>
            Bi-direction int-tuple for looking up bonds by index.
            </summary>
        </member>
        <member name="M:NCDK.Tools.Manipulator.ReactionManipulator.FindMappedBonds(NCDK.IReaction)">
            <summary>
            Collect the set of bonds that mapped in both a reactant and a product. The method uses
            the <see cref="F:NCDK.CDKPropertyName.AtomAtomMapping"/> property of atoms.
            </summary>
            <param name="reaction">reaction</param>
            <returns>mapped bonds</returns>
        </member>
        <member name="T:NCDK.Tools.Manipulator.MolecularFormulaManipulator">
            <summary>
            Class with convenience methods that provide methods to manipulate <see cref="T:NCDK.IMolecularFormula"/>'s.
            </summary>
        </member>
        <member name="M:NCDK.Tools.Manipulator.MolecularFormulaManipulator.GetAtomCount(NCDK.IMolecularFormula)">
            <summary>
            Checks a set of Nodes for the occurrence of each isotopes
            instance in the molecular formula. In short number of atoms.
            </summary>
            <param name="formula">The MolecularFormula to check</param>
            <returns>The occurrence total</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.MolecularFormulaManipulator.GetElementCount(NCDK.IMolecularFormula,NCDK.IElement)">
            <summary>
            Checks a set of Nodes for the occurrence of the isotopes in the
            molecular formula from a particular IElement. It returns 0 if the
            element does not exist. The search is based only on the IElement.
            </summary>
            <param name="formula">The MolecularFormula to check</param>
            <param name="element">The IElement object</param>
            <returns>The occurrence of this element in this molecular formula</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.MolecularFormulaManipulator.GetElementCount(NCDK.IMolecularFormula,NCDK.IIsotope)">
            <summary>
            Occurrences of a given element from an isotope in a molecular formula.
            </summary>
            <param name="formula">the formula</param>
            <param name="isotope">isotope of an element</param>
            <returns>number of the times the element occurs</returns>
            <seealso cref="M:NCDK.Tools.Manipulator.MolecularFormulaManipulator.GetElementCount(NCDK.IMolecularFormula,NCDK.IElement)"/>
        </member>
        <member name="M:NCDK.Tools.Manipulator.MolecularFormulaManipulator.GetElementCount(NCDK.IMolecularFormula,System.String)">
            <summary>
            Occurrences of a given element in a molecular formula.
            </summary>
            <param name="formula">the formula</param>
            <param name="symbol">element symbol (e.g. C for carbon)</param>
            <returns>number of the times the element occurs</returns>
            <seealso cref="M:NCDK.Tools.Manipulator.MolecularFormulaManipulator.GetElementCount(NCDK.IMolecularFormula,NCDK.IElement)"/>
        </member>
        <member name="M:NCDK.Tools.Manipulator.MolecularFormulaManipulator.GetIsotopes(NCDK.IMolecularFormula,NCDK.IElement)">
            <summary>
            Get a list of <see cref="T:NCDK.IIsotope"/> from a given <paramref name="element"/> which is contained
            molecular. The search is based only on the <see cref="T:NCDK.IElement"/>.
            </summary>
            <param name="formula">The <see cref="T:NCDK.IMolecularFormula"/> to check</param>
            <param name="element">The <see cref="T:NCDK.IElement"/> object</param>
            <returns>The list with the IIsotopes in this molecular formula</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.MolecularFormulaManipulator.Elements(NCDK.IMolecularFormula)">
            <summary>
             Get a list of all <see cref="T:NCDK.IElement"/>s which are contained molecular.
            </summary>
            <param name="formula">The molecular formula to check</param>
            <returns>The list with the elements in this molecular formula</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.MolecularFormulaManipulator.ContainsElement(NCDK.IMolecularFormula,NCDK.IElement)">
            <summary>
            True, if the <paramref name="formula"/> contains the given element as <see cref="T:NCDK.IIsotope"/> object.
            </summary>
            <param name="formula">molecular formula</param>
            <param name="element">The element this <see cref="T:NCDK.IMolecularFormula"/> is searched for</param>
            <returns>True, if the MolecularFormula contains the given element object</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.MolecularFormulaManipulator.RemoveElement(NCDK.IMolecularFormula,NCDK.IElement)">
            <summary>
            Removes all isotopes from a given element in the molecular formula.
            </summary>
            <param name="formula">molecular formula</param>
            <param name="element">The <see cref="T:NCDK.IElement"/> of the IIsotopes to be removed</param>
            <returns>The molecularFormula with the isotopes removed</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.MolecularFormulaManipulator.GetString(NCDK.IMolecularFormula,System.String[],System.Boolean)">
            <summary>
            Returns the string representation of the molecule formula.
            </summary>
            <param name="formula">The IMolecularFormula Object</param>
            <param name="orderElements">The order of Elements</param>
            <param name="setOne">True, when must be set the value 1 for elements with one atom</param>
            <returns>A string containing the molecular formula</returns>
            <seealso cref="M:NCDK.Tools.Manipulator.MolecularFormulaManipulator.GetHTML(NCDK.IMolecularFormula)"/>
            <seealso cref="P:NCDK.Tools.Manipulator.MolecularFormulaManipulator.OrderEle"/>
            <seealso cref="M:NCDK.Tools.Manipulator.MolecularFormulaManipulator.GenerateOrderEle_Hill_NoCarbons"/>
            <seealso cref="M:NCDK.Tools.Manipulator.MolecularFormulaManipulator.GenerateOrderEle_Hill_WithCarbons"/>
        </member>
        <member name="M:NCDK.Tools.Manipulator.MolecularFormulaManipulator.GetString(NCDK.IMolecularFormula)">
            <summary>
            Returns the string representation of the molecule formula.
            Based on Hill System. The Hill system is a system of writing
            chemical formulas such that the number of carbon atoms in a
            molecule is indicated first, the number of hydrogen atoms next,
            and then the number of all other chemical elements subsequently,
            in alphabetical order. When the formula contains no carbon, all
            the elements, including hydrogen, are listed alphabetically.
            </summary>
            <param name="formula">The IMolecularFormula Object</param>
            <returns>A string containing the molecular formula</returns>
            <seealso cref="M:NCDK.Tools.Manipulator.MolecularFormulaManipulator.GetHTML(NCDK.IMolecularFormula)"/>
        </member>
        <member name="M:NCDK.Tools.Manipulator.MolecularFormulaManipulator.GetString(NCDK.IMolecularFormula,System.Boolean)">
            <summary>
            Returns the string representation of the molecule formula.
            Based on Hill System. The Hill system is a system of writing
            chemical formulas such that the number of carbon atoms in a
            molecule is indicated first, the number of hydrogen atoms next,
            and then the number of all other chemical elements subsequently,
            in alphabetical order. When the formula contains no carbon, all
            the elements, including hydrogen, are listed alphabetically.
            </summary>
            <param name="formula">The IMolecularFormula Object</param>
            <param name="setOne">True, when must be set the value 1 for elements with one atom</param>
            <returns>A string containing the molecular formula</returns>
            <seealso cref="M:NCDK.Tools.Manipulator.MolecularFormulaManipulator.GetHTML(NCDK.IMolecularFormula)"/>
        </member>
        <member name="M:NCDK.Tools.Manipulator.MolecularFormulaManipulator.GetHTML(NCDK.IMolecularFormula)">
            <summary>
            Returns the string representation of the molecule formula based on Hill
            System with numbers wrapped in &lt;sub&gt;&lt;/sub&gt; tags. Useful for
            displaying formulae in Swing components or on the web.
            </summary>
            <param name="formula">The IMolecularFormula object</param>
            <returns>A HTML representation of the molecular formula</returns>
            <seealso cref="M:NCDK.Tools.Manipulator.MolecularFormulaManipulator.GetHTML(NCDK.IMolecularFormula,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:NCDK.Tools.Manipulator.MolecularFormulaManipulator.GetHTML(NCDK.IMolecularFormula,System.Boolean,System.Boolean)">
            <summary>
            Returns the string representation of the molecule formula based on Hill
            System with numbers wrapped in &lt;sub&gt;&lt;/sub&gt; tags and the
            isotope of each Element in &lt;sup&gt;&lt;/sup&gt; tags and the total
            charge of IMolecularFormula in &lt;sup&gt;&lt;/sup&gt; tags. Useful for
            displaying formulae in Swing components or on the web.
            </summary>
            <param name="formula">The IMolecularFormula object</param>
            <param name="chargeB">True, If it has to show the charge</param>
            <param name="isotopeB">True, If it has to show the Isotope mass</param>
            <returns>A HTML representation of the molecular formula</returns>
            <seealso cref="M:NCDK.Tools.Manipulator.MolecularFormulaManipulator.GetHTML(NCDK.IMolecularFormula)"/>
        </member>
        <member name="M:NCDK.Tools.Manipulator.MolecularFormulaManipulator.GetHTML(NCDK.IMolecularFormula,System.String[],System.Boolean,System.Boolean)">
            <summary>
            Returns the string representation of the molecule formula with numbers
            wrapped in &lt;sub&gt;&lt;/sub&gt; tags and the isotope of each Element
            in &lt;sup&gt;&lt;/sup&gt; tags and the total showCharge of IMolecularFormula
            in &lt;sup&gt;&lt;/sup&gt; tags. Useful for displaying formulae in Swing
            components or on the web.
            </summary>
            <param name="formula">The IMolecularFormula object</param>
            <param name="orderElements">The order of Elements</param>
            <param name="showCharge">True, If it has to show the showCharge</param>
            <param name="showIsotopes">True, If it has to show the Isotope mass</param>
            <returns>A HTML representation of the molecular formula</returns>
            <seealso cref="M:NCDK.Tools.Manipulator.MolecularFormulaManipulator.GetHTML(NCDK.IMolecularFormula)"/>
        </member>
        <member name="M:NCDK.Tools.Manipulator.MolecularFormulaManipulator.GetMolecularFormula(System.String,NCDK.IChemObjectBuilder)">
            <summary>
            Construct an instance of IMolecularFormula, initialized with a molecular
            formula string. The string is immediately analyzed and a set of Nodes
            is built based on this analysis
            <para>The hydrogens must be implicit.</para>
            </summary>
            <param name="stringMF">The molecularFormula string</param>
            <param name="builder">a IChemObjectBuilder which is used to construct atoms</param>
            <returns>The filled IMolecularFormula</returns>
            <seealso cref="M:NCDK.Tools.Manipulator.MolecularFormulaManipulator.GetMolecularFormula(System.String,NCDK.IMolecularFormula)"/>
        </member>
        <member name="M:NCDK.Tools.Manipulator.MolecularFormulaManipulator.GetMajorIsotopeMolecularFormula(System.String,NCDK.IChemObjectBuilder)">
            <summary>
            Construct an instance of IMolecularFormula, initialized with a molecular
            formula string. The string is immediately analyzed and a set of Nodes
            is built based on this analysis. The hydrogens must be implicit. Major
            isotopes are being used.
            </summary>
            <param name="stringMF">The molecularFormula string</param>
            <param name="builder">a IChemObjectBuilder which is used to construct atoms</param>
            <returns>The filled IMolecularFormula</returns>
            <seealso cref="M:NCDK.Tools.Manipulator.MolecularFormulaManipulator.GetMolecularFormula(System.String,NCDK.IMolecularFormula)"/>
        </member>
        <member name="M:NCDK.Tools.Manipulator.MolecularFormulaManipulator.GetMolecularFormula(System.String,NCDK.IMolecularFormula)">
            <summary>
            add in a instance of IMolecularFormula the elements extracts form
            molecular formula string. The string is immediately analyzed and a set of Nodes
            is built based on this analysis
            <para> The hydrogens must be implicit.</para>
            </summary>
            <param name="stringMF">The molecularFormula string</param>
            <returns>The filled IMolecularFormula</returns>
            <seealso cref="M:NCDK.Tools.Manipulator.MolecularFormulaManipulator.GetMolecularFormula(System.String,NCDK.IChemObjectBuilder)"/>
        </member>
        <member name="M:NCDK.Tools.Manipulator.MolecularFormulaManipulator.GetMolecularFormula(System.String,NCDK.IMolecularFormula,System.Boolean)">
            <summary>
            Add to an instance of IMolecularFormula the elements extracts form
            molecular formula string. The string is immediately analyzed and a set of Nodes
            is built based on this analysis. The hydrogens are assumed to be implicit.
            The bool indicates if the major isotope is to be assumed, or if no
            assumption is to be made.
            </summary>
            <param name="stringMF">The molecularFormula string</param>
            <param name="assumeMajorIsotope">If true, it will take the major isotope for each element</param>
            <returns>The filled IMolecularFormula</returns>
            <seealso cref="M:NCDK.Tools.Manipulator.MolecularFormulaManipulator.GetMolecularFormula(System.String,NCDK.IChemObjectBuilder)"/>
            <seealso cref="M:NCDK.Tools.Manipulator.MolecularFormulaManipulator.GetMolecularFormula(System.String,System.Boolean,NCDK.IChemObjectBuilder)"/>
        </member>
        <member name="M:NCDK.Tools.Manipulator.MolecularFormulaManipulator.CleanMFfromCharge(System.String)">
            <summary>
            Extract the molecular formula when it is defined with charge. e.g. [O3S]2-.
            </summary>
            <param name="formula">The formula to inspect</param>
            <returns>The corrected formula</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.MolecularFormulaManipulator.ExtractCharge(System.String)">
            <summary>
            Extract the charge given a molecular formula format [O3S]2-.
            </summary>
            <param name="formula">The formula to inspect</param>
            <returns>The charge</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.MolecularFormulaManipulator.GetTotalExactMass(NCDK.IMolecularFormula)">
            <summary>
            Get the summed exact mass of all isotopes from an MolecularFormula. It
            assumes isotope masses to be preset, and returns 0.0 if not.
            </summary>
            <param name="formula">The IMolecularFormula to calculate</param>
            <returns>The summed exact mass of all atoms in this MolecularFormula</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.MolecularFormulaManipulator.CorrectMass(System.Double,System.Int32)">
            <summary>
            Correct the mass according the charge of the IMmoleculeFormula.
            Negative charge will add the mass of one electron to the mass.
            </summary>
            <param name="mass">The mass to correct</param>
            <param name="charge">The charge</param>
            <returns>The mass with the correction</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.MolecularFormulaManipulator.GetTotalMassNumber(NCDK.IMolecularFormula)">
            <summary>
            Get the summed mass number of all isotopes from an MolecularFormula. It
            assumes isotope masses to be preset, and returns 0.0 if not.
            </summary>
            <param name="formula">The IMolecularFormula to calculate</param>
            <returns>The summed nominal mass of all atoms in this MolecularFormula</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.MolecularFormulaManipulator.GetNaturalExactMass(NCDK.IMolecularFormula)">
            <summary>
            Get the summed natural mass of all elements from an MolecularFormula.
            </summary>
            <param name="formula">The IMolecularFormula to calculate</param>
            <returns>The summed exact mass of all atoms in this MolecularFormula</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.MolecularFormulaManipulator.GetMajorIsotopeMass(NCDK.IMolecularFormula)">
            <summary>
            Get the summed major isotopic mass of all elements from an MolecularFormula.
            </summary>
            <param name="formula">The IMolecularFormula to calculate</param>
            <returns>The summed exact major isotope masses of all atoms in this MolecularFormula</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.MolecularFormulaManipulator.GetTotalNaturalAbundance(NCDK.IMolecularFormula)">
            <summary>
            Get the summed natural abundance of all isotopes from an MolecularFormula. Assumes
            abundances to be preset, and will return 0.0 if not.
            </summary>
            <param name="formula">The IMolecularFormula to calculate</param>
            <returns>The summed natural abundance of all isotopes in this MolecularFormula</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.MolecularFormulaManipulator.GetDBE(NCDK.IMolecularFormula)">
            <summary>
            Returns the number of double bond equivalents in this molecule.
            </summary>
            <param name="formula">The IMolecularFormula to calculate</param>
            <returns>The number of DBEs</returns>
            <exception cref="T:NCDK.CDKException">if DBE cannot be be evaluated</exception>
        </member>
        <member name="M:NCDK.Tools.Manipulator.MolecularFormulaManipulator.GetMolecularFormula(NCDK.IAtomContainer)">
            <summary>
            Method that actually does the work of convert the atomContainer
            to IMolecularFormula.
            <para>The hydrogens must be implicit.</para>
            </summary>
            <param name="atomContainer">IAtomContainer object</param>
            <returns>a molecular formula object</returns>
            <seealso cref="M:NCDK.Tools.Manipulator.MolecularFormulaManipulator.GetMolecularFormula(NCDK.IAtomContainer,NCDK.IMolecularFormula)"/>
        </member>
        <member name="M:NCDK.Tools.Manipulator.MolecularFormulaManipulator.GetMolecularFormula(NCDK.IAtomContainer,NCDK.IMolecularFormula)">
            <summary>
            Method that actually does the work of convert the atomContainer
            to IMolecularFormula given a IMolecularFormula.
            <para>The hydrogens must be implicit.</para>
            </summary>
            <param name="atomContainer">IAtomContainer object</param>
            <param name="formula">IMolecularFormula molecularFormula to put the new Isotopes</param>
            <returns>the filled AtomContainer</returns>
            <seealso cref="M:NCDK.Tools.Manipulator.MolecularFormulaManipulator.GetMolecularFormula(NCDK.IAtomContainer)"/>
        </member>
        <member name="M:NCDK.Tools.Manipulator.MolecularFormulaManipulator.GetAtomContainer(NCDK.IMolecularFormula)">
            <summary>
            Method that actually does the work of convert the IMolecularFormula
            to IAtomContainer.
            <para>The hydrogens must be implicit.</para>
            </summary>
            <param name="formula">IMolecularFormula object</param>
            <returns>the filled AtomContainer</returns>
            <seealso cref="M:NCDK.Tools.Manipulator.MolecularFormulaManipulator.GetAtomContainer(NCDK.IMolecularFormula,NCDK.IAtomContainer)"/>
        </member>
        <member name="M:NCDK.Tools.Manipulator.MolecularFormulaManipulator.GetAtomContainer(NCDK.IMolecularFormula,NCDK.IAtomContainer)">
            <summary>
            Method that actually does the work of convert the IMolecularFormula
            to IAtomContainer given a IAtomContainer.
            <para>The hydrogens must be implicit.</para>
            </summary>
            <param name="formula">IMolecularFormula object</param>
            <param name="atomContainer">IAtomContainer to put the new Elements</param>
            <returns>the filled AtomContainer</returns>
            <see cref="M:NCDK.Tools.Manipulator.MolecularFormulaManipulator.GetAtomContainer(NCDK.IMolecularFormula)"/>
        </member>
        <member name="M:NCDK.Tools.Manipulator.MolecularFormulaManipulator.GetAtomContainer(System.String,NCDK.IChemObjectBuilder)">
            <summary>
            Converts a formula string (like "C2H4") into an atom container with atoms
            but no bonds.
            </summary>
            <param name="formulaString">the formula to convert</param>
            <param name="builder">a chem object builder</param>
            <returns>atoms wrapped in an atom container</returns>
        </member>
        <member name="P:NCDK.Tools.Manipulator.MolecularFormulaManipulator.OrderEle">
            <summary>
            The Elements ordered according to (approximate) probability of occurrence.
            </summary>
            <remarks>This begins with the "elements of life" C, H, O, N, (Si, P, S, F, Cl),
            then continues with the "common" chemical synthesis ingredients, closing off
            with the tail-end of the periodic table in atom-number order and finally
            the generic R-group.
            </remarks>
        </member>
        <member name="M:NCDK.Tools.Manipulator.MolecularFormulaManipulator.GenerateOrderEle_Hill_NoCarbons">
            <summary>
            Returns the Elements in Hill system order for non-carbon-containing formulas
            (i.e. strict alphabetical order, with one-letter elements preceding two-letter elements.)
            The generic R-group is treated specially and comes last.
            </summary>
            <returns>Elements in Hill system order (strictly alphabetical), with generic R-groups last.</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.MolecularFormulaManipulator.GenerateOrderEle_Hill_WithCarbons">
            <summary>
            Returns the Elements in Hill system order for carbon-containing formulas
            (i.e. first carbon and hydrogen, and then the rest of the elements in strict
            alphabetical order, with one-letter elements preceding two-letter elements.)
            The generic R-group is treated specially and comes last.
            </summary>
            <returns>Elements in Hill system order with carbons and hydrogens first (and generic R-groups last).</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.MolecularFormulaManipulator.Compare(NCDK.IMolecularFormula,NCDK.IMolecularFormula)">
            <summary>
            Compare two IMolecularFormula looking at type and number of IIsotope and
            charge of the formula.
            </summary>
            <param name="formula1">The first IMolecularFormula</param>
            <param name="formula2">The second IMolecularFormula</param>
            <returns>True, if the both IMolecularFormula are the same</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.MolecularFormulaManipulator.GetHeavyElements(NCDK.IMolecularFormula)">
            <summary>
            Returns a set of nodes excluding all the hydrogens.
            </summary>
            <param name="formula">The IMolecularFormula</param>
            <returns>The heavyElements value into a List</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.MolecularFormulaManipulator.SimplifyMolecularFormula(System.String)">
            <summary>
            Simplify the molecular formula. E.g the dot '.' character convention is
            used when dividing a formula into parts. In this case any numeral following a dot refers
            to all the elements within that part of the formula that follow it.
            </summary>
            <param name="formula">The molecular formula</param>
            <returns>The simplified molecular formula</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.MolecularFormulaManipulator.BreakExtractor(System.String)">
            <summary>
            The parenthesis convention is used to show a quantity by which a formula is multiplied.
            For example: (C12H20O11)2 really means that a C24H40O22 unit.
            </summary>
            <param name="formula">Formula to correct</param>
            <returns>Formula with the correction</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.MolecularFormulaManipulator.MultipleExtractor(System.String)">
            <summary>
            The starting with numeric value is used to show a quantity by which a formula is multiplied.
            For example: 2H2O really means that a H4O2 unit.
            </summary>
            <param name="formula">Formula to correct</param>
            <returns>Formula with the correction</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.MolecularFormulaManipulator.Muliplier(System.String,System.Int32)">
            <summary>
            This method multiply all the element over a value.
            </summary>
            <param name="formula">Formula to correct</param>
            <param name="factor">Factor to multiply</param>
            <returns>Formula with the correction</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.MolecularFormulaManipulator.AdjustProtonation(NCDK.IMolecularFormula,System.Int32)">
            <summary>
            Adjust the protonation of a molecular formula. This utility method adjusts the hydrogen isotope count
            and charge at the same time.
            </summary>
            <example>
            <code>
            IMolecularFormula mf = MolecularFormulaManipulator.GetMolecularFormula("[C6H5O]-", bldr);
            MolecularFormulaManipulator.AdjustProtonation(mf, +1); // now "C6H6O"
            MolecularFormulaManipulator.AdjustProtonation(mf, -1); // now "C6H5O-"
            </code>
            
            The return value indicates whether the protonation could be adjusted:
            
            <code>
            IMolecularFormula mf = MolecularFormulaManipulator.GetMolecularFormula("[Cl]-", bldr);
            MolecularFormulaManipulator.AdjustProtonation(mf, +0); // false still "[Cl]-"
            MolecularFormulaManipulator.AdjustProtonation(mf, +1); // true now "HCl"
            MolecularFormulaManipulator.AdjustProtonation(mf, -1); // true now "[Cl]-" (again)
            MolecularFormulaManipulator.AdjustProtonation(mf, -1); // false still "[Cl]-" (no H to remove!)
            </code>
            
            The method tries to select an existing hydrogen isotope to augment. If no hydrogen isotopes are found
            a new major isotope (<sup>1</sup>H) is created.
            </example>
            <param name="mf">molecular formula</param>
            <param name="hcnt">the number of hydrogens to add/remove, (&gt;0 protonate:, &lt;0: deprotonate)</param>
            <returns>the protonation was be adjusted</returns>
        </member>
        <member name="T:NCDK.Tools.Manipulator.MolecularFormulaRangeManipulator">
            <summary>
            Class with convenience methods that provide methods to manipulate
            MolecularFormulaRange's.
            </summary>
        </member>
        <member name="M:NCDK.Tools.Manipulator.MolecularFormulaRangeManipulator.GetRange(NCDK.IMolecularFormulaSet)">
            <summary>
            Extract from a set of MolecularFormula the range of each each element found and
            put the element and occurrence in a new MolecularFormulaRange.
            </summary>
            <param name="mfSet">The set of molecularFormules to inspect</param>
            <returns>A MolecularFormulaRange containing range occurrence of the elements</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.MolecularFormulaRangeManipulator.GetMaximalFormula(NCDK.Formula.MolecularFormulaRange,NCDK.IChemObjectBuilder)">
            <summary>
            Returns the maximal occurrence of the IIsotope into IMolecularFormula
            from this MolelecularFormulaRange.
            </summary>
            <param name="mfRange">The MolecularFormulaRange to analyze</param>
            <returns>A IMolecularFormula containing the maximal occurrence of each isotope</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.MolecularFormulaRangeManipulator.GetMinimalFormula(NCDK.Formula.MolecularFormulaRange,NCDK.IChemObjectBuilder)">
            <summary>
            Returns the minimal occurrence of the IIsotope into IMolecularFormula
            from this MolelecularFormulaRange.
            </summary>
            <param name="mfRange">The MolecularFormulaRange to analyze</param>
            <returns>A IMolecularFormula containing the minimal occurrence of each isotope</returns>
        </member>
        <member name="T:NCDK.Tools.Manipulator.MolecularFormulaSetManipulator">
            <summary>
            Class with convenience methods that provide methods to manipulate
            MolecularFormulaSet's. 
            </summary>
            <example>
            <code>
             IMolecularFormula molecularFormula = MolecularFormulaSetManipulator.GetMaxOccurrenceElements(molecularFormulaSet);
            </code>
            </example>
        </member>
        <member name="M:NCDK.Tools.Manipulator.MolecularFormulaSetManipulator.GetMaxOccurrenceElements(NCDK.IMolecularFormulaSet)">
            <summary>
            Extract from a set of MolecularFormula the maximum occurrence of each element found and
            put the element and occurrence in a new IMolecularFormula.
            </summary>
            <param name="mfSet">The set of molecularFormules to inspect</param>
            <returns>A IMolecularFormula containing the maximum occurrence of the elements</returns>
            <seealso cref="M:NCDK.Tools.Manipulator.MolecularFormulaSetManipulator.GetMinOccurrenceElements(NCDK.IMolecularFormulaSet)"/> 
        </member>
        <member name="M:NCDK.Tools.Manipulator.MolecularFormulaSetManipulator.GetMinOccurrenceElements(NCDK.IMolecularFormulaSet)">
            <summary>
            Extract from a set of MolecularFormula the minimal occurrence of each element found and
            put the element and occurrence in a new IMolecularFormula.
            </summary>
            <param name="mfSet">The set of molecularFormules to inspect</param>
            <returns>A IMolecularFormula containing the minimal occurrence of the elements</returns>
            <seealso cref="M:NCDK.Tools.Manipulator.MolecularFormulaSetManipulator.GetMaxOccurrenceElements(NCDK.IMolecularFormulaSet)"/>
        </member>
        <member name="M:NCDK.Tools.Manipulator.MolecularFormulaSetManipulator.Remove(NCDK.IMolecularFormulaSet,NCDK.IMolecularFormula,NCDK.IMolecularFormula)">
            <summary>
            Remove all those IMolecularFormula which are not fit theirs IElement
            occurrence into a limits. The limits are given from formulaMax and formulaMin.
            In the minimal IMolecularFormula must contain all those IElement found in the
            minimal IMolecularFormula.
            </summary>
            <param name="formulaSet">IMolecularFormulaSet to look for</param>
            <param name="formulaMax">A IMolecularFormula which contains the maximal representation of the Elements</param>
            <param name="formulaMin">A IMolecularFormula which contains the minimal representation of the Elements</param>
            <returns>A IMolecularFormulaSet with only the IMolecularFormula which the IElements
                                    are into the correct occurrence</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.MolecularFormulaSetManipulator.ValidCorrelation(NCDK.IMolecularFormula,NCDK.IMolecularFormula)">
            <summary>
            In the minimal IMolecularFormula must contain all those IElement found in the
            minimal IMolecularFormula.
            </summary>
            <param name="formulaMax">A IMolecularFormula which contains the maximal representation of the Elements</param>
            <param name="formulaMin">A IMolecularFormula which contains the minimal representation of the Elements</param>
            <returns>True, if the correlation is valid</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.MolecularFormulaSetManipulator.Contains(NCDK.IMolecularFormulaSet,NCDK.IMolecularFormula)">
            <summary>
             True, if the IMolecularFormulaSet contains the given IMolecularFormula but not
             as object. It compare according contains the same number and type of Isotopes.
             It is not based on compare objects.
            </summary>
            <param name="formulaSet">The IMolecularFormulaSet</param>
            <param name="formula">The IMolecularFormula this IMolecularFormulaSet is searched for</param>
            <returns>True, if the IMolecularFormulaSet contains the given formula</returns>
            <seealso cref="M:System.Collections.Generic.ICollection`1.Contains(`0)"/>
        </member>
        <member name="M:NCDK.Tools.Manipulator.MolecularFormulaSetManipulator.Remove(NCDK.IMolecularFormulaSet,NCDK.Formula.MolecularFormulaRange)">
            <summary>
            Remove all those IMolecularFormula which are not fit theirs IElement
            occurrence into a limits. The limits are given from formulaMax and formulaMin.
            In the minimal IMolecularFormula must contain all those IElement found in the
            minimal IMolecularFormula.
            </summary>
            <param name="formulaSet">IMolecularFormulaSet to look for</param>
            <param name="formulaRange">A IMolecularFormulaRange which contains the range representation of the IIsotope</param>
        </member>
        <member name="T:NCDK.Tools.Manipulator.ReactionSchemeManipulator">
            <summary>
            </summary>
            <seealso cref="T:NCDK.Tools.Manipulator.ChemModelManipulator"/>
        </member>
        <member name="M:NCDK.Tools.Manipulator.ReactionSchemeManipulator.GetAllAtomContainers(NCDK.IReactionScheme,NCDK.IChemObjectSet{NCDK.IAtomContainer})">
            <summary>
            Get all molecule objects from a set of Reactions given a <see cref="T:NCDK.IAtomContainerSet"/> to add.
            </summary>
            <param name="scheme">The set of reaction to inspect</param>
            <param name="molSet">The set of molecules to be added</param>
            <returns>All molecules</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.ReactionSchemeManipulator.GetAllAtomContainers(NCDK.IReactionScheme)">
            <summary>
            Get all AtomContainers object from a set of Reactions.
            </summary>
            <param name="scheme">The scheme of reaction to inspect</param>
            <returns>All molecules</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.ReactionSchemeManipulator.GetAllIDs(NCDK.IReactionScheme)">
            <summary>
            Get all ID of this IReactionSet.
            </summary>
            <param name="scheme">The IReactionScheme to analyze</param>
            <returns>A List with all ID</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.ReactionSchemeManipulator.GetAllReactions(NCDK.IReactionScheme)">
            <summary>
            Get all IReaction's object from a given IReactionScheme.
            </summary>
            <param name="scheme">The IReactionScheme to extract</param>
            <returns>The IReactionSet</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.ReactionSchemeManipulator.NewReactionScheme(NCDK.IReactionSet)">
            <summary>
            Create a IReactionScheme give a IReactionSet object.
            </summary>
            <param name="reactionSet">The IReactionSet</param>
            <returns>The IReactionScheme</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.ReactionSchemeManipulator.ExtractTopReactions(NCDK.IReactionScheme)">
            <summary>
            Extract a set of Reactions which are in top of a IReactionScheme. The top reactions are those
            which any of their reactants are participating in other reactions as a products.
            </summary>
            <param name="reactionScheme">The IReactionScheme</param>
            <returns>The set of top reactions</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.ReactionSchemeManipulator.SetScheme(NCDK.IReaction,NCDK.IReactionSet)">
            <summary>
            Create a IReactionScheme given as a top a IReaction. If it doesn't exist any subsequent reaction
            return null;
            </summary>
            <param name="reaction">The IReaction as a top</param>
            <param name="reactionSet">The IReactionSet to extract a IReactionScheme</param>
            <returns>The IReactionScheme</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.ReactionSchemeManipulator.ExtractPrecursorReaction(NCDK.IReaction,NCDK.IReactionSet)">
            <summary>
            Extract reactions from a IReactionSet which at least one product is existing
            as reactant given a IReaction
            </summary>
            <param name="reaction">The IReaction to analyze</param>
            <param name="reactionSet">The IReactionSet to inspect</param>
            <returns>A IReactionSet containing the reactions</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.ReactionSchemeManipulator.ExtractSubsequentReaction(NCDK.IReaction,NCDK.IReactionSet)">
            <summary>
            Extract reactions from a IReactionSet which at least one reactant is existing
            as precursor given a IReaction
            </summary>
            <param name="reaction">The IReaction to analyze</param>
            <param name="reactionSet">The IReactionSet to inspect</param>
            <returns>A IReactionSet containing the reactions</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.ReactionSchemeManipulator.GetAtomContainerSet(NCDK.IAtomContainer,NCDK.IAtomContainer,NCDK.IReactionScheme)">
            <summary>
            Extract the list of AtomContainers taking part in the IReactionScheme to originate a
            product given a reactant.
            </summary>
            <param name="origenMol">The start IAtomContainer</param>
            <param name="finalMol">The end IAtomContainer</param>
            <param name="reactionScheme">The IReactionScheme containing the AtomContainers</param>
            <returns>A List of IAtomContainerSet given the path</returns>
        </member>
        <member name="T:NCDK.Tools.Manipulator.ReactionSetManipulator">
            <summary>
            </summary>
            <seealso cref="T:NCDK.Tools.Manipulator.ChemModelManipulator"/>
        </member>
        <member name="M:NCDK.Tools.Manipulator.ReactionSetManipulator.GetAllMolecules(NCDK.IReactionSet)">
            <summary>
            get all Molecules object from a set of Reactions.
            </summary>
            <param name="set">The set of reaction to inspect</param>
            <returns>The IAtomContanerSet</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.ReactionSetManipulator.GetAllAtomContainers(NCDK.IReactionSet)">
            <summary>
            Returns all the AtomContainer's of a Reaction.
            </summary>
            <param name="set">the reaction set to get the molecules from</param>
            <returns>a List containing the IAtomContainer objects in the IReactionSet</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.ReactionSetManipulator.GetRelevantReactions(NCDK.IReactionSet,NCDK.IAtomContainer)">
            <summary>
            Get all Reactions object containing a Molecule from a set of Reactions.
            </summary>
            <param name="reactSet">The set of reaction to inspect</param>
            <param name="molecule">The molecule to find</param>
            <returns>The IReactionSet</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.ReactionSetManipulator.GetRelevantReactionsAsReactant(NCDK.IReactionSet,NCDK.IAtomContainer)">
            <summary>
            Get all Reactions object containing a Molecule as a Reactant from a set
            of Reactions.
            </summary>
            <param name="reactSet">The set of reaction to inspect</param>
            <param name="molecule">The molecule to find as a reactant</param>
            <returns>The IReactionSet</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.ReactionSetManipulator.GetRelevantReactionsAsProduct(NCDK.IReactionSet,NCDK.IAtomContainer)">
            <summary>
            Get all Reactions object containing a Molecule as a Product from a set of
            Reactions.
            </summary>
            <param name="reactSet">The set of reaction to inspect</param>
            <param name="molecule">The molecule to find as a product</param>
            <returns>The IReactionSet</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.ReactionSetManipulator.GetReactionByAtomContainerID(NCDK.IReactionSet,System.String)">
            <summary>
            Gets a reaction from a ReactionSet by ID of any product or reactant. If several exist,
            only the first one will be returned.
            </summary>
            <param name="reactionSet">The reactionSet to search in</param>
            <param name="id">The id to search for.</param>
            <returns>The Reaction or null;</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.ReactionSetManipulator.GetReactionByReactionID(NCDK.IReactionSet,System.String)">
            <summary>
            Gets a reaction from a ReactionSet by ID. If several exist,
            only the first one will be returned.
            </summary>
            <param name="reactionSet">The reactionSet to search in</param>
            <param name="id">The id to search for.</param>
            <returns>The Reaction or null;</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.RingManipulator.MarkAromaticRings(NCDK.IRing)">
             <summary>
             Marks the ring aromatic if all atoms and all bonds are aromatic.
            
             The method assumes that aromaticity of atoms and bonds have been
             detected beforehand
             </summary>
             <param name="ring">The ring to examine</param>
        </member>
        <member name="M:NCDK.Tools.Manipulator.RingSetManipulator.GetAtomCount(NCDK.IRingSet)">
            <summary>
            Return the total number of atoms over all the rings in the colllection.
            </summary>
            <param name="set">The collection of rings</param>
            <returns> The total number of atoms</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.RingSetManipulator.GetAllInOneContainer(NCDK.IRingSet)">
            <summary>
            Puts all rings of a ringSet in a single atomContainer
            </summary>
            <param name="ringSet">The ringSet to use</param>
            <returns>The produced atomContainer</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.RingSetManipulator.GetLargestRingSet(System.Collections.Generic.IList{NCDK.IRingSet})">
             <summary>
             Returns the largest (number of atoms) ring set in a molecule
            
             <param name="ringSystems">RingSystems of a molecule</param>
             <returns>The largestRingSet</returns>
             </summary>
        </member>
        <member name="M:NCDK.Tools.Manipulator.RingSetManipulator.GetBondCount(NCDK.IRingSet)">
             <summary>
             Return the total number of bonds over all the rings in the colllection.
            
             <param name="set">The collection of rings</param>
             <returns>The total number of  bonds</returns>
             </summary>
        </member>
        <member name="M:NCDK.Tools.Manipulator.RingSetManipulator.GetAllAtomContainers(System.Collections.Generic.IEnumerable{NCDK.IRing})">
            <summary>
            Returns all the AtomContainer's in a RingSet.
            <param name="set">The collection of rings</param>
            <returns>A list of IAtomContainer objects corresponding to individual rings</returns>
            </summary>
        </member>
        <member name="M:NCDK.Tools.Manipulator.RingSetManipulator.Sort(System.Collections.Generic.IList{NCDK.IRing})">
            <summary>
            Sorts the rings in the set by size. The smallest ring comes
            first.
            <param name="ringSet">The collection of rings</param>
            </summary>
        </member>
        <member name="M:NCDK.Tools.Manipulator.RingSetManipulator.GetHeaviestRing(NCDK.IRingSet,NCDK.IBond)">
            <summary>
            We define the heaviest ring as the one with the highest number of double bonds.
            Needed for example for the placement of in-ring double bonds.
            </summary>
            <param name="ringSet">The collection of rings</param>
            <param name="bond">A bond which must be contained by the heaviest ring</param>
            <returns>The ring with the higest number of double bonds connected to a given bond</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.RingSetManipulator.GetMostComplexRing(NCDK.IChemObjectSet{NCDK.IRing})">
            <summary>
            Returns the ring with the highest numbers of other rings attached to it. If an
            equally complex ring is found the last one is selected allow prioritization by
            size with <see cref="M:NCDK.Tools.Manipulator.RingSetManipulator.Sort(System.Collections.Generic.IList{NCDK.IRing})"/>.
            </summary>
            <param name="ringSet">The collection of rings</param>
            <returns>the ring with the highest numbers of other rings attached to it.</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.RingSetManipulator.IsSameRing(NCDK.IRingSet,NCDK.IAtom,NCDK.IAtom)">
            <summary>
            Checks if <paramref name="atom1"/> and <paramref name="atom2"/> share membership in the same ring or ring system.
            Membership in the same ring is checked if the RingSet contains the SSSR of a molecule; membership in
            the same ring or same ring system is checked if the RingSet contains all rings of a molecule.
            </summary>
            <remarks>
            <note type="important">
            This method only returns meaningful results if <paramref name="atom1"/> and 
            <paramref name="atom2"/> are members of the same molecule for which the RingSet was calculated!
            </note>
            </remarks>
            <param name="ringSet">The collection of rings</param>
            <param name="atom1">The first atom</param>
            <param name="atom2">The second atom</param>
            <returns>bool true if <paramref name="atom1"/> and <paramref name="atom2"/> share membership of at least one ring or ring system, false otherwise</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.RingSetManipulator.RingAlreadyInSet(NCDK.IRing,NCDK.IRingSet)">
            <summary>
            Checks - and returns 'true' - if a certain ring is already
            stored in the ringset. This is not a test for equality of Ring
            objects, but compares all Bond objects of the ring.
            </summary>
            <param name="newRing">The ring to be tested if it is already stored</param>
            <param name="ringSet">The collection of rings</param>
            <returns><see langword="true"/> if it is already stored</returns>
        </member>
        <member name="M:NCDK.Tools.Manipulator.RingSetManipulator.MarkAromaticRings(NCDK.IRingSet)">
             <summary>
             Iterates over the rings in the ring set, and marks the ring
             aromatic if all atoms and all bonds are aromatic.
            
             This method assumes that aromaticity perception has been done before hand.
             </summary>
             <param name="ringset">The collection of rings</param>
        </member>
        <member name="F:NCDK.Tools.Manipulator.RingSizeComparator.LARGE_FIRST">
            <summary>Flag to denote that the set is order with the largest ring first</summary>
        </member>
        <member name="F:NCDK.Tools.Manipulator.RingSizeComparator.SMALL_FIRST">
            <summary>Flag to denote that the set is order with the smallest ring first</summary>
        </member>
        <member name="M:NCDK.Tools.Manipulator.RingSizeComparator.#ctor(System.Int32)">
            <summary>
            Constructs a new comparator to sort rings by size.
            </summary>
            <param name="order">Sort order: either RingSet.SMALL_FIRST or
                                            RingSet.LARGE_FIRST.</param>
        </member>
        <member name="T:NCDK.Tools.PeriodicTable">
            <summary>
            Represents elements of the Periodic Table.  This utility class was
            previously useful when one wants generic properties of elements such as
            atomic number, VdW radius etc. The new approach to this is to use the
            <see cref="T:NCDK.Config.Elements"/> enumeration.
            </summary>
        </member>
        <member name="F:NCDK.Tools.PeriodicTable.syncLock">
            <summary>A lock used for locking CAD ID initialisation.</summary>
        </member>
        <member name="M:NCDK.Tools.PeriodicTable.GetVdwRadius(System.String)">
            <summary>
            Get the Van der Waals radius for the element in question.
            </summary>
            <param name="symbol">The symbol of the element</param>
            <returns>the Van der waals radius</returns>
        </member>
        <member name="M:NCDK.Tools.PeriodicTable.GetCovalentRadius(System.String)">
            <summary>
            Get the covalent radius for an element.
            </summary>
            <param name="symbol">the symbol of the element</param>
            <returns>the covalent radius</returns>
        </member>
        <member name="M:NCDK.Tools.PeriodicTable.GetCASId(System.String)">
            <summary>
            Get the CAS ID for an element.
            </summary>
            <param name="symbol">the symbol of the element</param>
            <returns>the CAS ID</returns>
        </member>
        <member name="M:NCDK.Tools.PeriodicTable.GetChemicalSeries(System.String)">
            <summary>
            Get the chemical series for an element.
            </summary>
            <param name="symbol">the symbol of the element</param>
            <returns>the chemical series of the element</returns>
        </member>
        <member name="M:NCDK.Tools.PeriodicTable.GetGroup(System.String)">
            <summary>
            Get the group of the element.
            </summary>
            <param name="symbol">the symbol of the element</param>
            <returns>the group</returns>
        </member>
        <member name="M:NCDK.Tools.PeriodicTable.GetName(System.String)">
            <summary>
            Get the name of the element.
            </summary>
            <param name="symbol">the symbol of the element</param>
            <returns>the name of the element</returns>
        </member>
        <member name="M:NCDK.Tools.PeriodicTable.GetPeriod(System.String)">
            <summary>
            Get the period of the element.
            </summary>
            <param name="symbol">the symbol of the element</param>
            <returns>the period</returns>
        </member>
        <member name="M:NCDK.Tools.PeriodicTable.GetPhase(System.String)">
            <summary>
            Get the phase of the element.
            </summary>
            <param name="symbol">the symbol of the element</param>
            <returns>the phase of the element</returns>
        </member>
        <member name="M:NCDK.Tools.PeriodicTable.GetAtomicNumber(System.String)">
            <summary>
            Get the atomic number of the element.
            </summary>
            <param name="symbol">the symbol of the element</param>
            <returns>the atomic number</returns>
        </member>
        <member name="M:NCDK.Tools.PeriodicTable.GetPaulingElectronegativity(System.String)">
            <summary>
            Get the Pauling electronegativity of an element.
            </summary>
            <param name="symbol">the symbol of the element</param>
            <returns>the Pauling electronegativity</returns>
        </member>
        <member name="M:NCDK.Tools.PeriodicTable.GetSymbol(System.Int32)">
            <summary>
            Get the symbol for the specified atomic number.
            </summary>
            <param name="atomicNumber">the atomic number of the element</param>
            <returns>the corresponding symbol</returns>
        </member>
        <member name="P:NCDK.Tools.PeriodicTable.ElementCount">
            <summary>
            The number of elements in the periodic table
            </summary>
        </member>
        <member name="T:NCDK.Tools.AtomTypeAwareSaturationChecker">
            <summary>
            This class tries to figure out the bond order of the bonds that has the flag
            <see cref="P:NCDK.IBond.IsSingleOrDouble"/> raised (i.e. set to <see langword="true"/>).
            <para>
            The code is written with the assumption that the properties of the atoms in
            the molecule has configured with the help of <see cref="T:NCDK.Tools.Manipulator.AtomContainerManipulator"/>.
            This class uses the <see cref="T:NCDK.Tools.SaturationChecker"/> internally.</para>
            <para>
            If it can't find a solution where all atoms in the molecule are saturated,
            it gives a "best guess", i.e. the solution with most saturated atoms. If not
            all atoms are saturated then it will be noticed as a warning in the log.</para>
            </summary>
        </member>
        <member name="M:NCDK.Tools.AtomTypeAwareSaturationChecker.#ctor">
            <summary>
            Constructs an <see cref="T:NCDK.Tools.AtomTypeAwareSaturationChecker"/> checker.
            </summary>
        </member>
        <member name="M:NCDK.Tools.AtomTypeAwareSaturationChecker.DecideBondOrder(NCDK.IAtomContainer,System.Boolean)">
            <summary>
            This method decides the bond order on bonds that has the
            <see cref="P:NCDK.IBond.IsSingleOrDouble"/> raised.
            </summary>
            <param name="atomContainer">The molecule to investigate</param>
            <param name="atomsSaturated">Set to true if you want to make sure that all atoms are saturated.</param>
        </member>
        <member name="M:NCDK.Tools.AtomTypeAwareSaturationChecker.DecideBondOrder(NCDK.IAtomContainer)">
            <summary>
            This method decides the bond order on bonds that has the
            <see cref="P:NCDK.IBond.IsSingleOrDouble"/> raised.
            </summary>
            <param name="atomContainer">The molecule to investigate.</param>
        </member>
        <member name="M:NCDK.Tools.AtomTypeAwareSaturationChecker.DecideBondOrder(NCDK.IAtomContainer,System.Int32)">
            <summary>
            This method decides the bond order on bonds that has the 
            <see cref="P:NCDK.IBond.IsSingleOrDouble"/> raised.
            </summary>
            <param name="atomContainer">The molecule to investigate</param>
            <param name="start">The bond to start with</param>
        </member>
        <member name="M:NCDK.Tools.AtomTypeAwareSaturationChecker.CheckBond(NCDK.IAtomContainer,System.Int32)">
            <summary>
            This method tries to set the bond order on the current bond.
            </summary>
            <param name="atomContainer">The molecule</param>
            <param name="index">The index of the current bond</param>
            <exception cref="T:NCDK.CDKException">when no suitable solution can be found</exception>
        </member>
        <member name="M:NCDK.Tools.AtomTypeAwareSaturationChecker.SetMaxBondOrder(NCDK.IBond,NCDK.IAtomContainer)">
            <summary>
            This method decides the highest bond order that the bond can have and set
            it to that.
            </summary>
            <param name="bond">The bond to be investigated</param>
            <param name="atomContainer">The <see cref="T:NCDK.IAtomContainer"/> that contains the bond</param>
            <exception cref="T:NCDK.CDKException">when the bond cannot be further increased</exception>
        </member>
        <member name="M:NCDK.Tools.AtomTypeAwareSaturationChecker.BondOrderCanBeIncreased(NCDK.IBond,NCDK.IAtomContainer)">
            <summary>
            Check if the bond order can be increased. This method assumes that the
            bond is between only two atoms.
            </summary>
            <param name="bond">The bond to check</param>
            <param name="atomContainer">The <see cref="T:NCDK.IAtomContainer"/> that the bond belongs to</param>
            <returns>True if it is possibly to increase the bond order</returns>
        </member>
        <member name="M:NCDK.Tools.AtomTypeAwareSaturationChecker.GetAtomBondOrderSum(NCDK.IAtom,NCDK.IAtomContainer)">
            <summary>
            This method is used if, by some reason, the bond order sum is not set
            for an atom.
            </summary>
            <param name="atom">The atom in question</param>
            <param name="mol">The molecule that the atom belongs to</param>
            <returns>The bond order sum</returns>
        </member>
        <member name="M:NCDK.Tools.AtomTypeAwareSaturationChecker.IsConnected(NCDK.IBond,NCDK.IBond)">
            <summary>
            Look if any atoms in <paramref name="bond1"/> also are in <paramref name="bond2"/>
            and if so it conceder the bonds connected.
            </summary>
            <param name="bond1">The first bond</param>
            <param name="bond2">The other bond</param>
            <returns>True if any of  the atoms in <paramref name="bond1"/> also are in <paramref name="bond2"/></returns>
        </member>
        <member name="M:NCDK.Tools.AtomTypeAwareSaturationChecker.GetMaxNoOfBonds(NCDK.IAtom)">
            <summary>
            This method calculates the number of bonds that an <see cref="T:NCDK.IAtom"/>
            can have.
            </summary>
            <param name="atom">The <see cref="T:NCDK.IAtom"/> to be investigated</param>
            <returns>The max number of bonds the <see cref="T:NCDK.IAtom"/> can have</returns>
            <exception cref="T:NCDK.CDKException">when the atom's valency is not set</exception>
        </member>
        <member name="M:NCDK.Tools.AtomTypeAwareSaturationChecker.BondsUsed(NCDK.IAtom,NCDK.IAtomContainer)">
            <summary>
            A small help method that count how many bonds an atom has, regarding
            bonds due to its charge and to implicit hydrogens.
            </summary>
            <param name="atom">The atom to check</param>
            <param name="atomContainer">The atomContainer containing the atom</param>
            <returns>The number of bonds that the atom has</returns>
        </member>
        <member name="M:NCDK.Tools.AtomTypeAwareSaturationChecker.Saturate(NCDK.IAtomContainer)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Tools.AtomTypeAwareSaturationChecker.IsSaturated(NCDK.IAtomContainer)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Tools.AtomTypeAwareSaturationChecker.IsSaturated(NCDK.IAtom,NCDK.IAtomContainer)">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Tools.AtomTypeAwareSaturationChecker.CantDecideBondOrderException">
            <summary>
            This is a private exception thrown when it detects an error and needs to
            start to back-trace.
            </summary>
        </member>
        <member name="M:NCDK.Tools.AtomTypeAwareSaturationChecker.CantDecideBondOrderException.#ctor(System.String)">
            <summary>
            Creates a new <see cref="T:NCDK.Tools.AtomTypeAwareSaturationChecker.CantDecideBondOrderException"/> with a given message.
            </summary>
            <param name="message">Explanation about why the decision could not be made.</param>
        </member>
        <member name="T:NCDK.Tools.CDKHydrogenAdder">
            <summary>
            Adds implicit hydrogens based on atom type definitions. The class assumes
            that CDK atom types are already detected. 
            </summary>
            <example>
            A full code example is:
            <code>                IAtomContainer methane = new AtomContainer();
                IAtom carbon = new Atom("C");
                methane.Atoms.Add(carbon);
                CDKAtomTypeMatcher matcher = CDKAtomTypeMatcher.GetInstance(methane.Builder);
                foreach (var atom in methane.Atoms)
                {
                    IAtomType type = matcher.FindMatchingAtomType(methane, atom);
                    AtomTypeManipulator.Configure(atom, type);
                }
                CDKHydrogenAdder adder = CDKHydrogenAdder.GetInstance(methane.Builder);
                adder.AddImplicitHydrogens(methane);
</code>
            If you want to add the hydrogens to a specific atom only,
            use this example:
            <code>                IAtomContainer ethane = new AtomContainer();
                IAtom carbon1 = new Atom("C");
                IAtom carbon2 = new Atom("C");
                ethane.Atoms.Add(carbon1);
                ethane.Atoms.Add(carbon2);
                CDKAtomTypeMatcher matcher = CDKAtomTypeMatcher.GetInstance(ethane.Builder);
                IAtomType type = matcher.FindMatchingAtomType(ethane, carbon1);
                AtomTypeManipulator.Configure(carbon1, type);
                CDKHydrogenAdder adder = CDKHydrogenAdder.GetInstance(ethane.Builder);
                adder.AddImplicitHydrogens(ethane, carbon1);
</code>
            </example>
        </member>
        <member name="M:NCDK.Tools.CDKHydrogenAdder.AddImplicitHydrogens(NCDK.IAtomContainer)">
            <summary>
            Sets implicit hydrogen counts for all atoms in the given <see cref="T:NCDK.IAtomContainer"/>.
            </summary>
            <param name="container">The molecule to which H's will be added</param>
            <exception cref="T:NCDK.CDKException">If insufficient information is present</exception>
        </member>
        <member name="M:NCDK.Tools.CDKHydrogenAdder.AddImplicitHydrogens(NCDK.IAtomContainer,NCDK.IAtom)">
            <summary>
            Sets the implicit hydrogen count for the indicated IAtom in the given <see cref="T:NCDK.IAtomContainer"/>.
            If the atom type is "X", then the atom is assigned zero implicit hydrogens.
            </summary>
            <param name="container">The molecule to which H's will be added</param>
            <param name="atom">IAtom to set the implicit hydrogen count for</param>
            <exception cref="T:NCDK.CDKException">if insufficient information is present</exception>
        </member>
        <member name="T:NCDK.Tools.CDKValencyChecker">
            <summary>
            Assumes CDK atom types to be detected and adds missing hydrogens based on the
            atom typing.
            </summary>
        </member>
        <member name="T:NCDK.Tools.DataFeatures">
            <summary>
            Class with constants for possible data features defined in the
            a Data Feature Ontology. Actual integers are random
            and should <b>not</b> be used directly.
            </summary>
            <example>
            To test whether a IChemFormat supports a certain feature, the
            following code can be used:
            <code>            int features = new XYZFormat().SupportedDataFeatures;
            bool has3DCoords = (features &amp; HAS_3D_COORDINATES) == HAS_3D_COORDINATES;
</code>
            This list of constants matches the latest <see href="http://qsar.sourceforge.net/ontologies/data-features/index.xhtml">Blue Obelisk Data Features Ontology</see>.
            </example>
        </member>
        <member name="F:NCDK.Tools.DataFeatures.None">
            <summary>Indicated that no feature are defined.</summary>
        </member>
        <member name="F:NCDK.Tools.DataFeatures.HAS_2D_COORDINATES">
            <summary>@cdk.dictref bodf:coordinates2D</summary>
        </member>
        <member name="F:NCDK.Tools.DataFeatures.HAS_3D_COORDINATES">
            <summary>@cdk.dictref bodf:coordinates3D</summary>
        </member>
        <member name="F:NCDK.Tools.DataFeatures.HAS_FRACTIONAL_CRYSTAL_COORDINATES">
            <summary>@cdk.dictref bodf:fractionalUnitCellCoordinatesCoordinates</summary>
        </member>
        <member name="F:NCDK.Tools.DataFeatures.HAS_ATOM_ELEMENT_SYMBOL">
            <summary>@cdk.dictref bodf:hasAtomElementSymbol</summary>
        </member>
        <member name="F:NCDK.Tools.DataFeatures.HAS_ATOM_PARTIAL_CHARGES">
            <summary>@cdk.dictref bodf:partialAtomicCharges</summary>
        </member>
        <member name="F:NCDK.Tools.DataFeatures.HAS_ATOM_FORMAL_CHARGES">
            <summary>@cdk.dictref bodf:formalAtomicCharges</summary>
        </member>
        <member name="F:NCDK.Tools.DataFeatures.HAS_ATOM_HYBRIDIZATIONS">
            <summary>FIXME: NOT YET IN BODF !!! </summary>
        </member>
        <member name="F:NCDK.Tools.DataFeatures.HAS_ATOM_MASS_NUMBERS">
            <summary>@cdk.dictref bodf:massNumbers</summary>
        </member>
        <member name="F:NCDK.Tools.DataFeatures.HAS_ATOM_ISOTOPE_NUMBERS">
            <summary>@cdk.dictref bodf:isotopeNumbers</summary>
        </member>
        <member name="F:NCDK.Tools.DataFeatures.HAS_GRAPH_REPRESENTATION">
            <summary>@cdk.dictref bodf:graphRepresentation</summary>
        </member>
        <member name="F:NCDK.Tools.DataFeatures.HAS_DIETZ_REPRESENTATION">
            <summary>@cdk.dictref bodf:dietzRepresentation</summary>
        </member>
        <member name="F:NCDK.Tools.DataFeatures.HAS_UNITCELL_PARAMETERS">
            <summary>FIXME: NOT YET IN BODF !!! </summary>
        </member>
        <member name="F:NCDK.Tools.DataFeatures.HAS_REACTIONS">
            <summary>FIXME: NOT YET IN BODF !!! </summary>
        </member>
        <member name="T:NCDK.Tools.Diff.AtomContainerDiff">
            <summary>
            Compares two <see cref="T:NCDK.IAtomContainer"/> classes.
            </summary>
        </member>
        <member name="M:NCDK.Tools.Diff.AtomContainerDiff.#ctor">
            <summary>
            Overwrite the default public constructor because this class is not
            supposed to be instantiated.
            </summary>
        </member>
        <member name="M:NCDK.Tools.Diff.AtomContainerDiff.Diff(NCDK.IChemObject,NCDK.IChemObject)">
            <summary>
            Compare two <see cref="T:NCDK.IChemObject"/> classes and return the difference as a <see cref="T:System.String"/>.
            </summary>
            <param name="first">the first of the two classes to compare</param>
            <param name="second">the second of the two classes to compare</param>
            <returns>a <see cref="T:System.String"/> representation of the difference between the first and second <see cref="T:NCDK.IChemObject"/>.</returns>
        </member>
        <member name="M:NCDK.Tools.Diff.AtomContainerDiff.Difference(NCDK.IChemObject,NCDK.IChemObject)">
            <summary>
            Compare two <see cref="T:NCDK.IChemObject"/> classes and return the difference as an <see cref="T:NCDK.Tools.Diff.Tree.IDifference"/>.
            </summary>
            <param name="first">the first of the two classes to compare</param>
            <param name="second">the second of the two classes to compare</param>
            <returns>an <see cref="T:NCDK.Tools.Diff.Tree.IDifference"/> representation of the difference between the first and second <see cref="T:NCDK.IChemObject"/>.</returns>
        </member>
        <member name="T:NCDK.Tools.Diff.AtomDiff">
            <summary>
            Compares two <see cref="T:NCDK.IAtom"/> classes.
            </summary>
        </member>
        <member name="M:NCDK.Tools.Diff.AtomDiff.#ctor">
            <summary>
            Overwrite the default public constructor because this class is not
            supposed to be instantiated.
            </summary>
        </member>
        <member name="M:NCDK.Tools.Diff.AtomDiff.Diff(NCDK.IChemObject,NCDK.IChemObject)">
            <summary>
            Compare two <see cref="T:NCDK.IChemObject"/> classes and return the difference as a <see cref="T:System.String"/>.
            </summary>
            <param name="first">the first of the two classes to compare</param>
            <param name="second">the second of the two classes to compare</param>
            <returns>a <see cref="T:System.String"/> representation of the difference between the first and second <see cref="T:NCDK.IChemObject"/>.</returns>
        </member>
        <member name="M:NCDK.Tools.Diff.AtomDiff.Difference(NCDK.IChemObject,NCDK.IChemObject)">
            <summary>
            Compare two <see cref="T:NCDK.IChemObject"/> classes and return the difference as an <see cref="T:NCDK.Tools.Diff.Tree.IDifference"/>.
            </summary>
            <param name="first">the first of the two classes to compare</param>
            <param name="second">the second of the two classes to compare</param>
            <returns>an <see cref="T:NCDK.Tools.Diff.Tree.IDifference"/> representation of the difference between the first and second <see cref="T:NCDK.IChemObject"/>.</returns>
        </member>
        <member name="T:NCDK.Tools.Diff.AtomTypeDiff">
            <summary>
            Compares two <see cref="T:NCDK.IAtomType"/> classes.
            </summary>
        </member>
        <member name="M:NCDK.Tools.Diff.AtomTypeDiff.#ctor">
            <summary>
            Overwrite the default public constructor because this class is not
            supposed to be instantiated.
            </summary>
        </member>
        <member name="M:NCDK.Tools.Diff.AtomTypeDiff.Diff(NCDK.IChemObject,NCDK.IChemObject)">
            <summary>
            Compare two <see cref="T:NCDK.IChemObject"/> classes and return the difference as a <see cref="T:System.String"/>.
            </summary>
            <param name="first">the first of the two classes to compare</param>
            <param name="second">the second of the two classes to compare</param>
            <returns>a <see cref="T:System.String"/> representation of the difference between the first and second <see cref="T:NCDK.IChemObject"/>.</returns>
        </member>
        <member name="M:NCDK.Tools.Diff.AtomTypeDiff.Difference(NCDK.IChemObject,NCDK.IChemObject)">
            <summary>
            Compare two <see cref="T:NCDK.IChemObject"/> classes and return the difference as an <see cref="T:NCDK.Tools.Diff.Tree.IDifference"/>.
            </summary>
            <param name="first">the first of the two classes to compare</param>
            <param name="second">the second of the two classes to compare</param>
            <returns>an <see cref="T:NCDK.Tools.Diff.Tree.IDifference"/> representation of the difference between the first and second <see cref="T:NCDK.IChemObject"/>.</returns>
        </member>
        <member name="T:NCDK.Tools.Diff.Tree.BondDiff">
            <summary>
            Compares two <see cref="T:NCDK.IBond"/> classes.
            </summary>
        </member>
        <member name="M:NCDK.Tools.Diff.Tree.BondDiff.#ctor">
            <summary>
            Overwrite the default public constructor because this class is not
            supposed to be instantiated.
            </summary>
        </member>
        <member name="M:NCDK.Tools.Diff.Tree.BondDiff.Diff(NCDK.IChemObject,NCDK.IChemObject)">
            <summary>
            Compare two <see cref="T:NCDK.IChemObject"/> classes and return the difference as a <see cref="T:System.String"/>.
            </summary>
            <param name="first">the first of the two classes to compare</param>
            <param name="second">the second of the two classes to compare</param>
            <returns>a <see cref="T:System.String"/> representation of the difference between the first and second <see cref="T:NCDK.IChemObject"/>.</returns>
        </member>
        <member name="M:NCDK.Tools.Diff.Tree.BondDiff.Difference(NCDK.IChemObject,NCDK.IChemObject)">
            <summary>
            Compare two <see cref="T:NCDK.IChemObject"/> classes and return the difference as an <see cref="T:NCDK.Tools.Diff.Tree.IDifference"/>.
            </summary>
            <param name="first">the first of the two classes to compare</param>
            <param name="second">the second of the two classes to compare</param>
            <returns>an <see cref="T:NCDK.Tools.Diff.Tree.IDifference"/> representation of the difference between the first and second <see cref="T:NCDK.IChemObject"/>.</returns>
        </member>
        <member name="T:NCDK.Tools.Diff.Tree.ElectronContainerDiff">
            <summary>
            Compares two <see cref="T:NCDK.IChemObject"/> classes.
            </summary>
        </member>
        <member name="M:NCDK.Tools.Diff.Tree.ElectronContainerDiff.#ctor">
            <summary>
            Overwrite the default public constructor because this class is not
            supposed to be instantiated.
            </summary>
        </member>
        <member name="M:NCDK.Tools.Diff.Tree.ElectronContainerDiff.Diff(NCDK.IChemObject,NCDK.IChemObject)">
             <summary>
             Compare two <see cref="T:NCDK.IChemObject"/> classes and return the difference as a <see cref="T:System.String"/>.
            
             <param name="first">the first of the two classes to compare</param>
             <param name="second">the second of the two classes to compare</param>
             <returns>a <see cref="T:System.String"/> representation of the difference between the first and second <see cref="T:NCDK.IChemObject"/>.</returns>
             </summary>
        </member>
        <member name="M:NCDK.Tools.Diff.Tree.ElectronContainerDiff.Difference(NCDK.IChemObject,NCDK.IChemObject)">
             <summary>
             Compare two <see cref="T:NCDK.IChemObject"/> classes and return the difference as an <see cref="T:NCDK.Tools.Diff.Tree.IDifference"/>.
            
             <param name="first">the first of the two classes to compare</param>
             <param name="second">the second of the two classes to compare</param>
             <returns>an <see cref="T:NCDK.Tools.Diff.Tree.IDifference"/> representation of the difference between the first and second <see cref="T:NCDK.IChemObject"/>.</returns>
             </summary>
        </member>
        <member name="T:NCDK.Tools.Diff.Tree.ElementDiff">
            <summary>
            Compares two <see cref="T:NCDK.IElement"/> classes.
            </summary>
        </member>
        <member name="M:NCDK.Tools.Diff.Tree.ElementDiff.#ctor">
            <summary>
            Overwrite the default public constructor because this class is not
            supposed to be instantiated.
            </summary>
        </member>
        <member name="M:NCDK.Tools.Diff.Tree.ElementDiff.Diff(NCDK.IChemObject,NCDK.IChemObject)">
             <summary>
             Compare two <see cref="T:NCDK.IChemObject"/> classes and return the difference as a <see cref="T:System.String"/>.
            
             <param name="first">the first of the two classes to compare</param>
             <param name="second">the second of the two classes to compare</param>
             <returns>a <see cref="T:System.String"/> representation of the difference between the first and second <see cref="T:NCDK.IChemObject"/>.</returns>
             </summary>
        </member>
        <member name="M:NCDK.Tools.Diff.Tree.ElementDiff.Difference(NCDK.IChemObject,NCDK.IChemObject)">
             <summary>
             Compare two <see cref="T:NCDK.IChemObject"/> classes and return the difference as an <see cref="T:NCDK.Tools.Diff.Tree.IDifference"/>.
            
             <param name="first">the first of the two classes to compare</param>
             <param name="second">the second of the two classes to compare</param>
             <returns>an <see cref="T:NCDK.Tools.Diff.Tree.IDifference"/> representation of the difference between the first and second <see cref="T:NCDK.IChemObject"/>.</returns>
             </summary>
        </member>
        <member name="T:NCDK.Tools.Diff.Tree.IsotopeDiff">
            <summary>
            Compares two <see cref="T:NCDK.IIsotope"/> classes.
            </summary>
        </member>
        <member name="M:NCDK.Tools.Diff.Tree.IsotopeDiff.#ctor">
            <summary>
            Overwrite the default public constructor because this class is not
            supposed to be instantiated.
            </summary>
        </member>
        <member name="M:NCDK.Tools.Diff.Tree.IsotopeDiff.Diff(NCDK.IChemObject,NCDK.IChemObject)">
            <summary>
            Compare two <see cref="T:NCDK.IChemObject"/> classes and return the difference as a <see cref="T:System.String"/>.
            </summary>
            <param name="first">the first of the two classes to compare</param>
            <param name="second">the second of the two classes to compare</param>
            <returns>a <see cref="T:System.String"/> representation of the difference between the first and second <see cref="T:NCDK.IChemObject"/>.</returns>
        </member>
        <member name="M:NCDK.Tools.Diff.Tree.IsotopeDiff.Difference(NCDK.IChemObject,NCDK.IChemObject)">
            <summary>
            Compare two <see cref="T:NCDK.IChemObject"/> classes and return the difference as an <see cref="T:NCDK.Tools.Diff.Tree.IDifference"/>.
            </summary>
            <param name="first">the first of the two classes to compare</param>
            <param name="second">the second of the two classes to compare</param>
            <returns>an <see cref="T:NCDK.Tools.Diff.Tree.IDifference"/> representation of the difference between the first and second <see cref="T:NCDK.IChemObject"/>.</returns>
        </member>
        <member name="T:NCDK.Tools.Diff.Tree.AbstractDifference">
            <summary>
            Difference between two IChemObjects.
            </summary>
        </member>
        <member name="T:NCDK.Tools.Diff.Tree.AbstractDifferenceList">
            <summary>
            Diff between two IChemObjects.
            </summary>
        </member>
        <member name="M:NCDK.Tools.Diff.Tree.AbstractDifferenceList.AddChild(NCDK.Tools.Diff.Tree.IDifference)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Tools.Diff.Tree.AbstractDifferenceList.AddChildren(System.Collections.Generic.IEnumerable{NCDK.Tools.Diff.Tree.IDifference})">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Tools.Diff.Tree.AbstractDifferenceList.GetChildren">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Tools.Diff.Tree.AbstractDifferenceList.ChildCount">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Tools.Diff.Tree.AtomTypeHybridizationDifference">
            <summary>
            <see cref="T:NCDK.Tools.Diff.Tree.IDifference"/> between two <see cref="T:NCDK.Hybridization"/>s.
            </summary>
        </member>
        <member name="M:NCDK.Tools.Diff.Tree.AtomTypeHybridizationDifference.Construct(System.String,NCDK.Hybridization,NCDK.Hybridization)">
            <summary>
            Constructs a new <see cref="T:NCDK.Tools.Diff.Tree.IDifference"/> object.
            </summary>
            <param name="name">a name reflecting the nature of the created <see cref="T:NCDK.Tools.Diff.Tree.IDifference"/></param>
            <param name="first">the first object to compare</param>
            <param name="second">the second object to compare</param>
            <returns>an <see cref="T:NCDK.Tools.Diff.Tree.IDifference"/> reflecting the differences between the first and second object</returns>
        </member>
        <member name="M:NCDK.Tools.Diff.Tree.AtomTypeHybridizationDifference.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> representation for this <see cref="T:NCDK.Tools.Diff.Tree.IDifference"/>.
            </summary>
            <returns></returns>
        </member>
        <member name="T:NCDK.Tools.Diff.Tree.BondOrderDifference">
            <summary>
            <see cref="T:NCDK.Tools.Diff.Tree.IDifference"/> between two <see cref="T:NCDK.BondOrder"/>s.
            </summary>
        </member>
        <member name="M:NCDK.Tools.Diff.Tree.BondOrderDifference.Construct(System.String,NCDK.BondOrder,NCDK.BondOrder)">
            <summary>
            Constructs a new <see cref="T:NCDK.Tools.Diff.Tree.IDifference"/> object.
            </summary>
            <param name="name">a name reflecting the nature of the created <see cref="T:NCDK.Tools.Diff.Tree.IDifference"/></param>
            <param name="first">the first object to compare</param>
            <param name="second">the second object to compare</param>
            <returns>an <see cref="T:NCDK.Tools.Diff.Tree.IDifference"/> reflecting the differences between the first and second object</returns>
        </member>
        <member name="M:NCDK.Tools.Diff.Tree.BondOrderDifference.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> representation for this <see cref="T:NCDK.Tools.Diff.Tree.IDifference"/>.
            </summary>
            <returns>a <see cref="T:System.String"/></returns>
        </member>
        <member name="T:NCDK.Tools.Diff.Tree.BooleanArrayDifference">
            <summary>
            Difference between two bool[]'s.
            </summary>
        </member>
        <member name="M:NCDK.Tools.Diff.Tree.BooleanArrayDifference.Construct(System.String,System.Boolean[],System.Boolean[])">
            <summary>
            Constructs a new <see cref="T:NCDK.Tools.Diff.Tree.IDifference"/> object.
            </summary>
            <param name="name">a name reflecting the nature of the created <see cref="T:NCDK.Tools.Diff.Tree.IDifference"/></param>
            <param name="first">the first object to compare</param>
            <param name="second">the second object to compare</param>
            <returns>an <see cref="T:NCDK.Tools.Diff.Tree.IDifference"/> reflecting the differences between the first and second object</returns>
        </member>
        <member name="M:NCDK.Tools.Diff.Tree.BooleanArrayDifference.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> representation for this <see cref="T:NCDK.Tools.Diff.Tree.IDifference"/>.
            </summary>
            <returns>a <see cref="T:System.String"/></returns>
        </member>
        <member name="T:NCDK.Tools.Diff.Tree.BooleanDifference">
            <summary>
            <see cref="T:NCDK.Tools.Diff.Tree.IDifference"/> between two <see cref="T:System.Boolean"/>s.
            </summary>
        </member>
        <member name="M:NCDK.Tools.Diff.Tree.BooleanDifference.Construct(System.String,System.Nullable{System.Boolean},System.Nullable{System.Boolean})">
            <summary>
            Constructs a new <see cref="T:NCDK.Tools.Diff.Tree.IDifference"/> object.
            </summary>
            <param name="name">a name reflecting the nature of the created <see cref="T:NCDK.Tools.Diff.Tree.IDifference"/></param>
            <param name="first">the first object to compare</param>
            <param name="second">the second object to compare</param>
            <returns>an <see cref="T:NCDK.Tools.Diff.Tree.IDifference"/> reflecting the differences between the first and second object</returns>
        </member>
        <member name="M:NCDK.Tools.Diff.Tree.BooleanDifference.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> representation for this <see cref="T:NCDK.Tools.Diff.Tree.IDifference"/>.
            </summary>
            <returns>a <see cref="T:System.String"/></returns>
        </member>
        <member name="T:NCDK.Tools.Diff.Tree.ChemObjectDifference">
            <summary>
            <see cref="T:NCDK.Tools.Diff.Tree.IDifference"/> between two <see cref="T:NCDK.IChemObject"/>s.
            </summary>
        </member>
        <member name="M:NCDK.Tools.Diff.Tree.ChemObjectDifference.ToString">
             <summary>
             Returns a <see cref="T:System.String"/> representation for this <see cref="T:NCDK.Tools.Diff.Tree.IDifference"/>.
            
             <returns>a <see cref="T:System.String"/></returns>
             </summary>
        </member>
        <member name="T:NCDK.Tools.Diff.Tree.DoubleDifference">
            <summary>
            <see cref="T:NCDK.Tools.Diff.Tree.IDifference"/> between two <see cref="T:System.Double"/>.
            </summary>
        </member>
        <member name="M:NCDK.Tools.Diff.Tree.DoubleDifference.Construct(System.String,System.Nullable{System.Double},System.Nullable{System.Double})">
            <summary>
            Constructs a new <see cref="T:NCDK.Tools.Diff.Tree.IDifference"/> object.
            </summary>
            <param name="name">a name reflecting the nature of the created <see cref="T:NCDK.Tools.Diff.Tree.IDifference"/></param>
            <param name="first">the first object to compare</param>
            <param name="second">the second object to compare</param>
            <returns>an <see cref="T:NCDK.Tools.Diff.Tree.IDifference"/> reflecting the differences between the first and second object</returns>
        </member>
        <member name="M:NCDK.Tools.Diff.Tree.DoubleDifference.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> representation for this <see cref="T:NCDK.Tools.Diff.Tree.IDifference"/>.
            </summary>
            <returns>a <see cref="T:System.String"/></returns>
        </member>
        <member name="T:NCDK.Tools.Diff.Tree.IDifference">
            <summary>
            Object that describes the difference between two <see cref="T:System.Object"/>s.
            </summary>
        </member>
        <member name="T:NCDK.Tools.Diff.Tree.IDifferenceList">
            <summary>
            <see cref="T:NCDK.Tools.Diff.Tree.IDifference"/> between two <see cref="T:System.Object"/>s which contains one or more child
            <see cref="T:NCDK.Tools.Diff.Tree.IDifference"/> objects.
            </summary>
        </member>
        <member name="M:NCDK.Tools.Diff.Tree.IDifferenceList.AddChild(NCDK.Tools.Diff.Tree.IDifference)">
             <summary>
             Adds a new <see cref="T:NCDK.Tools.Diff.Tree.IDifference"/> as child to this tree. For example, an <see cref="T:NCDK.IAtom"/> difference
             would have a child difference for <see cref="T:NCDK.Numerics.Vector2"/>.
            
             <param name="childDiff">child <see cref="T:NCDK.Tools.Diff.Tree.IDifference"/> to add to this <see cref="T:NCDK.Tools.Diff.Tree.IDifference"/></param>
             </summary>
        </member>
        <member name="M:NCDK.Tools.Diff.Tree.IDifferenceList.AddChildren(System.Collections.Generic.IEnumerable{NCDK.Tools.Diff.Tree.IDifference})">
             <summary>
             Adds multiple <see cref="T:NCDK.Tools.Diff.Tree.IDifference"/>s as child to this tree.
            
             <param name="children">a <see cref="T:System.Collections.Generic.List`1"/> of <see cref="T:NCDK.Tools.Diff.Tree.IDifference"/>s to add to this <see cref="T:NCDK.Tools.Diff.Tree.IDifference"/></param>
             </summary>
        </member>
        <member name="M:NCDK.Tools.Diff.Tree.IDifferenceList.GetChildren">
            <summary>
            Returns an <see cref="T:System.Collections.Generic.IEnumerable`1"/> of <see cref="T:NCDK.Tools.Diff.Tree.IDifference"/> for all childs of this <see cref="T:NCDK.Tools.Diff.Tree.IDifference"/>.
            </summary>
            <returns>an <see cref="T:System.Collections.Generic.IEnumerable`1"/> implementation with all children</returns>
        </member>
        <member name="M:NCDK.Tools.Diff.Tree.IDifferenceList.ChildCount">
            <summary>
            Returns the number of children of this <see cref="T:NCDK.Tools.Diff.Tree.IDifference"/>.
            </summary>
            <returns>an int reflecting the number of children</returns>
        </member>
        <member name="T:NCDK.Tools.Diff.Tree.IntegerDifference">
            <summary>
            <see cref="T:NCDK.Tools.Diff.Tree.IDifference"/> between two <see cref="T:System.Nullable`1"/> of <see cref="T:System.Int32"/>.
            </summary>
        </member>
        <member name="M:NCDK.Tools.Diff.Tree.IntegerDifference.Construct(System.String,System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <summary>
            Constructs a new <see cref="T:NCDK.Tools.Diff.Tree.IDifference"/> object.
            </summary>
            <param name="name">a name reflecting the nature of the created <see cref="T:NCDK.Tools.Diff.Tree.IDifference"/></param>
            <param name="first">the first object to compare</param>
            <param name="second">the second object to compare</param>
            <returns>an <see cref="T:NCDK.Tools.Diff.Tree.IDifference"/> reflecting the differences between the first and second object</returns>
        </member>
        <member name="M:NCDK.Tools.Diff.Tree.IntegerDifference.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> representation for this <see cref="T:NCDK.Tools.Diff.Tree.IDifference"/>.
            </summary>
        </member>
        <member name="T:NCDK.Tools.Diff.Tree.Point2dDifference">
            <summary>
            Difference between two bool[]'s.
            </summary>
        </member>
        <member name="M:NCDK.Tools.Diff.Tree.Point2dDifference.Construct(System.String,System.Nullable{NCDK.Numerics.Vector2},System.Nullable{NCDK.Numerics.Vector2})">
            <summary>
            Constructs a new <see cref="T:NCDK.Tools.Diff.Tree.IDifference"/> object.
            </summary>
            <param name="name">a name reflecting the nature of the created <see cref="T:NCDK.Tools.Diff.Tree.IDifference"/></param>
            <param name="first">the first object to compare</param>
            <param name="second">the second object to compare</param>
            <returns>an <see cref="T:NCDK.Tools.Diff.Tree.IDifference"/> reflecting the differences between the first and second object</returns>
        </member>
        <member name="M:NCDK.Tools.Diff.Tree.Point2dDifference.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> representation for this <see cref="T:NCDK.Tools.Diff.Tree.IDifference"/>.
            </summary>
            <returns>a <see cref="T:System.String"/></returns>
        </member>
        <member name="T:NCDK.Tools.Diff.Tree.Point3dDifference">
            <summary>
            Difference between two bool[]'s.
            </summary>
        </member>
        <member name="M:NCDK.Tools.Diff.Tree.Point3dDifference.Construct(System.String,System.Nullable{NCDK.Numerics.Vector3},System.Nullable{NCDK.Numerics.Vector3})">
            <summary>
            Constructs a new <see cref="T:NCDK.Tools.Diff.Tree.IDifference"/> object.
            </summary>
            <param name="name">a name reflecting the nature of the created <see cref="T:NCDK.Tools.Diff.Tree.IDifference"/></param>
            <param name="first">the first object to compare</param>
            <param name="second">the second object to compare</param>
            <returns>an <see cref="T:NCDK.Tools.Diff.Tree.IDifference"/> reflecting the differences between the first and second object</returns>
        </member>
        <member name="M:NCDK.Tools.Diff.Tree.Point3dDifference.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> representation for this <see cref="T:NCDK.Tools.Diff.Tree.IDifference"/>.
            </summary>
            <returns>a <see cref="T:System.String"/></returns>
        </member>
        <member name="T:NCDK.Tools.Diff.Tree.StringDifference">
            <summary>
            <see cref="T:NCDK.Tools.Diff.Tree.IDifference"/> between two <see cref="T:System.String"/>.
            </summary>
        </member>
        <member name="M:NCDK.Tools.Diff.Tree.StringDifference.Construct(System.String,System.String,System.String)">
            <summary>
            Constructs a new <see cref="T:NCDK.Tools.Diff.Tree.IDifference"/> object.
            </summary>
            <param name="name">a name reflecting the nature of the created <see cref="T:NCDK.Tools.Diff.Tree.IDifference"/></param>
            <param name="first">the first object to compare</param>
            <param name="second">the second object to compare</param>
            <returns>an <see cref="T:NCDK.Tools.Diff.Tree.IDifference"/> reflecting the differences between the first and second object</returns>
        </member>
        <member name="M:NCDK.Tools.Diff.Tree.StringDifference.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> representation for this <see cref="T:NCDK.Tools.Diff.Tree.IDifference"/>.
            </summary>
        </member>
        <member name="T:NCDK.Tools.Diff.ChemObjectDiff">
            <summary>
            Compares two <see cref="T:NCDK.IChemObject"/> classes.
            </summary>
        </member>
        <member name="M:NCDK.Tools.Diff.ChemObjectDiff.#ctor">
            <summary>
            Overwrite the default public constructor because this class is not
            supposed to be instantiated.
            </summary>
        </member>
        <member name="M:NCDK.Tools.Diff.ChemObjectDiff.Diff(NCDK.IChemObject,NCDK.IChemObject)">
            <summary>
            Compare two <see cref="T:NCDK.IChemObject"/> classes and return the difference as a <see cref="T:System.String"/>.
            </summary>
            <param name="first">the first of the two classes to compare</param>
            <param name="second">the second of the two classes to compare</param>
            <returns>a <see cref="T:System.String"/> representation of the difference between the first and second <see cref="T:NCDK.IChemObject"/>.</returns>
        </member>
        <member name="M:NCDK.Tools.Diff.ChemObjectDiff.Difference(NCDK.IChemObject,NCDK.IChemObject)">
            <summary>
            Compare two <see cref="T:NCDK.IChemObject"/> classes and return the difference as an <see cref="T:NCDK.Tools.Diff.Tree.IDifference"/>.
            </summary>
            <param name="first">the first of the two classes to compare</param>
            <param name="second">the second of the two classes to compare</param>
            <returns>an <see cref="T:NCDK.Tools.Diff.Tree.IDifference"/> representation of the difference between the first and second <see cref="T:NCDK.IChemObject"/>.</returns>
        </member>
        <member name="T:NCDK.Tools.Diff.LonePairDiff">
            <summary>
            Compares two <see cref="T:NCDK.ILonePair"/> classes.
            </summary>
        </member>
        <member name="M:NCDK.Tools.Diff.LonePairDiff.#ctor">
            <summary>
            Overwrite the default public constructor because this class is not
            supposed to be instantiated.
            </summary>
        </member>
        <member name="M:NCDK.Tools.Diff.LonePairDiff.Diff(NCDK.IChemObject,NCDK.IChemObject)">
            <summary>
            Compare two <see cref="T:NCDK.IChemObject"/> classes and return the difference as a <see cref="T:System.String"/>.
            </summary>
            <param name="first">the first of the two classes to compare</param>
            <param name="second">the second of the two classes to compare</param>
            <returns>a <see cref="T:System.String"/> representation of the difference between the first and second <see cref="T:NCDK.IChemObject"/>.</returns>
        </member>
        <member name="M:NCDK.Tools.Diff.LonePairDiff.Difference(NCDK.IChemObject,NCDK.IChemObject)">
            <summary>
            Compare two <see cref="T:NCDK.IChemObject"/> classes and return the difference as an <see cref="T:NCDK.Tools.Diff.Tree.IDifference"/>.
            </summary>
            <param name="first">the first of the two classes to compare</param>
            <param name="second">the second of the two classes to compare</param>
            <returns>an <see cref="T:NCDK.Tools.Diff.Tree.IDifference"/> representation of the difference between the first and second <see cref="T:NCDK.IChemObject"/>.</returns>
        </member>
        <member name="T:NCDK.Tools.Diff.SingleElectronDiff">
            <summary>
            Compares two <see cref="T:NCDK.ISingleElectron"/> classes.
            </summary>
        </member>
        <member name="M:NCDK.Tools.Diff.SingleElectronDiff.#ctor">
            <summary>
            Overwrite the default public constructor because this class is not
            supposed to be instantiated.
            </summary>
        </member>
        <member name="M:NCDK.Tools.Diff.SingleElectronDiff.Diff(NCDK.IChemObject,NCDK.IChemObject)">
            <summary>
            Compare two <see cref="T:NCDK.IChemObject"/> classes and return the difference as a <see cref="T:System.String"/>.
            </summary>
            <param name="first">the first of the two classes to compare</param>
            <param name="second">the second of the two classes to compare</param>
            <returns>a <see cref="T:System.String"/> representation of the difference between the first and second <see cref="T:NCDK.IChemObject"/>.</returns>
        </member>
        <member name="M:NCDK.Tools.Diff.SingleElectronDiff.Difference(NCDK.IChemObject,NCDK.IChemObject)">
            <summary>
            Compare two <see cref="T:NCDK.IChemObject"/> classes and return the difference as an <see cref="T:NCDK.Tools.Diff.Tree.IDifference"/>.
            </summary>
            <param name="first">the first of the two classes to compare</param>
            <param name="second">the second of the two classes to compare</param>
            <returns>an <see cref="T:NCDK.Tools.Diff.Tree.IDifference"/> representation of the difference between the first and second <see cref="T:NCDK.IChemObject"/>.</returns>
        </member>
        <member name="T:NCDK.Tools.AtomTypeTools">
            <summary>
            AtomTypeTools is a helper class for assigning atom types to an atom.
            </summary>
        </member>
        <member name="M:NCDK.Tools.AtomTypeTools.#ctor">
            <summary>
            Constructor for the MMFF94AtomTypeMatcher object.
            </summary>
        </member>
        <member name="M:NCDK.Tools.AtomTypeTools.AssignAtomTypePropertiesToAtom(NCDK.IAtomContainer,System.Boolean)">
            <summary>
             Method assigns certain properties to an atom. Necessary for the atom type matching
             Properties:
             <list type="bullet">
              <item>aromaticity)</item>
              <item>ChemicalGroup (CDKChemicalRingGroupConstant)</item>
              <item>
                <item>SSSR</item>
                <item>Ring/Group, ringSize, aromaticity</item>
                <item>SphericalMatcher (HoSe Code)</item>
              </item>
             </list>
            </summary>
            <param name="molecule"></param>
            <param name="aromaticity">bool true/false true if aromaticity should be calculated</param>
            <returns>sssrf ring set of the molecule</returns>
        </member>
        <member name="M:NCDK.Tools.AtomTypeTools.GetSubgraphSmiles(NCDK.IAtomContainer,NCDK.IAtomContainer)">
            <summary>
            New SMILES code respects atom valency hence a ring subgraph of 'o1cccc1CCCC' is correctly
            written as 'o1ccc[c]1' note there is no hydrogen there since it was an external attachment.
            To get unique subgraph SMILES we need to adjust valencies of atoms by adding Hydrogens. We
            base this on the sum of bond orders removed.
            </summary>
            <param name="subgraph">subgraph (atom and bond refs in 'molecule')</param>
            <param name="molecule">the molecule</param>
            <returns>the canonical smiles of the subgraph</returns>
            <exception cref="T:NCDK.CDKException">something went wrong with SMILES gen</exception>
        </member>
        <member name="M:NCDK.Tools.AtomTypeTools.Cansmi(NCDK.IAtomContainer)">
            <summary>
            Canonical SMILES for the provided molecule.
            </summary>
            <param name="mol">molecule</param>
            <returns>the cansmi string</returns>
            <exception cref="T:NCDK.CDKException">something went wrong with SMILES gen</exception>
        </member>
        <member name="M:NCDK.Tools.AtomTypeTools.RingSystemClassifier(NCDK.IRing,System.String)">
            <summary>
             Identifies ringSystem and returns a number which corresponds to
             CDKChemicalRingConstant
            </summary>
            <param name="ring">Ring class with the ring system</param>
            <param name="smile">smile of the ring system</param>
            <returns>chemicalRingConstant</returns>
        </member>
        <member name="T:NCDK.Tools.AtomicProperties">
            <summary>
            Provides atomic property values for descriptor calculations.
            This class currently provides values for mass, van der Waals volume, electronegativity and polarizability.
            </summary>
        </member>
        <member name="T:NCDK.Tools.CDKUtilities">
            <summary>
            Utility class written by Todd Martin, for help in his QSAR descriptors and SMILES
            parser. Seems to have overlap with, at least, cdk.normalize.Normalizer.
            </summary>
            <para>TODO: merge with Normalizer.</para>
            <seealso cref="T:NCDK.Normalizers.Normalizer"/>
        </member>
        <member name="T:NCDK.Tools.DataFeaturesTool">
            <summary>
            Utility that helps determine which data features are present.
            </summary>
        </member>
        <member name="M:NCDK.Tools.DataFeaturesTool.GetSupportedDataFeatures(NCDK.IAtomContainer)">
            <summary>
            Determines the features present in the given <see cref="T:NCDK.IAtomContainer"/>.
            </summary>
            <param name="molecule">IAtomContainer to determine the features off</param>
            <returns>integer representation of the present features</returns>
        </member>
        <member name="T:NCDK.Tools.ElementComparator">
            <summary>
            Compares elements based on the order commonly used in
            molecular formula. Order:
            C, H, other elements in alphabetic order.
            </summary>
        </member>
        <member name="M:NCDK.Tools.ElementComparator.Compare(System.String,System.String)">
            <summary>
            Returns a negative if o1 comes before o2 in a molecular formula,
            returns zero if they are identical, and positive if o1 comes
            after o2 in the formula.
            </summary>
        </member>
        <member name="T:NCDK.Tools.HOSECodeGenerator">
            <summary>
            Generates HOSE codes <token>cdk-cite-BRE78</token>.
            IMPORTANT: Your molecule must contain implicit or explicit hydrogens
            for this method to work properly.
            </summary>
        </member>
        <member name="F:NCDK.Tools.HOSECodeGenerator.sphereNodes">
            <summary>
            Container for the nodes in a sphere.
            </summary>
        </member>
        <member name="F:NCDK.Tools.HOSECodeGenerator.nextSphereNodes">
            <summary>
            Container for the node in the next sphere assembled in a recursive method
            and then passed to the next recursion to become <see cref="F:NCDK.Tools.HOSECodeGenerator.sphereNodes"/>.
            </summary>
        </member>
        <member name="F:NCDK.Tools.HOSECodeGenerator.sphere">
            <summary>
            Counter for the sphere in which we currently work.
            </summary>
        </member>
        <member name="F:NCDK.Tools.HOSECodeGenerator.maxSphere">
            <summary>
            How many spheres are we supposed inspect.
            </summary>
        </member>
        <member name="F:NCDK.Tools.HOSECodeGenerator.spheres">
            <summary>
            Here we store the spheres that we assemble, in order to parse them into a code later.
            </summary>
        </member>
        <member name="F:NCDK.Tools.HOSECodeGenerator.HOSECode">
            <summary>
            The HOSECode string that we assemble
            </summary>
        </member>
        <member name="F:NCDK.Tools.HOSECodeGenerator.atomContainer">
            <summary>
            The molecular structure on which we work
            </summary>
        </member>
        <member name="F:NCDK.Tools.HOSECodeGenerator.sphereDelimiters">
            <summary>
            Delimiters used to separate spheres in the output string. Bremser uses the
            sequence"(//)" for the first four spheres.
            </summary>
        </member>
        <member name="F:NCDK.Tools.HOSECodeGenerator.bondSymbols">
            <summary>
            The bond symbols used for bond orders "single", "double", "triple" and "aromatic"
            </summary>
        </member>
        <member name="F:NCDK.Tools.HOSECodeGenerator.rankedSymbols">
            <summary>
            The rank order for the given element symbols.
            </summary>
        </member>
        <member name="F:NCDK.Tools.HOSECodeGenerator.symbolRankings">
            <summary>
            The ranking values to be used for the symbols above.
            </summary>
        </member>
        <member name="F:NCDK.Tools.HOSECodeGenerator.bondRankings">
            <summary>
            The bond rankings to be used for the four bond order possibilities.
            </summary>
        </member>
        <member name="M:NCDK.Tools.HOSECodeGenerator.GetSpheres(NCDK.IAtomContainer,NCDK.IAtom,System.Int32,System.Boolean)">
            <summary>
             This method is intended to be used to get the atoms around an atom in spheres. It is not used in this class, but is provided for other classes to use.
             It also creates the HOSE code in HOSECode as a side-effect.
            </summary>
            <param name="ac">The <see cref="T:NCDK.IAtomContainer"/> with the molecular skeleton in which the root atom resides.</param>
            <param name="root">The root atom for which to produce the spheres.</param>
            <param name="noOfSpheres">The number of spheres to look at.</param>
            <param name="ringsize">Shall the center code have the ring size in it? Only use if you want to have the hose code later, else say false.</param>
            <returns> An array <see cref="T:System.Collections.Generic.IList`1"/> of <see cref="T:NCDK.IAtom"/>. The list at i-1 contains the atoms at sphere i as <see cref="T:NCDK.Tools.HOSECodeGenerator.TreeNode"/>s.</returns>
        </member>
        <member name="M:NCDK.Tools.HOSECodeGenerator.GetHOSECode(NCDK.IAtomContainer,NCDK.IAtom,System.Int32)">
            <summary>
            Produces a HOSE code for Atom <paramref name="root"/> in the <see cref="T:NCDK.IAtomContainer"/> <paramref name="ac"/>. The HOSE
            code is produced for the number of spheres given by <paramref name="noOfSpheres"/>.
            IMPORTANT: if you want aromaticity to be included in the code, you need
            to run the <see cref="T:NCDK.IAtomContainer"/> <paramref name="ac"/> to the <see cref="!:CDK.Aromaticities.CDKHueckelAromaticityDetector"/> prior to
            using <see cref="M:NCDK.Tools.HOSECodeGenerator.GetHOSECode(NCDK.IAtomContainer,NCDK.IAtom,System.Int32)"/>. This method only gives proper results if the molecule is
            fully saturated (if not, the order of the HOSE code might depend on atoms in higher spheres).
            This method is known to fail for protons sometimes.
            </summary>
            <remarks>
            <note type="important">
            Your molecule must contain implicit or explicit hydrogens
            for this method to work properly.
            </note>
            </remarks>
            <param name="ac">The <see cref="T:NCDK.IAtomContainer"/> with the molecular skeleton in which the root atom resides</param>
            <param name="root">The root atom for which to produce the HOSE code</param>
            <param name="noOfSpheres">The number of spheres to look at</param>
            <returns>The HOSECode value</returns>
            <exception cref="T:NCDK.CDKException"> Thrown if something is wrong</exception>
        </member>
        <member name="M:NCDK.Tools.HOSECodeGenerator.GetHOSECode(NCDK.IAtomContainer,NCDK.IAtom,System.Int32,System.Boolean)">
            <summary>
            Produces a HOSE code for Atom <paramref name="root"/> in the <see cref="T:NCDK.IAtomContainer"/> <paramref name="ac"/>. The HOSE
            code is produced for the number of spheres given by <paramref name="noOfSpheres"/>.
            IMPORTANT: if you want aromaticity to be included in the code, you need
            to run the <see cref="T:NCDK.IAtomContainer"/> <paramref name="ac"/> to the <see cref="!:CDK.Aromaticities.CDKHueckelAromaticityDetector"/> prior to
            using <see cref="M:NCDK.Tools.HOSECodeGenerator.GetHOSECode(NCDK.IAtomContainer,NCDK.IAtom,System.Int32,System.Boolean)"/>. This method only gives proper results if the molecule is
            fully saturated (if not, the order of the HOSE code might depend on atoms in higher spheres).
            This method is known to fail for protons sometimes.
            IMPORTANT: Your molecule must contain implicit or explicit hydrogens
            for this method to work properly.
            </summary>
            <param name="ac">The IAtomContainer with the molecular skeleton in which the root atom resides</param>
            <param name="root">The root atom for which to produce the HOSE code</param>
            <param name="noOfSpheres">The number of spheres to look at</param>
            <param name="ringsize">The size of the Ring(s) it is in is included in center atom code</param>
            <returns>The HOSECode value</returns>
            <exception cref="T:NCDK.CDKException">Thrown if something is wrong</exception>
        </member>
        <member name="M:NCDK.Tools.HOSECodeGenerator.BreadthFirstSearch(NCDK.IAtom,System.Boolean)">
            <summary>
             Prepares for a breadth first search within the <see cref="T:NCDK.IAtomContainer"/>. The actual
             recursion is done in <see cref="M:NCDK.Tools.HOSECodeGenerator.NextSphere(System.Collections.Generic.List{NCDK.Tools.HOSECodeGenerator.TreeNode})"/>.
            </summary>
            <param name="root">The atom at which we start the search</param>
            <param name="addTreeNode"></param>
            <exception cref="T:NCDK.CDKException"> If something goes wrong.</exception>
        </member>
        <member name="M:NCDK.Tools.HOSECodeGenerator.NextSphere(System.Collections.Generic.List{NCDK.Tools.HOSECodeGenerator.TreeNode})">
            <summary>
            The actual recursion method for our breadth first search. Each node in
            sphereNodes is inspected for its descendants which are then stored in
            <see cref="F:NCDK.Tools.HOSECodeGenerator.nextSphereNodes"/>, which again is passed to the next recursion level of
            <see cref="M:NCDK.Tools.HOSECodeGenerator.NextSphere(System.Collections.Generic.List{NCDK.Tools.HOSECodeGenerator.TreeNode})"/>.
            </summary>
            <param name="sphereNodes">The sphereNodes to be inspected</param>
            <exception cref="T:NCDK.CDKException"> If something goes wrong</exception>
        </member>
        <member name="M:NCDK.Tools.HOSECodeGenerator.CreateCode">
            <summary>
             After recursively having established the spheres and assigning each node an
             appropriate score, we now generate the complete HOSE code.
            </summary>
            <exception cref="T:NCDK.CDKException"> Thrown if something goes wrong</exception>
        </member>
        <member name="M:NCDK.Tools.HOSECodeGenerator.GetSphereCode(System.Collections.Generic.List{NCDK.Tools.HOSECodeGenerator.TreeNode})">
            <summary>
             Generates the string code for a given sphere.
            </summary>
            <param name="sphereNodes">A vector of TreeNodes for which a string code is to be generated</param>
            <returns>The SphereCode value</returns>
            <exception cref="T:NCDK.CDKException"> Thrown if something goes wrong</exception>
        </member>
        <member name="M:NCDK.Tools.HOSECodeGenerator.GetElementRank(System.String)">
            <summary>
            Gets the element rank for a given element symbol as given in Bremser's publication.
            </summary>
            <param name="symbol">The element symbol for which the rank is to be determined</param>
            <returns>The element rank</returns>
        </member>
        <member name="M:NCDK.Tools.HOSECodeGenerator.GetElementSymbol(System.String)">
            <summary>
             Returns the Bremser-compatible symbols for a given element. Silicon, for
             example, is actually "Q". :-)
            </summary>
            <param name="sym">The element symbol to be converted</param>
            <returns>The converted symbol</returns>
        </member>
        <member name="M:NCDK.Tools.HOSECodeGenerator.CalculateNodeScores(System.Collections.Generic.List{NCDK.Tools.HOSECodeGenerator.TreeNode})">
            <summary>
             Determines the ranking score for each node, allowing for a sorting of nodes
             within one sphere.
            </summary>
            <param name="sphereNodes">The nodes for which the score is to be calculated.</param>
            <exception cref="T:NCDK.CDKException"> Thrown if something goes wrong.</exception>
        </member>
        <member name="M:NCDK.Tools.HOSECodeGenerator.SortNodesByScore(System.Collections.Generic.List{NCDK.Tools.HOSECodeGenerator.TreeNode})">
            <summary>
             Sorts the nodes (atoms) in the sphereNode vector according to their score.
             This is used for the essential ranking of nodes in HOSE code sphere.
            </summary>
            <param name="sphereNodes">A vector with sphere nodes to be sorted.</param>
        </member>
        <member name="M:NCDK.Tools.HOSECodeGenerator.FillUpSphereDelimiters">
            <summary>
             If we use less than four sphere, this fills up the code with the missing
             delimiters such that we are compatible with Bremser's HOSE code table.
            </summary>
        </member>
        <member name="M:NCDK.Tools.HOSECodeGenerator.TreeNodeComparator.Compare(NCDK.Tools.HOSECodeGenerator.TreeNode,NCDK.Tools.HOSECodeGenerator.TreeNode)">
             <summary>
            The compare method, compares by canonical label of atoms
             </summary>
             <param name="a">The first TreeNode</param>
             <param name="b">The second TreeNode</param>
             <returns>-1,0,1</returns>
        </member>
        <member name="M:NCDK.Tools.HOSECodeGenerator.TreeNodeComparator.Label(NCDK.Tools.HOSECodeGenerator.TreeNode)">
            <summary>
            Access the canonical label for the given tree node's atom. If any component is null
            then <see cref="F:System.Int64.MinValue"/> is return thus sorting that object in lower order.
            </summary>
            <param name="node">a tree node to get the label from</param>
            <returns>canonical label value</returns>
        </member>
        <member name="T:NCDK.Tools.HOSECodeGenerator.TreeNode">
            <summary>
             Helper class for storing the properties of a node in our breadth first search.
            </summary>
        </member>
        <member name="M:NCDK.Tools.HOSECodeGenerator.TreeNode.#ctor(NCDK.Tools.HOSECodeGenerator,System.String,NCDK.Tools.HOSECodeGenerator.TreeNode,NCDK.IAtom,System.Double,System.Int32,System.Int64)">
            <summary>
            Constructor for the TreeNode object.
            </summary>
            <param name="parent"></param>
            <param name="symbol">The Element symbol of the node</param>
            <param name="source">The preceding node for this node</param>
            <param name="atom">The IAtom object belonging to this node</param>
            <param name="bondType">The bond type by which this node was connect to its predecessor</param>
            <param name="degree">Description of the Parameter</param>
            <param name="score">The score used to rank this node within its sphere.</param>
        </member>
        <member name="M:NCDK.Tools.HOSECodeGenerator.TreeNode.Equals(System.Object)">
            <summary>
            A TreeNode is equal to another TreeNode if it  stands for the same atom object.
            </summary>
            <param name="o">The object that we compare this TreeNode to</param>
            <returns><see langword="true"/>, if the this <see cref="T:NCDK.Tools.HOSECodeGenerator.TreeNode"/>'s atom object equals the one of the other <see cref="T:NCDK.Tools.HOSECodeGenerator.TreeNode"/></returns>
        </member>
        <member name="T:NCDK.Tools.IDCreator">
            <summary>
            Class that provides methods to give unique IDs to ChemObjects.
            Methods are implemented for Atom, Bond, AtomContainer, AtomContainerSet
            and Reaction. It will only create missing IDs. If you want to create new
            IDs for all ChemObjects, you need to delete them first.
            </summary>
        </member>
        <member name="F:NCDK.Tools.IDCreator.SET_UNIQUE_POLICY">
            <summary>
            Old ID generation policy - to generate IDs unique over the entire set
            </summary>
        </member>
        <member name="F:NCDK.Tools.IDCreator.OBJECT_UNIQUE_POLICY">
            <summary>
            New ID generation policy - to generate IDs unique only in a molecule
            </summary>
        </member>
        <member name="F:NCDK.Tools.IDCreator.policy">
            <summary>
            Internal flag identifying the IDs generation policy. The old policy
            is to generate IDs so that in a sequence of several molecules all the
            atoms and bonds will receive the unique IDs even across molecules, i.e.
            in a set of 2 molecules the first atom of the first molecule will be "a1"
            while the first atom of the second molecule will be "aX" where X equals
            to the number of atoms in the first molecule plus 1.
            </summary>
            <remarks>
            The new policy is to keep the singularity of IDs only within a single
            molecule, i.e. in a set of two molecules first atoms of each will be "a1".
            </remarks>
        </member>
        <member name="M:NCDK.Tools.IDCreator.SetIDPolicy(System.Int32)">
            <summary>
            Alters the policy of ID generation. The IDCreator should in any case
            preserve the already existing IDs therefore if one of objects already
            has an ID set, this ID will be skipped in all the cases when attempting to
            generate a new ID value
            <param name="policy">new policy to be used</param>
            <seealso cref="F:NCDK.Tools.IDCreator.OBJECT_UNIQUE_POLICY"/>
            <seealso cref="F:NCDK.Tools.IDCreator.SET_UNIQUE_POLICY"/>
            </summary>
        </member>
        <member name="M:NCDK.Tools.IDCreator.CreateIDs(NCDK.IChemObject)">
            <summary>
            Labels the Atom's and Bond's in the AtomContainer using the a1, a2, b1, b2
            scheme often used in CML. Supports IAtomContainer, IAtomContainerSet,
            IChemFile, IChemModel, IChemSequence, IReaction, IReactionSet,
            and derived interfaces.
            </summary>
            <param name="chemObject">IChemObject to create IDs for.</param>
        </member>
        <member name="M:NCDK.Tools.IDCreator.ReSetCounters">
            <summary>
            Reset the counters so that we keep generating simple IDs within
            single chem object or a set of them
            </summary>
        </member>
        <member name="M:NCDK.Tools.IDCreator.SetId(System.String,System.Int32,NCDK.IChemObject,System.Collections.Generic.IList{System.String})">
            <summary>
            Sets the ID on the object and adds it to the tabu list.
            </summary>
            <param name="prefix"></param>
            <param name="identifier"></param>
            <param name="obj">IChemObject to set the ID for</param>
            <param name="tabuList">Tabu list to add the ID to</param>
        </member>
        <member name="M:NCDK.Tools.IDCreator.CreateIDsForAtomContainer(NCDK.IAtomContainer,System.Collections.Generic.IList{System.String})">
            <summary>
            Labels the Atom's and Bond's in the AtomContainer using the a1, a2, b1, b2
            scheme often used in CML.
            </summary>
            <seealso cref="M:NCDK.Tools.IDCreator.CreateIDs(NCDK.IChemObject)"/>
        </member>
        <member name="M:NCDK.Tools.IDCreator.CreateIDsForAtomContainerSet(NCDK.IChemObjectSet{NCDK.IAtomContainer},System.Collections.Generic.IList{System.String})">
            <summary>
            Labels the Atom's and Bond's in each AtomContainer using the a1, a2, b1, b2
            scheme often used in CML. It will also set id's for all AtomContainers, naming
            them m1, m2, etc.
            It will not the AtomContainerSet itself.
            </summary>
        </member>
        <member name="M:NCDK.Tools.IDCreator.CreateIDsForReaction(NCDK.IReaction,System.Collections.Generic.IList{System.String})">
            <summary>
            Labels the reactants and products in the Reaction m1, m2, etc, and the atoms
            accordingly, when no ID is given.
            </summary>
        </member>
        <member name="T:NCDK.Tools.IDeduceBondOrderTool">
            <summary>
            A common interface for tools that deduce bond orders from connectivity
            and optionally additional information, like number of implicit or
            explicit hydrogens, or hybridization states.
            </summary>
        </member>
        <member name="T:NCDK.Tools.IValencyChecker">
            <summary>
            A common interface for SaturationChecker and ValencyChecker. Mainly created
            to be able to have HydrogenAdder use both.
            </summary>
        </member>
        <member name="T:NCDK.Tools.GridGenerator">
            <summary>
            Generates a Grid of points in 3D space within given boundaries.
            </summary>
        </member>
        <member name="M:NCDK.Tools.GridGenerator.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            </summary>
            <param name="min"></param>
            <param name="max"></param>
            <param name="initialValue">used as initial value for the Grid points</param>
        </member>
        <member name="M:NCDK.Tools.GridGenerator.SetDimension(System.Double,System.Double)">
            <summary>
            Method sets the maximal 3d dimensions to given min and max values.
            </summary>
        </member>
        <member name="M:NCDK.Tools.GridGenerator.SetDimension(System.Double[],System.Boolean)">
            <summary>
            Method sets the maximal 3d dimensions to given min and max values.
            </summary>
        </member>
        <member name="M:NCDK.Tools.GridGenerator.SetDimension(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Method sets the maximal 3d dimensions to given min and max values.
            </summary>
        </member>
        <member name="M:NCDK.Tools.GridGenerator.GenerateGrid">
            <summary>
            Main method creates a Grid between given boundaries (dimensions).
            The Grid my be extended over the given boundaries with the
            variable ExtendGrid.
            </summary>
        </member>
        <member name="M:NCDK.Tools.GridGenerator.InitializeGrid(System.Double)">
            <summary>
            Method initialise the given Grid points with a value.
            </summary>
        </member>
        <member name="M:NCDK.Tools.GridGenerator.InitializeGrid(System.Double[][][],System.Double)">
            <summary>
            Method initialise the given Grid points with a value.
            </summary>
        </member>
        <member name="M:NCDK.Tools.GridGenerator.GridToGridArray(System.Double[][][])">
            <summary>
            Method transforms the Grid to an array.
            </summary>
        </member>
        <member name="M:NCDK.Tools.GridGenerator.GetCoordinatesFromGridPoint(NCDK.Numerics.Vector3)">
            <summary>
            Method calculates coordinates from a given Grid point.
            </summary>
        </member>
        <member name="M:NCDK.Tools.GridGenerator.GetCoordinatesFromGridPoint(System.Int32)">
            <summary>
            Method calculates coordinates from a given Grid array position.
            </summary>
        </member>
        <member name="M:NCDK.Tools.GridGenerator.GetGridPointFrom3dCoordinates(NCDK.Numerics.Vector3)">
            <summary>
            Method calculates the nearest Grid point from given coordinates.
            </summary>
        </member>
        <member name="M:NCDK.Tools.GridGenerator.WriteGridInPmeshFormat(System.String)">
            <summary>
            Method transforms the Grid into pmesh format.
            </summary>
        </member>
        <member name="M:NCDK.Tools.GridGenerator.WriteGridInPmeshFormat(System.String,System.Double)">
            <summary>
            Method transforms the Grid into pmesh format. Only Grid points
            with specific value defined with cutoff are considered.
            <para>
            cutoff &lt; 0, the values considered must be &lt;=cutoff
            cutoff &gt; 0, the values considered must be &gt;=cutoff
            </para>
            </summary>
        </member>
        <member name="T:NCDK.Tools.HOSECodeAnalyser">
            <summary>
            Analyses a molecular formula given in string format and builds
            an AtomContainer with the Atoms in the molecular formula.
            </summary>
            <remarks>
            About implicit H handling: By default the methods to calculate formula, natural and canonical mass
            use the explicit Hs and only the explicit Hs if there is at least one in the molecule, implicit Hs are
            ignored. If there is no explicit H and only then the implicit Hs are used. If you use the constructor
            MFAnalyser(IAtomContainer ac, bool useboth) and set useboth to true, all explicit Hs and all implicit Hs are used,
            the implicit ones also on atoms with explicit Hs.
            </remarks>
        </member>
        <member name="T:NCDK.Tools.LonePairElectronChecker">
            <summary>
            Provides methods for checking whether an atoms lone pair electrons are saturated
            with respect to a particular atom type.
            </summary>
        </member>
        <member name="M:NCDK.Tools.LonePairElectronChecker.IsSaturated(NCDK.IAtomContainer)">
            <summary>
            Determines of all atoms on the AtomContainer have the
            right number the lone pair electrons.
            </summary>
        </member>
        <member name="M:NCDK.Tools.LonePairElectronChecker.AllSaturated(NCDK.IAtomContainer)">
            <summary>
            Determines of all atoms on the AtomContainer have
            the right number the lone pair electrons.
            </summary>
        </member>
        <member name="M:NCDK.Tools.LonePairElectronChecker.IsSaturated(NCDK.IAtom,NCDK.IAtomContainer)">
            <summary>
            Checks if an Atom is saturated their lone pair electrons
            by comparing it with known AtomTypes.
            </summary>
            <returns>True, if it's right saturated</returns>
        </member>
        <member name="M:NCDK.Tools.LonePairElectronChecker.Saturate(NCDK.IAtomContainer)">
            <summary>
            Saturates a molecule by setting appropriate number lone pair electrons.
            </summary>
        </member>
        <member name="M:NCDK.Tools.LonePairElectronChecker.Saturate(NCDK.IAtom,NCDK.IAtomContainer)">
            <summary>
            Saturates an IAtom by adding the appropriate number lone pairs.
            </summary>
        </member>
        <member name="T:NCDK.Tools.ProteinBuilderTool">
            <summary>
            Class that facilitates building protein structures. Building DNA and RNA
            is done by a complementary class <see cref="!:NucleicAcidBuilderTool"/> (to be
            written).
            </summary>
        </member>
        <member name="M:NCDK.Tools.ProteinBuilderTool.AddAminoAcidAtNTerminus(NCDK.IBioPolymer,NCDK.IAminoAcid,NCDK.IStrand,NCDK.IAminoAcid)">
            <summary>
            Builds a protein by connecting a new amino acid at the N-terminus of the
            given strand.
            </summary>
            <param name="protein">protein to which the strand belongs</param>
            <param name="aaToAdd">amino acid to add to the strand of the protein</param>
            <param name="strand">strand to which the protein is added</param>
            <param name="aaToAddTo"></param>
        </member>
        <member name="M:NCDK.Tools.ProteinBuilderTool.AddAminoAcidAtCTerminus(NCDK.IBioPolymer,NCDK.IAminoAcid,NCDK.IStrand,NCDK.IAminoAcid)">
            <summary>
            Builds a protein by connecting a new amino acid at the C-terminus of the
            given strand. The acidic oxygen of the added amino acid is removed so that
            additional amino acids can be added savely. But this also means that you
            might want to add an oxygen at the end of the protein building!
            </summary>
            <param name="protein">protein to which the strand belongs</param>
            <param name="aaToAdd">amino acid to add to the strand of the protein</param>
            <param name="strand">strand to which the protein is added</param>
            <param name="aaToAddTo"></param>
        </member>
        <member name="M:NCDK.Tools.ProteinBuilderTool.CreateProtein(System.String)">
            <summary>
            Creates a BioPolymer from a sequence of amino acid as identified by a
            the sequence of their one letter codes. It uses the <see cref="T:NCDK.Default.ChemObjectBuilder"/> 
            to create a data model.
            </summary>
            <example>
            For example:
            <code>
            IBioPolymer protein = ProteinBuilderTool.CreateProtein("GAGA");
            </code>
            </example>
            <seealso cref="M:NCDK.Tools.ProteinBuilderTool.CreateProtein(System.String)"/>
        </member>
        <member name="M:NCDK.Tools.ProteinBuilderTool.CreateProtein(System.String,NCDK.IChemObjectBuilder)">
            <summary>
            Creates a BioPolymer from a sequence of amino acid as identified by a
            the sequence of their one letter codes. It uses the given <see cref="T:NCDK.IChemObjectBuilder"/>
            to create a data model.
            </summary>
            <example>
            For example:
            <code>
            IBioPolymer protein = ProteinBuilderTool.CreateProtein(
                "GAGA", Silent.ChemObjectBuilder.Instance
            );
            </code>
            </example>
            <seealso cref="M:NCDK.Tools.ProteinBuilderTool.CreateProtein(System.String)"/>
        </member>
        <member name="T:NCDK.Tools.SaturationChecker">
            <summary>
            Provides methods for checking whether an atoms valences are saturated with
            respect to a particular atom type.
            </summary>
            <remarks>
            Important: this class does not deal with hybridization states, which makes
            it fail, for example, for situations where bonds are marked as aromatic (either
            1.5 or single an Aromatic).</remarks>
        </member>
        <member name="M:NCDK.Tools.SaturationChecker.GetAtomTypeFactory(NCDK.IChemObjectBuilder)">
            <summary>
            </summary>
            <param name="builder">the ChemObjectBuilder implementation used to construct the AtomType's.</param>
        </member>
        <member name="M:NCDK.Tools.SaturationChecker.IsSaturated(NCDK.IAtomContainer)">
            <summary>
            Determines of all atoms on the AtomContainer are saturated.
            </summary>
        </member>
        <member name="M:NCDK.Tools.SaturationChecker.IsUnsaturated(NCDK.IBond,NCDK.IAtomContainer)">
            <summary>
            Returns whether a bond is unsaturated. A bond is unsaturated if
            <b>both</b> Atoms in the bond are unsaturated.
            </summary>
        </member>
        <member name="M:NCDK.Tools.SaturationChecker.IsSaturated(NCDK.IBond,NCDK.IAtomContainer)">
            <summary>
            Returns whether a bond is saturated. A bond is saturated if
            <b>both</b> Atoms in the bond are saturated.
            </summary>
        </member>
        <member name="M:NCDK.Tools.SaturationChecker.IsSaturated(NCDK.IAtom,NCDK.IAtomContainer)">
            <summary>
            Checks whether an Atom is saturated by comparing it with known AtomTypes.
            </summary>
        </member>
        <member name="M:NCDK.Tools.SaturationChecker.IsOverSaturated(NCDK.IAtom,NCDK.IAtomContainer)">
            <summary>
            Checks if the current atom has exceeded its bond order sum value.
            </summary>
            <param name="atom">The Atom to check</param>
            <param name="ac">The atomcontainer context</param>
            <returns>oversaturated or not</returns>
        </member>
        <member name="M:NCDK.Tools.SaturationChecker.GetCurrentMaxBondOrder(NCDK.IAtom,NCDK.IAtomContainer)">
            <summary>
            Returns the currently maximum formable bond order for this atom.
            </summary>
            <param name="atom">The atom to be checked</param>
            <param name="ac">The AtomContainer that provides the context</param>
            <returns>the currently maximum formable bond order for this atom</returns>
        </member>
        <member name="M:NCDK.Tools.SaturationChecker.Unsaturate(NCDK.IAtomContainer)">
            <summary>
            Resets the bond orders of all atoms to 1.0.
            </summary>
        </member>
        <member name="M:NCDK.Tools.SaturationChecker.UnsaturateBonds(NCDK.IAtomContainer)">
            <summary>
            Resets the bond order of the Bond to 1.0.
            </summary>
        </member>
        <member name="M:NCDK.Tools.SaturationChecker.NewSaturate(NCDK.IAtomContainer)">
            <summary>
            Saturates a molecule by setting appropriate bond orders.
            This method is known to fail, especially on pyrolle-like compounds.
            Consider using import org.openscience.cdk.smiles.DeduceBondSystemTool, which should work better
            </summary>
        </member>
        <member name="M:NCDK.Tools.SaturationChecker.NewSaturate(NCDK.IBond[],NCDK.IAtomContainer)">
            <summary>
            Saturates a set of Bonds in an AtomContainer.
            This method is known to fail, especially on pyrolle-like compounds.
            Consider using import org.openscience.cdk.smiles.DeduceBondSystemTool, which should work better
            </summary>
        </member>
        <member name="M:NCDK.Tools.SaturationChecker.NewSaturate(NCDK.IBond,NCDK.IAtomContainer)">
            <summary>
            Saturate atom by adjusting its bond orders.
            This method is known to fail, especially on pyrolle-like compounds.
            Consider using import org.openscience.cdk.smiles.DeduceBondSystemTool, which should work better
            </summary>
        </member>
        <member name="M:NCDK.Tools.SaturationChecker.CouldMatchAtomType(NCDK.IAtomContainer,NCDK.IAtom,NCDK.IAtomType)">
            <summary>
            Determines if the atom can be of type AtomType.
            </summary>
        </member>
        <member name="M:NCDK.Tools.SaturationChecker.Saturate(NCDK.IAtomContainer)">
            <summary>
            The method is known to fail for certain compounds. For more information, see
            cdk.test.limitations package.
            This method is known to fail, especially on pyrolle-like compounds.
            Consider using import org.openscience.cdk.smiles.DeduceBondSystemTool, which should work better
            </summary>
        </member>
        <member name="M:NCDK.Tools.SaturationChecker.CalculateNumberOfImplicitHydrogens(NCDK.IAtom,NCDK.IAtomContainer)">
            <summary>
            Calculate the number of missing hydrogens by subtracting the number of
            bonds for the atom from the expected number of bonds. Charges are included
            in the calculation. The number of expected bonds is defined by the AtomType
            generated with the AtomTypeFactory.
            </summary>
            <param name="atom">Description of the Parameter</param>
            <param name="container">Description of the Parameter</param>
            <returns>Description of the Return Value</returns>
            <seealso cref="T:NCDK.Config.AtomTypeFactory"/>
        </member>
        <member name="M:NCDK.Tools.SaturationChecker.CalculateNumberOfImplicitHydrogens(NCDK.IAtom,System.Double,System.Double,System.Collections.Generic.IEnumerable{NCDK.IBond},System.Boolean)">
            <summary>
            Calculate the number of missing hydrogens by subtracting the number of
            bonds for the atom from the expected number of bonds. Charges are included
            in the calculation. The number of expected bonds is defined by the AtomType
            generated with the AtomTypeFactory.
            </summary>
            <param name="atom">Description of the Parameter</param>
            <param name="bondOrderSum"></param>
            <param name="singleElectronSum"></param>
            <param name="connectedBonds"></param>
            <param name="throwExceptionForUnknowAtom">Should an exception be thrown if an unknown atomtype is found or 0 returned ?</param>
            <returns>Description of the Return Value</returns>
            <seealso cref="T:NCDK.Config.AtomTypeFactory"/>
        </member>
        <member name="T:NCDK.Tools.SmilesValencyChecker">
            <summary>
            Small customization of ValencyHybridChecker suggested by Todd Martin
            specially tuned for SMILES parsing.
            </summary>
        </member>
        <member name="M:NCDK.Tools.SmilesValencyChecker.Saturate(NCDK.IAtomContainer)">
            <summary>
            Saturates a molecule by setting appropriate bond orders.
            </summary>
        </member>
        <member name="M:NCDK.Tools.SmilesValencyChecker.Saturate(NCDK.IBond[],NCDK.IAtomContainer)">
            <summary>
            Saturates a set of Bonds in an AtomContainer.
            </summary>
        </member>
        <member name="M:NCDK.Tools.SmilesValencyChecker.IsUnsaturated(NCDK.IBond,NCDK.IAtomContainer)">
            <summary>
            Returns whether a bond is unsaturated. A bond is unsaturated if
            <b>all</b> Atoms in the bond are unsaturated.
            </summary>
        </member>
        <member name="M:NCDK.Tools.SmilesValencyChecker.SaturateByIncreasingBondOrder(NCDK.IBond,NCDK.IAtomContainer)">
            <summary>
            Tries to saturate a bond by increasing its bond orders by 1.0.
            </summary>
            <returns>true if the bond could be increased</returns>
        </member>
        <member name="M:NCDK.Tools.SmilesValencyChecker.IsSaturated(NCDK.IBond,NCDK.IAtomContainer)">
            <summary>
            Returns whether a bond is saturated. A bond is saturated if
            <b>both</b> Atoms in the bond are saturated.
            </summary>
        </member>
        <member name="M:NCDK.Tools.SmilesValencyChecker.IsSaturated(NCDK.IAtomContainer)">
            <summary>
            Determines of all atoms on the AtomContainer are saturated.
            </summary>
        </member>
        <member name="M:NCDK.Tools.SmilesValencyChecker.CouldMatchAtomType(NCDK.IAtom,System.Double,NCDK.BondOrder,NCDK.IAtomType)">
            <summary>
            Determines if the atom can be of type AtomType. That is, it sees if this
            AtomType only differs in bond orders, or implicit hydrogen count.
            </summary>
        </member>
        <member name="M:NCDK.Tools.SmilesValencyChecker.CalculateNumberOfImplicitHydrogens(NCDK.IAtom,System.Double,NCDK.BondOrder,System.Int32)">
            <summary>
            Calculates the number of hydrogens that can be added to the given atom to fullfil
            the atom's valency. It will return 0 for PseudoAtoms, and for atoms for which it
            does not have an entry in the configuration file.
            </summary>
        </member>
        <member name="M:NCDK.Tools.SmilesValencyChecker.IsSaturated(NCDK.IAtom,NCDK.IAtomContainer)">
            <summary>
            Checks whether an Atom is saturated by comparing it with known AtomTypes.
            It returns true if the atom is an PseudoAtom and when the element is not in the list.
            </summary>
        </member>
        <member name="M:NCDK.Tools.SmilesValencyChecker.CouldMatchAtomType(NCDK.IAtomContainer,NCDK.IAtom,NCDK.IAtomType)">
            <summary>
            Determines if the atom can be of type AtomType.
            </summary>
        </member>
        <member name="T:NCDK.Tools.StructureResonanceGenerator">
             <summary>
             This class try to generate resonance structure for a determinate molecule.
             </summary>
             <remarks>
             <para>Make sure that the molecule has the corresponding lone pair electrons
             for each atom. You can use the method: <see cref="T:NCDK.Tools.LonePairElectronChecker" />
             </para>
             <para>It is needed to call the addExplicitHydrogensToSatisfyValency  
              from the class <see cref="T:NCDK.Tools.CDKHydrogenAdder" />.</para>
             <para>It is based on rearrangements of electrons and charge</para>
             <para>The method is based on call by reactions which occur in a resonance.</para>
            
             <code>            StructureResonanceGenerator sRG = new StructureResonanceGenerator();
            IChemObjectSet&lt;IAtomContainer&gt; setOf = sRG.GetContainers(molecule);
</code>
            
             <para>We have the possibility to localize the reactive center. Good method if you
             want to localize the reaction in a fixed point</para>
             <code>            molecule.Atoms[0].IsReactiveCenter = true;
</code>
             <para>Moreover you must put the parameter as true</para>
             <para>If the reactive center is not localized then the reaction process will
             try to find automatically the possible reactive center.</para>
             </remarks>
             <seealso cref="T:NCDK.Reactions.IReactionProcess" />
        </member>
        <member name="F:NCDK.Tools.StructureResonanceGenerator.lookingSymmetry">
            <summary>Generate resonance structure without looking at the symmetry</summary>
        </member>
        <member name="M:NCDK.Tools.StructureResonanceGenerator.#ctor">
            <summary>
            Construct an instance of StructureResonanceGenerator. Default restrictions
            are initiated.
            </summary>
            <seealso cref="M:NCDK.Tools.StructureResonanceGenerator.SetDefaultReactions"/>
        </member>
        <member name="M:NCDK.Tools.StructureResonanceGenerator.#ctor(System.Boolean)">
            <summary>
            Construct an instance of StructureResonanceGenerator. Default restrictions
            are initiated.
            </summary>
            <param name="lookingSymmetry">Specify if the resonance generation is based looking at the symmetry</param>
            <seealso cref="M:NCDK.Tools.StructureResonanceGenerator.SetDefaultReactions"/>
        </member>
        <member name="P:NCDK.Tools.StructureResonanceGenerator.Reactions">
            <summary>
             The reactions that must be used in the generation of the resonance.
            </summary>
            <seealso cref="T:NCDK.Reactions.IReactionProcess"/>
        </member>
        <member name="P:NCDK.Tools.StructureResonanceGenerator.MaximalStructures">
            <summary>
            The number maximal of resonance structures to be found. The
            algorithm breaks the process when is came to this number.
            </summary>
        </member>
        <member name="M:NCDK.Tools.StructureResonanceGenerator.SetDefaultReactions">
            <summary>
            Set the default reactions that must be presents to generate the resonance.
            </summary>
            <seealso cref="P:NCDK.Tools.StructureResonanceGenerator.Reactions"/>
        </member>
        <member name="M:NCDK.Tools.StructureResonanceGenerator.GetStructures(NCDK.IAtomContainer)">
            <summary>
            Get the resonance structures from an <see cref="T:NCDK.IAtomContainer"/>.
            </summary>
            <param name="molecule">The IAtomContainer to analyze</param>
            <returns>The different resonance structures</returns>
        </member>
        <member name="M:NCDK.Tools.StructureResonanceGenerator.GetContainers(NCDK.IAtomContainer)">
            <summary>
            Get the container which is found resonance from a <see cref="T:NCDK.IAtomContainer"/>.
            It is based on looking if the order of the bond changes.
            </summary>
            <param name="molecule">The IAtomContainer to analyze</param>
            <returns>The different containers</returns>
        </member>
        <member name="M:NCDK.Tools.StructureResonanceGenerator.GetContainer(NCDK.IAtomContainer,NCDK.IAtom)">
            <summary>
            Get the container which the atom is found on resonance from a <see cref="T:NCDK.IAtomContainer"/>.
            It is based on looking if the order of the bond changes. Return null
            is any is found.
            </summary>
            <param name="molecule">The IAtomContainer to analyze</param>
            <param name="atom">The IAtom</param>
            <returns>The container with the atom</returns>
        </member>
        <member name="M:NCDK.Tools.StructureResonanceGenerator.GetContainer(NCDK.IAtomContainer,NCDK.IBond)">
            <summary>
            Get the container which the bond is found on resonance from a <see cref="T:NCDK.IAtomContainer"/>.
            It is based on looking if the order of the bond changes. Return null
            is any is found.
            </summary>
            <param name="molecule">The IAtomContainer to analyze</param>
            <param name="bond">The IBond</param>
            <returns>The container with the bond</returns>
        </member>
        <member name="M:NCDK.Tools.StructureResonanceGenerator.ExistAC(NCDK.IChemObjectSet{NCDK.IAtomContainer},NCDK.IAtomContainer)">
            <summary>
            Search if the setOfAtomContainer contains the atomContainer
            </summary>
            <param name="set">ISetOfAtomContainer object where to search</param>
            <param name="atomContainer">IAtomContainer to search</param>
            <returns>True, if the atomContainer is contained</returns>
        </member>
        <member name="T:NCDK.IChemObjectListener">
            <summary>
            Classes implementing this interface must implement this method
            such that they react appropriately to changes in the object they
            are interested in.
            </summary>
        </member>
        <member name="M:NCDK.IChemObjectListener.OnStateChanged(NCDK.ChemObjectChangeEventArgs)">
            <summary>
            Called by objects to notify objects that implemented this interface
            and registered with them as ChemObjectListeners.
            </summary>
            <param name="event">a ChemObjectChangeEvent object</param>
        </member>
        <member name="T:NCDK.IChemObjectBuilder">
            <summary>
            A helper class to instantiate a <see cref="T:NCDK.ICDKObject"/> instance for a specific implementation.
            </summary>
        </member>
        <member name="T:NCDK.RingSearches.RingSearch">
            <summary>
            Efficiently search for atoms that are members of a ring. A depth first search
            (DFS) determines which vertices belong to cycles (rings). As cycles are
            discovered they are separated into two sets of cycle systems, fused and
            isolated. A ring is in a fused cycle systems if it shares at least one edge
            (bond) with another cycle. The isolated cycles consist of cycles which at
            most share only one vertex (atom) with another cyclic system. A molecule may
            contain more then one isolated and/or fused cycle system (see. Examples).
            Additional computations such as C<sub>R</sub> (relevant cycles), Minimum
            Cycle Basis (MCB) (aka. Smallest Set of Smallest Rings (SSSR)) or the Set of
            All Rings can be completely bypassed for members of the isolated rings. Since
            every isolated cycle (ring) does not share any edges (bonds) with any other
            elementary cycle it cannot be made by composing any other cycles (rings).
            Therefore, all isolated cycles (rings) are relevant and are members of all
            minimum cycle bases (SSSRs). 
            <note type="important">The cycle sets returned are not ordered in the path of the cycle.</note> 
            </summary>
            <remarks>
            <para>Further Explanation</para> 
            <para>The diagram below illustrates the isolated
            and fused sets of cyclic atoms. The colored circles indicate the atoms and
            bonds that are returned for each molecules.
            </para>
            <para>
            <img alt="isolated and fused cycle systems" src="http://i56.photobucket.com/albums/g187/johnymay/isolated-and-fused-cycles-01_zpse0311377.png" />
            </para>
            <list type="bullet">
            <item>Two separate isolated cycles</item> <item>Two
            separate fused cycle systems. The bridged systems are fused but separate from
            each other</item> <item>Fused rings - a single fused cycle system</item> <item>Spiro
            rings - three separate isolated systems, no bonds are shared</item>
            <item>Cyclophane - a single fused system, the perimeter rings share bonds with
            the smaller rings </item> <item>One isolated system and one fused system</item>
            </list>
            </remarks>
            <example>
            <!-- No matching elements were found for the following include tag --><include file="IncludeExamples.xml" path="Comments/Codes[@id=&quot;NCDK.RingSearches.RinSearch_Example.cs&quot;]/*" />
            </example>
            <seealso href="http://en.wikipedia.org/wiki/Cycle_(graph_theory)">Cycle (Graph Theory) - Wikipedia</seealso>
            <seealso href="http://efficientbits.blogspot.co.uk/2012/12/scaling-up-faster-ring-detection-in-cdk.html">Scaling Up: Faster Ring Detecting in CDK - Efficient Bits, Blog</seealso>
            <seealso cref="T:NCDK.Graphs.SpanningTree" />
            <seealso cref="T:NCDK.RingSearches.AllRingsFinder" />
            <seealso cref="T:NCDK.RingSearches.CyclicVertexSearch" />
        </member>
        <member name="F:NCDK.RingSearches.RingSearch.searcher">
            <summary>depending on molecule size, delegate the search to one of two sub-classes</summary>
        </member>
        <member name="F:NCDK.RingSearches.RingSearch.container">
            <summary>input atom container</summary>
        </member>
        <member name="M:NCDK.RingSearches.RingSearch.#ctor(NCDK.IAtomContainer)">
            <summary>
            Create a new RingSearch for the specified container.
            </summary>
            <param name="container">non-null input structure</param>
            <exception cref="T:System.ArgumentNullException">if the container was null</exception>
            <exception cref="T:System.ArgumentException">if the container contains a bond which references an atom which could not be found</exception>
        </member>
        <member name="M:NCDK.RingSearches.RingSearch.#ctor(NCDK.IAtomContainer,System.Int32[][])">
            <summary>
            Create a new RingSearch for the specified container and graph. The
            adjacency list allows much faster graph traversal but is not free to
            create. If the adjacency list representation of the input container has
            already been created you can bypass the creation with this constructor.
            </summary>
            <param name="container">non-null input structure</param>
            <param name="graph">non-null adjacency list representation of the container</param>
            <exception cref="T:System.ArgumentNullException">if the container or graph was null</exception>
        </member>
        <member name="M:NCDK.RingSearches.RingSearch.#ctor(NCDK.IAtomContainer,NCDK.RingSearches.CyclicVertexSearch)">
            <summary>
            Create a new RingSearch for the specified container using the provided
            search.
            </summary>
            <param name="container">non-null input structure</param>
            <param name="searcher">non-null adjacency list representation of the container</param>
            <exception cref="T:System.ArgumentNullException">if the container or graph was null</exception>
        </member>
        <member name="M:NCDK.RingSearches.RingSearch.MakeSearcher(System.Int32[][])">
            <summary>
            Utility method making a new <see cref="T:NCDK.RingSearches.CyclicVertexSearch"/> during
            construction.
            </summary>
            <param name="graph">non-null graph</param>
            <returns>a new cyclic vertex search for the given graph</returns>
            <exception cref="T:System.ArgumentNullException">if the graph was null</exception>
        </member>
        <member name="P:NCDK.RingSearches.RingSearch.NumRings">
            <summary>
            Access the number of rings found (aka. circuit rank, SSSR size).
            </summary>
            <returns>number of rings</returns>
            <seealso href="https://en.wikipedia.org/wiki/Circuit_rank">Circuit Rank</seealso>
        </member>
        <member name="M:NCDK.RingSearches.RingSearch.Cyclic(System.Int32,System.Int32)">
            <summary>
            Determine whether the edge between the vertices <paramref name="u"/> and <paramref name="v"/> is
            cyclic.
            </summary>
            <param name="u">an end point of the edge</param>
            <param name="v">another end point of the edge</param>
            <returns>whether the edge formed by the given end points is in a cycle</returns>
        </member>
        <member name="M:NCDK.RingSearches.RingSearch.Cyclic(NCDK.IAtom)">
            <summary>
            Determine whether the provided atom belongs to a ring (is cyclic).
            </summary>
            <example>
            <code>                IAtomContainer mol = TestMoleculeFactory.MakeAlphaPinene();
                RingSearch ringSearch = new RingSearch(mol);
                foreach (var atom in mol.Atoms)
                {
                    if (ringSearch.Cyclic(atom))
                    {
                        // ...
                    }
                }
</code>
            </example>
            <param name="atom">an atom</param>
            <returns>whether the atom is in a ring</returns>
            <exception cref="T:NCDK.NoSuchAtomException">the atom was not found</exception>
        </member>
        <member name="M:NCDK.RingSearches.RingSearch.Cyclic(NCDK.IBond)">
            <summary>
            Determine whether the bond is cyclic. Note this currently requires a
            linear search to look-up the indices of each atoms.
            </summary>
            <param name="bond">a bond of the container</param>
            <returns>whether the vertex at the given index is in a cycle</returns>
        </member>
        <member name="M:NCDK.RingSearches.RingSearch.Cyclic(System.Int32)">
            <summary>
            Determine whether the vertex at index <paramref name="i" /> is a cyclic vertex.
            </summary>
            <example>
            <code>                IAtomContainer mol = TestMoleculeFactory.MakeAlphaPinene();
                RingSearch tester = new RingSearch(mol);

                int n = mol.Atoms.Count;
                for (int i = 0; i &lt; n; i++)
                {
                    if (tester.Cyclic(i))
                    {
                        // ...
                    }
                }
</code>
            </example>
            <param name="i">atom index</param>
            <returns>whether the vertex at the given index is in a cycle</returns>
        </member>
        <member name="M:NCDK.RingSearches.RingSearch.Cyclic">
            <summary>
            Construct a set of vertices which belong to any cycle (ring).
            </summary>
            <returns>cyclic vertices</returns>
        </member>
        <member name="M:NCDK.RingSearches.RingSearch.Isolated">
            <summary>
            Construct the sets of vertices which belong to isolated rings.
            </summary>
            <example>
            <code>                IAtomContainer biphenyl = TestMoleculeFactory.MakeBiphenyl();
                RingSearch ringSearch = new RingSearch(biphenyl);

                int[][] isolated = ringSearch.Isolated();
                Console.WriteLine(isolated.Length); // 2 isolated rings in biphenyl
                Console.WriteLine(isolated[0].Length); // 6 vertices in one benzene
                Console.WriteLine(isolated[1].Length); // 6 vertices in the other benzene
</code>
            </example>
            <returns>array of isolated fragments, defined by the vertices in the fragment</returns>
        </member>
        <member name="M:NCDK.RingSearches.RingSearch.Fused">
            <summary>
            Construct the sets of vertices which belong to fused ring systems.
            </summary>
            <example>
            <code>                IAtomContainer mol = new Smiles.SmilesParser(Default.ChemObjectBuilder.Instance).ParseSmiles("c1cc(cc2cc(ccc12)C3C4CC34)C6CC5CCC6(C5)");
                RingSearch ringSearch = new RingSearch(mol);
                
                int[][] fused = ringSearch.Fused();
                Console.WriteLine(fused.Length); // e.g. 3 separate fused ring systems
                Console.WriteLine(fused[0].Length); // e.g. 10 vertices in the first system
                Console.WriteLine(fused[1].Length); // e.g. 4 vertices in the second system
                Console.WriteLine(fused[2].Length); // e.g. 7 vertices in the third system
</code>
            </example>
            <returns>array of fused fragments, defined by the vertices in the fragment</returns>
        </member>
        <member name="M:NCDK.RingSearches.RingSearch.RingFragments">
            <summary>
            Extract the cyclic atom and bond fragments of the container. Bonds which
            join two different isolated/fused cycles (e.g. biphenyl) are not be
            included.
            </summary>
            <returns>a new container with only the cyclic atoms and bonds</returns>
            <seealso cref="M:NCDK.Graphs.SpanningTree.GetCyclicFragmentsContainer"/>>
        </member>
        <member name="M:NCDK.RingSearches.RingSearch.Match(System.Int32,System.Int32)">
            <summary>
            Determines whether the two vertex colors match. This method provides the
            conditional as to whether to include a bond in the construction of the
            <see cref="M:NCDK.RingSearches.RingSearch.RingFragments"/>.
            </summary>
            <param name="eitherColor">either vertex color</param>
            <param name="otherColor">other vertex color</param>
            <returns>whether the two vertex colours match</returns>
        </member>
        <member name="M:NCDK.RingSearches.RingSearch.IsolatedRingFragments">
            <summary>
            Construct a list of <see cref="T:NCDK.IAtomContainer"/>s each of which only contains a
            single isolated ring. A ring is consider isolated if it does not share
            any bonds with another ring. By this definition each ring of a spiro ring
            system is considered isolated. The atoms are <b>not</b> arranged
            sequential.
            </summary>
            <returns>list of isolated ring fragments</returns>
            <seealso cref="M:NCDK.RingSearches.RingSearch.Isolated"/>
        </member>
        <member name="M:NCDK.RingSearches.RingSearch.FusedRingFragments">
            <summary>
            Construct a list of <see cref="T:NCDK.IAtomContainer"/>s which only contain fused
            rings. A ring is consider fused if it shares any bonds with another ring.
            By this definition bridged ring systems are also included. The atoms are
            <b>not</b> arranged sequential.
            </summary>
            <returns>list of fused ring fragments</returns>
            <seealso cref="M:NCDK.RingSearches.RingSearch.Fused"/>
        </member>
        <member name="M:NCDK.RingSearches.RingSearch.ToFragments(System.Int32[][])">
            <summary>
            Utility method for creating the fragments for the fused/isolated sets
            </summary>
            <param name="verticesList">2D array of vertices (rows=n fragments)</param>
            <returns>the vertices converted to an atom container</returns>
            <seealso cref="M:NCDK.RingSearches.RingSearch.ToFragment(System.Int32[])"/>
            <seealso cref="M:NCDK.RingSearches.RingSearch.FusedRingFragments"/>
            <seealso cref="M:NCDK.RingSearches.RingSearch.IsolatedRingFragments"/>
        </member>
        <member name="M:NCDK.RingSearches.RingSearch.ToFragment(System.Int32[])">
            <summary>
            Utility method for creating a fragment from an array of vertices
            </summary>
            <param name="vertices">array of vertices. Length=cycle weight, values 0 ... nAtoms</param>
            <returns>atom container only containing the specified atoms (and bonds)</returns>
        </member>
        <member name="T:NCDK.RingSearches.CyclicVertexSearch">
            <summary>
            Describes a search to identify vertices which belong to elementary cycles and
            if those cycles are isolated or are part of a fused system. We define a cycle
            as isolated if it edge disjoint with all other cycles. This corresponds to
            the isolated and spiro rings of a chemical structures.
            </summary>
        </member>
        <member name="P:NCDK.RingSearches.CyclicVertexSearch.NumCycles">
            <summary>
            The number of cycles (circuit rank, fr√®re jacques number, num SSSR).
            </summary>
            <returns>number of cycles</returns>
        </member>
        <member name="M:NCDK.RingSearches.CyclicVertexSearch.Cyclic(System.Int32)">
            <summary>
            Returns true if the vertex <paramref name="v"/> is in a cycle.
            </summary>
            <param name="v">a vertex identifier by index</param>
            <returns>whether the vertex is in a cycle</returns>
        </member>
        <member name="M:NCDK.RingSearches.CyclicVertexSearch.Cyclic(System.Int32,System.Int32)">
            <summary>
            Is the edge between the two vertices <paramref name="u"/> and <paramref name="v"/> in a cycle?
            </summary>
            <param name="u">a vertex</param>
            <param name="v">another vertex</param>
            <returns>whether the edge is cycle</returns>
        </member>
        <member name="M:NCDK.RingSearches.CyclicVertexSearch.Cyclic">
            <summary>
            The set of cyclic vertices.
            </summary>
            <returns>the cyclic vertices of the molecule.</returns>
        </member>
        <member name="M:NCDK.RingSearches.CyclicVertexSearch.Isolated">
            <summary>
            Construct the sets of vertices which belong to isolated cycles. Each row
            in the array describes a set of cyclic vertices which is edge disjoint
            with all other elementary cycles.
            </summary>
            <returns>vertices belonging to the isolated rings</returns>
        </member>
        <member name="M:NCDK.RingSearches.CyclicVertexSearch.Fused">
            <summary>
            Construct the sets of vertices which belong to fused cycle systems (share
            at least one edge). Each row in the array describes a set of vertices in
            a separate fused system. Each fused system is edge disjoint with every
            other fused system.
            </summary>
            <returns>vertices belonging to the fused cycles</returns>
        </member>
        <member name="M:NCDK.RingSearches.CyclicVertexSearch.VertexColor">
            <summary>
            Build an indexed lookup of vertex color. The vertex color indicates which
            cycle a given vertex belongs. If a vertex belongs to more then one cycle
            it is colored '0'. If a vertex belongs to no cycle it is colored '-1'.
            </summary>
            <returns>vertex colors</returns>
        </member>
        <member name="T:NCDK.RingSearches.JumboCyclicVertexSearch">
            <summary>
            CyclicVertexSearch for graphs with more then 64 vertices.
            </summary>
        </member>
        <member name="F:NCDK.RingSearches.JumboCyclicVertexSearch.g">
            <summary>graph representation</summary>
        </member>
        <member name="F:NCDK.RingSearches.JumboCyclicVertexSearch.cyclic">
            <summary>set of known cyclic vertices</summary>
        </member>
        <member name="F:NCDK.RingSearches.JumboCyclicVertexSearch.cycles">
            <summary>cycle systems as they are discovered</summary>
        </member>
        <member name="F:NCDK.RingSearches.JumboCyclicVertexSearch.fused">
            <summary>indicates if the 'cycle' at 'i' in 'cycles' is fused</summary>
        </member>
        <member name="F:NCDK.RingSearches.JumboCyclicVertexSearch.visited">
            <summary>set of visited vertices</summary>
        </member>
        <member name="F:NCDK.RingSearches.JumboCyclicVertexSearch.state">
            <summary>the vertices in our path at a given vertex index</summary>
        </member>
        <member name="F:NCDK.RingSearches.JumboCyclicVertexSearch.colors">
            <summary>vertex colored by each component.</summary>
        </member>
        <member name="M:NCDK.RingSearches.JumboCyclicVertexSearch.#ctor(System.Int32[][])">
            <summary>
            Create a new cyclic vertex search for the provided graph.
            </summary>
            <param name="graph">adjacency list representation of a graph</param>
        </member>
        <member name="M:NCDK.RingSearches.JumboCyclicVertexSearch.Search(System.Int32,System.Collections.BitArray,System.Collections.BitArray)">
            <summary>
            Perform a depth first search from the vertex <paramref name="v"/>.
            </summary>
            <param name="v">vertex to search from</param>
            <param name="prev">the state before we vistaed our parent (previous state)</param>
            <param name="curr">the current state (including our parent)</param>
        </member>
        <member name="F:NCDK.RingSearches.JumboCyclicVertexSearch.syncLock">
            <summary>Synchronisation lock.</summary>
        </member>
        <member name="M:NCDK.RingSearches.JumboCyclicVertexSearch.VertexColor">
            <summary>
            Lazily build an indexed lookup of vertex color. The vertex color
            indicates which cycle a given vertex belongs. If a vertex belongs to more
            then one cycle it is colored '0'. If a vertex belongs to no cycle it is
            colored '-1'.
            </summary>
            <returns>vertex colors</returns>
        </member>
        <member name="M:NCDK.RingSearches.JumboCyclicVertexSearch.BuildVertexColor">
            <summary>
            Build an indexed lookup of vertex color. The vertex color indicates which
            cycle a given vertex belongs. If a vertex belongs to more then one cycle
            it is colored '0'. If a vertex belongs to no cycle it is colored '-1'.
            </summary>
            <returns>vertex colors</returns>
        </member>
        <member name="M:NCDK.RingSearches.JumboCyclicVertexSearch.Cyclic(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.RingSearches.JumboCyclicVertexSearch.Cyclic(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.RingSearches.JumboCyclicVertexSearch.Cyclic">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.RingSearches.JumboCyclicVertexSearch.Isolated">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.RingSearches.JumboCyclicVertexSearch.Fused">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.RingSearches.JumboCyclicVertexSearch.Add(System.Collections.BitArray)">
            <summary>
            Add the cycle vertices to our discovered cycles. The cycle is first
            checked to see if it is isolated (shares at most one vertex) or
            <i>potentially</i> fused.
            </summary>
            <param name="cycle">newly discovered cyclic vertex set</param>
        </member>
        <member name="M:NCDK.RingSearches.JumboCyclicVertexSearch.AddIsolated(System.Collections.BitArray)">
            <summary>
            Add an a new isolated cycle which is currently edge disjoint with all
            other cycles.
            </summary>
            <param name="cycle">newly discovered cyclic vertices</param>
        </member>
        <member name="M:NCDK.RingSearches.JumboCyclicVertexSearch.AddFused(System.Collections.BitArray)">
            <summary>
            Adds a <i>potentially</i> fused cycle. If the cycle is discovered not be
            fused it will still be added as isolated.
            </summary>
            <param name="cycle">vertex set of a potentially fused cycle, indicated by the set bits</param>
        </member>
        <member name="M:NCDK.RingSearches.JumboCyclicVertexSearch.IndexOfFused(System.Int32,System.Collections.BitArray)">
            <summary>
            Find the next index that the <i>cycle</i> intersects with by at least two
            vertices. If the intersect of a vertex set with another contains more
            then two vertices it cannot be edge disjoint.
            </summary>
            <param name="start">start searching from here</param>
            <param name="cycle">test whether any current cycles are fused with this one</param>
            <returns>the index of the first fused after 'start', -1 if none</returns>
        </member>
        <member name="M:NCDK.RingSearches.JumboCyclicVertexSearch.ToArray(System.Collections.BitArray)">
            <summary>
            Convert the set bits of a BitArray to an int[].
            </summary>
            <param name="set">input with 0 or more set bits</param>
            <returns>the bits which are set in the input</returns>
        </member>
        <member name="M:NCDK.RingSearches.JumboCyclicVertexSearch.Xor(System.Collections.BitArray,System.Collections.BitArray)">
            <summary>
            XOR the to bit sets together and return the result. Neither input is
            modified.
            </summary>
            <param name="x">first bit set</param>
            <param name="y">second bit set</param>
            <returns>the XOR of the two bit sets</returns>
        </member>
        <member name="M:NCDK.RingSearches.JumboCyclicVertexSearch.And(System.Collections.BitArray,System.Collections.BitArray)">
            <summary>
            AND the to bit sets together and return the result. Neither input is
            modified.
            </summary>
            <param name="x">first bit set</param>
            <param name="y">second bit set</param>
            <returns>the AND of the two bit sets</returns>
        </member>
        <member name="M:NCDK.RingSearches.JumboCyclicVertexSearch.Copy(System.Collections.BitArray)">
            <summary>
            Copy the original bit set.
            </summary>
            <param name="org">input bit set</param>
            <returns>copy of the input</returns>
        </member>
        <member name="T:NCDK.RingSearches.RegularCyclicVertexSearch">
            <summary>
            CyclicVertexSearch for graphs with 64 vertices or less. This search is
            optimised using primitive <see cref="T:System.Int64"/> values to represent vertex sets.
            </summary>
        </member>
        <member name="F:NCDK.RingSearches.RegularCyclicVertexSearch.g">
            <summary>graph representation</summary>
        </member>
        <member name="F:NCDK.RingSearches.RegularCyclicVertexSearch.cyclic">
            <summary>set of known cyclic vertices</summary>
        </member>
        <member name="F:NCDK.RingSearches.RegularCyclicVertexSearch.cycles">
            <summary>cycle systems as they are discovered</summary>
        </member>
        <member name="F:NCDK.RingSearches.RegularCyclicVertexSearch.fused">
            <summary>indicates if the 'cycle' at 'i' in 'cycles' is fused</summary>
        </member>
        <member name="F:NCDK.RingSearches.RegularCyclicVertexSearch.visited">
            <summary>set of visited vertices</summary>
        </member>
        <member name="F:NCDK.RingSearches.RegularCyclicVertexSearch.state">
            <summary>the vertices in our path at a given vertex index</summary>
        </member>
        <member name="F:NCDK.RingSearches.RegularCyclicVertexSearch.colors">
            <summary>Vertex colors - which component does each vertex belong.</summary>
        </member>
        <member name="M:NCDK.RingSearches.RegularCyclicVertexSearch.#ctor(System.Int32[][])">
            <summary>
            Create a new cyclic vertex search for the provided graph.
            </summary>
            <param name="graph">adjacency list representation of a graph</param>
        </member>
        <member name="M:NCDK.RingSearches.RegularCyclicVertexSearch.Search(System.Int32,System.Int64,System.Int64)">
            <summary>
            Perform a depth first search from the vertex <paramref name="v"/>.
            </summary>
            <param name="v">vertex to search from</param>
            <param name="prev">the state before we vistaed our parent (previous state)</param>
            <param name="curr">the current state (including our parent)</param>
        </member>
        <member name="M:NCDK.RingSearches.RegularCyclicVertexSearch.Visited(System.Int32)">
            <summary>
            Returns whether the vertex 'v' has been visited.
            </summary>
            <param name="v">a vertex</param>
            <returns>whether the vertex has been visited</returns>
        </member>
        <member name="M:NCDK.RingSearches.RegularCyclicVertexSearch.Add(System.Int64)">
            <summary>
            Add the cycle vertices to our discovered cycles. The cycle is first
            checked to see if it is isolated (shares at most one vertex) or
            <i>potentially</i> fused.
            </summary>
            <param name="cycle">newly discovered cyclic vertex set</param>
        </member>
        <member name="M:NCDK.RingSearches.RegularCyclicVertexSearch.AddIsolated(System.Int64)">
            <summary>
            Add an a new isolated cycle which is currently edge disjoint with all
            other cycles.
            </summary>
            <param name="cycle">newly discovered cyclic vertices</param>
        </member>
        <member name="M:NCDK.RingSearches.RegularCyclicVertexSearch.AddFused(System.Int64)">
            <summary>
            Adds a <i>potentially</i> fused cycle. If the cycle is discovered not be
            fused it will still be added as isolated.
            </summary>
            <param name="cycle">vertex set of a potentially fused cycle, indicated by the set bits</param>
        </member>
        <member name="M:NCDK.RingSearches.RegularCyclicVertexSearch.IndexOfFused(System.Int32,System.Int64)">
            <summary>
            Find the next index that the <i>cycle</i> intersects with by at least two
            vertices. If the intersect of a vertex set with another contains more
            then two vertices it cannot be edge disjoint.
            </summary>
            <param name="start">start searching from here</param>
            <param name="cycle">test whether any current cycles are fused with this one</param>
            <returns>the index of the first fused after 'start', -1 if none</returns>
        </member>
        <member name="F:NCDK.RingSearches.RegularCyclicVertexSearch.syncLock">
            <summary>Synchronisation lock.</summary>
        </member>
        <member name="M:NCDK.RingSearches.RegularCyclicVertexSearch.VertexColor">
            <summary>
            Lazily build an indexed lookup of vertex color. The vertex color
            indicates which cycle a given vertex belongs. If a vertex belongs to more
            then one cycle it is colored '0'. If a vertex belongs to no cycle it is
            colored '-1'.
            </summary>
            <returns>vertex colors</returns>
        </member>
        <member name="M:NCDK.RingSearches.RegularCyclicVertexSearch.BuildVertexColor">
            <summary>
            Build an indexed lookup of vertex color. The vertex color indicates which
            cycle a given vertex belongs. If a vertex belongs to more then one cycle
            it is colored '0'. If a vertex belongs to no cycle it is colored '-1'.
            </summary>
            <returns>vertex colors</returns>
        </member>
        <member name="M:NCDK.RingSearches.RegularCyclicVertexSearch.Cyclic(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.RingSearches.RegularCyclicVertexSearch.Cyclic(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.RingSearches.RegularCyclicVertexSearch.Cyclic">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.RingSearches.RegularCyclicVertexSearch.Isolated">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.RingSearches.RegularCyclicVertexSearch.Fused">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.RingSearches.RegularCyclicVertexSearch.ToArray(System.Int64)">
            <summary>
            Convert the bits of a <see cref="T:System.Int64"/> to an array of integers. The size of
            the output array is the number of bits set in the value.
            </summary>
            <param name="set">value to convert</param>
            <returns>array of the set bits in the long value</returns>
        </member>
        <member name="M:NCDK.RingSearches.RegularCyclicVertexSearch.IsBitSet(System.Int64,System.Int32)">
            <summary>
            Determine if the specified bit on the value is set.
            </summary>
            <param name="value">bits indicate that vertex is in the set</param>
            <param name="bit">bit to test</param>
            <returns>whether the specified bit is set</returns>
        </member>
        <member name="M:NCDK.RingSearches.RegularCyclicVertexSearch.SetBit(System.Int64,System.Int32)">
            <summary>
            Set the specified bit on the value and return the modified value.
            </summary>
            <param name="value">the value to set the bit on</param>
            <param name="bit">the bit to set</param>
            <returns>modified value</returns>
        </member>
        <member name="T:NCDK.RingSearches.AllRingsFinder">
            <summary>
            Compute the set of all rings in a molecule. This set includes <i>every</i>
            cyclic path of atoms. As the set is exponential it can be very large and is
            often impractical (e.g. fullerenes).
            </summary>
            <remarks>
            To avoid combinatorial explosion there is a configurable threshold, at which
            the computation aborts. The <see cref="F:NCDK.RingSearches.AllRingsFinder.threshold" /> values have been precomputed on
            PubChem-Compound and can be used with the <see cref="M:NCDK.RingSearches.AllRingsFinder.UsingThreshold(NCDK.RingSearches.AllRingsFinder.Threshold)" /> .
            Alternatively, other ring sets which are a subset of this set offer a
            tractable alternative. </remarks>
            <example>
            <code>                AllRingsFinder arf = new AllRingsFinder();
                foreach (var m in ms)
                {
                    try
                    {
                        IRingSet rs = arf.FindAllRings(m);
                    }
                    catch (CDKException)
                    {
                        // molecule was too complex, handle error
                    }
                }
</code>
            </example>
            <seealso cref="T:NCDK.Graphs.AllCycles" />
        </member>
        <member name="F:NCDK.RingSearches.AllRingsFinder.threshold">
            <summary>Precomputed threshold - stops the computation running forever.</summary>
        </member>
        <member name="M:NCDK.RingSearches.AllRingsFinder.#ctor(System.Boolean)">
            <summary>
            Constructor for the AllRingsFinder.
            </summary>
            <param name="logging">true=logging will be done (slower), false = no logging.</param>
        </member>
        <member name="M:NCDK.RingSearches.AllRingsFinder.#ctor">
            <summary>Default constructor using a threshold of <see cref="F:NCDK.RingSearches.AllRingsFinder.Threshold.PubChem_99"/>.</summary>
        </member>
        <member name="M:NCDK.RingSearches.AllRingsFinder.#ctor(NCDK.RingSearches.AllRingsFinder.Threshold)">
            <summary>Internal constructor.</summary>
        </member>
        <member name="M:NCDK.RingSearches.AllRingsFinder.FindAllRings(NCDK.IAtomContainer)">
            <summary>
            Compute all rings in the given <see cref="T:NCDK.IAtomContainer"/>. The container is
            first partitioned into ring systems which are then processed separately.
            If the molecule has already be partitioned, consider using <see cref="M:NCDK.RingSearches.AllRingsFinder.FindAllRingsInIsolatedRingSystem(NCDK.IAtomContainer)"/>. 
            </summary>
            <param name="container">The AtomContainer to be searched for rings</param>
            <returns>A RingSet with all rings in the AtomContainer</returns>
            <exception cref="T:NCDK.CDKException">An exception thrown if the threshold was exceeded</exception>
            <seealso cref="M:NCDK.RingSearches.AllRingsFinder.FindAllRings(NCDK.IAtomContainer,System.Int32)"/>
            <seealso cref="M:NCDK.RingSearches.AllRingsFinder.FindAllRingsInIsolatedRingSystem(NCDK.IAtomContainer)"/>
        </member>
        <member name="M:NCDK.RingSearches.AllRingsFinder.FindAllRings(NCDK.IAtomContainer,System.Int32)">
            <summary>
            Compute all rings up to and including the <paramref name="maxRingSize"/>. The
            container is first partitioned into ring systems which are then processed
            separately. If the molecule has already be partitioned, consider using <see cref="M:NCDK.RingSearches.AllRingsFinder.FindAllRingsInIsolatedRingSystem(NCDK.IAtomContainer,System.Int32)"/>. 
            </summary>
            <param name="container">The AtomContainer to be searched for rings</param>
            <param name="maxRingSize">Maximum ring size to consider. Provides a possible
                               breakout from recursion for complex compounds.</param>
            <returns>A RingSet with all rings in the AtomContainer</returns>
            <exception cref="T:NCDK.CDKException">An exception thrown if the threshold was exceeded</exception>
        </member>
        <member name="M:NCDK.RingSearches.AllRingsFinder.FindAllRingsInIsolatedRingSystem(NCDK.IAtomContainer)">
            <summary>
            Compute all rings in the given <see cref="T:NCDK.IAtomContainer"/>. No pre-processing
            is done on the container.
            </summary>
            <param name="container">The Atom Container to find the ring systems of</param>
            <returns>RingSet for the container</returns>
            <exception cref="T:NCDK.CDKException">An exception thrown if the threshold was exceeded</exception>
        </member>
        <member name="M:NCDK.RingSearches.AllRingsFinder.FindAllRingsInIsolatedRingSystem(NCDK.IAtomContainer,System.Int32)">
            <summary>
            Compute all rings up to an including the <paramref name="maxRingSize"/>. No
            pre-processing is done on the container.
            </summary>
            <param name="atomContainer">the molecule to be searched for rings</param>
            <param name="maxRingSize">Maximum ring size to consider. Provides a possible
                                 breakout from recursion for complex compounds.</param>
            <returns>a RingSet containing the rings in molecule</returns>
            <exception cref="T:NCDK.CDKException">An exception thrown if the threshold was exceeded</exception>
        </member>
        <member name="M:NCDK.RingSearches.AllRingsFinder.CheckTimeout">
            <summary>
            Checks if the timeout has been reached and  exception if so.
            This is used to prevent this AllRingsFinder to run for ages in certain
            rare cases with ring systems of large size or special topology.
            </summary>
            <exception cref="T:NCDK.IntractableException">The exception thrown in case of hitting the timeout</exception>
        </member>
        <member name="M:NCDK.RingSearches.AllRingsFinder.SetTimeout(System.Int64)">
            <summary>
            Sets the timeout value in milliseconds of the <see cref="T:NCDK.RingSearches.AllRingsFinder"/> object This
            is used to prevent this AllRingsFinder to run for ages in certain rare
            cases with ring systems of large size or special topology
            </summary>
            <param name="timeout">The new timeout value</param>
            <returns>a reference to the instance this method was called for</returns>
        </member>
        <member name="P:NCDK.RingSearches.AllRingsFinder.TimeOut">
            <summary>
            Gets the timeout values in milliseconds of the <see cref="T:NCDK.RingSearches.AllRingsFinder"/> object
            </summary>
            <returns>The timeout value</returns>
        </member>
        <member name="M:NCDK.RingSearches.AllRingsFinder.ToRing(NCDK.IAtomContainer,NCDK.Graphs.GraphUtil.EdgeToBondMap,System.Int32[])">
            <summary>
            Convert a cycle in <see cref="T:System.Int32"/>[] representation to an <see cref="T:NCDK.IRing"/>.
            </summary>
            <param name="container">atom container</param>
            <param name="edges">edge map</param>
            <param name="cycle">vertex walk forming the cycle, first and last vertex the same</param>
            <returns>a new ring</returns>
        </member>
        <member name="M:NCDK.RingSearches.AllRingsFinder.ToRing(NCDK.IAtomContainer,NCDK.Graphs.GraphUtil.EdgeToBondMap,System.Int32[],System.Int32[])">
            <summary>
            Convert a cycle in <see cref="T:System.Int32"/>[] representation to an <see cref="T:NCDK.IRing"/>
            but first map back using the given <paramref name="mapping"/>.
            </summary>
            <param name="container">atom container</param>
            <param name="edges">edge map</param>
            <param name="cycle">vertex walk forming the cycle, first and last vertex the same</param>
            <returns>a new ring</returns>
        </member>
        <member name="T:NCDK.RingSearches.AllRingsFinder.Threshold">
            <summary>
            The threshold values provide a limit at which the computation stops.
            There will always be some ring systems in which we cannot compute every
            possible ring (e.g. Fullerenes). This limit replaces the previous timeout
            and provides a more meaningful measure of what to expect based on
            precomputed percentiles. It is important to consider that, higher is not
            always better - generally the large values generate many more rings then
            can be reasonably be handled.
            </summary>
            <remarks>
            The latest results were calculated on PubChem Compound (Dec' 12) and
            summarised below.
            <list type="table">
            <item><term>Maximum Degree</term><term>Percent
            (%)</term><term>Completed<br /> (ring systems)</term><term>Uncompleted<br />
            (ring systems)</term></item> <item><term> </term></item>
            <item><term>72</term><term>99.95</term><term>17834013</term><term>8835</term></item>
            <item><term>84</term><term>99.96</term><term>17835876</term><term>6972</term></item>
            <item><term>126</term><term>99.97</term><term>17837692</term><term>5156</term></item>
            <item><term>216</term><term>99.98</term><term>17839293</term><term>3555</term></item>
            <item><term>684</term><term>99.99 (default)</term><term>17841065</term><term>1783</term></item>
            <item><term> </term></item> <item><term>882</term><term>99.991</term><term>17841342</term><term>1506</term></item>
            <item><term>1062</term><term>99.992</term><term>17841429</term><term>1419</term></item>
            <item><term>1440</term><term>99.993</term><term>17841602</term><term>1246</term></item>
            <item><term>3072</term><term>99.994</term><term>17841789</term><term>1059</term></item>
            </list>
            </remarks>
            <seealso href="http://efficientbits.blogspot.co.uk/2013/06/allringsfinder-sport-edition.html">AllRingsFinder, Sport Edition</seealso>
        </member>
        <member name="F:NCDK.RingSearches.AllRingsFinder.Threshold.PubChem_95">
            <summary>
            Based on PubChem Compound (Dec '12), perception will complete for
            99.95% of ring systems.
            </summary>
        </member>
        <member name="F:NCDK.RingSearches.AllRingsFinder.Threshold.PubChem_96">
            <summary>
            Based on PubChem Compound (Dec '12), perception will complete for
            99.96% of ring systems.
            </summary>
        </member>
        <member name="F:NCDK.RingSearches.AllRingsFinder.Threshold.PubChem_97">
            <summary>
            Based on PubChem Compound (Dec '12), perception will complete for
            99.97% of ring systems.
            </summary>
        </member>
        <member name="F:NCDK.RingSearches.AllRingsFinder.Threshold.PubChem_98">
            <summary>
            Based on PubChem Compound (Dec '12), perception will complete for
            99.98% of ring systems.
            </summary>
        </member>
        <member name="F:NCDK.RingSearches.AllRingsFinder.Threshold.PubChem_99">
            <summary>
            Based on PubChem Compound (Dec '12), perception will complete for
            99.99% of ring systems.
            </summary>
        </member>
        <member name="F:NCDK.RingSearches.AllRingsFinder.Threshold.PubChem_991">
            <summary>
            Based on PubChem Compound (Dec '12), perception will complete for
            99.991% of ring systems.
            </summary>
        </member>
        <member name="F:NCDK.RingSearches.AllRingsFinder.Threshold.PubChem_992">
            <summary>
            Based on PubChem Compound (Dec '12), perception will complete for
            99.992% of ring systems.
            </summary>
        </member>
        <member name="F:NCDK.RingSearches.AllRingsFinder.Threshold.PubChem_993">
            <summary>
            Based on PubChem Compound (Dec '12), perception will complete for
            99.993% of ring systems.
            </summary>
        </member>
        <member name="F:NCDK.RingSearches.AllRingsFinder.Threshold.PubChem_994">
            <summary>
            Based on PubChem Compound (Dec '12), perception will complete for
            99.994% of ring systems.
            </summary>
        </member>
        <member name="F:NCDK.RingSearches.AllRingsFinder.Threshold.None">
            <summary>Run without any threshold, possibly until the end of time itself.</summary>
        </member>
        <member name="M:NCDK.RingSearches.AllRingsFinder.UsingThreshold(NCDK.RingSearches.AllRingsFinder.Threshold)">
            <summary>
            Create an <see cref="T:NCDK.RingSearches.AllRingsFinder" /> instance using the given threshold.
            </summary>
            <example>
            <code>                // using static NCDK.RingSearches.AllRingsFinder.Threshold;
                AllRingsFinder arf = AllRingsFinder.UsingThreshold(PubChem_99);
</code>
            </example>
            <param name="threshold">the threshold value</param>
            <returns>instance with the set threshold</returns>
        </member>
        <member name="T:NCDK.RingSearches.RingPartitioner">
            <summary>
             Partitions a RingSet into RingSets of connected rings. Rings which share an
             Atom, a Bond or three or more atoms with at least on other ring in the
             RingSet are considered connected.
            </summary>
        </member>
        <member name="F:NCDK.RingSearches.RingPartitioner.debug">
            <summary>
             Debugging on/off
            </summary>
        </member>
        <member name="M:NCDK.RingSearches.RingPartitioner.PartitionRings(System.Collections.Generic.IEnumerable{NCDK.IRing})">
            <summary>
             Partitions a RingSet into RingSets of connected rings. Rings which share
             an Atom, a Bond or three or more atoms with at least on other ring in
             the RingSet are considered connected. Thus molecules such as azulene and
            indole will return a List with 1 element.
            </summary>
            <remarks>
            Note that an isolated ring is considered to be <i>self-connect</i>. As a result
            a molecule such as biphenyl will result in a 2-element List being returned (each
            element corresponding to a phenyl ring).
            </remarks>
            <param name="ringSet">The RingSet to be partitioned</param>
            <returns>A <see cref="T:System.Collections.Generic.List`1"/> of connected RingSets</returns>
        </member>
        <member name="M:NCDK.RingSearches.RingPartitioner.ConvertToAtomContainer(NCDK.IRingSet)">
            <summary>
             Converts a RingSet to an AtomContainer.
            </summary>
            <param name="ringSet">The RingSet to be converted.</param>
            <returns>The AtomContainer containing the bonds and atoms of the ringSet.</returns>
        </member>
        <member name="M:NCDK.RingSearches.RingPartitioner.WalkRingSystem(NCDK.IRingSet,NCDK.IRing,NCDK.IRingSet)">
            <summary>
             Perform a walk in the given RingSet, starting at a given Ring and
             recursively searching for other Rings connected to this ring. By doing
             this it finds all rings in the RingSet connected to the start ring,
             putting them in newRs, and removing them from rs.
            </summary>
            <param name="rs">The RingSet to be searched</param>
            <param name="ring">The ring to start with</param>
            <param name="newRs">The RingSet containing all Rings connected to ring</param>
            <returns>newRs The RingSet containing all Rings connected to ring</returns>
        </member>
        <member name="T:NCDK.AtomTypes.CDKAtomTypeMatcher">
            <summary>
            Atom Type matcher that perceives atom types as defined in the CDK atom type list
            <c>NCDK.Dict.Data.cdk-atom-types.owl</c>.
             If there is not an atom type defined for the tested atom, then <see langword="null"/> is returned.
            </summary>
        </member>
        <member name="M:NCDK.AtomTypes.CDKAtomTypeMatcher.IsSingleHeteroAtom(NCDK.IAtom,NCDK.IAtomContainer)">
            <summary>
            Determines whether the bonds (up to two spheres away) are only to non
            hetroatoms. Currently used in N.planar3 perception of (e.g. pyrrole).
            </summary>
            <param name="atom">an atom to test</param>
            <param name="container">container of the atom</param>
            <returns>whether the atom's only bonds are to heteroatoms</returns>
            <seealso cref="M:NCDK.AtomTypes.CDKAtomTypeMatcher.PerceiveNitrogens(NCDK.IAtomContainer,NCDK.IAtom,NCDK.RingSearches.RingSearch,System.Collections.Generic.IList{NCDK.IBond})"/>
        </member>
        <member name="M:NCDK.AtomTypes.CDKAtomTypeMatcher.HeavyBonds(System.Collections.Generic.IList{NCDK.IBond})">
            <summary>
            Filter a bond list keeping only bonds between heavy atoms.
            </summary>
            <param name="bonds">a list of bond</param>
            <returns>the bond list only with heavy bonds</returns>
        </member>
        <member name="M:NCDK.AtomTypes.CDKAtomTypeMatcher.CountAttachedBonds(System.Collections.Generic.IList{NCDK.IBond},NCDK.IAtom,NCDK.BondOrder,System.String)">
            <summary>
            Count the number of doubly bonded atoms.
            </summary>
            <param name="connectedBonds"></param>
            <param name="atom">the atom being looked at</param>
            <param name="order">the desired bond order of the attached bonds</param>
            <param name="symbol">If not null, then it only counts the double bonded atoms which match the given symbol.</param>
            <returns>the number of doubly bonded atoms</returns>
        </member>
        <member name="T:NCDK.AtomTypes.IAtomTypeMatcher">
            <summary>
            Classes that implement this interface are atom type matchers. They find the
            most appropriate AtomType matching the given Atom in a given atom type list.
            </summary>
            <seealso cref="T:NCDK.AtomTypes.IAtomTypeGuesser"/>
        </member>
        <member name="M:NCDK.AtomTypes.IAtomTypeMatcher.FindMatchingAtomType(NCDK.IAtomContainer,NCDK.IAtom)">
            <summary>
            Method that assigns an atom type to a given atom belonging to an atom container.
            </summary>
            <param name="container">AtomContainer of which the <paramref name="atom"/> is part</param>
            <param name="atom">Atom for which a matching atom type is searched</param>
            <returns>The matching AtomType</returns>
            <exception cref="T:NCDK.CDKException">when something went wrong with going through the AtomType's</exception>
        </member>
        <member name="M:NCDK.AtomTypes.IAtomTypeMatcher.FindMatchingAtomTypes(NCDK.IAtomContainer)">
            <summary>
            Method that assigns atom types to atoms in the given atom container.
            </summary>
            <param name="container">AtomContainer for which atom types are perceived</param>
            <returns>The matching AtomType</returns>      
            <exception cref="T:NCDK.CDKException"> when something went wrong with going through  the AtomType's</exception>        
        </member>
        <member name="T:NCDK.AtomTypes.EStateAtomTypeMatcher">
            <summary>
            Determines the EState atom types.
            </summary>
        </member>
        <member name="T:NCDK.AtomTypes.IAtomTypeGuesser">
            <summary>
            Classes that implement this interface are atom type guessers. As compared
            to the IAtomTypeMatcher, this guesser has room for missing information.
            Not uncommonly, one bit of information is missing.
            </summary>
            <seealso cref="T:NCDK.AtomTypes.IAtomTypeMatcher"/>
        </member>
        <member name="M:NCDK.AtomTypes.IAtomTypeGuesser.PossibleAtomTypes(NCDK.IAtomContainer,NCDK.IAtom)">
            <summary>
            Method that returns an iterator with a suitable list of atom types
            given the provided atom.
            </summary>
            <param name="container">AtomContainer of which the <paramref name="atom"/> is part</param>
            <param name="atom">Atom for which a matching atom type is searched</param>
            <returns>The matching AtomTypes</returns>
            <exception cref="T:NCDK.CDKException">when something went wrong with going through the AtomType's</exception>
        </member>
        <member name="T:NCDK.AtomTypes.Mappers.AtomTypeMapper">
            <summary>
            An <see cref="T:NCDK.AtomTypes.Mappers.AtomTypeMapper"/> allows the mapping of atom types between atom type
            schemes. For example, it allows to convert atom types from the CDK scheme to the
            Sybyl scheme; using this approach it is possible to use the CDK atom type perception
            algorithm and write the resulting atom types using the Sybyl atom type scheme.
            </summary>
        </member>
        <member name="M:NCDK.AtomTypes.Mappers.AtomTypeMapper.GetInstance(System.String)">
            <summary>
            Instantiates an atom type to atom type mapping, based on the given mapping file.
            For example, the mapping file NCDK.Config.Data.cdk-sybyl-mappings.owl
            which defines how CDK atom types are mapped to Sybyl atom types.
            </summary>
            <param name="mappingFile">File name of the OWL file defining the atom type to atom type mappings.</param>
            <returns>An instance of AtomTypeMapper for the given mapping file.</returns>
        </member>
        <member name="M:NCDK.AtomTypes.Mappers.AtomTypeMapper.GetInstance(System.String,System.IO.Stream)">
            <summary>
            Instantiates an atom type to atom type mapping, based on the given <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="mappingFile">Name of the <see cref="T:System.IO.Stream"/> defining the atom type to atom type mappings.</param>
            <param name="stream">the <see cref="T:System.IO.Stream"/> from which the mappings as read</param>
            <returns>An instance of AtomTypeMapper for the given mapping file.</returns>
        </member>
        <member name="M:NCDK.AtomTypes.Mappers.AtomTypeMapper.MapAtomType(System.String)">
             <summary>
             Maps an atom type from one scheme to another, as specified in the input used when creating
             this <see cref="T:NCDK.AtomTypes.Mappers.AtomTypeMapper"/> instance.
             </summary>
            
             <param name="type">atom type to map to the target schema</param>
             <returns>atom type name in the target schema</returns>
        </member>
        <member name="P:NCDK.AtomTypes.Mappers.AtomTypeMapper.Mapping">
            <summary>
            Returns the name of this mapping. In case of file inputs, it returns the filename,
            but when the input was an <see cref="T:System.IO.Stream"/> then the name is less well defined.
            </summary>
            <returns>the name of the mapping represented by this <see cref="T:NCDK.AtomTypes.Mappers.AtomTypeMapper"/>.</returns>
        </member>
        <member name="T:NCDK.AtomTypes.StructGenAtomTypeGuesser">
            <summary>
            AtomTypeMatcher that finds an AtomType by matching the Atom's element symbol.
            This atom type matcher takes into account formal charge and number of
            implicit hydrogens, and requires bond orders to be given.
            </summary>
            <remarks>
            <para>
            This class uses the <b>NCDK.Config.Data.structgen_atomtypes.xml</b>
            list. If there is not an atom type defined for the tested atom, then <see langword="null"/>
            is returned.
            </para>
            </remarks>
        </member>
        <member name="M:NCDK.AtomTypes.StructGenAtomTypeGuesser.#ctor">
            <summary>
            Constructor for the StructGenMatcher object.
            </summary>
        </member>
        <member name="M:NCDK.AtomTypes.StructGenAtomTypeGuesser.PossibleAtomTypes(NCDK.IAtomContainer,NCDK.IAtom)">
            <summary>
            Finds the AtomType matching the Atom's element symbol, formal charge and
            hybridization state.
            </summary>
            <param name="atomContainer">AtomContainer</param>
            <param name="atom">the target atom</param>
            <exception cref="T:NCDK.CDKException">Exception thrown if something goes wrong</exception>
            <returns>the matching AtomType</returns>
        </member>
        <member name="T:NCDK.AtomTypes.StructGenMatcher">
            <summary>
            AtomTypeMatcher that finds an AtomType by matching the Atom's element symbol.
            This atom type matcher takes into account formal charge and number of
            implicit hydrogens, and requires bond orders to be given.
            <para>
            This class uses the <b>cdk/config/data/structgen_atomtypes.xml</b>
            list. If there is not an atom type defined for the tested atom, then null
            is returned.</para>
            </summary>
        </member>
        <member name="M:NCDK.AtomTypes.StructGenMatcher.#ctor">
            <summary>
            Constructor for the StructGenMatcher object.
            </summary>
        </member>
        <member name="M:NCDK.AtomTypes.StructGenMatcher.FindMatchingAtomType(NCDK.IAtomContainer,NCDK.IAtom)">
            <summary>
            Finds the AtomType matching the Atom's element symbol, formal charge and
            hybridization state.
            </summary>
            <param name="atomContainer">AtomContainer</param>
            <param name="atom">the target atom</param>
            <exception cref="T:NCDK.CDKException">Exception thrown if something goes wrong</exception>
            <returns>the matching AtomType</returns>
        </member>
        <member name="T:NCDK.AtomTypes.SybylAtomTypeMatcher">
            <summary>
            Atom Type matcher for Sybyl atom types. It uses the <see cref="T:NCDK.AtomTypes.CDKAtomTypeMatcher"/>
            for perception and then maps CDK to Sybyl atom types.
            </summary>
        </member>
        <member name="M:NCDK.AtomTypes.SybylAtomTypeMatcher.GetInstance(NCDK.IChemObjectBuilder)">
            <summary>
            Returns an instance of this atom typer. It uses the given <paramref name="builder"/> to
            create atom type objects.
            </summary>
            <param name="builder"><see cref="T:NCDK.IChemObjectBuilder"/> to use to create <see cref="T:NCDK.IAtomType"/> instances.</param>
            <returns>an instance of this atom type matcher.</returns>
        </member>
        <member name="M:NCDK.AtomTypes.SybylAtomTypeMatcher.FindMatchingAtomType(NCDK.IAtomContainer,NCDK.IAtom)">
            <summary>
            Sybyl atom type perception for a single atom. The molecular property <i>aromaticity</i> is not perceived;
            Aromatic carbons will, therefore, be perceived as <i>C.2</i> and not <i>C.ar</i>. If the latter is
            required, please use FindMatchingAtomType(IAtomContainer) instead.
            </summary>
            <param name="atomContainer">the <see cref="T:NCDK.IAtomContainer"/> in which the atom is found</param>
            <param name="atom">the <see cref="T:NCDK.IAtom"/> to find the atom type of</param>
            <returns>the atom type perceived from the given atom</returns>
        </member>
        <member name="T:NCDK.ChemObjectChangeEventArgs">
            <summary>
            Event fired by cdk classes to their registered listeners
            in case something changes within them.
            </summary>
        </member>
        <member name="M:NCDK.ChemObjectChangeEventArgs.#ctor(System.Object)">
            <summary>
            Constructs a ChemObjectChangeEvent with a reference
            to the object where it originated.
            </summary>
            <param name="source">The reference to the object where this change event originated</param>
        </member>
        <member name="T:NCDK.Aromaticities.Aromaticity">
            <summary>
            A configurable model to perceive aromatic systems. 
            </summary>
            <remarks>
            Aromaticity is useful as
            both a chemical property indicating stronger stabilisation and as a way to
            treat different resonance forms as equivalent. Each has its own implications
            the first in physicochemical attributes and the second in similarity,
            depiction and storage.
            <para>
            To address the resonance forms, several simplified (sometimes conflicting)
            models have arisen. Generally the models <b>loosely</b> follow
            <see href="https://en.wikipedia.org/wiki/H%C3%BCckel's_rule">H√ºckel's rule</see>
            for determining aromaticity. A common omission being that planarity is not
            tested and chemical compounds which are non-planar can be perceived
            as aromatic. An example of one such compound is, cyclodeca-1,3,5,7,9-pentaene.
            </para>
            <para>
            Although there is not a single universally accepted model there are models
            which may better suited for a specific use (<see href="http://www.slideshare.net/NextMoveSoftware/cheminformatics-toolkits-a-personal-perspective">Cheminformatics Toolkits: A Personal Perspective, Roger Sayle</see>).
            The different models are often ill-defined or unpublished but it is important
            to acknowledge that there are differences (see. <see href="http://blueobelisk.shapado.com/questions/aromaticity-perception-differences">Aromaticity Perception Differences, Blue Obelisk</see>).
            </para>
            <para>
            Although models may get more complicated (e.g. considering tautomers)
            normally the reasons for differences are:
            <list type="bullet">
                <item>the atoms allowed and how many electrons each contributes</item>
                <item>the rings/cycles are tested</item>
            </list>
            </para>
            <para>
            This implementation allows configuration of these via an <see cref="T:NCDK.Aromaticities.ElectronDonation" /> model and <see cref="T:NCDK.Graphs.CycleFinder" />. To obtain an instance
            of the electron donation model use one of the factory methods,
            <see cref="P:NCDK.Aromaticities.ElectronDonation.CDKModel" />, <see cref="P:NCDK.Aromaticities.ElectronDonation.CDKAllowingExocyclicModel" />,
            <see cref="P:NCDK.Aromaticities.ElectronDonation.DaylightModel" /> or <see cref="P:NCDK.Aromaticities.ElectronDonation.PiBondsModel" />.
            </para>
            </remarks>
            <example>
            <code>                // mimics the old CDKHuckelAromaticityDetector which uses the CDK atom types
                ElectronDonation model = ElectronDonation.CDKModel;
                CycleFinder cycles = Cycles.CDKAromaticSetFinder;
                Aromaticity aromaticity = new Aromaticity(model, cycles);
                // apply our configured model to each molecule, the CDK model
                // requires that atom types are perceived
                var molecule = TestMoleculeFactory.MakeAnthracene();
                AtomContainerManipulator.PercieveAtomTypesAndConfigureAtoms(molecule);
                aromaticity.Apply(molecule);
</code>
            </example>
            <seealso href="http://en.wikipedia.org/wiki/H%C3%BCckel's_rule">H√ºckel's rule</seealso>
            <seealso href="http://www.slideshare.net/NextMoveSoftware/cheminformatics-toolkits-a-personal-perspective">Cheminformatics Toolkits: A Personal Perspective, Roger Sayle</seealso>
            <seealso href="http://blueobelisk.shapado.com/questions/aromaticity-perception-differences">Aromaticity Perception Differences, Blue Obelisk</seealso>
        </member>
        <member name="F:NCDK.Aromaticities.Aromaticity.model">
            <summary>Find how many electrons each atom contributes.</summary>
        </member>
        <member name="F:NCDK.Aromaticities.Aromaticity.cycles">
            <summary>The method to find cycles which will be tested for aromaticity.</summary>
        </member>
        <member name="M:NCDK.Aromaticities.Aromaticity.#ctor(NCDK.Aromaticities.ElectronDonation,NCDK.Graphs.CycleFinder)">
            <summary>
            Create an aromaticity model using the specified electron donation
            <paramref name="model" /> which is tested on the <paramref name="cycles" />. The <paramref name="model" /> defines
            how many œÄ-electrons each atom may contribute to an aromatic system. The
            <paramref name="cycles" /> defines the <see cref="T:NCDK.Graphs.CycleFinder" /> which is used to find
            cycles in a molecule. The total electron donation from each atom in each
            cycle is counted and checked. If the electron contribution is equal to
            <c>4n + 2</c> for a <c>n &gt;= 0</c> then the cycle is considered
            aromatic. 
            </summary>
            <remarks>
            Changing the electron contribution model or which cycles
            are tested affects which atoms/bonds are found to be aromatic. There are
            several <see cref="T:NCDK.Aromaticities.ElectronDonation" /> models and <see cref="T:NCDK.Graphs.Cycles" />
            available. A good choice for the cycles
            is to use <see cref="P:NCDK.Graphs.Cycles.AllFinder" /> falling back to
            <see cref="P:NCDK.Graphs.Cycles.RelevantFinder" /> on failure. Finding all cycles is very
            fast but may produce an exponential number of cycles. It is therefore not
            feasible for complex fused systems and an exception is thrown.
            In such cases the aromaticity can either be skipped or a simpler
            polynomial cycle set <see cref="P:NCDK.Graphs.Cycles.RelevantFinder" /> used.
            </remarks>
            <example>
            <code>                // mimics the CDKHuckelAromaticityDetector
                Aromaticity aromaticity_cdk = new Aromaticity(ElectronDonation.CDKModel, Cycles.CDKAromaticSetFinder);
                // mimics the DoubleBondAcceptingAromaticityDetector
                Aromaticity aromaticity_exo = new Aromaticity(ElectronDonation.CDKAllowingExocyclicModel, Cycles.CDKAromaticSetFinder);
                // a good model for writing SMILES
                Aromaticity aromaticity_smi = new Aromaticity(ElectronDonation.DaylightModel, Cycles.AllFinder);
                // a good model for writing MDL/Mol2
                Aromaticity aromaticity_mdl = new Aromaticity(ElectronDonation.PiBondsModel, Cycles.AllFinder);
</code>
            </example>
            <param name="model" />
            <param name="cycles" />
            <seealso cref="T:NCDK.Aromaticities.ElectronDonation" />
            <seealso cref="T:NCDK.Graphs.Cycles" />
        </member>
        <member name="M:NCDK.Aromaticities.Aromaticity.FindBonds(NCDK.IAtomContainer)">
            <summary>
            Find the bonds of a <paramref name="molecule" /> which this model determined were aromatic.
            </summary>
            <example>
            <code>                Aromaticity aromaticity = new Aromaticity(ElectronDonation.CDKModel, Cycles.AllFinder);
                IAtomContainer container = TestMoleculeFactory.MakeAnthracene();
                AtomContainerManipulator.PercieveAtomTypesAndConfigureAtoms(container);
                try
                {
                    var bonds = aromaticity.FindBonds(container);
                    int nAromaticBonds = bonds.Count();
                }
                catch (CDKException)
                {
                    // cycle computation was intractable
                }
</code>
            </example>
            <param name="molecule">the molecule to apply the model to</param>
            <returns>the set of bonds which are aromatic</returns>
            <exception cref="T:NCDK.CDKException">a problem occurred with the cycle perception - one can retry with a simpler cycle set</exception>
        </member>
        <member name="M:NCDK.Aromaticities.Aromaticity.Apply(NCDK.IAtomContainer)">
            <summary>
            Apply this aromaticity model to a molecule. Any existing aromaticity
            flags are removed - even if no aromatic bonds were found. This follows
            the idea of <i>applying</i> an aromaticity model to a molecule such that
            the result is the same irrespective of existing aromatic flags. If you
            require aromatic flags to be preserved the <see cref="M:NCDK.Aromaticities.Aromaticity.FindBonds(NCDK.IAtomContainer)" />
            can be used to find bonds without setting any flags.
            </summary>
            <example>
            <code>                Aromaticity aromaticity = new Aromaticity(ElectronDonation.CDKModel, Cycles.AllFinder);
                IAtomContainer container = TestMoleculeFactory.MakeAnthracene();
                try
                {
                    if (aromaticity.Apply(container))
                    {
                        //
                    }
                }
                catch (CDKException)
                {
                    // cycle computation was intractable
                }
</code>
            </example>
            <param name="molecule">the molecule to apply the model to</param>
            <returns>the model found the molecule was aromatic</returns>
        </member>
        <member name="M:NCDK.Aromaticities.Aromaticity.CheckElectronSum(System.Int32[],System.Int32[],System.Int32[])">
            <summary>
            Check if the number electrons in the <paramref name="cycle"/> could delocalise. The
            <paramref name="contributions"/> array indicates how many œÄ-electrons each atom can contribute.
            </summary>
            <param name="cycle">closed walk (last and first vertex the same) of vertices which form a cycle</param>
            <param name="contributions">œÄ-electron contribution from each atom</param>
            <param name="subset"></param>
            <returns>the number of electrons indicate they could delocalise</returns>
        </member>
        <member name="M:NCDK.Aromaticities.Aromaticity.ElectronSum(System.Int32[],System.Int32[],System.Int32[])">
            <summary>
            Count the number electrons in the <paramref name="cycle"/>. The 
            <paramref name="contributions"/> array indicates how many œÄ-electrons each atom can
            contribute. When the contribution of an atom is less than 0 the sum for
            the cycle is always 0.
            </summary>
            <param name="cycle">closed walk (last and first vertex the same) of vertices which form a cycle</param>
            <param name="contributions">œÄ-electron contribution from each atom</param>
            <param name="subset"></param>
            <returns>the total sum of œÄ-electrons contributed by the <paramref name="cycle"/></returns>
        </member>
        <member name="M:NCDK.Aromaticities.Aromaticity.ValidSum(System.Int32)">
            <summary>
            Given the number of pi electrons verify that <c>sum = 4n + 2</c> for <c>n >= 0</c>.
            </summary>
            <param name="sum">œÄ-electron sum</param>
            <returns>there is an <c>n</c> such that <c>sum = 4n + 2</c> is equal to the provided <c>sum</c>.</returns>
        </member>
        <member name="M:NCDK.Aromaticities.Aromaticity.Subset(System.Int32[])">
            <summary>
            Obtain a subset of the vertices which can contribute <paramref name="electrons"/>
            and are allowed to be involved in an aromatic system.
            </summary>
            <param name="electrons">electron contribution</param>
            <returns>vertices which can be involved in an aromatic system</returns>
        </member>
        <member name="P:NCDK.Aromaticities.Aromaticity.CDKLegacy">
            <summary>
            Access an aromaticity instance. It has the following configuration: 
            <code>                new Aromaticity(ElectronDonation.CDKModel, Cycles.CDKAromaticSetFinder);
</code>
            </summary>
            <remarks>
            <para>
            This model is not necessarily bad (or really considered legacy) but
            should <b>not</b> be considered a gold standard model that covers all
            possible cases. It was however the primary method used in previous
            versions of the CDK (1.4).
            </para>
            <para>
            This factory method is provided for convenience for
            those wishing to replicate aromaticity perception used in previous
            versions. The same electron donation model can be used to test
            aromaticity of more cycles. For instance, the following configuration
            will identify more bonds in a some structures as aromatic:
            <code>                new Aromaticity(ElectronDonation.CDKModel, Cycles.Or(Cycles.AllFinder, Cycles.RelevantFinder));
</code>
            </para>
            </remarks>
        </member>
        <member name="T:NCDK.Aromaticities.AtomTypeModel">
            <summary>
            Electron donation model using the CDK atom types. One can choose to allow
            contribution from exocyclic pi bonds in the constructor. Allowing exocyclic
            pi bonds results in molecules such as hexamethylidenecyclohexane (
            "C=C1C(=C)C(=C)C(=C)C(=C)C1=C") being considered aromatic.
            </summary>
        </member>
        <member name="F:NCDK.Aromaticities.AtomTypeModel.Types">
            <summary>Predefined electron contribution for several atom types.</summary>
        </member>
        <member name="F:NCDK.Aromaticities.AtomTypeModel.exocyclic">
            <summary>Allow exocyclic pi bonds.</summary>
        </member>
        <member name="M:NCDK.Aromaticities.AtomTypeModel.#ctor(System.Boolean)">
            <summary>
            Create the electron donation model specifying whether exocyclic pi bonds
            are allowed. Exocyclic pi bonds <i>sprout</i> from a ring, allowing these
            bonds to contribute means structure such as hexamethylidenecyclohexane,
            "C=C1C(=C)C(=C)C(=C)C(=C)C1=C" are considered <i>aromatic</i>.
            </summary>
            <param name="exocyclic">allow exocyclic double bonds</param>
        </member>
        <member name="M:NCDK.Aromaticities.AtomTypeModel.Contribution(NCDK.IAtomContainer,NCDK.RingSearches.RingSearch)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Aromaticities.AtomTypeModel.ElectronsForAtomType(NCDK.IAtom)">
            <summary>
            The number of contributed electrons for the atom type of the specified atom type.
            </summary>
            <param name="atom">an atom to get the contribution of</param>
            <returns>the number of electrons</returns>
        </member>
        <member name="M:NCDK.Aromaticities.AtomTypeModel.LonePairCount(NCDK.IAtom)">
            <summary>
            Access to the number of lone-pairs (specified as a property of the atom).
            </summary>
            <param name="atom">the atom to get the lone pairs from</param>
            <returns>number of lone pairs</returns>
        </member>
        <member name="T:NCDK.Aromaticities.DaylightModel">
            <summary>
            Electron donation model closely mirroring the Daylight model for use in
            generating SMILES. The model was interpreted from various resources and as
            such may not match exactly. If you find an inconsistency please add a request
            for enhancement to the patch tracker. One known limitation is that this model
            does not currently consider unknown/pseudo atoms '*'. 
            </summary>
            <remarks>
            <para>
            The model makes a couple of assumptions which it will not correct for.
            Checked assumptions cause the model to throw a runtime exception.
            <list type="bullet">
            <item>there should be no valence errors (unchecked)</item>
            <item>every atom has a set implicit hydrogen count (checked)</item> 
            <item>every bond has defined order, single, double etc (checked)</item> 
            <item>atomic number of non-pseudo atoms is set (checked)</item>
            </list>
            </para>
            <para>
            The aromaticity model in SMILES was designed to simplify canonicalisation and
            express symmetry in a molecule. The contributed electrons can be summarised
            as follows (refer to code for exact specification): 
            <list type="bullet">
            <item>carbon, nitrogen, oxygen, phosphorus, sulphur, arsenic and selenium are allow to be aromatic</item> 
            <item>atoms should be Sp2 hybridised - not actually computed</item>
            <item>atoms adjacent to a single cyclic pi bond contribute 1 electron</item>
            <item>neutral or negatively charged atoms with a lone pair contribute 2 </item> 
            <item>exocyclic pi bonds are allowed but if the exocyclic atom is more electronegative it consumes an electron. As an example ketone groups contribute '0' electrons.</item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:NCDK.Aromaticities.DaylightModel.Contribution(NCDK.IAtomContainer,NCDK.RingSearches.RingSearch)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Aromaticities.DaylightModel.ExocyclicContribution(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Defines the number of electrons contributed when a pi bond is exocyclic
            (spouting). 
            </summary>
            <remarks>
            When an atom is connected to an more electronegative atom
            then the electrons are 'pulled' from the ring. The preset conditions are
            as follows:
            <list type="bullet">
            <item>A cyclic carbon with an exocyclic pi bond to anything but carbon
            contributes 0 electrons. If the exocyclic atom is also a carbon then 1
            electron is contributed.</item>
            <item>A cyclic 4 valent nitrogen or
            phosphorus cation with an exocyclic pi bond will always contribute 1
            electron. A 5 valent neutral nitrogen or phosphorus with an exocyclic
            bond to an oxygen contributes 1 electron. </item>
            <item>A neutral sulphur connected to an oxygen contributes 2 electrons</item>
            <item>If none of the previous conditions are met the atom is not considered as being able to
            participate in an aromatic system and -1 is returned.</item>
            </list>
            </remarks>
            <param name="element">the element of the cyclic atom</param>
            <param name="otherElement">the element of the exocyclic atom which is connected to the cyclic atom by a pi bond</param>
            <param name="charge">the charge of the cyclic atom</param>
            <param name="nCyclic">the number of cyclic pi bonds adjacent to cyclic atom</param>
            <returns>number of contributed electrons</returns>
        </member>
        <member name="M:NCDK.Aromaticities.DaylightModel.AromaticElement(System.Int32)">
            <summary>
            Is the element specified by the atomic number, allowed to be aromatic by
            the daylight specification. Allowed elements are C, N, O, P, S, As, Se
            and *. This model allows all except for the unknown ('*') element.
            </summary>
            <param name="element">atomic number of element</param>
            <returns>the element can be aromatic</returns>
        </member>
        <member name="M:NCDK.Aromaticities.DaylightModel.Normal(System.Int32,System.Int32,System.Int32)">
            <summary>
            The element has normal valence for the specified charge.
            </summary>
            <param name="element">atomic number</param>
            <param name="charge">formal charge</param>
            <param name="valence">bonded electrons</param>
            <returns>acceptable for this model</returns>
        </member>
        <member name="M:NCDK.Aromaticities.DaylightModel.Valence(System.Int32,System.Int32)">
            <summary>
            Lookup of the number of valence electrons for the element at a given charge.
            </summary>
            <param name="element">the atomic number of an element</param>
            <param name="charge">the formal charge on the atom</param>
            <returns>the valence</returns>
            <exception cref="T:System.NotSupportedException">encountered an element which the valence was not encoded for</exception>
        </member>
        <member name="M:NCDK.Aromaticities.DaylightModel.Valence(System.Int32)">
            <summary>
            Lookup of the number of valence electrons for elements near those which
            this model considers aromatic. As only the <see cref="M:NCDK.Aromaticities.DaylightModel.AromaticElement(System.Int32)"/> 
            are checked we need only consider elements within a charge range.
            </summary>
            <param name="element">the atomic number of an element</param>
            <returns>the valence</returns>
            <exception cref="T:System.NotSupportedException">encountered an element which the valence was not encoded for</exception>
        </member>
        <member name="M:NCDK.Aromaticities.DaylightModel.Element(NCDK.IAtom)">
            <summary>
            Get the atomic number as an non-null integer value. Although pseudo atoms
            are not considered by this model the pseudo atoms are intercepted to have
            non-null atomic number (defaults to 0).
            </summary>
            <param name="atom">atom to get the element from</param>
            <returns>the formal charge</returns>
        </member>
        <member name="M:NCDK.Aromaticities.DaylightModel.Charge(NCDK.IAtom)">
            <summary>
            Get the formal charge as an integer value - null defaults to 0.
            </summary>
            <param name="atom">the atom to get the charge of</param>
            <returns>the formal charge</returns>
        </member>
        <member name="T:NCDK.Aromaticities.ElectronDonation">
            <summary>
            Defines an electron donation model for perceiving aromatic systems. The model
            defines which atoms are allowed and how many electron it contributes. 
            </summary>
            <remarks>
            There are currently several models available.
            <list type="bullet">
                <item><see cref="T:NCDK.CDK" />/<see cref="P:NCDK.Aromaticities.ElectronDonation.CDKAllowingExocyclicModel" /> - uses the information
                form the preset CDK atom types to determine how many electrons each atom
                should contribute. The model can either allow or exclude contributions
                from exocyclic pi bonds. This model requires that atom types have be
                perceived.
            </item>
                <item><see cref="P:NCDK.Aromaticities.ElectronDonation.PiBondsModel" /> - a simple model only allowing cyclic pi bonds to contribute. This model only requires that bond orders are set.</item>
                <item>
                 <see cref="P:NCDK.Aromaticities.ElectronDonation.DaylightModel" /> - a model similar to that used by Daylight for SMILES.
                 This model does not require atom types to be defined but every atom should
                 have it's hydrogen count set.
                </item>
            </list>
            </remarks>
            <example>
            To obtain an instance of the model simply invoke the named method.
            <code>                ElectronDonation model = ElectronDonation.CDKModel;
</code>
            </example>
        </member>
        <member name="M:NCDK.Aromaticities.ElectronDonation.Contribution(NCDK.IAtomContainer,NCDK.RingSearches.RingSearch)">
            <summary>
            Determine the number 'p' electron contributed by each atom in the
            provided <paramref name="container"/>. A value of '0' indicates the atom can
            contribute but that it contributes no electrons. A value of '-1'
            indicates the atom should not contribute at all.
            </summary>
            <param name="container">molecule</param>
            <param name="ringSearch">ring information</param>
            <returns>electron contribution of each atom (-1=none)</returns>
        </member>
        <member name="P:NCDK.Aromaticities.ElectronDonation.CDKModel">
            <summary>
            Electron donation model to use for aromaticity perception.
            <para>
            Use the preset CDK atom types to determine the electron contribution of
            atoms. If an atom type has not been perceived or hybridisation is unset a
            runtime exception is thrown.</para>
            </summary>
            <remarks>
            The model accepts cyclic atoms which
            are <see cref="F:NCDK.Hybridization.SP2"/> or
            <see cref="F:NCDK.Hybridization.Planar3"/>
            hybridised. The <see cref="F:NCDK.CDKPropertyName.PiBondCount"/> and
            <see cref="F:NCDK.CDKPropertyName.LonePairCount"/> to determine how
            many electrons an atom type can contribute. Generally these values are
            not automatically configured and so several atom types are cached
            for lookup: <list type="bullet"> <item>N.planar3: 2 electrons </item>
            <item>N.minus.planar3: 2 electrons </item> <item>N.amide: 2 electrons </item>
            <item>S.2: 2 electrons </item> <item>S.planar3: 2 electrons </item>
            <item>C.minus.planar: 2 electrons </item> <item>O.planar3: 2 electrons </item>
            <item>N.sp2.3: 1 electron </item> <item>C.sp2: 1 electron </item> </list>
            Exocyclic pi bonds are not allowed to contribute.
            </remarks>
            <seealso cref="P:NCDK.IAtomType.AtomTypeName"/>
        </member>
        <member name="P:NCDK.Aromaticities.ElectronDonation.CDKAllowingExocyclicModel">
            <summary>
            Electron donation model to use for aromaticity perception.
            </summary>
            <remarks>
            <para>
            Use the preset CDK atom types to determine the electron contribution of
            atoms. If an atom type has not been perceived or hybridisation is unset a
            runtime exception is thrown.
            </para>
            <para>
            The model accepts cyclic atoms which
            are <see cref="F:NCDK.Hybridization.SP2"/> or
            <see cref="F:NCDK.Hybridization.Planar3"/>
            hybridised. The <see cref="F:NCDK.CDKPropertyName.PiBondCount"/> and
            <see cref="F:NCDK.CDKPropertyName.LonePairCount"/> to determine how
            many electrons an atom type can contribute. Generally these values are
            not automatically configured and so several atom types are cached
            for lookup: <list type="bullet"> <item>N.planar3: 2 electrons </item>
            <item>N.minus.planar3: 2 electrons </item> <item>N.amide: 2 electrons </item>
            <item>S.2: 2 electrons </item> <item>S.planar3: 2 electrons </item>
            <item>C.minus.planar: 2 electrons </item> <item>O.planar3: 2 electrons </item>
            <item>N.sp2.3: 1 electron </item> <item>C.sp2: 1 electron </item> </list>
            Exocyclic pi bonds are not allowed to contribute.
            </para>
            </remarks>
            <seealso cref="P:NCDK.IAtomType.AtomTypeName"/>
        </member>
        <member name="P:NCDK.Aromaticities.ElectronDonation.PiBondsModel">
            <summary>
            Electron donation model to use for aromaticity perception.
            </summary>
            <remarks>
            <para>
            A very simple aromaticity model which only allows atoms adjacent to
            cyclic pi bonds. Lone pairs are not consider and as such molecules like
            furan and pyrrole are non-aromatic. The model is useful for storing
            aromaticity in MDL and Mol2 file formats where aromatic systems involving
            a lone pair can not be properly represented.</para>
            </remarks>
        </member>
        <member name="P:NCDK.Aromaticities.ElectronDonation.DaylightModel">
            <summary>
            Electron donation model closely mirroring the Daylight model for use in
            generating SMILES. The model was interpreted from various resources and
            as such may not match exactly. If you find an inconsistency please add a
            request for enhancement to the patch tracker. One known limitation is
            that this model does not currently consider unknown/pseudo atoms '*'.
            </summary>
            <remarks>
            <para>
            The model makes a couple of assumptions which it will not correct for.
            Checked assumptions cause the model to throw a runtime exception. <list type="bullet">
            <item>there should be no valence errors (unchecked)</item> <item>every atom has
            a set implicit hydrogen count (checked)</item> <item>every bond has defined
            order, single, double etc (checked)</item> <item>atomic number of non-pseudo
            atoms is set (checked)</item> </list> 
            </para>
            <para>
            The aromaticity model in SMILES was designed to simplify canonicalisation
            and express symmetry in a molecule. The contributed electrons can be
            summarised as follows (refer to code for exact specification): <list type="bullet">
            <item>carbon, nitrogen, oxygen, phosphorus, sulphur, arsenic and selenium
            are allow to be aromatic</item> <item>atoms should be Sp2 hybridised - not
            actually computed</item> <item>atoms adjacent to a single cyclic pi bond
            contribute 1 electron</item> <item>neutral or negatively charged atoms with a
            lone pair contribute 2 electrons</item> <item>exocyclic pi bonds are allowed
            but if the exocyclic atom is more electronegative it consumes an
            electron. As an example ketone groups contribute '0'
            electrons.</item></list>
            </para>
            </remarks>
        </member>
        <member name="T:NCDK.Aromaticities.Kekulization">
            <summary>
            Assign a Kekul√© representation to the aromatic systems of a compound. Input
            from some file-formats provides some bonds as aromatic / delocalised bond
            types. This method localises the electrons and assigns single and double
            bonds. Different atom and bond orderings may produce distinct but valid
            Kekul√© forms. Only bond orders are adjusted and any aromatic flags will
            remain untouched.
            <para>
            The procedure requires that all atoms have defined implicit hydrogens counts
            and formal charges. If this information is not present it should be assigned
            first. 
            </para>
            <para>
            For some inputs it may not be possible to assign a Kekul√© form. In general
            theses cases are rare but usually occur for one of two reasons.
            1) Missing / ambiguous implicit hydrogens, this is fundamental to determining the
            Kekul√© form and if guessed may be wrong. Some formats (e.g. molfile) can not
            include the exact number of implicit hydrogens attached to atom whilst others
            may omit it or optionally skip encoding. The typical example is found in the
            example for 1H-pyrrole, a correct SMILES encoding should include the hydrogen
            on the aromatic nitrogen '[nH]1cccc1' (not: 'n1cccc1').
            2) The aromaticity perception algorithm has allowed atoms with abnormal
            valence. This usually happens when a non-convalent bond has be <i>upgraded</i>
            to a sigma bond during format conversion. 
            </para>
            </summary>
        </member>
        <member name="M:NCDK.Aromaticities.Kekulization.Kekulize(NCDK.IAtomContainer)">
            <summary>
            Assign a Kekul√© representation to the aromatic systems of a compound.
            </summary>
            <param name="ac">structural representation</param>
            <exception cref="T:NCDK.CDKException">a Kekul√© form could not be assigned</exception>
        </member>
        <member name="M:NCDK.Aromaticities.Kekulization.IsAvailable(System.Int32[][],NCDK.IAtom[],NCDK.Graphs.GraphUtil.EdgeToBondMap)">
            <summary>
            Determine the set of atoms that are available to have a double-bond.
            </summary>
            <param name="graph">adjacent list representation</param>
            <param name="atoms">array of atoms</param>
            <param name="bonds">map of atom indices to bonds</param>
            <returns>atoms that can require a double-bond</returns>
        </member>
        <member name="M:NCDK.Aromaticities.Kekulization.IsAvailable(System.Int32,System.Int32,System.Int32)">
            <summary>
            Determine if the specified element with the provided charge and valance
            requires a pi bond?
            </summary>
            <param name="element">atomic number >= 0</param>
            <param name="charge">formal charge</param>
            <param name="valence">bonded electrons</param>
            <returns>a double-bond is required</returns>
        </member>
        <member name="T:NCDK.Aromaticities.PiBondModel">
            <summary>
            A simple aromatic model which only allows cyclic pi-bonds to contribute to an
            aromatic system. Lone pairs are not considered and as such molecules like
            furan and pyrrole are non-aromatic. This model is suitable for storing
            aromaticity in the MDL/Mol2 file formats.
            </summary>
        </member>
        <member name="M:NCDK.Aromaticities.PiBondModel.Contribution(NCDK.IAtomContainer,NCDK.RingSearches.RingSearch)">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.CDK">
            <summary>
            Helper class to provide general information about this CDK library.
            </summary>
        </member>
        <member name="P:NCDK.CDK.Version">
            <summary>
            Returns the version of this CDK library.
            </summary>
            <returns>The library version</returns>
        </member>
        <member name="T:NCDK.Charges.AtomTypeCharges">
            <summary>
            Assigns charges to atom types.
            </summary>
        </member>
        <member name="M:NCDK.Charges.AtomTypeCharges.#ctor">
            <summary>
             Constructor for the AtomTypeCharges object.
            </summary>
        </member>
        <member name="M:NCDK.Charges.AtomTypeCharges.SetCharges(NCDK.IAtomContainer)">
            <summary>
             Sets initial charges for atom types.
            +1 for cationic atom types
            -1 for anionic atom types
            carboxylic oxygen -0.5
            phosphorylic oxygen -0.66
            sulfanilic oxygen -0.5
            or to formal charge (which must be determined elsewhere or set manually)
            polycations are not handled by this approach
            </summary>
            <param name="atomContainer">AtomContainer</param>
            <returns>AtomContainer with set charges</returns>
        </member>
        <member name="M:NCDK.Charges.AtomTypeCharges.SetInitialCharges(NCDK.IAtomContainer)">
            <summary>
             Sets the initialCharges attribute of the AtomTypeCharges object.
            </summary>
            <param name="ac">AtomContainer</param>
            <returns>AtomContainer with (new) partial charges</returns>
            <exception cref="T:NCDK.CDKException"></exception>
        </member>
        <member name="T:NCDK.Charges.Electronegativity">
            <summary>
            Calculation of the electronegativity of orbitals of a molecule
            by the method Gasteiger based on electronegativity is given by X = a + bq + c(q*q).
            </summary>
        </member>
        <member name="M:NCDK.Charges.Electronegativity.#ctor">
            <summary>
            Constructor for the PiElectronegativity object.
            </summary>
        </member>
        <member name="M:NCDK.Charges.Electronegativity.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructor for the Electronegativity object.
            </summary>
            <param name="maxIterations">The maximal number of Iteration</param>
            <param name="maxResonStruc">The maximal number of Resonance Structures</param>
        </member>
        <member name="M:NCDK.Charges.Electronegativity.CalculateSigmaElectronegativity(NCDK.IAtomContainer,NCDK.IAtom)">
            <summary>
            calculate the electronegativity of orbitals sigma.
            </summary>
            <param name="ac">IAtomContainer</param>
            <param name="atom">atom for which effective atom electronegativity should be calculated</param>
            <returns>piElectronegativity</returns>
        </member>
        <member name="M:NCDK.Charges.Electronegativity.CalculateSigmaElectronegativity(NCDK.IAtomContainer,NCDK.IAtom,System.Int32,System.Int32)">
            <summary>
            calculate the electronegativity of orbitals sigma.
            </summary>
            <param name="ac">IAtomContainer</param>
            <param name="atom">atom for which effective atom electronegativity should be calculated</param>
            <param name="maxIterations">The maximal number of Iterations</param>
            <param name="maxResonStruc">The maximal number of Resonance Structures</param>
            <returns>piElectronegativity</returns>
        </member>
        <member name="P:NCDK.Charges.Electronegativity.MaxIterations">
            <summary>
            the maximum number of Iterations.
            </summary>
        </member>
        <member name="P:NCDK.Charges.Electronegativity.MaxResonanceStructures">
            <summary>
            the maximum number of resonance structures.
            </summary>
        </member>
        <member name="T:NCDK.Charges.GasteigerMarsiliPartialCharges">
            <summary>
            The calculation of the Gasteiger Marsili (PEOE) partial charges is based on
            <token>cdk-cite-GM80</token>. This class only implements the original method which only
            applies to ÔøΩÔøΩ-bond systems.
            </summary>
        </member>
        <member name="M:NCDK.Charges.GasteigerMarsiliPartialCharges.#ctor">
            <summary>
             Constructor for the GasteigerMarsiliPartialCharges object.
            </summary>
        </member>
        <member name="P:NCDK.Charges.GasteigerMarsiliPartialCharges.ChiCatHydrogen">
            <summary>
            chi_cat value for hydrogen, because H poses a special problem due to lack of possible second ionisation.
            </summary>
        </member>
        <member name="P:NCDK.Charges.GasteigerMarsiliPartialCharges.MaxGasteigerDamp">
            <summary>
            the maxGasteigerDamp attribute of the GasteigerMarsiliPartialCharges object.
            </summary>
        </member>
        <member name="P:NCDK.Charges.GasteigerMarsiliPartialCharges.MaxGasteigerIterations">
            <summary>
            the maxGasteigerIters attribute of the GasteigerMarsiliPartialCharges object.
            </summary>
        </member>
        <member name="M:NCDK.Charges.GasteigerMarsiliPartialCharges.AssignGasteigerMarsiliSigmaPartialCharges(NCDK.IAtomContainer,System.Boolean)">
            <summary>
             Main method which assigns Gasteiger Marisili partial sigma charges.
            </summary>
            <param name="ac">AtomContainer</param>
            <param name="setCharge">The Charge</param>
            <returns>AtomContainer with partial charges</returns>
        </member>
        <member name="P:NCDK.Charges.GasteigerMarsiliPartialCharges.StepSize">
            <summary>
            Get the StepSize attribute of the GasteigerMarsiliPartialCharges object.
            </summary>
        </member>
        <member name="M:NCDK.Charges.GasteigerMarsiliPartialCharges.AssignGasteigerSigmaMarsiliFactors(NCDK.IAtomContainer)">
            <summary>
             Method which stores and assigns the factors a,b,c and CHI+.
            </summary>
            <param name="ac">AtomContainer</param>
            <returns>Array of doubles [a1,b1,c1,denom1,chi1,q1...an,bn,cn...] 1:Atom 1-n in AtomContainer</returns>
        </member>
        <member name="T:NCDK.Charges.GasteigerPEPEPartialCharges">
            <summary>
            The calculation of the Gasteiger (PEPE) partial charges is based on
            <token>cdk-cite-Saller85</token>. This class doesn't implement the original method of the Marsili but the
            method based on H. Saller which is described from Petra manual version 2.6
            </summary>
            <remarks>
            They are calculated by generating all valence bond (resonance) structures
            for this system and then weighting them on the basis of pi-orbital electronegativities
            and formal considerations based on PEPE (Partial Equalization of pi-electronegativity).
            </remarks>
            <seealso cref="T:NCDK.Charges.GasteigerMarsiliPartialCharges"/>
        </member>
        <member name="P:NCDK.Charges.GasteigerPEPEPartialCharges.MaxGasteigerIterations">
            <summary>The maxGasteigerIters attribute of the GasteigerPEPEPartialCharges object.</summary>
        </member>
        <member name="P:NCDK.Charges.GasteigerPEPEPartialCharges.MaxResonanceStructures">
            <summary>The maximum resonance structures to be searched.</summary>
        </member>
        <member name="P:NCDK.Charges.GasteigerPEPEPartialCharges.StepSize">
            <summary>The StepSize attribute of the GasteigerMarsiliPartialCharges object.</summary>
        </member>
        <member name="F:NCDK.Charges.GasteigerPEPEPartialCharges.fE">
            <summary>Corresponds an empirical influence between the electrostatic potential and the neighbours.</summary>
        </member>
        <member name="F:NCDK.Charges.GasteigerPEPEPartialCharges.fS">
            <summary>Scale factor which makes same heavy for all structures</summary>
        </member>
        <member name="M:NCDK.Charges.GasteigerPEPEPartialCharges.#ctor">
            <summary>
             Constructor for the GasteigerPEPEPartialCharges object.
            </summary>
        </member>
        <member name="M:NCDK.Charges.GasteigerPEPEPartialCharges.AssignGasteigerPiPartialCharges(NCDK.IAtomContainer,System.Boolean)">
            <summary>
            Main method which assigns Gasteiger partial pi charges.
            </summary>
            <param name="ac">AtomContainer</param>
            <param name="setCharge">currently unused</param>
            <returns>AtomContainer with partial charges</returns>
        </member>
        <member name="M:NCDK.Charges.GasteigerPEPEPartialCharges.RemovingFlagsAromaticity(NCDK.IAtomContainer)">
            <summary>
            remove the aromaticity flags.
            </summary>
            <param name="ac">The IAtomContainer to remove flags</param>
            <returns>The IAtomContainer with the flags removed</returns>
        </member>
        <member name="M:NCDK.Charges.GasteigerPEPEPartialCharges.SetFlags(NCDK.IAtomContainer,NCDK.IAtomContainer,System.Boolean)">
            <summary>
            Set the Flags to atoms and bonds from an atomContainer.
            </summary>
            <param name="container">Container with the flags</param>
            <param name="ac">Container to put the flags</param>
            <param name="b"><see langword="true"/>, if the the flag is true</param>
            <returns>Container with added flags</returns>
        </member>
        <member name="M:NCDK.Charges.GasteigerPEPEPartialCharges.SetAntiFlags(NCDK.IAtomContainer,NCDK.IAtomContainer,System.Int32,System.Boolean)">
            <summary>
            Set the Flags to atoms and bonds which are not contained in an atomContainer.
            </summary>
            <param name="container">Container with the flags</param>
            <param name="ac">Container to put the flags</param>
            <param name="number"><see langword="true"/>, if the the flag is true</param>
            <param name="b">Container with added flags</param>
            <returns></returns>
        </member>
        <member name="M:NCDK.Charges.GasteigerPEPEPartialCharges.GetHyperconjugationInteractions(NCDK.IAtomContainer,NCDK.IChemObjectSet{NCDK.IAtomContainer})">
            <summary>
            get the possible structures after hyperconjugation interactions for bonds which do not belong to any resonance structure.
            </summary>
            <param name="ac"></param>
            <param name="iSet"></param>
            <returns></returns>
        </member>
        <member name="M:NCDK.Charges.GasteigerPEPEPartialCharges.GetElectrostaticPotentialN(NCDK.IAtomContainer,System.Int32,System.Double[])">
            <summary>
            get the electrostatic potential of the neighbours of a atom.
            </summary>
            <param name="ac">The IAtomContainer to study</param>
            <param name="atom1">The position of the IAtom to study</param>
            <param name="ds"></param>
            <returns>The sum of electrostatic potential of the neighbours</returns>
        </member>
        <member name="M:NCDK.Charges.GasteigerPEPEPartialCharges.GetTopologicalFactors(NCDK.IAtomContainer,NCDK.IAtomContainer)">
            <summary>
            Get the topological weight factor for each atomContainer.
            </summary>
            <param name="atomContainer">The IAtomContainer to study.</param>
            <param name="ac">The IAtomContainer to study.</param>
            <returns>The value</returns>
        </member>
        <member name="M:NCDK.Charges.GasteigerPEPEPartialCharges.AssignPiFactors(NCDK.IChemObjectSet{NCDK.IAtomContainer})">
            <summary>
            Method which stores and assigns the factors a,b,c and CHI+.
            </summary>
            <param name="setAc"></param>
            <returns>Array of doubles [a1,b1,c1,denom1,chi1,q1...an,bn,cn...] 1:Atom 1-n in AtomContainer</returns>
        </member>
        <member name="M:NCDK.Charges.GasteigerPEPEPartialCharges.AssignrPiMarsilliFactors(NCDK.IChemObjectSet{NCDK.IAtomContainer})">
            <summary>
            Method which stores and assigns the factors a,b,c and CHI+.
            </summary>
            <param name="setAc"></param>
            <returns>Array of doubles [a1,b1,c1,denom1,chi1,q1...an,bn,cn...] 1:Atom 1-n in AtomContainer</returns>
        </member>
        <member name="M:NCDK.Charges.GasteigerPEPEPartialCharges.CleanFlagReactiveCenter(NCDK.IAtomContainer)">
            <summary>
            clean the flags <see cref="P:NCDK.IAtomType.IsReactiveCenter"/> from the molecule.
            </summary>
            <param name="ac"></param>
        </member>
        <member name="T:NCDK.Charges.IChargeCalculator">
            <summary>
            Interface for classes that calculate (partial) charges centered on atom nuclei.
            </summary>
        </member>
        <member name="T:NCDK.Charges.IElectronicPropertyCalculator">
            <summary>
            Interface for classes that calculate (partial) charges centered on atom nuclei.
            </summary>
        </member>
        <member name="T:NCDK.Charges.InductivePartialCharges">
            <summary>
            The calculation of the inductive partial atomic charges and equalization of
            effective electronegativities is based on <token>cdk-cite-CHE03</token>.
            </summary>
        </member>
        <member name="M:NCDK.Charges.InductivePartialCharges.#ctor">
            <summary>
             Constructor for the InductivePartialCharges object.
            </summary>
        </member>
        <member name="M:NCDK.Charges.InductivePartialCharges.AssignInductivePartialCharges(NCDK.IAtomContainer)">
            <summary>
            Main method, set charge as atom properties.
            </summary>
            <param name="ac">AtomContainer</param>
            <returns>AtomContainer</returns>
        </member>
        <member name="M:NCDK.Charges.InductivePartialCharges.GetPaulingElectronegativities(NCDK.IAtomContainer,System.Boolean)">
            <summary>
             Gets the paulingElectronegativities attribute of the
             InductivePartialCharges object.
            </summary>
            <param name="ac">AtomContainer</param>
            <param name="modified">if true, some values are modified by following the reference</param>
            <returns>The pauling electronegativities</returns>
        </member>
        <member name="M:NCDK.Charges.InductivePartialCharges.GetAtomicSoftnessCore(NCDK.IAtomContainer,System.Int32)">
            <summary>
             Gets the atomicSoftnessCore attribute of the InductivePartialCharges object.
            </summary>
            <remarks>
            this method returns the result of the core of the equation of atomic softness
            that can be used for qsar descriptors and during the iterative calculation
            of effective electronegativity
            </remarks>
            <param name="ac">AtomContainer</param>
            <param name="atomPosition">position of target atom</param>
            <returns>The atomicSoftnessCore value</returns>
            <exception cref="T:NCDK.CDKException"></exception>
        </member>
        <member name="M:NCDK.Charges.InductivePartialCharges.GetAtomicChargeIncrement(NCDK.IAtomContainer,System.Int32,System.Double[],System.Int32)">
            <summary>
             Gets the atomicChargeIncrement attribute of the InductivePartialCharges object.
            </summary>
            <param name="ac">AtomContainer</param>
            <param name="atomPosition">position of target atom</param>
            <param name="ElEn">electronegativity of target atom</param>
            <param name="step">step in iteration</param>
            <returns>The atomic charge increment for the target atom</returns>
            <exception cref="T:NCDK.CDKException"></exception>
        </member>
        <member name="M:NCDK.Charges.InductivePartialCharges.GetCovalentRadius(System.String,NCDK.BondOrder)">
            <summary>
            Gets the covalentRadius attribute of the InductivePartialCharges object.
            </summary>
            <param name="symbol">symbol of the atom</param>
            <param name="maxBondOrder">its max bond order</param>
            <returns>The covalentRadius value given by the reference</returns>
        </member>
        <member name="M:NCDK.Charges.InductivePartialCharges.CalculateSquaredDistanceBetweenTwoAtoms(NCDK.IAtom,NCDK.IAtom)">
            <summary>
            Evaluate the square of the Euclidean distance between two atoms.
            </summary>
            <param name="atom1">first atom</param>
            <param name="atom2">second atom</param>
            <returns>squared distance between the 2 atoms</returns>
        </member>
        <member name="T:NCDK.Charges.MMFF94PartialCharges">
            <summary>
            The calculation of the MMFF94 partial charges. 
            </summary>
            <example>
            Charges are stored as atom properties ("MMFF94charge") for an AtomContainer ac, values are calculated with:
            <code>            SmilesParser sp = new SmilesParser(Silent.ChemObjectBuilder.Instance);
            IAtomContainer ac = sp.ParseSmiles("CC");
            AtomContainerManipulator.PercieveAtomTypesAndConfigureAtoms(ac);
            AtomContainerManipulator.ConvertImplicitToExplicitHydrogens(ac);
            MMFF94PartialCharges mmff = new MMFF94PartialCharges();
            mmff.AssignMMFF94PartialCharges(ac);
</code>
            and for each atom, the value is given by:
            <code>                    atom.GetProperty&lt;double&gt;("MMFF94charge")
</code>
             </example>
            <remarks>
            <note type="note">
            This class delegates to <see cref="T:NCDK.ForceField.MMFF.Mmff" /> and charges are also assigned
            directly to the atom attribute <see cref="P:NCDK.IAtom.Charge" />.
            </note>
            </remarks>
            <seealso cref="M:NCDK.ForceField.MMFF.Mmff.PartialCharges(NCDK.IAtomContainer)" /> 
        </member>
        <member name="M:NCDK.Charges.MMFF94PartialCharges.#ctor">
            <summary>
            Constructor for the MMFF94PartialCharges object
            </summary>
        </member>
        <member name="M:NCDK.Charges.MMFF94PartialCharges.AssignMMFF94PartialCharges(NCDK.IAtomContainer)">
            <summary>
            Main method which assigns MMFF94 partial charges
            </summary>
            <param name="ac">AtomContainer</param>
            <returns>AtomContainer with MMFF94 partial charges as atom properties</returns>
        </member>
        <member name="T:NCDK.Charges.PiElectronegativity">
            <summary>
            Calculation of the electronegativity of orbitals of a molecule
            by the method Gasteiger based on electronegativity is given by X = a + bq + c(q*q).
            </summary>
        </member>
        <member name="P:NCDK.Charges.PiElectronegativity.MaxIterations">
            <summary>The maximum number of Iterations.</summary>
        </member>
        <member name="P:NCDK.Charges.PiElectronegativity.MaxResonanceStructures">
            <summary>Number of maximum resonance structures</summary>
        </member>
        <member name="M:NCDK.Charges.PiElectronegativity.#ctor">
            <summary>
            Constructor for the PiElectronegativity object.
            </summary>
        </member>
        <member name="M:NCDK.Charges.PiElectronegativity.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructor for the Electronegativity object.
            </summary>
            <param name="maxIterations">The maximal number of Iteration</param>
            <param name="maxResonStruc">The maximal number of Resonance Structures</param>
        </member>
        <member name="M:NCDK.Charges.PiElectronegativity.CalculatePiElectronegativity(NCDK.IAtomContainer,NCDK.IAtom)">
            <summary>
            calculate the electronegativity of orbitals pi.
            </summary>
            <param name="ac">IAtomContainer</param>
            <param name="atom">atom for which effective atom electronegativity should be calculated</param>
            <returns>piElectronegativity</returns>
        </member>
        <member name="M:NCDK.Charges.PiElectronegativity.CalculatePiElectronegativity(NCDK.IAtomContainer,NCDK.IAtom,System.Int32,System.Int32)">
            <summary>
            Calculate the electronegativity of orbitals pi.
            </summary>
            <param name="ac"></param>
            <param name="atom">atom for which effective atom electronegativity should be calculated</param>
            <param name="maxIterations">The maximal number of Iteration</param>
            <param name="maxResonStruc">The maximal number of Resonance Structures</param>
            <returns>Electronegativity of orbitals pi.</returns>
        </member>
        <member name="T:NCDK.Charges.Polarizability">
            <summary>
            Calculation of the polarizability of a molecule by the method of Kang and
            Jhon and Gasteiger based on <token>cdk-cite-KJ81</token> and <token>cdk-cite-GH82</token>
            Limitations in parameterization of atoms:
            H, Csp3, Csp2, Csp2arom, Csp3, Nsp3, Nsp2, Nsp3,
            P, Osp3 and Osp2. Aromaticity must be calculated beforehand.
            </summary>
        </member>
        <member name="M:NCDK.Charges.Polarizability.#ctor">
            <summary>
            Constructor for the Polarizability object.
            </summary>
        </member>
        <member name="M:NCDK.Charges.Polarizability.GetPolarizabilitiyFactorForAtom(NCDK.IAtomContainer,NCDK.IAtom)">
            <summary>
             Gets the polarizabilitiyFactorForAtom.
            </summary>
            <param name="atomContainer">AtomContainer</param>
            <param name="atom">atom for which the factor should become known</param>
            <returns>The polarizabilitiyFactorForAtom value</returns>
        </member>
        <member name="M:NCDK.Charges.Polarizability.CalculateKJMeanMolecularPolarizability(NCDK.IAtomContainer)">
            <summary>
             calculates the mean molecular polarizability as described in paper of Kang and Jhorn.
            </summary>
            <param name="atomContainer">AtomContainer</param>
            <returns>polarizabilitiy</returns>
        </member>
        <member name="M:NCDK.Charges.Polarizability.CalculateGHEffectiveAtomPolarizability(NCDK.IAtomContainer,NCDK.IAtom,System.Int32,System.Boolean)">
            <summary>
             calculate effective atom polarizability.
            </summary>
            <param name="atomContainer">IAtomContainer</param>
            <param name="atom">atom for which effective atom polarizability should be calculated</param>
            <param name="influenceSphereCutOff">cut off for spheres which should taken into account for calculation</param>
            <param name="addExplicitH">if set to true, then explicit H's will be added, otherwise it assumes that they have
             been added to the molecule before being called</param>
            <returns>polarizabilitiy</returns>
        </member>
        <member name="M:NCDK.Charges.Polarizability.CalculateGHEffectiveAtomPolarizability(NCDK.IAtomContainer,NCDK.IAtom,System.Boolean,System.Int32[][])">
            <summary>
            calculate effective atom polarizability.
            </summary>
            <param name="atomContainer">IAtomContainer</param>
            <param name="atom">atom for which effective atom polarizability should be calculated</param>
            <param name="addExplicitH">if set to true, then explicit H's will be added, otherwise it assumes that they have
                                         been added to the molecule before being called</param>
            <param name="distanceMatrix">an n x n matrix of topological distances between all the atoms in the molecule.
                                         if this argument is non-null, then BFS will not be used and instead path lengths will be looked up. This
                                         form of the method is useful, if it is being called for multiple atoms in the same molecule</param>
            <returns>polarizabilitiy</returns>
        </member>
        <member name="M:NCDK.Charges.Polarizability.CalculateBondPolarizability(NCDK.IAtomContainer,NCDK.IBond)">
            <summary>
             calculate bond polarizability.
            </summary>
            <param name="atomContainer">AtomContainer</param>
            <param name="bond">Bond bond for which the polarizabilitiy should be calculated</param>
            <returns>polarizabilitiy</returns>
        </member>
        <member name="M:NCDK.Charges.Polarizability.GetKJPolarizabilityFactor(NCDK.IAtomContainer,NCDK.IAtom)">
            <summary>
             Method which assigns the polarizabilitiyFactors.
            </summary>
            <param name="atomContainer">AtomContainer</param>
            <param name="atom">Atom</param>
            <returns>double polarizabilitiyFactor</returns>
        </member>
        <member name="M:NCDK.Charges.Polarizability.GetNumberOfHydrogen(NCDK.IAtomContainer,NCDK.IAtom)">
            <summary>
             Gets the numberOfHydrogen attribute of the Polarizability object.
            </summary>
            <param name="atomContainer">Description of the Parameter</param>
            <param name="atom">Description of the Parameter</param>
            <returns>The numberOfHydrogen value</returns>
        </member>
        <member name="T:NCDK.Charges.StabilizationCharges">
            <summary>
            The stabilization of the positive and the negative charge
            obtained (e.g in the polar breaking of a bond) is calculated from the sigma- and
             lone pair-electronegativity values of the atoms that are in conjugation to the atoms
             obtaining the charges. Based on H. Saller Dissertation @cdk.cite{SallerH1895}.
            </summary>
        </member>
        <member name="M:NCDK.Charges.StabilizationCharges.#ctor">
            <summary>
            Constructor for the StabilizationCharges object.
            </summary>
        </member>
        <member name="M:NCDK.Charges.StabilizationCharges.CalculatePositive(NCDK.IAtomContainer,NCDK.IAtom)">
            <summary>
            calculate the stabilization of orbitals when they contain deficiency of charge.
            </summary>
            <param name="atomContainer">the molecule to be considered</param>
            <param name="atom">IAtom for which effective atom StabilizationCharges factor should be calculated</param>
            <returns>stabilizationValue</returns>
        </member>
        <member name="T:NCDK.Dict.CDKDictionaryReferences">
             <summary>
             This class transforms implicit references to dictionary of CDK
             objects into explicit references.
             </summary>
             <remarks>
             The syntax of the property names used is as follows:
             org.openscience.cdk.dict:self or
             org.openscience.cdk.dict:field:'fieldname', where fieldname
             indicates a field for this object. The name may be appended
             by :'number' to allow for more than one reference.
            </remarks>
        </member>
        <member name="T:NCDK.Dict.EntryDictionary">
            <summary>
            Dictionary with entries.
            <para>
            FIXME: this should be replaced by an uptodate Dictionary Schema DOM type thing.
            </para>
            </summary>
        </member>
        <member name="T:NCDK.Dict.DictionaryDatabase">
            <summary>
            Database of dictionaries listing entries with compounds, fragments
            and entities.
            </summary>
        </member>
        <member name="M:NCDK.Dict.DictionaryDatabase.ReadDictionary(System.IO.TextReader,System.String)">
            <summary>
            Reads a custom dictionary into the database.
            </summary>
            <param name="reader">The reader from which the dictionary data will be read</param>
            <param name="name">The name of the dictionary</param>
        </member>
        <member name="M:NCDK.Dict.DictionaryDatabase.GetDictionaryNames">
            <summary>
            Returns a string[] with the names of the known dictionaries.
            </summary>
            <returns>The names of the dictionaries</returns>
        </member>
        <member name="M:NCDK.Dict.DictionaryDatabase.GetDictionaryEntries(System.String)">
            <summary>
            Returns a string[] with the id's of all entries in the specified database.
            </summary>
            <returns>The entry names for the specified dictionary</returns>
            <param name="dictionaryName">The name of the dictionary</param>
        </member>
        <member name="M:NCDK.Dict.DictionaryDatabase.HasDictionary(System.String)">
            <summary>
            Returns true if the database contains the dictionary.
            </summary>
        </member>
        <member name="M:NCDK.Dict.DictionaryDatabase.HasEntry(System.String,System.String)">
            <summary>
            Returns true if the given dictionary contains the given entry.
            </summary>
        </member>
        <member name="T:NCDK.Dict.DictionaryHandler">
            <summary>
            Class for unmarshalling a dictionary schema file.
            </summary>
        </member>
        <member name="T:NCDK.Dict.DictRef">
            <summary>
            Object that can be used as key in IChemObject.SetProperty(key, value) to
            denote that this property is a dictionary reference for this IChemObject.
            </summary>
        </member>
        <member name="T:NCDK.Dict.Entry">
            <summary>
            Entry in a Dictionary.
            </summary>
            <seealso cref="T:NCDK.Dict.EntryDictionary"/>
        </member>
        <member name="T:NCDK.Dict.EntryReact">
            <summary>
            Entry in a Dictionary for reactions.
            </summary>
            <seealso cref="T:NCDK.Dict.EntryDictionary"/>
        </member>
        <member name="M:NCDK.Dict.EntryReact.#ctor(System.String,System.String)">
            <summary>
            Constructor of the EntryReact.
            </summary>
            <param name="identifier">The ID value</param>
            <param name="term"></param>
        </member>
        <member name="M:NCDK.Dict.EntryReact.#ctor(System.String)">
            <summary>
            Constructor of the EntryReact.
            </summary>
            <param name="identifier">The ID value</param>
        </member>
        <member name="M:NCDK.Dict.EntryReact.AddRepresentation(System.String)">
            <summary>
            Set the representation of the reaction.
            </summary>
            <param name="contentRepr">The representation of the reaction as string</param>
        </member>
        <member name="P:NCDK.Dict.EntryReact.Representations">
            <summary>
            The Representation of the reaction.
            </summary>
        </member>
        <member name="M:NCDK.Dict.EntryReact.SetParameters(System.String,System.String,System.String)">
            <summary>
            Set the parameters of the reaction.
            </summary>
            <param name="nameParam">The parameter names of the reaction as string</param>
            <param name="typeParam">The parameter types of the reaction as string</param>
            <param name="value">The value default of the parameter</param>
        </member>
        <member name="P:NCDK.Dict.EntryReact.Parameters">
            <summary>
            The parameters of the reaction.
            </summary>
        </member>
        <member name="P:NCDK.Dict.EntryReact.ParameterClass">
            <summary>
            The IParameterReact's of the reaction.
            </summary>
        </member>
        <member name="M:NCDK.Dict.EntryReact.AddParameter(System.Collections.Generic.IList{System.String})">
            <summary>
            Add a IParameterReact's of the reaction.
            </summary>
            <param name="param">A string List containing the information about this parameter.</param>
        </member>
        <member name="P:NCDK.Dict.EntryReact.ParameterValue">
            <summary>
            The parameter value of the reaction.
            </summary>
        </member>
        <member name="P:NCDK.Dict.EntryReact.Mechanism">
            <summary>
            The mechanism of this reaction.
            </summary>
        </member>
        <member name="M:NCDK.Dict.EntryReact.AddExampleReaction(System.String)">
            <summary>
            add a example for this reaction.
            </summary>
            <param name="xml">A reaction in XML scheme</param>
        </member>
        <member name="P:NCDK.Dict.EntryReact.ExampleReactions">
            <summary>
            A List of reactions in XML schema.
            </summary>
        </member>
        <member name="T:NCDK.Dict.OWLFile">
            <summary>
            Dictionary with entries build from an OWL file.
            </summary>
        </member>
        <member name="T:NCDK.Dict.OWLReact">
            <summary>
            Dictionary with entries build from an OWL React.
            </summary>
        </member>
        <member name="M:NCDK.Dict.OWLReact.#ctor">
            <summary>
            Constructor of the <see cref="T:NCDK.Dict.OWLReact"/> object.
            </summary>
        </member>
        <member name="M:NCDK.Dict.OWLReact.Unmarshal(System.IO.TextReader)">
            <summary>
            
            </summary>
            <param name="reader">The Reader</param>
            <returns>The Dictionary</returns>
        </member>
        <member name="T:NCDK.InvalidSmilesException">
            <summary>
            Exception thrown when an error is occurred during SMILES parsing.
            </summary>
        </member>
        <member name="M:NCDK.InvalidSmilesException.#ctor(System.String)">
            <summary>
            Constructs a new exception with a custom message.
            </summary>
            <param name="message">the custom message detailing what may be wrong with the SMILES.</param>
        </member>
        <member name="M:NCDK.InvalidSmilesException.#ctor(System.String,System.Exception)">
            <summary>
            Constructs a new exception with a custom message and a stacktrace.
            </summary>
            <param name="message">the custom message detailing what may be wrong with the SMILES.</param>
            <param name="exception">the underlying exception</param>
        </member>
        <member name="T:NCDK.ForceField.MMFF.Mmff">
            <summary>
            Facade to access Merck Molecular Force Field (MMFF) functions.
            </summary>
            <remarks>
            <list type="bullet">
                <item><token>cdk-cite-Halgren96a</token></item>
                <item><token>cdk-cite-Halgren96b</token></item>
                <item><token>cdk-cite-Halgren96c</token></item>
                <item><token>cdk-cite-Halgren96d</token></item>
                <item><token>cdk-cite-Halgren96e</token></item>     
            </list>
            
            <h4>Atom Types</h4>
            <para>
            Symbolic atom types are assigned with <see cref="M:NCDK.ForceField.MMFF.Mmff.AssignAtomTypes(NCDK.IAtomContainer)" />.
            The atom type name can be accessed with <see cref="P:NCDK.IAtomType.AtomTypeName" />.
            </para>
            <h4>Partial Charges</h4>
            <para>
            Partial charges are assigned with <see cref="M:NCDK.ForceField.MMFF.Mmff.PartialCharges(NCDK.IAtomContainer)" />.
            Atom types must be assigned before calling this function. Effective formal
            charges can also be obtained with <see cref="M:NCDK.ForceField.MMFF.Mmff.EffectiveCharges(NCDK.IAtomContainer)" />
            both charge values are accessed with <see cref="P:NCDK.IAtom.Charge" />. Atoms of
            unknown type are assigned a neutral charge - to avoid this check the return
            value of <see cref="M:NCDK.ForceField.MMFF.Mmff.AssignAtomTypes(NCDK.IAtomContainer)" />.
            </para>
            </remarks>
            <example>
            <!-- No matching elements were found for the following include tag --><include file="IncludeExamples.xml" path="Comments/Codes[@id=&quot;NCDK.ForceField.MMFF.Mmff.cs&quot;]/*" />
            </example>
        </member>
        <member name="M:NCDK.ForceField.MMFF.Mmff.AssignAtomTypes(NCDK.IAtomContainer)">
             <summary>
             Assign MMFF Symbolic atom types. The symbolic type can be accessed with
             <see cref="P:NCDK.IAtomType.AtomTypeName"/>. An atom of unknown type is assigned the
             symbolic type <pre>(UNK'</pre>.
             All atoms, including hydrogens must be explicitly represented.
            
             <param name="mol">molecule</param>
             <returns>all atoms had a type assigned</returns>
             </summary>
        </member>
        <member name="M:NCDK.ForceField.MMFF.Mmff.EffectiveCharges(NCDK.IAtomContainer)">
            <summary>
            Assign the effective formal charges used by MMFF in calculating the
            final partial charge values. Atom types must be assigned first. All 
            existing charges are cleared.
            </summary>
            <param name="mol">molecule</param>
            <returns>charges were assigned</returns>
            <seealso cref="M:NCDK.ForceField.MMFF.Mmff.PartialCharges(NCDK.IAtomContainer)"/>
            <seealso cref="M:NCDK.ForceField.MMFF.Mmff.AssignAtomTypes(NCDK.IAtomContainer)"/>
        </member>
        <member name="M:NCDK.ForceField.MMFF.Mmff.PartialCharges(NCDK.IAtomContainer)">
            <summary>
            Assign the partial charges, all existing charges are cleared.
            Atom types must be assigned first. 
            </summary>
            <param name="mol">molecule</param>
            <returns>charges were assigned</returns>
            <seealso cref="M:NCDK.ForceField.MMFF.Mmff.PartialCharges(NCDK.IAtomContainer)"/>
            <seealso cref="M:NCDK.ForceField.MMFF.Mmff.AssignAtomTypes(NCDK.IAtomContainer)"/>
        </member>
        <member name="M:NCDK.ForceField.MMFF.Mmff.ClearProps(NCDK.IAtomContainer)">
            <summary>
            Clear all transient properties assigned by this class. Assigned charges
            and atom type names remain set.
            </summary>
            <param name="mol">molecule</param>
        </member>
        <member name="M:NCDK.ForceField.MMFF.Mmff.PrimaryCharges(NCDK.IAtomContainer,System.Int32[][],NCDK.Graphs.GraphUtil.EdgeToBondMap)">
            <summary>
            Internal method, MMFF primary charges. Tabulated (MMFFFORMCHG.PAR) and
            variable (assigned in code).
            </summary>
            <param name="mol">molecule</param>
            <param name="adjList">adjacency list representation</param>
            <param name="edgeMap">edge to bond mapping</param>
        </member>
        <member name="M:NCDK.ForceField.MMFF.Mmff.EffectiveCharges(NCDK.IAtomContainer,System.Int32[][])">
            <summary>
            Internal effective charges method.
            </summary>
            <param name="mol">molecule</param>
            <param name="adjList">adjacency list representation</param>
            <seealso cref="M:NCDK.ForceField.MMFF.Mmff.EffectiveCharges(NCDK.IAtomContainer)"/>
        </member>
        <member name="M:NCDK.ForceField.MMFF.Mmff.GetAromatics(NCDK.IAtomContainer)">
            <summary>
            Helper method to find all existing aromatic chem objects.
            </summary>
            <param name="mol">molecule</param>
            <returns>chem objects</returns>
        </member>
        <member name="M:NCDK.ForceField.MMFF.Mmff.FCharge(NCDK.IAtom)">
            <summary>
            Access the formal charge - if the charge is null 0 is returned.
            <param name="atom">atom</param>
            <returns>formal charge</returns>
            </summary>
        </member>
        <member name="T:NCDK.ForceField.MMFF.MmffAromaticTypeMapping">
            <summary>
            Assign MMFF aromatic atom types from the preliminary symbolic type. The assignment is described
            in the appendix of <token>cdk-cite-Halgren96a</token>:
            <para>
            For non-hydrogen atoms, the assignment of symbolic MMFF atom types takes place in two stages. In
            the first, a provisional atom type is assigned based on local connectivity. In the second,
            aromatic systems are perceived, and properly qualified aromatic atom types are assigned based on
            ring size and, for five-membered rings, on the position within the ring. Information in this file
            (MMFFAROM.PAR) is used to make the proper correspondence between provisional and final (aromatic)
            atom types. 
            </para>
            </summary>
            <remarks>
            The column labeled "L5" refers, in the case of 5-ring systems, to the position of the atom in
            question relative to the unique pi-lone-pair containing heteroatom (which itself occupies
            position "1"); a "4" is an artificial entry that is assigned when no such unique heteroatom
            exists, as for example occurs in imidazolium cations and in tetrazole anions. An entry of "1" in
            the "IM CAT" or "N5 ANION" column must also be matched for such ionic species to convert the
            "OLD" (preliminary) to "AROM" (aromatic) symbolic atom type. Note: in matching the "OLD" symbolic
            atom types, an "exact" match is first attempted. If this match fails, a wild-carded match, using
            for example "C*" is then employed. 
            <para>
            This class implements this in three stages. Firstly, the aromatic rings are found with <see cref="M:NCDK.ForceField.MMFF.MmffAromaticTypeMapping.FindAromaticRings(System.Int32[][],System.Int32[],System.Int32[])"/>. 
            These rings are then parsed to <see cref="M:NCDK.ForceField.MMFF.MmffAromaticTypeMapping.UpdateAromaticTypesInSixMemberRing(System.Int32[],System.String[])"/> 
            and <see cref="M:NCDK.ForceField.MMFF.MmffAromaticTypeMapping.UpdateAromaticTypesInFiveMemberRing(System.Int32[],System.String[])"/>.
            The more complex of the two is the five member rings that normalises the ring to put
            the 'pi-lone-pair' hetroatom in position 1. The alpha and beta positions are then fixed and the
            <see cref="F:NCDK.ForceField.MMFF.MmffAromaticTypeMapping.alphaTypes"/>  and <see cref="F:NCDK.ForceField.MMFF.MmffAromaticTypeMapping.betaTypes"/>  mappings are used to obtain the correct assignment.
            </para>
            </remarks>
        </member>
        <member name="M:NCDK.ForceField.MMFF.MmffAromaticTypeMapping.#ctor">
            <summary>
            Create an instance to map from preliminary MMFF symbolic types to their aromatic equivalent.
            </summary>
        </member>
        <member name="M:NCDK.ForceField.MMFF.MmffAromaticTypeMapping.Assign(NCDK.IAtomContainer,System.String[],NCDK.Graphs.GraphUtil.EdgeToBondMap,System.Int32[][],System.Collections.Generic.ISet{NCDK.IBond})">
            <summary>
            Given the assigned preliminary MMFF atom types (symbs[]) update these to the aromatic types.
            To begin, all the 5 and 6 member aromatic cycles are discovered. The symbolic types of five
            and six member cycles are then update with <see cref="M:NCDK.ForceField.MMFF.MmffAromaticTypeMapping.UpdateAromaticTypesInFiveMemberRing(System.Int32[],System.String[])"/>
            and <see cref="M:NCDK.ForceField.MMFF.MmffAromaticTypeMapping.UpdateAromaticTypesInSixMemberRing(System.Int32[],System.String[])"/>.
            </summary>
            <param name="container">structure representation</param>
            <param name="symbs">vector of symbolic types for the whole structure</param>
            <param name="bonds">edge to bond map lookup</param>
            <param name="graph">adjacency list graph representation of structure</param>
            <param name="mmffArom">set of bonds that are aromatic</param>
        </member>
        <member name="M:NCDK.ForceField.MMFF.MmffAromaticTypeMapping.FindAromaticRings(System.Int32[][],System.Int32[],System.Int32[])">
            <summary>
            From a provided set of cycles find the 5/6 member cycles that fit the MMFF aromaticity
            definition - <see cref="M:NCDK.ForceField.MMFF.MmffAromaticTypeMapping.IsAromaticRing(System.Int32[],System.Int32[],System.Int32[],System.Boolean[])"/>. The cycles of size 6
            are listed first.
            </summary>
            <param name="cycles">initial set of cycles from</param>
            <param name="contribution">vector of p electron contributions from each vertex</param>
            <param name="dbs">vector of double-bond pairs, index stored double-bonded index</param>
            <returns>the cycles that are aromatic</returns>
        </member>
        <member name="M:NCDK.ForceField.MMFF.MmffAromaticTypeMapping.IsAromaticRing(System.Int32[],System.Int32[],System.Int32[],System.Boolean[])">
            <summary>
            Check if a cycle/ring is aromatic. A cycle is aromatic if the sum of its p electrons is equal
            to 4n+2. Double bonds can only contribute if they are in the cycle being tested or are
            already delocalised.
            </summary>
            <param name="cycle">closed walk of vertices in the cycle</param>
            <param name="contribution">vector of p electron contributions from each vertex</param>
            <param name="dbs">vector of double-bond pairs, index stored double-bonded index</param>
            <param name="aromatic">binary set of aromatic atoms</param>
            <returns>whether the ring is aromatic</returns>
        </member>
        <member name="M:NCDK.ForceField.MMFF.MmffAromaticTypeMapping.UpdateAromaticTypesInSixMemberRing(System.Int32[],System.String[])">
            <summary>
            Update aromatic atom types in a six member ring. The aromatic types here are hard coded from
            the 'MMFFAROM.PAR' file.
            </summary>
            <param name="cycle">6-member aromatic cycle / ring</param>
            <param name="symbs">vector of symbolic types for the whole structure</param>
        </member>
        <member name="M:NCDK.ForceField.MMFF.MmffAromaticTypeMapping.UpdateAromaticTypesInFiveMemberRing(System.Int32[],System.String[])">
            <summary>
            Update the symbolic for a 5-member cycle/ring. The cycle should first be normalised with
            <see cref="M:NCDK.ForceField.MMFF.MmffAromaticTypeMapping.NormaliseCycle(System.Int32[],System.Int32[])"/> to put the unique 'pi-lone-pair' in position 1 (index
            0). Using predefined mappings the symbolic atom types are updated in the 'symbs[]' vector.
            </summary>
            <param name="cycle">normalised 5-member cycle (6 indices)</param>
            <param name="symbs">vector of symbolic types for the whole structure</param>
        </member>
        <member name="M:NCDK.ForceField.MMFF.MmffAromaticTypeMapping.GetAlphaAromaticType(System.String,System.Boolean,System.Boolean)">
            <summary>
            Convenience method to obtain the aromatic type of a symbolic (SYMB) type in the alpha
            position of a 5-member ring. This method delegates to <see cref="M:NCDK.ForceField.MMFF.MmffAromaticTypeMapping.GetAromaticType(System.Collections.Generic.IDictionary{System.String,System.String},System.Char,System.String,System.Boolean,System.Boolean)"/>
            setup for alpha atoms.
            </summary>
            <param name="symb">symbolic atom type</param>
            <param name="imidazolium">imidazolium flag (IM naming from MMFFAROM.PAR)</param>
            <param name="anion">anion flag (AN naming from MMFFAROM.PAR)</param>
            <returns>the aromatic type</returns>
        </member>
        <member name="M:NCDK.ForceField.MMFF.MmffAromaticTypeMapping.GetBetaAromaticType(System.String,System.Boolean,System.Boolean)">
            <summary>
            Convenience method to obtain the aromatic type of a symbolic (SYMB) type in the beta position
            of a 5-member ring. This method delegates to <see cref="M:NCDK.ForceField.MMFF.MmffAromaticTypeMapping.GetAromaticType(System.Collections.Generic.IDictionary{System.String,System.String},System.Char,System.String,System.Boolean,System.Boolean)"/>
            setup for beta atoms.
            </summary>
            <param name="symb">symbolic atom type</param>
            <param name="imidazolium">imidazolium flag (IM naming from MMFFAROM.PAR)</param>
            <param name="anion">anion flag (AN naming from MMFFAROM.PAR)</param>
            <returns>the aromatic type</returns>
        </member>
        <member name="M:NCDK.ForceField.MMFF.MmffAromaticTypeMapping.GetAromaticType(System.Collections.Generic.IDictionary{System.String,System.String},System.Char,System.String,System.Boolean,System.Boolean)">
            <summary>
            Obtain the aromatic atom type for an atom in the alpha or beta position of a 5-member
            aromatic ring. The method primarily uses an HashMap to lookup up the aromatic type. The two
            maps are, <see cref="F:NCDK.ForceField.MMFF.MmffAromaticTypeMapping.alphaTypes"/> and <see cref="F:NCDK.ForceField.MMFF.MmffAromaticTypeMapping.betaTypes"/>. Depending on the position (alpha or
            beta), one map is passed to the method. The exceptions to using the HashMap directly are as
            follows: 1) if AN flag is raised and the symbolic type is a nitrogen, the type is 'N5M'. 2)
            If the IM or AN flag is raised, the atom is 'C5' or 'N5 instead of 'C5A', 'C5B', 'N5A', or
            'N5B'. This is because the hetroatom in these rings can resonate and so the atom is both
            alpha and beta.
            </summary>
            <param name="map">mapping of alpha or beta types</param>
            <param name="suffix">'A' or 'B'</param>
            <param name="symb">input symbolic type</param>
            <param name="imidazolium">imidazolium flag (IM naming from MMFFAROM.PAR)</param>
            <param name="anion">anion flag (AN naming from MMFFAROM.PAR)</param>
            <returns>the aromatic type</returns>
        </member>
        <member name="M:NCDK.ForceField.MMFF.MmffAromaticTypeMapping.IndexOfHetro(System.Int32[],System.Int32[])">
            <summary>
            Find the index of a hetroatom in a cycle. A hetroatom in MMFF is the unique atom that
            contributes a pi-lone-pair to the aromatic system.
            </summary>
            <param name="cycle">aromatic cycle, |C| = 5</param>
            <param name="contribution">vector of p electron contributions from each vertex</param>
            <returns>index of hetroatom, if none found index is &lt; 0.</returns>
        </member>
        <member name="M:NCDK.ForceField.MMFF.MmffAromaticTypeMapping.NormaliseCycle(System.Int32[],System.Int32[])">
            <summary>
            Normalises a 5-member 'cycle' such that the hetroatom contributing the lone-pair is in
            position 1 (index 0). The alpha atoms are then in index 1 and 4 whilst the beta atoms are in
            index 2 and 3. If the ring contains more than one hetroatom the cycle is not normalised
            (return=false).
            </summary>
            <param name="cycle">aromatic cycle to normalise, |C| = 5</param>
            <param name="contribution">vector of p electron contributions from each vertex (size |V|)</param>
            <returns>whether the cycle was normalised</returns>
        </member>
        <member name="M:NCDK.ForceField.MMFF.MmffAromaticTypeMapping.Contribution(System.Int32,System.Int32,System.Int32)">
            <summary>
            Electron contribution of an element with the specified connectivity and valence.
            </summary>
            <param name="elem">atomic number</param>
            <param name="x">connectivity</param>
            <param name="v">bonded valence</param>
            <returns>p electrons</returns>
        </member>
        <member name="M:NCDK.ForceField.MMFF.MmffAromaticTypeMapping.CyclesOfSizeFiveOrSix(NCDK.IAtomContainer,System.Int32[][])">
            <summary>
            Locate all 5 and 6 member cycles (rings) in a structure representation.
            </summary>
            <param name="container">structure representation</param>
            <param name="graph">adjacency list graph representation of structure</param>
            <returns>closed walks (first = last vertex) of the cycles</returns>
        </member>
        <member name="M:NCDK.ForceField.MMFF.MmffAromaticTypeMapping.SetupContributionAndDoubleBonds(NCDK.IAtomContainer,NCDK.Graphs.GraphUtil.EdgeToBondMap,System.Int32[][],System.Int32[],System.Int32[])">
            <summary>
            Internal - sets up the 'contribution' and 'dbs' vectors. These define how many pi electrons
            an atom can contribute and provide a lookup of the double bonded neighbour.
            </summary>
            <param name="molecule">structure representation</param>
            <param name="bonds">edge to bond map lookup</param>
            <param name="graph">adjacency list graph representation of structure</param>
            <param name="contribution">vector of p electron contributions from each vertex</param>
            <param name="dbs">vector of double-bond pairs, index stored double-bonded index</param>
        </member>
        <member name="F:NCDK.ForceField.MMFF.MmffAromaticTypeMapping.hetroTypes">
            <summary>
            Mapping of preliminary atom MMFF symbolic types to aromatic types for atoms that contribute a
            lone pair.
            </summary>
        </member>
        <member name="F:NCDK.ForceField.MMFF.MmffAromaticTypeMapping.alphaTypes">
            <summary>
            Mapping of preliminary atom MMFF symbolic types to aromatic types for atoms that contribute
            one electron and are alpha to an atom that contributes a lone pair.
            </summary>
        </member>
        <member name="F:NCDK.ForceField.MMFF.MmffAromaticTypeMapping.betaTypes">
            <summary>
            Mapping of preliminary atom MMFF symbolic types to aromatic types for atoms that contribute
            one electron and are beta to an atom that contributes a lone pair.
            </summary>
        </member>
        <member name="T:NCDK.ForceField.MMFF.MmffAtomTypeMatcher">
            <summary>
            Determine the MMFF symbolic atom types <token>cdk-cite-Halgren96a</token>. The matcher uses SMARTS patterns
            to assign preliminary symbolic types. The types are then adjusted considering aromaticity
            <see cref="T:NCDK.ForceField.MMFF.MmffAromaticTypeMapping" />. The assigned atom types validate completely with the validation suite
            (http://server.ccl.net/cca/data/MMFF94/).
            </summary>
            <example>
            <code>            MmffAtomTypeMatcher mmffAtomTypes = new MmffAtomTypeMatcher();
            foreach (var container in containers)
            {
                string[] symbs = mmffAtomTypes.SymbolicTypes(container);
            }
</code>
            </example>
        </member>
        <member name="F:NCDK.ForceField.MMFF.MmffAtomTypeMatcher.aromaticTypes">
            <summary>Aromatic types are assigned by this class.</summary>
        </member>
        <member name="F:NCDK.ForceField.MMFF.MmffAtomTypeMatcher.patterns">
            <summary>Substructure patterns for atom types.</summary>
        </member>
        <member name="F:NCDK.ForceField.MMFF.MmffAtomTypeMatcher.hydrogenMap">
            <summary>Mapping of parent to hydrogen symbols.</summary>
        </member>
        <member name="M:NCDK.ForceField.MMFF.MmffAtomTypeMatcher.#ctor">
            <summary>
            Create a new MMFF atom type matcher, definitions are loaded at instantiation.
            </summary>
        </member>
        <member name="M:NCDK.ForceField.MMFF.MmffAtomTypeMatcher.SymbolicTypes(NCDK.IAtomContainer)">
            <summary>
            Obtain the MMFF symbolic types to the atoms of the provided structure.
            </summary>
            <param name="container">container structure representation</param>
            <returns>MMFF symbolic types for each atom index</returns>
        </member>
        <member name="M:NCDK.ForceField.MMFF.MmffAtomTypeMatcher.SymbolicTypes(NCDK.IAtomContainer,System.Int32[][],NCDK.Graphs.GraphUtil.EdgeToBondMap,System.Collections.Generic.ISet{NCDK.IBond})">
            <summary>
            Obtain the MMFF symbolic types to the atoms of the provided structure.
            </summary>
            <param name="container">structure representation</param>
            <param name="graph">adj list data structure</param>
            <param name="bonds">bond lookup map</param>
            <param name="mmffArom">flags which bonds are aromatic by MMFF model</param>
            <returns>MMFF symbolic types for each atom index</returns>
        </member>
        <member name="M:NCDK.ForceField.MMFF.MmffAtomTypeMatcher.FixNCNTypes(System.String[],System.Int32[][])">
            <summary>
            Special case, 'NCN+' matches entries that the validation suite say should actually be 'NC=N'.
            We can achieve 100% compliance by checking if NCN+ is still next to CNN+ or CIM+ after
            aromatic types are assigned
            </summary>
            <param name="symbs">symbolic types</param>
            <param name="graph">adjacency list graph</param>
        </member>
        <member name="M:NCDK.ForceField.MMFF.MmffAtomTypeMatcher.CheckPreconditions(NCDK.IAtomContainer)">
            <summary>
            preconditions, 1. all hydrogens must be present as explicit nodes in the connection table.
            this requires that each atom explicitly states it has exactly 0 hydrogens 2. the SMARTS treat
            all atoms as aliphatic and therefore no aromatic flags should be set, we could remove this
            but ideally we don't want to modify the structure
            </summary>
            <param name="container">input structure representation</param>
        </member>
        <member name="M:NCDK.ForceField.MMFF.MmffAtomTypeMatcher.AssignHydrogenTypes(NCDK.IAtomContainer,System.String[],System.Int32[][])">
            <summary>
            Hydrogen types, assigned based on the MMFFHDEF.PAR parent associations.
            </summary>
            <param name="container">input structure representation</param>
            <param name="symbs">symbolic atom types</param>
            <param name="graph">adjacency list graph</param>
        </member>
        <member name="M:NCDK.ForceField.MMFF.MmffAtomTypeMatcher.AssignPreliminaryTypes(NCDK.IAtomContainer,System.String[])">
            <summary>
            Preliminary atom types are assigned using SMARTS definitions.
            </summary>
            <param name="container">input structure representation</param>
            <param name="symbs">symbolic atom types</param>
        </member>
        <member name="M:NCDK.ForceField.MMFF.MmffAtomTypeMatcher.LoadPatterns(System.IO.Stream)">
            <summary>
            Internal - load the SMARTS patterns for each atom type from MMFFSYMB.sma.
            </summary>
            <param name="smaIn">input stream of MMFFSYMB.sma</param>
            <returns>array of patterns</returns>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NCDK.ForceField.MMFF.MmffAtomTypeMatcher.LoadHydrogenDefinitions(System.IO.Stream)">
            <summary>
            Hydrogen atom types are assigned based on their parent types. The mmff-symb-mapping file
            provides this mapping.
            </summary>
            <param name="hdefIn">input stream of mmff-symb-mapping.tsv</param>
            <returns>mapping of parent to hydrogen definitions</returns>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NCDK.ForceField.MMFF.MmffAtomTypeMatcher.SkipLine(System.String)">
            <summary>
            A line is skipped if it is empty or is a comment. MMFF files use '*' to mark comments and '$'
            for end of file.
            </summary>
            <param name="line">an input line</param>
            <returns>whether to skip this line</returns>
        </member>
        <member name="M:NCDK.ForceField.MMFF.MmffAtomTypeMatcher.Close(System.IO.Stream)">
            <summary>
            Safely close an input stream.
            </summary>
            <param name="ins">stream to close</param>
        </member>
        <member name="T:NCDK.ForceField.MMFF.MmffAtomTypeMatcher.AtomTypePattern">
            <summary>
            A class that associates a pattern instance with the MMFF symbolic type. Using SMARTS the
            implied type is at index 0. The matching could be improved in future to skip subgraph
            matching of all typed atoms.
            </summary>
        </member>
        <member name="M:NCDK.ForceField.MMFF.MmffAtomTypeMatcher.AtomTypePattern.#ctor(NCDK.Isomorphisms.Pattern,System.String)">
            <summary>
            Create the atom type pattern.
            </summary>
            <param name="pattern">substructure pattern</param>
            <param name="symb">MMFF symbolic type</param>
        </member>
        <member name="M:NCDK.ForceField.MMFF.MmffAtomTypeMatcher.AtomTypePattern.Matches(NCDK.IAtomContainer)">
            <summary>
            Find the atoms that match this atom type.
            </summary>
            <param name="container">container structure representation</param>
            <returns>indices of atoms that matched this type</returns>
        </member>
        <member name="T:NCDK.ForceField.MMFF.MmffParamSet">
            <summary>
            Internal class for accessing MMFF parameters.
            </summary>
        </member>
        <member name="F:NCDK.ForceField.MMFF.MmffParamSet.bcis">
            <summary>
            Bond charge increments.
            </summary>
        </member>
        <member name="F:NCDK.ForceField.MMFF.MmffParamSet.properties">
            <summary>
            Atom type properties.
            </summary>
        </member>
        <member name="F:NCDK.ForceField.MMFF.MmffParamSet.fCharges">
            <summary>
            Symbolic formal charges - some are varible and assigned in code.
            </summary>
        </member>
        <member name="M:NCDK.ForceField.MMFF.MmffParamSet.IntType(System.String)">
            <summary>
            Obtain the integer MMFF atom type for a given symbolic MMFF type.
            </summary>
            <param name="sym">Symbolic MMFF type</param>
            <returns>integer MMFF type</returns>
        </member>
        <member name="M:NCDK.ForceField.MMFF.MmffParamSet.GetBondChargeIncrement(System.Int32,System.Int32,System.Int32)">
            <summary>
            Access bond charge increment (bci) for a bond between two atoms (referred
            to by MMFF integer type).
            </summary>
            <param name="cls">bond class</param>
            <param name="type1">first atom type</param>
            <param name="type2">second atom type</param>
            <returns>bci</returns>
        </member>
        <member name="M:NCDK.ForceField.MMFF.MmffParamSet.GetPartialBondChargeIncrement(System.Int32)">
            <summary>
            Access Partial Bond Charge Increments (pbci).
            </summary>
            <param name="atype">integer atom type</param>
            <returns>pbci</returns>
        </member>
        <member name="M:NCDK.ForceField.MMFF.MmffParamSet.GetFormalChargeAdjustment(System.Int32)">
            <summary>
            Access Formal charge adjustment factor.
            </summary>
            <param name="atype">integer atom type</param>
            <returns>adjustment factor</returns>
        </member>
        <member name="M:NCDK.ForceField.MMFF.MmffParamSet.GetCrd(System.Int32)">
            <summary>
            Access the CRD for an MMFF int type.
            </summary>
            <param name="atype">int atom type</param>
            <returns>CRD</returns>
        </member>
        <member name="M:NCDK.ForceField.MMFF.MmffParamSet.GetFormalCharge(System.String)">
            <summary>
            Access the tabulated formal charge (may be fractional) for
            a symbolic atom type. Some formal charges are variable and
            need to be implemented in code.
            </summary>
            <param name="symb">symbolic type</param>
            <returns>formal charge</returns>
        </member>
        <member name="M:NCDK.ForceField.MMFF.MmffParamSet.GetBondCls(System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            see. MMFF Part V - p 620, a nonstandard bond-type index of ‚Äú1‚Äù is
            assigned whenever a single bond (formal bond order 1) is found: (a)
            between atoms i and j of types that are not both aromatic and for which
            ‚Äùsbmb‚Äù entries of ‚Äù1‚Äù appear in Table I; or (b) between pairs of atoms
            belonging to different aromatic rings (as in the case of the connecting
            C-C bond in biphenyl).
            </summary>
        </member>
        <member name="T:NCDK.ForceField.MMFF.MmffParamSet.BondKey">
            <summary>
            Key for indexing bond parameters by
            </summary>
        </member>
        <member name="F:NCDK.ForceField.MMFF.MmffParamSet.BondKey.cls">
            <summary>Bond class.</summary>
        </member>
        <member name="F:NCDK.ForceField.MMFF.MmffParamSet.BondKey.type1">
            <summary>
            MMFF atom types for the bond.
            </summary>
        </member>
        <member name="F:NCDK.ForceField.MMFF.MmffParamSet.BondKey.type2">
            <summary>
            MMFF atom types for the bond.
            </summary>
        </member>
        <member name="T:NCDK.ForceField.MMFF.MmffParamSet.MmffProp">
            <summary>
            Properties of an MMFF atom type.
            </summary>
        </member>
        <member name="T:NCDK.Fragments.ExhaustiveFragmenter">
            <summary>
            Generate fragments exhaustively.
            </summary>
            <remarks>
            This fragmentation scheme simply breaks single non-ring bonds. By default
            fragments smaller than 6 atoms in size are not considered, but this can be
            changed by the user. Side chains are retained.
            </remarks>
        </member>
        <member name="P:NCDK.Fragments.ExhaustiveFragmenter.MinimumFragmentSize">
            <summary>
            The minimum fragment size.
            </summary>
        </member>
        <member name="M:NCDK.Fragments.ExhaustiveFragmenter.#ctor">
            <summary>
            Instantiate fragmenter with default minimum fragment size.
            </summary>
        </member>
        <member name="M:NCDK.Fragments.ExhaustiveFragmenter.#ctor(System.Int32)">
            <summary>
            Instantiate fragmenter with user specified minimum fragment size.
            </summary>
            <param name="minFragSize">the minimum fragment size desired</param>
        </member>
        <member name="M:NCDK.Fragments.ExhaustiveFragmenter.GenerateFragments(NCDK.IAtomContainer)">
            <summary>
            Generate fragments for the input molecule.
            </summary>
            <param name="atomContainer">The input molecule.</param>
        </member>
        <member name="M:NCDK.Fragments.ExhaustiveFragmenter.GetFragments">
            <summary>
            Get the fragments generated as SMILES strings.
            </summary>
            <returns>a string[] of the fragments.</returns>
        </member>
        <member name="M:NCDK.Fragments.ExhaustiveFragmenter.GetFragmentsAsContainers">
            <summary>
            Get the fragments generated as <see cref="T:NCDK.IAtomContainer"/> objects..
            </summary>
            <returns>a IAtomContainer[] of the fragments.</returns>
        </member>
        <member name="T:NCDK.Fragments.FragmentUtils">
            <summary>
            Helper methods for fragmentation algorithms.
            </summary>
            <remarks>
            Most of these methods are specific to the fragmentation algorithms
            in this package and so are protected. In general, these methods will
            not be used by the rest of the API or by other users of the library.
            </remarks>
        </member>
        <member name="M:NCDK.Fragments.FragmentUtils.SplitMolecule(NCDK.IAtomContainer,NCDK.IBond)">
            <summary>
            Non destructively split a molecule into two parts at the specified bond.
            </summary>
            <remarks>
            Note that if a ring bond is specified, the resultant list will contain
            teh opened ring twice.
            </remarks>
            <param name="atomContainer">The molecule to split</param>
            <param name="bond">The bond to split at</param>
            <returns>A list containing the two parts of the molecule</returns>
        </member>
        <member name="M:NCDK.Fragments.FragmentUtils.MakeAtomContainer(NCDK.IAtom,System.Collections.Generic.IEnumerable{NCDK.IBond},NCDK.IAtom)">
            Given a list of bonds representing a fragment obtained by splitting the molecule
            at a bond, we need to create an IAtomContainer from it, containing *one* of the atoms
            of the splitting bond. In addition, the new IAtomContainer should not contain the
            splitting bond itself
        </member>
        <member name="T:NCDK.Fragments.IFragmenter">
            <summary>
            An interface for classes implementing fragmentation algorithms.
            </summary>
        </member>
        <member name="M:NCDK.Fragments.IFragmenter.GenerateFragments(NCDK.IAtomContainer)">
            <summary>
            Generate fragments for the input molecule.
            </summary>
            <param name="atomContainer">The input molecule</param>
            <exception cref="T:NCDK.CDKException">if ring detection fails</exception>
        </member>
        <member name="M:NCDK.Fragments.IFragmenter.GetFragments">
            <summary>
            Get the fragments generated as SMILES strings.
            </summary>
            <returns>a string[] of the fragments.</returns>
        </member>
        <member name="M:NCDK.Fragments.IFragmenter.GetFragmentsAsContainers">
            <summary>
            Get fragments generated as <see cref="T:NCDK.IAtomContainer"/> objects.
            </summary>
            <returns>an IAtomContainer[] of fragments</returns>
        </member>
        <member name="T:NCDK.Fragments.MurckoFragmenter">
            <summary>
            An implementation of the Murcko fragmenation method <token>cdk-cite-MURCKO96</token>.
            </summary>
            <remarks>
            As an implementation of <see cref="T:NCDK.Fragments.IFragmenter"/> this class will return
            the Murcko frameworks (i.e., ring systems + linkers) along with
            the ring systems ia getFragments. The
            class also provides methods to extract the ring systems and frameworks
            separately. For all these methods, the user can retrieve the substructures
            as canonical SMILES strings or as <see cref="T:NCDK.IAtomContainer"/> objects.
            <para>
            Note that in contrast to the original paper which implies that a single molecule
            has a single framework, this class returns multiple frameworks consisting of all
            combinations of ring systems and linkers. The "true" Murcko framework is simply
            the largest framework.
            </para>
            </remarks>
        </member>
        <member name="M:NCDK.Fragments.MurckoFragmenter.#ctor">
            <summary>
            Instantiate Murcko fragmenter.
            </summary>
            <remarks>
            Considers fragments with 5 or more atoms and generates multiple
            frameworks if available.
            </remarks>
        </member>
        <member name="M:NCDK.Fragments.MurckoFragmenter.#ctor(System.Boolean,System.Int32)">
            <summary>
            Instantiate Murcko fragmenter.
            </summary>
            <param name="singleFrameworkOnly">if <see langword="true"/>, only the true Murcko framework is generated.</param>
            <param name="minimumFragmentSize">the smallest size of fragment to consider</param>
        </member>
        <member name="M:NCDK.Fragments.MurckoFragmenter.#ctor(System.Boolean,System.Int32,NCDK.Hash.IMoleculeHashGenerator)">
            <summary>
            Instantiate Murcko fragmenter.
            </summary>
            <param name="singleFrameworkOnly">if <see langword="true"/>, only the true Murcko framework is generated.</param>
            <param name="minimumFragmentSize">the smallest size of fragment to consider</param>
            <param name="generator">An instance of a <see cref="T:NCDK.Hash.IMoleculeHashGenerator"/> to be used to check for duplicate fragments</param>
        </member>
        <member name="M:NCDK.Fragments.MurckoFragmenter.GenerateFragments(NCDK.IAtomContainer)">
            <summary>
            Perform the fragmentation procedure.
            </summary>
            <param name="atomContainer">The input molecule</param>
            <exception cref="T:NCDK.CDKException"></exception>
        </member>
        <member name="M:NCDK.Fragments.MurckoFragmenter.GetFragments">
            <summary>
            This returns the frameworks and ring systems from a Murcko fragmentation.
            </summary>
            <remarks>
            To get frameworks, ring systems and side chains seperately, use the
            respective functions
            </remarks>
            <returns>a string[] of the fragments.</returns>
            <seealso cref="M:NCDK.Fragments.MurckoFragmenter.GetRingSystems"/>
            <seealso cref="M:NCDK.Fragments.MurckoFragmenter.GetRingSystemsAsContainers"/>
            <seealso cref="M:NCDK.Fragments.MurckoFragmenter.GetFrameworks"/>
            <seealso cref="M:NCDK.Fragments.MurckoFragmenter.GetFrameworksAsContainers"/>
        </member>
        <member name="M:NCDK.Fragments.MurckoFragmenter.GetFragmentsAsContainers">
            <summary>
            Get all frameworks and ring systems as <see cref="T:NCDK.IAtomContainer"/> objects.
            </summary>
            <returns>An array of structures representing frameworks and ring systems</returns>
        </member>
        <member name="M:NCDK.Fragments.MurckoFragmenter.GetRingSystems">
            <summary>
            Get the ring system fragments as SMILES strings.
            </summary>
            <returns>The fragments.</returns>
        </member>
        <member name="M:NCDK.Fragments.MurckoFragmenter.GetRingSystemsAsContainers">
            <summary>
            Get rings systems as <see cref="T:NCDK.IAtomContainer"/> objects.
            </summary>
            <returns>an array of ring systems.</returns>
        </member>
        <member name="M:NCDK.Fragments.MurckoFragmenter.GetFrameworks">
            <summary>
            Get frameworks as SMILES strings.
            </summary>
            <returns>an array of SMILES strings</returns>
        </member>
        <member name="M:NCDK.Fragments.MurckoFragmenter.GetFrameworksAsContainers">
            <summary>
            Get frameworks as <see cref="T:NCDK.IAtomContainer"/> as objects.
            </summary>
            <returns>an array of frameworks.</returns>
        </member>
        <member name="T:NCDK.IImplementationSpecification">
            <summary>
            Interface that is used to describe the specification of a certain
            implementation of an algorithm.
            </summary>
        </member>
        <member name="P:NCDK.IImplementationSpecification.SpecificationReference">
            <summary>
            Pointer to a dictionary or ontology describing a unique algorithm.
            </summary>
            <returns>the URN pointing to a (virtual) dictionary or ontology.</returns>
        </member>
        <member name="P:NCDK.IImplementationSpecification.ImplementationTitle">
             <summary>
             Human-readable name for the implementation for the algorithm
             specified by the reference.
            
             <returns>the name of this implementation</returns>
             </summary>
        </member>
        <member name="P:NCDK.IImplementationSpecification.ImplementationIdentifier">
            <summary>
            Identifier for this implementation which must include
            version information. The format is free.
            </summary>
            <returns>a free format identifier for this implementation</returns>
        </member>
        <member name="P:NCDK.IImplementationSpecification.ImplementationVendor">
            <summary>
            Human-readable name for the vendor that holds copyright for this implementation.
            </summary>
            <returns>the copyright holder of the implementation</returns>
        </member>
        <member name="T:NCDK.IReactionScheme">
            <summary>
            Classes that implement this interface of a scheme.
            This is designed to contain a set of reactions which are linked in
            some way but without hard coded semantics.
            </summary>
        </member>
        <member name="M:NCDK.IReactionScheme.Add(NCDK.IReactionScheme)">
            <summary>
            Add a scheme of reactions.
            </summary>
            <param name="reactScheme">The <see cref="T:NCDK.IReactionScheme"/> to include</param>
        </member>
        <member name="P:NCDK.IReactionScheme.Schemes">
            <summary>
            ll schemes in this scheme.
            </summary>
        </member>
        <member name="P:NCDK.IReactionScheme.Reactions">
            <summary>
            The reactions in this scheme.
            </summary>
        </member>
        <member name="M:NCDK.IReactionScheme.Remove(NCDK.IReactionScheme)">
            <summary>
            Removes an <see cref="T:NCDK.IReactionScheme"/> from this.
            </summary>
            <param name="scheme">The scheme to be removed from this </param>
        </member>
        <member name="T:NCDK.Layout.AtomPlacer">
            <summary>
             Methods for generating coordinates for atoms in various situations. They can
             be used for Automated Structure Diagram Generation or in the interactive
             buildup of molecules by the user.
            </summary>
        </member>
        <member name="M:NCDK.Layout.AtomPlacer.#ctor">
            <summary>
             Constructor for the AtomPlacer object
            </summary>
        </member>
        <member name="P:NCDK.Layout.AtomPlacer.Molecule">
            <summary>
            The molecule the AtomPlacer currently works with
            </summary>
        </member>
        <member name="M:NCDK.Layout.AtomPlacer.DistributePartners(NCDK.IAtom,NCDK.IAtomContainer,NCDK.Numerics.Vector2,NCDK.IAtomContainer,System.Double)">
            <summary>
             Distribute the bonded atoms (neighbours) of an atom such that they fill the
             remaining space around an atom in a geometrically nice way.
             IMPORTANT: This method is not supposed to handle the
             case of one or no place neighbor. In the case of
             one placed neigbor, the chain placement methods
             should be used.
            </summary>
            <param name="atom">The atom whose partners are to be placed</param>
            <param name="placedNeighbours">The atoms which are already placed</param>
            <param name="unplacedNeighbours">The partners to be placed</param>
            <param name="bondLength">The standared bond length for the newly placed Atoms</param>
            <param name="sharedAtomsCenter">The 2D centre of the placed Atoms</param>
        </member>
        <member name="M:NCDK.Layout.AtomPlacer.PlaceLinearChain(NCDK.IAtomContainer,NCDK.Numerics.Vector2,System.Double)">
            <summary>
            Places the atoms in a linear chain.
            </summary>
            <remarks>
            Expects the first atom to be placed and
            places the next atom according to initialBondVector. The rest of the chain
            is placed such that it is as linear as possible (in the overall result, the
            angles in the chain are set to 120 Deg.)
            </remarks>
            <param name="atomContainer">The IAtomContainer containing the chain atom to be placed</param>
            <param name="initialBondVector">The Vector indicating the direction of the first bond</param>
            <param name="bondLength">The factor used to scale the initialBondVector</param>
        </member>
        <member name="M:NCDK.Layout.AtomPlacer.GetNextBondVector(NCDK.IAtom,NCDK.IAtom,NCDK.Numerics.Vector2,System.Boolean)">
            <summary>
             Returns the next bond vector needed for drawing an extended linear chain of
             atoms. It assumes an angle of 120 deg for a nice chain layout and
             calculates the two possible placments for the next atom. It returns the
             vector pointing farmost away from a given start atom.
            </summary>
            <param name="atom">An atom for which the vector to the next atom to draw is calculated</param>
            <param name="previousAtom">The preceding atom for angle calculation</param>
            <param name="distanceMeasure">A point from which the next atom is to be farmost away</param>
            <param name="trans">if true E (trans) configurations are built, false makes Z (cis) configurations</param>
            <returns>A vector pointing to the location of the next atom to draw</returns>
        </member>
        <member name="M:NCDK.Layout.AtomPlacer.PopulatePolygonCorners(System.Collections.Generic.IList{NCDK.IAtom},NCDK.Numerics.Vector2,System.Double,System.Double,System.Double)">
            <summary>
             Populates the corners of a polygon with atoms. Used to place atoms in a
             geometrically regular way around a ring center or another atom. If this is
             used to place the bonding partner of an atom (and not to draw a ring) we
             want to place the atoms such that those with highest "weight" are placed
             farmost away from the rest of the molecules. The "weight" mentioned here is
             calculated by a modified morgan number algorithm.
            </summary>
            <param name="atoms">All the atoms to draw</param>
            <param name="thetaBeg">A start angle (in radians), giving the angle of the most clockwise                  atom which has already been placed</param>
            <param name="thetaStep">An angle (in radians) to be added for each atom from                  atomsToDraw</param>
            <param name="center">The center of a ring, or an atom for which the                  partners are to be placed</param>
            <param name="radius">The radius of the polygon to be populated: bond length or ring radius</param>
        </member>
        <member name="M:NCDK.Layout.AtomPlacer.PartitionPartners(NCDK.IAtom,NCDK.IAtomContainer,NCDK.IAtomContainer)">
            <summary>
             Partition the bonding partners of a given atom into placed (coordinates assinged) and not placed.
            </summary>
            <param name="atom">The atom whose bonding partners are to be partitioned</param>
            <param name="unplacedPartners">A vector for the unplaced bonding partners to go in</param>
            <param name="placedPartners">A vector for the placed bonding partners to go in</param>
        </member>
        <member name="M:NCDK.Layout.AtomPlacer.GetInitialLongestChain(NCDK.IAtomContainer)">
            <summary>
             Search an aliphatic molecule for the longest chain. This is the method to
             be used if there are no rings in the molecule and you want to layout the
             longest chain in the molecule as a starting point of the structure diagram
             generation.
            </summary>
            <param name="molecule">The molecule to be search for the longest unplaced chain</param>
            <returns>An AtomContainer holding the longest chain.</returns>
            <exception cref="T:NCDK.NoSuchAtomException">Description of the Exception</exception>
        </member>
        <member name="M:NCDK.Layout.AtomPlacer.GetLongestUnplacedChain(NCDK.IAtomContainer,NCDK.IAtom)">
            <summary>
             Search a molecule for the longest unplaced, aliphatic chain in it. If an
             aliphatic chain encounters an unplaced ring atom, the ring atom is also
             appended to allow for it to be laid out. This gives us a vector for
             attaching the unplaced ring later.
            </summary>
            <param name="molecule">The molecule to be search for the longest unplaced chain</param>
            <param name="startAtom">A start atom from which the chain search starts</param>
            <returns>An AtomContainer holding the longest unplaced chain.</returns>
            <exception cref="T:NCDK.CDKException">Description of the Exception</exception>
        </member>
        <member name="M:NCDK.Layout.AtomPlacer.BreadthFirstSearch(NCDK.IAtomContainer,System.Collections.Generic.IList{NCDK.IAtom},NCDK.IAtomContainer[])">
            <summary>
             Performs a breadthFirstSearch in an AtomContainer starting with a
             particular sphere, which usually consists of one start atom, and searches
             for the longest aliphatic chain which is yet unplaced. If the search
             encounters an unplaced ring atom, it is also appended to the chain so that
             this last bond of the chain can also be laid out. This gives us the
             orientation for the attachment of the ring system.
            </summary>
            <param name="ac">The AtomContainer to be searched</param>
            <param name="sphere">A sphere of atoms to start the search with</param>
            <param name="pathes">A vector of N pathes (N = no of heavy atoms).</param>
            <exception cref="T:NCDK.CDKException"> Description of the Exception</exception>
        </member>
        <member name="M:NCDK.Layout.AtomPlacer.ListPlaced(NCDK.IAtomContainer)">
            <summary>
             Returns a string with the numbers of all placed atoms in an AtomContainer
            </summary>
            <param name="ac">The AtomContainer for which the placed atoms are to be listed</param>
            <returns>A string with the numbers of all placed atoms in an AtomContainer</returns>
        </member>
        <member name="M:NCDK.Layout.AtomPlacer.ListNumbers(NCDK.IAtomContainer,NCDK.IAtomContainer)">
            <summary>
             Returns a string with the numbers of all atoms in an AtomContainer relative
             to a given Molecule. I.e. the number the is listesd is the position of each
             atom in the Molecule.
            </summary>
            <param name="ac">The AtomContainer for which the placed atoms are to be listed</param>
            <param name="mol">Description of  Parameter</param>
            <returns>A string with the numbers of all placed atoms in an AtomContainer</returns>
            <exception cref="T:NCDK.CDKException"></exception>
        </member>
        <member name="M:NCDK.Layout.AtomPlacer.ListNumbers(NCDK.IAtomContainer,System.Collections.Generic.List{NCDK.IAtom})">
            <summary>
             Returns a string with the numbers of all atoms in a Vector relative to a
             given Molecule. I.e. the number the is listesd is the position of each atom
             in the Molecule.
            </summary>
            <param name="ac">The Vector for which the placed atoms are to be listed</param>
            <param name="mol">Description of the Parameter</param>
            <returns>A string with the numbers of all placed atoms in an AtomContainer</returns>
        </member>
        <member name="M:NCDK.Layout.AtomPlacer.AllPlaced(NCDK.IAtomContainer)">
            <summary>
             True is all the atoms in the given AtomContainer have been placed
            </summary>
            <param name="ac">The AtomContainer to be searched</param>
            <returns>True is all the atoms in the given AtomContainer have been placed</returns>
        </member>
        <member name="M:NCDK.Layout.AtomPlacer.MarkNotPlaced(NCDK.IAtomContainer)">
            <summary>
             Marks all the atoms in the given AtomContainer as not placed
            </summary>
            <param name="ac">The AtomContainer whose atoms are to be marked</param>
        </member>
        <member name="M:NCDK.Layout.AtomPlacer.MarkPlaced(NCDK.IAtomContainer)">
            <summary>
             Marks all the atoms in the given AtomContainer as placed
            </summary>
            <param name="ac">The AtomContainer whose atoms are to be marked</param>
        </member>
        <member name="M:NCDK.Layout.AtomPlacer.GetPlacedAtoms(NCDK.IAtomContainer)">
            <summary>
             Get all the placed atoms in an AtomContainer
            </summary>
            <param name="ac">The AtomContainer to be searched for placed atoms</param>
            <returns>An AtomContainer containing all the placed atoms</returns>
        </member>
        <member name="M:NCDK.Layout.AtomPlacer.CopyPlaced(NCDK.IRing,NCDK.IAtomContainer)">
            <summary>
            Copy placed atoms/bonds from one container to another.
            </summary>
            <param name="dest">destination container</param>
            <param name="src">source container</param>
        </member>
        <member name="M:NCDK.Layout.AtomPlacer.GetDegreeSum(NCDK.IAtomContainer,NCDK.IAtomContainer)">
            <summary>
             Sums up the degrees of atoms in an atomcontainer
            </summary>
            <param name="ac">The atomcontainer to be processed</param>
            <param name="superAC">The superAtomContainer from which the former has been derived</param>
            <returns>sum of degrees</returns>
        </member>
        <member name="M:NCDK.Layout.AtomPlacer.Prioritise(NCDK.IAtomContainer)">
            <summary>
            Calculates priority for atoms in a Molecule.
            </summary>
            <param name="mol">connected molecule</param>
            <seealso cref="F:NCDK.Layout.AtomPlacer.Priority"/>
        </member>
        <member name="M:NCDK.Layout.AtomPlacer.Prioritise(NCDK.IAtomContainer,System.Int32[][])">
            <summary>
            Calculates priority for atoms in a Molecule.
            </summary>
            <param name="mol">connected molecule</param>
            <param name="adjList">fast adjacency lookup</param>
            <seealso cref="F:NCDK.Layout.AtomPlacer.Priority"/>
        </member>
        <member name="M:NCDK.Layout.AtomPlacer.GetPriority(NCDK.IAtomContainer,System.Int32[][])">
            <summary>
            Prioritise atoms of a molecule base on how 'buried' they are. The priority
            is cacheted with a morgan-like relaxation O(n^2 lg n). Priorities are assign
            from 1..|V| (usually less than |V| due to symmetry) where the lowest numbers
            have priority.
            </summary>
            <param name="mol">molecule</param>
            <param name="adjList">fast adjacency lookup</param>
            <returns>the priority</returns>
        </member>
        <member name="M:NCDK.Layout.AtomPlacer.IsColinear(NCDK.IAtom,System.Collections.Generic.IEnumerable{NCDK.IBond})">
            <summary>
            <pre>
            -C#N
            -[N+]#[C-]
            -C=[N+]=N
            -N=[N+]=N
            </pre>
            </summary>
        </member>
        <member name="T:NCDK.Layout.Congestion">
            <summary>
            Measure and update a score of congestion in a molecule layout 
            <token>cdk-cite-HEL99</token>, <token>cdk-cite-Clark06</token>. This can be tuned in
            several ways but currently uses a basic '1/(dist^2)'.
            </summary>
        </member>
        <member name="M:NCDK.Layout.Congestion.InitScore">
            <summary>
            Calculate the initial score.
            </summary>
            <returns>congestion score</returns>
        </member>
        <member name="M:NCDK.Layout.Congestion.Update(System.Boolean[],System.Int32[],System.Int32)">
            <summary>
            Update the score considering that some atoms have moved. We only
            need to update the score of atom that have moved vs those that haven't
            since all those that moved did so together.
            </summary>
            <param name="visit">visit flags</param>
            <param name="vs">visit list</param>
            <param name="n">number of visited in visit list</param>
        </member>
        <member name="M:NCDK.Layout.Congestion.Update(System.Int32[],System.Int32)">
            <summary>
            Update the score considering the atoms have moved (provided). 
            </summary>
            <param name="vs">visit list</param>
            <param name="n">number of visited in visit list</param>
        </member>
        <member name="M:NCDK.Layout.Congestion.Score">
            <summary>
            The congestion score.
            </summary>
            <returns>the current score</returns>
        </member>
        <member name="M:NCDK.Layout.Congestion.Contribution(System.Int32,System.Int32)">
            <summary>
            Access the contribution of an atom pair to the congestion.
            </summary>
            <param name="i">atom idx</param>
            <param name="j">atom idx</param>
            <returns>score</returns>
        </member>
        <member name="T:NCDK.Layout.CorrectGeometricConfiguration">
            <summary>
            Correct double-bond configuration depiction in 2D to be correct for it's
            specified <see cref="T:NCDK.IDoubleBondStereochemistry"/>. Ideally double-bond adjustment
            should be done in when generating a structure diagram (and consider
            overlaps). This method finds double bonds with incorrect depicted
            configuration and reflects one side to correct the configuration.
            </summary>
            <remarks>
            <note type="important">
            Should be invoked before labelling up/down bonds. Cyclic
            double-bonds with a configuration can not be corrected (error logged).
            </note>
            </remarks>
        </member>
        <member name="F:NCDK.Layout.CorrectGeometricConfiguration.container">
            <summary>The structure we are assigning labels to.</summary>
        </member>
        <member name="F:NCDK.Layout.CorrectGeometricConfiguration.graph">
            <summary>Adjacency list graph representation of the structure.</summary>
        </member>
        <member name="F:NCDK.Layout.CorrectGeometricConfiguration.atomToIndex">
            <summary>Lookup atom index (avoid IAtomContainer).</summary>
        </member>
        <member name="F:NCDK.Layout.CorrectGeometricConfiguration.ringSearch">
            <summary>Test if a bond is cyclic.</summary>
        </member>
        <member name="F:NCDK.Layout.CorrectGeometricConfiguration.visited">
            <summary>Visited flags when atoms are being reflected.</summary>
        </member>
        <member name="M:NCDK.Layout.CorrectGeometricConfiguration.Correct(NCDK.IAtomContainer)">
            <summary>
            Adjust all double bond elements in the provided structure. 
            </summary>
            <remarks>
            <note type="important">
            up/down labels should be adjusted before adjust double-bond
            configurations. coordinates are reflected by this method which can lead
            to incorrect tetrahedral specification.
            </note>
            </remarks>
            <param name="container">the structure to adjust</param>
            <exception cref="T:System.ArgumentException">an atom had unset coordinates</exception>
        </member>
        <member name="M:NCDK.Layout.CorrectGeometricConfiguration.#ctor(NCDK.IAtomContainer)">
            <summary>
            Adjust all double bond elements in the provided structure.
            </summary>
            <param name="container">the structure to adjust</param>
            <exception cref="T:System.ArgumentException">an atom had unset coordinates</exception>
        </member>
        <member name="M:NCDK.Layout.CorrectGeometricConfiguration.#ctor(NCDK.IAtomContainer,System.Int32[][])">
            <summary>
            Adjust all double bond elements in the provided structure.
            </summary>
            <param name="container">the structure to adjust</param>
            <param name="graph">the adjacency list representation of the structure</param>
            <exception cref="T:System.ArgumentException">an atom had unset coordinates</exception>
        </member>
        <member name="M:NCDK.Layout.CorrectGeometricConfiguration.Adjust(NCDK.IDoubleBondStereochemistry)">
            <summary>
            Adjust the configuration of the <paramref name="dbs"/> element (if required).
            </summary>
            <param name="dbs">double-bond stereochemistry element</param>
        </member>
        <member name="M:NCDK.Layout.CorrectGeometricConfiguration.GetAtoms(NCDK.IAtom,NCDK.IAtom,NCDK.IAtom)">
            <summary>
            Create an array of three atoms for a side of the double bond. This is
            used to determine the 'winding' of one side of the double bond.
            </summary>
            <param name="focus">a double bonded atom</param>
            <param name="substituent">the substituent we know the configuration of</param>
            <param name="otherFocus">the other focus (i.e. the atom focus is double bonded to)</param>
            <returns>3 atoms arranged as, substituent, other substituent and other
                    focus. if the focus atom has an implicit hydrogen the other
                    substituent is the focus.</returns>
        </member>
        <member name="M:NCDK.Layout.CorrectGeometricConfiguration.Parity(NCDK.IDoubleBondStereochemistry)">
            <summary>
            Access the parity (odd/even) parity of the double bond configuration (together/opposite).
            </summary>
            <param name="element">double bond element</param>
            <returns>together = -1, opposite = +1</returns>
        </member>
        <member name="M:NCDK.Layout.CorrectGeometricConfiguration.Parity(NCDK.IAtom[])">
            <summary>
            Determine the parity (odd/even) of the triangle formed by the 3 atoms.
            </summary>
            <param name="atoms">array of 3 atoms</param>
            <returns>the parity of the triangle formed by 3 points, odd = -1, even = +1</returns>
        </member>
        <member name="M:NCDK.Layout.CorrectGeometricConfiguration.Parity(NCDK.Numerics.Vector2,NCDK.Numerics.Vector2,NCDK.Numerics.Vector2)">
            <summary>
            Determine the parity of the triangle formed by the 3 coordinates a, b and c.
            </summary>
            <param name="a">point 1</param>
            <param name="b">point 2</param>
            <param name="c">point 3</param>
            <returns>the parity of the triangle formed by 3 points</returns>
        </member>
        <member name="M:NCDK.Layout.CorrectGeometricConfiguration.Reflect(System.Int32,NCDK.IBond)">
            <summary>
            Reflect the atom at index <paramref name="v"/> and any then reflect any unvisited neighbors.
            </summary>
            <param name="v">index of the atom to reflect</param>
            <param name="bond">bond</param>
        </member>
        <member name="M:NCDK.Layout.CorrectGeometricConfiguration.Reflect(NCDK.Numerics.Vector2,NCDK.IBond)">
            <summary>
            Reflect the point <paramref name="p"/> over the <paramref name="bond"/>.
            </summary>
            <param name="p">the point to reflect</param>
            <param name="bond">bond</param>
            <returns>the reflected point</returns>
        </member>
        <member name="M:NCDK.Layout.CorrectGeometricConfiguration.Reflect(NCDK.Numerics.Vector2,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Reflect the point <paramref name="p"/> 
            in the line (<paramref name="x0"/>, <paramref name="y0"/> - <paramref name="x1"/>, <paramref name="y1"/>).
            </summary>
            <param name="p">the point to reflect</param>
            <param name="x0">plane x start</param>
            <param name="y0">plane y end</param>
            <param name="x1">plane x start</param>
            <param name="y1">plane y end</param>
            <returns>the reflected point</returns>
        </member>
        <member name="T:NCDK.Layout.HydrogenPlacer">
            <summary>
            This is a wrapper class for some existing methods in AtomPlacer. It helps you
            to layout 2D and 3D coordinates for hydrogen atoms added to a molecule which
            already has coordinates for the rest of the atoms.
            </summary>
            <example>
            <code>            IAtomContainer container = TestMoleculeFactory.MakeAlphaPinene();
            HydrogenPlacer hydrogenPlacer = new HydrogenPlacer();
            hydrogenPlacer.PlaceHydrogens2D(container, 1.5);
</code>
            </example>  
            <seealso cref="T:NCDK.Layout.AtomPlacer" />
        </member>
        <member name="M:NCDK.Layout.HydrogenPlacer.PlaceHydrogens2D(NCDK.IAtomContainer,System.Double)">
            <summary>
            Place all hydrogens connected to atoms which have already been laid out.
            </summary>
            <param name="container">atom container</param>
            <param name="bondLength">bond length to user</param>
        </member>
        <member name="M:NCDK.Layout.HydrogenPlacer.PlaceHydrogens2D(NCDK.IAtomContainer,NCDK.IAtom)">
            <summary>
            Place hydrogens connected to the given atom using the average bond length
            in the container.
            </summary>
            <param name="container">atom container of which <paramref name="atom"/> is a member</param>
            <param name="atom">the atom of which to place connected hydrogens</param>
            <exception cref="T:System.ArgumentException">if the <paramref name="atom"/> does not have 2d coordinates</exception>
            <seealso cref="M:NCDK.Layout.HydrogenPlacer.PlaceHydrogens2D(NCDK.IAtomContainer,System.Double)"/>
        </member>
        <member name="M:NCDK.Layout.HydrogenPlacer.PlaceHydrogens2D(NCDK.IAtomContainer,NCDK.IAtom,System.Double)">
            <summary>
            Place hydrogens connected to the provided atom <paramref name="atom"/> using the
            specified <paramref name="bondLength"/>.
            </summary>
            <param name="container">atom container</param>
            <param name="atom"></param>
            <param name="bondLength">bond length to user</param>
            <exception cref="T:System.ArgumentException">thrown if the <paramref name="atom"/> or 
            <i>container</i> was null or the atom has connected atoms which have not been placed.</exception>
        </member>
        <member name="T:NCDK.Layout.IdentityTemplateLibrary">
             <summary>
             A library for 2D layout templates that are retrieved based on identity. Such a library is useful
             for ensure ring systems are laid out in their de facto orientation. Importantly, identity
             templates means the library size can be very large but still searched in constant time.
             </summary>
             <example>
             <code>
             // load from a resource file on the classpath
             IdentityTemplateLibrary lib = IdentityTemplateLibrary.LoadFromResource("/data/ring-templates.smi");
            
             IAtomContainer container, container2;
            
             // add to the library
             lib.Add(container);
            
             // assign a layout
             bool modified = lib.AssignLayout(container2);
            
             // store
             Stream out = new FileOutputStream("/tmp/lib.smi");
             lib.Store(out);
             out.Close();
             </code>
             </example>
        </member>
        <member name="M:NCDK.Layout.IdentityTemplateLibrary.Add(NCDK.Layout.IdentityTemplateLibrary)">
            <summary>
            Add one template library to another.
            </summary>
            <param name="library">another template library</param>
            <returns>this library with the other one added in (allows chaining)</returns>
        </member>
        <member name="M:NCDK.Layout.IdentityTemplateLibrary.CreateCanonicalSmiles(NCDK.IAtomContainer,System.Int32[])">
            <summary>
            Internal - create a canonical SMILES string temporarily adjusting to default
            hydrogen count. This method may be moved to the SMILESGenerator in future.
            </summary>
            <param name="mol">molecule</param>
            <param name="ordering">ordering output</param>
            <returns>SMILES</returns>
            <exception cref="T:NCDK.CDKException">SMILES could be generate</exception>
        </member>
        <member name="M:NCDK.Layout.IdentityTemplateLibrary.CreateEntry(NCDK.IAtomContainer)">
            <summary>
            Create a library entry from an atom container. Note the entry is not added to the library.
            </summary>
            <param name="container">structure representation</param>
            <returns>a new library entry (not stored).</returns>
            <seealso cref="M:NCDK.Layout.IdentityTemplateLibrary.Add(System.Nullable{System.Collections.Generic.KeyValuePair{System.String,NCDK.Numerics.Vector2[]}})"/>
        </member>
        <member name="M:NCDK.Layout.IdentityTemplateLibrary.DecodeEntry(System.String)">
            <summary>
            Create a library entry from a SMILES string with the coordinates suffixed in binary. The
            entry should be created with <see cref="M:NCDK.Layout.IdentityTemplateLibrary.EncodeEntry(System.Collections.Generic.KeyValuePair{System.String,NCDK.Numerics.Vector2[]})"/>  and not created
            manually. Note, the entry is not added to the library.
            </summary>
            <param name="str">input string</param>
            <returns>library entry</returns>
        </member>
        <member name="M:NCDK.Layout.IdentityTemplateLibrary.DecodeCoordinates(System.String)">
            <summary>
            Decode coordinates that have been placed in a byte buffer.
            </summary>
            <param name="str">the string to decode</param>
            <returns>array of coordinates</returns>
        </member>
        <member name="M:NCDK.Layout.IdentityTemplateLibrary.EncodeEntry(System.Collections.Generic.KeyValuePair{System.String,NCDK.Numerics.Vector2[]})">
            <summary>
            Encodes an entry in a compact string representation. The encoded entry is a SMILES string
            with the coordinates suffixed in binary.
            </summary>
            <param name="entry">the entry to encode</param>
            <returns>encoded entry</returns>
        </member>
        <member name="M:NCDK.Layout.IdentityTemplateLibrary.EncodeCoordinates(NCDK.Numerics.Vector2[])">
            <summary>
            Encode coordinates in a string.
            </summary>
            <param name="points">points</param>
            <returns>extended SMILES format coordinates</returns>
        </member>
        <member name="M:NCDK.Layout.IdentityTemplateLibrary.Add(System.Nullable{System.Collections.Generic.KeyValuePair{System.String,NCDK.Numerics.Vector2[]}})">
             <summary>
             Add a created entry to the library.
            
             <param name="entry">entry</param>
             </summary>
        </member>
        <member name="M:NCDK.Layout.IdentityTemplateLibrary.Add(NCDK.IAtomContainer)">
            <summary>
            Create an entry for the provided container and add it to the library.
            </summary>
            <param name="container">structure representation</param>
        </member>
        <member name="M:NCDK.Layout.IdentityTemplateLibrary.AssignLayout(NCDK.IAtomContainer)">
            <summary>
            Assign a 2D layout to the atom container using the contents of the library. If multiple
            coordinates are available the first is choosen.
            </summary>
            <param name="container">structure representation</param>
            <returns>a layout was assigned</returns>
        </member>
        <member name="M:NCDK.Layout.IdentityTemplateLibrary.GetCoordinates(NCDK.IAtomContainer)">
            <summary>
            Get all templated coordinates for the provided molecule. The return collection has
            coordinates ordered based on the input.
            </summary>
            <param name="mol">molecule (or fragment) to lookup</param>
            <returns>the coordinates</returns>
        </member>
        <member name="M:NCDK.Layout.IdentityTemplateLibrary.Empty">
            <summary>
            Create an empty template library.
            </summary>
            <returns>an empty template library</returns>
        </member>
        <member name="M:NCDK.Layout.IdentityTemplateLibrary.LoadFromResource(System.String)">
            <summary>
            Load a template library from a resource on the class path.
            </summary>
            <returns>loaded template library</returns>
            <exception cref="T:System.ArgumentException">resource not found or could not be loaded</exception>
        </member>
        <member name="M:NCDK.Layout.IdentityTemplateLibrary.Load(System.IO.Stream)">
            <summary>
            Load a template library from an input stream.
            </summary>
            <returns>loaded template library</returns>
            <exception cref="T:System.IO.IOException">low level IO error</exception>
        </member>
        <member name="M:NCDK.Layout.IdentityTemplateLibrary.ReorderCoords(NCDK.Numerics.Vector2[],System.Int32[])">
            <summary>
            Reorder coordinates.
            </summary>
            <param name="coords">coordinates</param>
            <param name="order">permutation</param>
            <returns>reordered coordinates</returns>
        </member>
        <member name="M:NCDK.Layout.IdentityTemplateLibrary.Update(NCDK.IChemObjectBuilder)">
            <summary>
            Update the template library - can be called for safety after
            each load.
            </summary>
            <param name="bldr">builder</param>
        </member>
        <member name="M:NCDK.Layout.IdentityTemplateLibrary.Store(System.IO.Stream)">
            <summary>
            Store a template library to the provided output stream.
            </summary>
            <param name="output">output stream</param>
            <exception cref="T:System.IO.IOException">low level IO error</exception>
        </member>
        <member name="T:NCDK.Layout.LayoutRefiner">
            <summary>
            An overlap resolver that tries to resolve overlaps by rotating (reflecting),
            bending, and stretching bonds. 
            </summary>
            <remarks>
            <para>
            The RBS (rotate, bend, stretch) algorithm is first described by <token>cdk-cite-Shelley83</token>,
            and later in more detail by <token>cdk-cite-HEL99</token>.
            </para>
            <para>
            Essentially we have a measure of <see cref="T:NCDK.Layout.Congestion"/>. From that we find 
            un-bonded atoms that contribute significantly (i.e. overlap). To resolve
            that overlap we try resolving the overlap by changing (acyclic) bonds in the
            shortest path between the congested pair. Operations, from most to least 
            favourable, are:
            <list type="bullet">
                <item>Rotation (or reflection), <see cref="M:NCDK.Layout.LayoutRefiner.Rotate(System.Collections.Generic.ICollection{NCDK.Layout.LayoutRefiner.AtomPair})"/></item>
                <item>Inversion (not described in lit), <see cref="M:NCDK.Layout.LayoutRefiner.Invert(System.Collections.Generic.IEnumerable{NCDK.Layout.LayoutRefiner.AtomPair})"/></item>
                <item>Stretch, <see cref="M:NCDK.Layout.LayoutRefiner.Stretch(NCDK.Layout.LayoutRefiner.AtomPair,NCDK.Layout.LayoutRefiner.IntStack,NCDK.Numerics.Vector2[],System.Collections.Generic.IDictionary{NCDK.IBond,NCDK.Layout.LayoutRefiner.AtomPair})"/></item>
                <item>Bend, <see cref="M:NCDK.Layout.LayoutRefiner.Bend(NCDK.Layout.LayoutRefiner.AtomPair,NCDK.Layout.LayoutRefiner.IntStack,NCDK.Numerics.Vector2[],System.Collections.Generic.IDictionary{NCDK.IBond,NCDK.Layout.LayoutRefiner.AtomPair})"/></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="F:NCDK.Layout.LayoutRefiner.BondLength">
            <summary>
            These value are constants but could be parametrised in future.
            </summary>
        </member>
        <member name="M:NCDK.Layout.LayoutRefiner.#ctor(NCDK.IAtomContainer,System.Collections.Generic.ISet{NCDK.IAtom},System.Collections.Generic.ISet{NCDK.IBond})">
            <summary>
            Create a new layout refiner for the provided molecule.
            </summary>
            <param name="mol">molecule to refine</param>
        </member>
        <member name="M:NCDK.Layout.LayoutRefiner.TraverseRing(System.Int32[],System.Int32,System.Int32)">
            <summary>
            Simple method for marking ring systems with a flood-fill.
            </summary>
            <param name="ringSystem">ring system vector</param>
            <param name="v">start atom</param>
            <param name="rnum">the number to mark atoms of this ring</param>
        </member>
        <member name="M:NCDK.Layout.LayoutRefiner.FindCongestedPairs">
            <summary>
            Find all pairs of un-bonded atoms that are congested.
            </summary>
            <returns>pairs of congested atoms</returns>
        </member>
        <member name="M:NCDK.Layout.LayoutRefiner.IsCrossed(NCDK.Numerics.Vector2,NCDK.Numerics.Vector2,NCDK.Numerics.Vector2,NCDK.Numerics.Vector2)">
            <summary>
            Check if two bonds are crossing.
            </summary>
            <param name="beg1">first atom of first bond</param>
            <param name="end1">second atom of first bond</param>
            <param name="beg2">first atom of second bond</param>
            <param name="end2">first atom of second bond</param>
            <returns>bond is crossing</returns>
        </member>
        <member name="M:NCDK.Layout.LayoutRefiner.HaveCrossingBonds(System.Int32,System.Int32)">
            <summary>
            Check if any of the bonds adjacent to <paramref name="u"/>, <paramref name="v"/> (not bonded) are crossing.
            </summary>
            <param name="u">an atom (idx)</param>
            <param name="v">another atom (idx)</param>
            <returns>there are crossing bonds</returns>
        </member>
        <member name="F:NCDK.Layout.LayoutRefiner.probablySymmetric">
            <summary>Set of rotatable bonds we've explored and found are probably symmetric.</summary>
        </member>
        <member name="M:NCDK.Layout.LayoutRefiner.Rotate(System.Collections.Generic.ICollection{NCDK.Layout.LayoutRefiner.AtomPair})">
            <summary>
            Attempt to reduce congestion through rotation of flippable bonds between
            congest pairs.
            </summary>
            <param name="pairs">congested pairs of atoms</param>
        </member>
        <member name="M:NCDK.Layout.LayoutRefiner.Invert(System.Collections.Generic.IEnumerable{NCDK.Layout.LayoutRefiner.AtomPair})">
            <summary>
            Special case congestion minimisation, rotate terminals bonds around ring
            systems so they are inside the ring.
            </summary>
            <param name="pairs">congested atom pairs</param>
        </member>
        <member name="M:NCDK.Layout.LayoutRefiner.Bend(NCDK.Layout.LayoutRefiner.AtomPair,NCDK.Layout.LayoutRefiner.IntStack,NCDK.Numerics.Vector2[],System.Collections.Generic.IDictionary{NCDK.IBond,NCDK.Layout.LayoutRefiner.AtomPair})">
            <summary>
            Bend all bonds in the shortest path between a pair of atoms in an attempt
            to resolve the overlap. The bend that produces the minimum congestion is
            stored in the provided stack and coords with the congestion score
            returned.
            </summary>
            <param name="pair">congested atom pair</param>
            <param name="stack">best result vertices</param>
            <param name="coords">best result coords</param>
            <param name="firstVisit">visit map to avoid repeating work</param>
            <returns>congestion score of best result</returns>
        </member>
        <member name="M:NCDK.Layout.LayoutRefiner.Stretch(NCDK.Layout.LayoutRefiner.AtomPair,NCDK.Layout.LayoutRefiner.IntStack,NCDK.Numerics.Vector2[],System.Collections.Generic.IDictionary{NCDK.IBond,NCDK.Layout.LayoutRefiner.AtomPair})">
            <summary>
            Stretch all bonds in the shortest path between a pair of atoms in an
            attempt to resolve the overlap. The stretch that produces the minimum
            congestion is stored in the provided stack and coords with the congestion
            score returned.
            </summary>
            <param name="pair">congested atom pair</param>
            <param name="stack">best result vertices</param>
            <param name="coords">best result coords</param>
            <param name="firstVisit">visit map to avoid repeating work</param>
            <returns>congestion score of best result</returns>
        </member>
        <member name="M:NCDK.Layout.LayoutRefiner.BendOrStretch(System.Collections.Generic.IEnumerable{NCDK.Layout.LayoutRefiner.AtomPair})">
            <summary>
            Resolves conflicts either by bending bonds or stretching bonds in the
            shortest path between an overlapping pair. Bending and stretch are tried
            for each pair and the best resolution is used.
            </summary>
            <param name="pairs">pairs</param>
        </member>
        <member name="M:NCDK.Layout.LayoutRefiner.Refine">
            <summary>
            Refine the 2D coordinates of a layout to reduce overlap and congestion.
            </summary>
        </member>
        <member name="M:NCDK.Layout.LayoutRefiner.BackupCoords(NCDK.Numerics.Vector2[],NCDK.Layout.LayoutRefiner.IntStack)">
            <summary>
            Backup the coordinates of atoms (idxs) in the stack to the provided
            destination.
            </summary>
            <param name="dest">destination</param>
            <param name="stack">atom indexes to backup</param>
        </member>
        <member name="M:NCDK.Layout.LayoutRefiner.RestoreCoords(NCDK.Layout.LayoutRefiner.IntStack,NCDK.Numerics.Vector2[])">
            <summary>
            Restore the coordinates of atoms (idxs) in the stack to the provided
            source.
            </summary>
            <param name="stack">atom indexes to backup</param>
            <param name="src">source of coordinates</param>
        </member>
        <member name="M:NCDK.Layout.LayoutRefiner.Reflect(NCDK.Layout.LayoutRefiner.IntStack,NCDK.IAtom,NCDK.IAtom)">
            <summary>
            Reflect all atoms (indexes) int he provided stack around the line formed
            of the beg and end atoms.
            </summary>
            <param name="stack">atom indexes to reflect</param>
            <param name="beg">beg atom of a bond</param>
            <param name="end">end atom of a bond</param>
        </member>
        <member name="M:NCDK.Layout.LayoutRefiner.Reflect(NCDK.IAtom,NCDK.Numerics.Vector2,System.Double,System.Double)">
            <summary>
            Reflect a point (p) in a line formed of <paramref name="baseOfSource"/>, <paramref name="a"/>, and <paramref name="b"/>.
            </summary>
            <param name="ap">point to reflect</param>
            <param name="baseOfSource">base of the refection source</param>
            <param name="a">a reflection coef</param>
            <param name="b">b reflection coef</param>
        </member>
        <member name="M:NCDK.Layout.LayoutRefiner.Bend(System.Int32[],System.Int32,System.Int32,NCDK.IAtom,System.Double)">
            <summary>
            Bend select atoms around a provided pivot by the specified amount (r).
            </summary>
            <param name="indexes">array of atom indexes</param>
            <param name="from">start offset into the array (inclusive)</param>
            <param name="to">end offset into the array (exclusive)</param>
            <param name="pivotAtm">the point about which we are pivoting</param>
            <param name="r">radians to bend by</param>
        </member>
        <member name="M:NCDK.Layout.LayoutRefiner.Stretch(NCDK.Layout.LayoutRefiner.IntStack,NCDK.IAtom,NCDK.IAtom,System.Double)">
            <summary>
            Stretch the distance between beg and end, moving all atoms provided in
            the stack.
            </summary>
            <param name="stack">atoms to be moved</param>
            <param name="beg">begin atom of a bond</param>
            <param name="end">end atom of a bond</param>
            <param name="amount">amount to try stretching by (absolute)</param>
        </member>
        <member name="M:NCDK.Layout.LayoutRefiner.MakeAtmBndQueues(System.Int32[],System.Int32[],NCDK.IBond[])">
            <summary>
            Internal - makes atom (seq) and bond priority queues for resolving
            overlap. Only (acyclic - but not really) atoms and bonds in the shortest
            path between the two atoms can resolve an overlap. We create prioritised
            sequences of atoms/bonds where the more central in the shortest path.
            </summary>
            <param name="path">shortest path between atoms</param>
            <param name="seqAt">prioritised atoms, first atom is the middle of the path</param>
            <param name="bndAt">prioritised bonds, first bond is the middle of the path</param>
        </member>
        <member name="M:NCDK.Layout.LayoutRefiner.VisitAdj(System.Boolean[],System.Int32[],System.Int32,System.Int32)">
            <summary>
            Recursively visit <paramref name="v"/> and all vertices adjacent to it (excluding <paramref name="p"/>)
            adding all except <paramref name="v"/> to the result array.
            </summary>
            <param name="visited">visit flags array, should be cleared before search</param>
            <param name="result">visited vertices</param>
            <param name="p">previous vertex</param>
            <param name="v">start vertex</param>
            <returns>number of visited vertices</returns>
        </member>
        <member name="M:NCDK.Layout.LayoutRefiner.Visit(System.Boolean[],System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Recursively visit <paramref name="v"/> and all vertices adjacent to it (excluding <paramref name="p"/>)
            adding them to the result array.
            </summary>
            <param name="visited">visit flags array, should be cleared before search</param>
            <param name="result">visited vertices</param>
            <param name="p">previous vertex</param>
            <param name="v">start vertex</param>
            <param name="n">current number of visited vertices</param>
            <returns>new number of visited vertices</returns>
        </member>
        <member name="M:NCDK.Layout.LayoutRefiner.GetCommon(NCDK.IBond,NCDK.IBond)">
            <summary>
            Access the common atom shared by two bonds.
            </summary>
            <param name="bndA">first bond</param>
            <param name="bndB">second bond</param>
            <returns>common atom or null if non exists</returns>
        </member>
        <member name="T:NCDK.Layout.LayoutRefiner.AtomPair">
            <summary>
            Congested pair of un-bonded atoms, described by the index of the atoms
            (<see cref="F:NCDK.Layout.LayoutRefiner.AtomPair.fst"/>, <see cref="F:NCDK.Layout.LayoutRefiner.AtomPair.snd"/>). The atoms (<see cref="F:NCDK.Layout.LayoutRefiner.AtomPair.seqAt"/>) and bonds (<see cref="F:NCDK.Layout.LayoutRefiner.AtomPair.bndAt"/>) in the shortest path
            between the pair are stored as well as a bndAtCode for checking special
            case ring bond patterns.
            </summary>
        </member>
        <member name="F:NCDK.Layout.LayoutRefiner.AtomPair.attempt">
            <summary>
            Which attempt are we trying to resolve this overlap with.
            </summary>
        </member>
        <member name="M:NCDK.Layout.LayoutRefiner.AtomPair.bndCode(System.Collections.Generic.IEnumerable{NCDK.IBond})">
            <summary>
            Create the bond code bit mask, lowest bit is whether the path is
            odd/even then the other bits are whether the bonds are in a ring or
            not.
            </summary>
            <param name="enumBonds">bonds to encode</param>
            <returns>the bond code</returns>
        </member>
        <member name="T:NCDK.Layout.LayoutRefiner.IntStack">
            <summary>
            Internal - fixed size integer stack.
            </summary>
        </member>
        <member name="T:NCDK.Layout.LayoutRefiner.IntTuple">
            <summary>
            Internal - A hashable tuple of integers, allows to check for previously
            seen pairs.
            </summary>
        </member>
        <member name="T:NCDK.Layout.MacroCycleLayout">
            <summary>
            A class for helping layout macrocycles.
            </summary>
        </member>
        <member name="M:NCDK.Layout.MacroCycleLayout.#ctor(NCDK.IAtomContainer)">
            <summary>
            Create a new helper for the provided molecule.
            </summary>
            <param name="mol">molecule</param>
        </member>
        <member name="M:NCDK.Layout.MacroCycleLayout.Layout(NCDK.IRing,NCDK.IRingSet)">
            <summary>
            Layout a macro cycle (the rest of the ring set is untouched).
            </summary>
            <param name="macrocycle">the macrocycle</param>
            <param name="ringset">the ring set the macrocycle belongs to (may only be it's self)</param>
            <returns>layout was successfully, if false caller fall-back to regular polygons</returns>
        </member>
        <member name="M:NCDK.Layout.MacroCycleLayout.BestScore(NCDK.IRing,NCDK.IRingSet,System.Int32,System.Int32[])">
            <summary>
            Select the best scoring template + offset for the given macrocycle.
            </summary>
            <param name="macrocycle">macrocycle</param>
            <param name="ringset">entire ring system</param>
            <param name="wind">winding of ring CW/CCW</param>
            <param name="winding">winding of each turn in the ring</param>
            <returns>the best scoring configuration</returns>
        </member>
        <member name="M:NCDK.Layout.MacroCycleLayout.GetAttachedInOrder(NCDK.IRing,NCDK.IAtomContainer)">
            <summary>
            Get the shared indices of a macrocycle and atoms shared with another ring.
            </summary>
            <param name="macrocycle">macrocycle ring</param>
            <param name="shared">shared atoms</param>
            <returns>the integers</returns>
        </member>
        <member name="M:NCDK.Layout.MacroCycleLayout.SelectCoords(System.Collections.Generic.IEnumerable{NCDK.Numerics.Vector2[]},NCDK.Numerics.Vector2[],NCDK.IRing,NCDK.IRingSet)">
            <summary>
            Select the best coordinates
            </summary>
            <param name="ps">template points</param>
            <param name="coords">best coordinates (updated by this method)</param>
            <param name="macrocycle">the macrocycle</param>
            <param name="ringset">rest of the ring system</param>
            <returns>offset into the coordinates</returns>
        </member>
        <member name="M:NCDK.Layout.MacroCycleLayout.Winding(NCDK.Numerics.Vector2[],System.Int32[])">
            <summary>
            Determine the overall winding and the vertex of a ring template.
            </summary>
            <param name="coords">ring coordinates</param>
            <param name="winding">winding result for each atom (cw/ccw)</param>
            <returns>global winding</returns>
        </member>
        <member name="M:NCDK.Layout.MacroCycleLayout.Winding(NCDK.Numerics.Vector2,NCDK.Numerics.Vector2,NCDK.Numerics.Vector2)">
            <summary>
            Determine the winding of three points using the determinant.
            </summary>
            <param name="a">first point</param>
            <param name="b">second point</param>
            <param name="c">third point</param>
            <returns>&lt;0 =&gt; clockwise, 0 =&gt; linear, &gt;0 anti-clockwise</returns>
        </member>
        <member name="T:NCDK.Layout.MacroCycleLayout.MacroScore">
            <summary>
            Helper class for storing/ranking macrocycle templates.
            </summary>
        </member>
        <member name="M:NCDK.Layout.MacroCycleLayout.RoundUpIfNeeded(NCDK.IAtomContainer)">
            <summary>
            Make a ring one atom bigger if it's of an odd size.
            </summary>
            <param name="anon">ring</param>
            <returns>'anon' returned of chaining convenience</returns>
        </member>
        <member name="T:NCDK.Layout.NonplanarBonds">
            <summary>
            Assigns non-planar labels (wedge/hatch) to the tetrahedral and extended tetrahedral 
            stereocentres in a 2D depiction. Labels are assigned to atoms using the following priority. 
            <list type="bullet">
            <item>bond to non-stereo atoms</item> 
            <item>acyclic bonds</item> 
            <item>bonds to atoms with lower degree (i.e. terminal)</item>
            <item>lower atomic number</item>
            </list>
            Unspecified bonds are also marked.
            </summary>
        </member>
        <member name="F:NCDK.Layout.NonplanarBonds.container">
            <summary>The structure we are assigning labels to.</summary>
        </member>
        <member name="F:NCDK.Layout.NonplanarBonds.graph">
            <summary>Adjacency list graph representation of the structure.</summary>
        </member>
        <member name="F:NCDK.Layout.NonplanarBonds.ringSearch">
            <summary>Search for cyclic atoms.</summary>
        </member>
        <member name="F:NCDK.Layout.NonplanarBonds.tetrahedralElements">
            <summary>Tetrahedral elements indexed by central atom.</summary>
        </member>
        <member name="F:NCDK.Layout.NonplanarBonds.doubleBondElements">
            <summary>Double-bond elements indexed by end atoms.</summary>
        </member>
        <member name="F:NCDK.Layout.NonplanarBonds.atomToIndex">
            <summary>Lookup atom index (avoid IAtomContainer).</summary>
        </member>
        <member name="F:NCDK.Layout.NonplanarBonds.edgeToBond">
            <summary>Quick lookup of a bond give the atom index of it's atoms.</summary>
        </member>
        <member name="M:NCDK.Layout.NonplanarBonds.Assign(NCDK.IAtomContainer)">
            <summary>
            Assign non-planar, up and down labels to indicate tetrahedral configuration. Currently all
            existing directional labels are removed before assigning new labels.
            </summary>
            <param name="container">the structure to assign labels to</param>
            <returns>a container with assigned labels (currently the same as the input)</returns>
            <exception cref="T:System.ArgumentException">an atom had no 2D coordinates or labels could not be assigned to a tetrahedral centre</exception>
        </member>
        <member name="M:NCDK.Layout.NonplanarBonds.#ctor(NCDK.IAtomContainer,System.Int32[][],NCDK.Graphs.GraphUtil.EdgeToBondMap)">
            <summary>
            Assign non-planar bonds to the tetrahedral stereocenters in the <paramref name="container"/>.
            </summary>
            <param name="container">structure</param>
            <param name="g">graph adjacency list representation</param>
            <exception cref="T:System.ArgumentException">an atom had no 2D coordinates or labels could not be assigned to a tetrahedral centre</exception>
        </member>
        <member name="M:NCDK.Layout.NonplanarBonds.Label(NCDK.Stereo.ExtendedTetrahedral)">
            <summary>
            Assign non-planar labels (wedge/hatch) to the bonds of extended
            tetrahedral elements to correctly represent its stereochemistry.
            </summary>
            <param name="element">a extended tetrahedral element</param>
        </member>
        <member name="M:NCDK.Layout.NonplanarBonds.Label(NCDK.ITetrahedralChirality)">
            <summary>
            Assign labels to the bonds of tetrahedral element to correctly represent
            its stereo configuration.
            </summary>
            <param name="element">a tetrahedral element</param>
            <exception cref="T:System.ArgumentException">the labels could not be assigned</exception>
        </member>
        <member name="M:NCDK.Layout.NonplanarBonds.Parity(System.Int32)">
            <summary>
            Obtain the parity of a value x. The parity is -1 if the value is odd or
            +1 if the value is even.
            </summary>
            <param name="x">a value</param>
            <returns>the parity</returns>
        </member>
        <member name="M:NCDK.Layout.NonplanarBonds.Parity(NCDK.TetrahedralStereo)">
            <summary>
            Obtain the parity (winding) of a tetrahedral element. The parity is -1
            for clockwise (odd), +1 for anticlockwise (even) and 0 for unspecified.
            </summary>
            <param name="stereo">configuration</param>
            <returns>the parity</returns>
        </member>
        <member name="M:NCDK.Layout.NonplanarBonds.NAdjacentCentres(System.Int32)">
            <summary>
            Obtain the number of centres adjacent to the atom at the index, <paramref name="i"/>.
            </summary>
            <param name="i">atom index</param>
            <returns>number of adjacent centres</returns>
        </member>
        <member name="M:NCDK.Layout.NonplanarBonds.Priority(System.Int32,System.Collections.Generic.IList{NCDK.IAtom},System.Int32)">
            <summary>
            Obtain a prioritised array where the indices 0 to <paramref name="n"/> which correspond to
            the provided <paramref name="atoms"/>.
            </summary>
            <param name="focus">focus of the tetrahedral atom</param>
            <param name="atoms">the atom</param>
            <param name="n">number of atoms</param>
            <returns>prioritised indices</returns>
        </member>
        <member name="M:NCDK.Layout.NonplanarBonds.HasPriority(System.Int32,System.Int32,System.Int32)">
            <summary>
            Does the atom at index <paramref name="i"/> have priority over the atom at index
            <paramref name="j"/> for the tetrahedral atom <paramref name="focus"/>.
            </summary>
            <param name="focus">tetrahedral centre (or -1 if double bond)</param>
            <param name="i">adjacent atom index</param>
            <param name="j">adjacent atom index</param>
            <returns>whether atom i has priority</returns>
        </member>
        <member name="M:NCDK.Layout.NonplanarBonds.SortClockwise(System.Int32[],NCDK.IAtom,System.Collections.Generic.IList{NCDK.IAtom},System.Int32)">
            <summary>
            Sort the <paramref name="indices"/>, which correspond to an index in the <paramref name="atoms"/> array in
            clockwise order.
            </summary>
            <param name="indices">indices, 0 to n</param>
            <param name="focus">the central atom</param>
            <param name="atoms">the neighbors of the focus</param>
            <param name="n">the number of neighbors</param>
            <returns>the permutation parity of the sort</returns>
        </member>
        <member name="M:NCDK.Layout.NonplanarBonds.Less(System.Int32,System.Int32,System.Collections.Generic.IList{NCDK.IAtom},NCDK.Numerics.Vector2)">
            <summary>
            Is index <paramref name="i"/>, to the left of index <paramref name="j"/> when sorting clockwise around the <paramref name="center"/>.
            </summary>
            <param name="i">an index in <paramref name="atoms"/></param>
            <param name="j">an index in <paramref name="atoms"/></param>
            <param name="atoms">atoms</param>
            <param name="center">central point</param>
            <returns>atom <paramref name="i"/> is before <paramref name="j"/></returns>
            <seealso href="http://stackoverflow.com/a/6989383">Sort points in clockwise order, ciamej</seealso>
        </member>
        <member name="M:NCDK.Layout.NonplanarBonds.LabelUnspecified(NCDK.IBond)">
            <summary>
            Labels a double bond as unspecified either by marking an adjacent bond as
            wavy (up/down) or if that's not possible (e.g. it's conjugated with other double bonds
            that have a conformation), setting the bond to a crossed double bond.
            </summary>
            <param name="doubleBond">the bond to mark as unspecified</param>
        </member>
        <member name="M:NCDK.Layout.NonplanarBonds.IsCisTransEndPoint(System.Int32)">
            <summary>
            Checks if the atom can be involved in a double-bond.
            </summary>
            <param name="idx">atom idx</param>
            <returns>the atom at index (idx) is valid for a double bond</returns>
            <seealso href="http://www.inchi-trust.org/download/104/InChI_TechMan.pdf">Double bond stereochemistry, InChI Technical Manual</seealso>
        </member>
        <member name="M:NCDK.Layout.NonplanarBonds.GetBondTypes(System.Int32)">
            <summary>
            Generate a bond type code for a given atom. The bond code
            can be quickly tested to count the number of single, double,
            or 'other' bonds.
            </summary>
            <param name="idx">the atom idx</param>
            <returns>bond code</returns>
        </member>
        <member name="M:NCDK.Layout.NonplanarBonds.FindUnspecifiedDoubleBonds(System.Int32[][])">
            <summary>
            Locates double bonds to mark as unspecified stereochemistry.
            </summary>
            <returns>set of double bonds</returns>
        </member>
        <member name="M:NCDK.Layout.NonplanarBonds.HasOnlyPlainBonds(System.Int32,NCDK.IBond)">
            <summary>
            Check that an atom (<paramref name="v"/>:index) is only adjacent to plain single bonds (may be a bold or
            hashed wedged - e.g. at fat end) with the single exception being the allowed double bond
            passed as an argument. 
            </summary>
            <param name="v">atom index</param>
            <param name="allowedDoubleBond">a double bond that is allowed</param>
            <returns>the atom is adjacent to one or more plain single bonds</returns>
        </member>
        <member name="T:NCDK.Layout.RingPlacer">
            <summary>
            Class providing methods for generating coordinates for ring atoms.
            Various situations are supported, like condensation, spiro-attachment, etc.
            They can be used for Automated Structure Diagram Generation or in the interactive
            buildup of ringsystems by the user.
            </summary>
        </member>
        <member name="P:NCDK.Layout.RingPlacer.DefaultAngles">
            <summary>
            Default ring start angles. Map contains pairs: ring size with start angle.
            </summary>
        </member>
        <member name="P:NCDK.Layout.RingPlacer.JCPAngles">
            <summary>
            Suggested ring start angles for JChempaint, different due to Y inversion of canvas.
            </summary>
        </member>
        <member name="M:NCDK.Layout.RingPlacer.PlaceRing(NCDK.IRing,NCDK.IAtomContainer,NCDK.Numerics.Vector2,NCDK.Numerics.Vector2,System.Double)">
            <summary>
            Generated coordinates for a given ring. Multiplexes to special handlers
            for the different possible situations (spiro-, fusion-, bridged attachement)
            </summary>
            <param name="ring">The ring to be placed</param>
            <param name="sharedAtoms">The atoms of this ring, also members of another ring, which are already placed</param>
            <param name="sharedAtomsCenter">The geometric center of these atoms</param>
            <param name="ringCenterVector">A vector pointing the the center of the new ring</param>
            <param name="bondLength">The standard bondlength</param>
        </member>
        <member name="M:NCDK.Layout.RingPlacer.PlaceRing(NCDK.IRing,NCDK.Numerics.Vector2,System.Double)">
            <summary>
            Place ring with default start angles, using <see cref="P:NCDK.Layout.RingPlacer.DefaultAngles"/>.
            </summary>
            <param name="ring">the ring to place.</param>
            <param name="ringCenter">center coordinates of the ring.</param>
            <param name="bondLength">given bond length.</param>
        </member>
        <member name="M:NCDK.Layout.RingPlacer.PlaceRing(NCDK.IRing,NCDK.Numerics.Vector2,System.Double,System.Collections.Generic.IDictionary{System.Int32,System.Double})">
            <summary>
            Place ring with user provided angles.
            </summary>
            <param name="ring">the ring to place.</param>
            <param name="ringCenter">center coordinates of the ring.</param>
            <param name="bondLength">given bond length.</param>
            <param name="startAngles">a map with start angles when drawing the ring.</param>
        </member>
        <member name="M:NCDK.Layout.RingPlacer.PlaceRingSubstituents(NCDK.IRingSet,System.Double)">
            <summary>
            Positions the aliphatic substituents of a ring system
            </summary>
            <param name="rs">The RingSystem for which the substituents are to be laid out</param>
            <returns>A list of atoms that where laid out</returns>
        </member>
        <member name="M:NCDK.Layout.RingPlacer.PlaceBridgedRing(NCDK.IRing,NCDK.IAtomContainer,NCDK.Numerics.Vector2,NCDK.Numerics.Vector2,System.Double)">
            <summary>
            Generated coordinates for a given ring, which is connected to another ring a bridged ring,
            i.e. it shares more than two atoms with another ring.
            </summary>
            <param name="ring">The ring to be placed</param>
            <param name="sharedAtoms">The atoms of this ring, also members of another ring, which are already placed</param>
            <param name="sharedAtomsCenter">The geometric center of these atoms</param>
            <param name="ringCenterVector">A vector pointing the the center of the new ring</param>
            <param name="bondLength">The standard bondlength</param>
        </member>
        <member name="M:NCDK.Layout.RingPlacer.PlaceSpiroRing(NCDK.IRing,NCDK.IAtomContainer,NCDK.Numerics.Vector2,NCDK.Numerics.Vector2,System.Double)">
            <summary>
            Generated coordinates for a given ring, which is connected to a spiro ring.
            The rings share exactly one atom.
            </summary>
            <param name="ring">The ring to be placed</param>
            <param name="sharedAtoms">The atoms of this ring, also members of another ring, which are already placed</param>
            <param name="sharedAtomsCenter">The geometric center of these atoms</param>
            <param name="ringCenterVector">A vector pointing the the center of the new ring</param>
            <param name="bondLength">The standard bondlength</param>
        </member>
        <member name="M:NCDK.Layout.RingPlacer.PlaceFusedRing(NCDK.IRing,NCDK.IAtomContainer,NCDK.Numerics.Vector2,System.Double)">
            <summary>
            Generated coordinates for a given ring, which is fused to another ring.
            The rings share exactly one bond.
            </summary>
            <param name="ring">The ring to be placed</param>
            <param name="sharedAtoms">The atoms of this ring, also members of another ring, which are already placed</param>
            <param name="ringCenterVector">A vector pointing the the center of the new ring</param>
            <param name="bondLength">The standard bondlength</param>
        </member>
        <member name="M:NCDK.Layout.RingPlacer.CompletePartiallyPlacedRing(NCDK.IRingSet,NCDK.IRing,System.Double)">
            <summary>
            Completes the layout of a partiallyed laid out ring.
            </summary>
            <param name="rset">ring set</param>
            <param name="ring">the ring to complete</param>
            <param name="bondLength">the bond length</param>
        </member>
        <member name="M:NCDK.Layout.RingPlacer.GetMidPoint(NCDK.Numerics.Vector2,NCDK.Numerics.Vector2)">
            <summary>
            Get the middle of two provide points.
            </summary>
            <param name="a">first point</param>
            <param name="b">second point</param>
            <returns>mid</returns>
        </member>
        <member name="M:NCDK.Layout.RingPlacer.GetPerpendicular(NCDK.Numerics.Vector2,NCDK.Numerics.Vector2,NCDK.Numerics.Vector2)">
            <summary>
            Gat a vector perpendicular to the line, a-b, that is pointing
            the same direction as 'ref'.
            </summary>
            <param name="a">first coordinate</param>
            <param name="b">second coordinate</param>
            <param name="reference">reference vector</param>
            <returns>perpendicular vector</returns>
        </member>
        <member name="M:NCDK.Layout.RingPlacer.AllPlaced(NCDK.IRingSet)">
            <summary>
            True if coordinates have been assigned to all atoms in all rings.
            </summary>
            <param name="rs">The ringset to be checked</param>
            <returns>True if coordinates have been assigned to all atoms in all rings.</returns>
        </member>
        <member name="M:NCDK.Layout.RingPlacer.CheckAndMarkPlaced(NCDK.IRingSet)">
            <summary>
            Walks throught the atoms of each ring in a ring set and marks
            a ring as PLACED if all of its atoms have been placed.
            </summary>
            <param name="rs">The ringset to be checked</param>
        </member>
        <member name="M:NCDK.Layout.RingPlacer.GetBridgeAtoms(NCDK.IAtomContainer)">
            <summary>
            Returns the bridge atoms, that is the outermost atoms in
            the chain of more than two atoms which are shared by two rings
            </summary>
            <param name="sharedAtoms">The atoms (n > 2) which are shared by two rings</param>
            <returns>The bridge atoms, i.e. the outermost atoms in the chain of more than two atoms which are shared by two rings</returns>
        </member>
        <member name="M:NCDK.Layout.RingPlacer.PartitionNonRingPartners(NCDK.IAtom,NCDK.IRing,NCDK.IAtomContainer,NCDK.IAtomContainer)">
            <summary>
            Partition the bonding partners of a given atom into ring atoms and non-ring atoms
            </summary>
            <param name="atom">The atom whose bonding partners are to be partitioned</param>
            <param name="ring">The ring against which the bonding partners are checked</param>
            <param name="ringAtoms">An AtomContainer to store the ring bonding partners</param>
            <param name="nonRingAtoms">An AtomContainer to store the non-ring bonding partners</param>
        </member>
        <member name="M:NCDK.Layout.RingPlacer.GetNativeRingRadius(NCDK.IRing,System.Double)">
            <summary>
            Returns the ring radius of a perfect polygons of size ring.Atoms.Count
            The ring radius is the distance of each atom to the ringcenter.
            </summary>
            <param name="ring">The ring for which the radius is to calculated</param>
            <param name="bondLength">The bond length for each bond in the ring</param>
            <returns>The radius of the ring.</returns>
        </member>
        <member name="M:NCDK.Layout.RingPlacer.GetRingCenterOfFirstRing(NCDK.IRing,NCDK.Numerics.Vector2,System.Double)">
            <summary>
            Calculated the center for the first ring so that it can
            layed out. Only then, all other rings can be assigned
            coordinates relative to it.
            </summary>
            <param name="ring">The ring for which the center is to be calculated</param>
            <returns>A Vector2 pointing to the new ringcenter</returns>
        </member>
        <member name="M:NCDK.Layout.RingPlacer.PlaceConnectedRings(NCDK.IRingSet,NCDK.IRing,System.Int32,System.Double)">
            <summary>
            Layout all rings in the given RingSet that are connected to a given Ring
            </summary>
            <param name="rs">The RingSet to be searched for rings connected to Ring</param>
            <param name="ring">The Ring for which all connected rings in RingSet are to be layed out.</param>
        </member>
        <member name="F:NCDK.Layout.RingPlacer.RING_COMPARATOR">
            <summary>
            Sorts ring systems prioritising the most complex. To sort correctly,
            <see cref="M:NCDK.Layout.RingPlacer.CountHetero(System.Collections.Generic.List{NCDK.IRingSet})"/> must first be invoked.
            </summary>
        </member>
        <member name="M:NCDK.Layout.RingPlacer.CountHetero(System.Collections.Generic.List{NCDK.IRingSet})">
            <summary>
            Counds the number of hetero atoms and hetero rings in a ringset. The
            properties <code>sdg:numHeteroRings</code> and <code>sdg:numHeteroAtoms</code>
            are set.
            </summary>
            <param name="rsets">ring systems</param>
        </member>
        <member name="T:NCDK.Layout.StructureDiagramGenerator">
            <summary>
            Generates 2D coordinates for a molecule for which only connectivity is known
            or the coordinates have been discarded for some reason.
            </summary>
            <example>
            Usage: Create an instance of this class, thereby assigning a molecule,
            call <see cref="M:NCDK.Layout.StructureDiagramGenerator.GenerateCoordinates" /> and get your molecule back:
            <code>            StructureDiagramGenerator sdg = new StructureDiagramGenerator();
             sdg.Molecule = someMolecule;
             sdg.GenerateCoordinates();
            IAtomContainer layedOutMol = sdg.Molecule;
</code>
            </example>
            <remarks>
            The method will fail if the molecule is disconnected. The 
            <see cref="M:NCDK.Graphs.ConnectivityChecker.PartitionIntoMolecules(NCDK.IAtomContainer)" /> can help here.
            </remarks>
            <seealso cref="M:NCDK.Graphs.ConnectivityChecker.PartitionIntoMolecules(NCDK.IAtomContainer)" />
        </member>
        <member name="P:NCDK.Layout.StructureDiagramGenerator.BondLength">
            <summary>
            The bond length used for laying out the molecule. 
            The default value is 1.5.
            </summary>
        </member>
        <member name="P:NCDK.Layout.StructureDiagramGenerator.UseIdentityTemplates">
            <summary>
            Whether identity templates are used. Identity templates use an exact match
            are are very fast. They are used for layout of the 'primary' ring system
            in de facto orientation.
            </summary>
        </member>
        <member name="F:NCDK.Layout.StructureDiagramGenerator.selectOrientation">
            <summary>
            show we orient the structure (false: keep de facto ring systems drawn the right way up)
            </summary>
        </member>
        <member name="F:NCDK.Layout.StructureDiagramGenerator.identityLibrary">
            <summary>
            Identity templates - for laying out primary ring system.
            </summary>
        </member>
        <member name="M:NCDK.Layout.StructureDiagramGenerator.#ctor(NCDK.IAtomContainer)">
            <summary>
            Creates an instance of this class while assigning a molecule to be layed out.
            </summary>
            <param name="molecule">The molecule to be layed out.</param>
        </member>
        <member name="M:NCDK.Layout.StructureDiagramGenerator.GenerateCoordinates(NCDK.IAtomContainer)">
            <summary>
            Convenience method for generating 2D coordinates.
            </summary>
            <example>
            The method is short-hand for calling:
            <code>
            sdg.setMolecule(mol, false);
            sdg.generateCoordinates();
            </code></example>
            <param name="mol">molecule to layout</param>
            <exception cref="T:NCDK.CDKException">problem with layout</exception>
        </member>
        <member name="M:NCDK.Layout.StructureDiagramGenerator.GenerateCoordinates(NCDK.IReaction)">
            <summary>
            <para>Convenience method to generate 2D coordinates for a reaction. If atom-atom
            maps are present on a reaction, the substructures are automatically aligned.</para>
            <para>This feature can be disabled by changing the <see cref="M:NCDK.Layout.StructureDiagramGenerator.SetAlignMappedReaction(System.Boolean)"/>.</para>
            </summary>
            <param name="reaction">reaction to layout</param>
            <exception cref="T:NCDK.CDKException">problem with layout</exception>
        </member>
        <member name="M:NCDK.Layout.StructureDiagramGenerator.SetMolecule(NCDK.IAtomContainer,System.Boolean,System.Collections.Generic.ISet{NCDK.IAtom},System.Collections.Generic.ISet{NCDK.IBond})">
            <summary>
            Assigns a molecule to be laid out. After, setting the molecule call generateCoordinates() to assign
            2D coordinates. An optional set of atoms/bonds can be parsed in to allow partial layout, these will
            be 'fixed' in place. This only applies to non-cloned molecules, and only atoms with coordinates can
            be fixed.
            </summary>
            <param name="mol">the molecule for which coordinates are to be generated.</param>
            <param name="clone">Should the whole process be performed with a cloned copy?</param>
            <param name="afix">Atoms that should be fixed in place, coordinates are not changed.</param>
            <param name="bfix">Bonds that should be fixed in place, they will not be flipped, bent, or streched.</param>
        </member>
        <member name="P:NCDK.Layout.StructureDiagramGenerator.UseTemplates">
            <summary>
            whether the use of templates is enabled or disabled.
            true, when the use of templates is enables, false otherwise
            </summary>
            <remarks>always false, substructure templates are not used anymore</remarks>
        </member>
        <member name="P:NCDK.Layout.StructureDiagramGenerator.TemplateHandler">
            <summary>
            The templateHandler attribute of the <see cref="T:NCDK.Layout.StructureDiagramGenerator"/>  object.
            </summary>
            <remarks>Always <see langword="null"/>, substructure templates are not used anymore
            substructure templates are no longer used for layout but those provided here
            will be converted to identity templates</remarks>
        </member>
        <member name="M:NCDK.Layout.StructureDiagramGenerator.SetAlignMappedReaction(System.Boolean)">
            <summary>
            Set whether reaction reactants should be allignned to their product.
            </summary>
            <param name="align">align setting</param>
        </member>
        <member name="P:NCDK.Layout.StructureDiagramGenerator.Molecule">
            <summary>
            The molecule with new coordinates (if <see cref="M:NCDK.Layout.StructureDiagramGenerator.GenerateCoordinates"/> had been called)
            </summary>
        </member>
        <member name="M:NCDK.Layout.StructureDiagramGenerator.GenerateExperimentalCoordinates">
            <summary>
            This method uses <see cref="M:NCDK.Layout.StructureDiagramGenerator.GenerateCoordinates"/>, but it removes the hydrogens first,
            lays out the structure and then adds them again.
            </summary>
            <exception cref="T:NCDK.CDKException">if an error occurs</exception>
            <seealso cref="M:NCDK.Layout.StructureDiagramGenerator.GenerateCoordinates"/>
        </member>
        <member name="M:NCDK.Layout.StructureDiagramGenerator.GenerateExperimentalCoordinates(NCDK.Numerics.Vector2)">
            <summary>
            Generates 2D coordinates on the non-hydrogen skeleton, after which
            coordinates for the hydrogens are calculated.
            </summary>
            <param name="firstBondVector">the vector of the first bond to lay out</param>
            <exception cref="T:NCDK.CDKException">if an error occurs</exception>
        </member>
        <member name="M:NCDK.Layout.StructureDiagramGenerator.GenerateCoordinates(NCDK.Numerics.Vector2)">
            <summary>
            The main method of this StructurDiagramGenerator. Assign a molecule to the
            StructurDiagramGenerator, call the GenerateCoordinates() method and get
            your molecule back.
            </summary>
            <param name="firstBondVector">The vector of the first bond to layout</param>
            <exception cref="T:NCDK.CDKException">if an error occurs</exception>
        </member>
        <member name="M:NCDK.Layout.StructureDiagramGenerator.GenerateCoordinates(NCDK.Numerics.Vector2,System.Boolean,System.Boolean)">
            <summary>
            The main method of this StructureDiagramGenerator. Assign a molecule to the
            StructureDiagramGenerator, call the generateCoordinates() method and get
            your molecule back.
            </summary>
            <param name="firstBondDirection">the vector of the first bond to lay out</param>
            <param name="isConnected">the 'molecule' attribute is guaranteed to be connected (we have checked)</param>
            <param name="isSubLayout">the 'molecule' is being laid out as part of a large collection of fragments</param>
            <exception cref="T:NCDK.CDKException">problem occurred during layout</exception>
        </member>
        <member name="M:NCDK.Layout.StructureDiagramGenerator.HasFixedPart(NCDK.IAtomContainer)">
            <summary>
            Determine if any atoms in a connected molecule are fixed (i.e. already have coordinates/
            have been placed).
            </summary>
            <param name="mol">the moleucle to check</param>
            <returns>atoms are fixed</returns>
        </member>
        <member name="M:NCDK.Layout.StructureDiagramGenerator.FinalizeLayout(NCDK.IAtomContainer)">
            <summary>
            Finalize the molecule layout, primarily updating Sgroups.
            </summary>
            <param name="mol">molecule being laid out</param>
        </member>
        <member name="M:NCDK.Layout.StructureDiagramGenerator.SelectOrientation(NCDK.IAtomContainer,System.Double,System.Int32)">
            <summary>
            Select the global orientation of the layout. We click round at 30 degree increments
            and select the orientation that a) is the widest or b) has the most bonds aligned to
            +/- 30 degrees <token>cdk-cite-Clark06</token>.
            </summary>
            <param name="mol">molecule</param>
            <param name="widthDiff">parameter at which to consider orientations equally good (wide select)</param>
            <param name="alignDiff">parameter at which we consider orientations equally good (bond align select)</param>
        </member>
        <member name="M:NCDK.Layout.StructureDiagramGenerator.CountAlignedBonds(NCDK.IAtomContainer)">
            <summary>
            Count the number of bonds aligned to 30 degrees.
            </summary>
            <param name="mol">molecule</param>
            <returns>number of aligned bonds</returns>
        </member>
        <member name="M:NCDK.Layout.StructureDiagramGenerator.GetAprxBounds(NCDK.IAtomContainer)">
            <summary>
            Similar to the method <see cref="M:NCDK.Geometries.GeometryUtil.GetMinMax(NCDK.IAtomContainer)"/> but considers
            heteroatoms with hydrogens.
            </summary>
            <param name="mol">molecule</param>
            <returns>the min/max x and y bounds</returns>
        </member>
        <member name="F:NCDK.Layout.StructureDiagramGenerator.FragmentCharge">
            <summary>
            Property to cache the charge of a fragment.
            </summary>
        </member>
        <member name="M:NCDK.Layout.StructureDiagramGenerator.MergeAtomicIons(System.Collections.Generic.IEnumerable{NCDK.IAtomContainer})">
            <summary>
            Merge fragments with duplicate atomic ions (e.g. [Na+].[Na+].[Na+]) into
            single fragments.
            </summary>
            <param name="frags">input fragments (all connected)</param>
            <returns>the merge ions</returns>
        </member>
        <member name="M:NCDK.Layout.StructureDiagramGenerator.SelectIons(NCDK.IAtomContainer,System.Int32)">
            <summary>
            Select ions from a charged fragment. Ions not in charge separated
            bonds are favoured but select if needed. If an atom has lost or
            gained more than one electron it is added mutliple times to the
            output list
            </summary>
            <param name="frag">charged fragment</param>
            <param name="sign">the charge sign to select (+1 : cation, -1: anion)</param>
            <returns>the select atoms (includes duplicates)</returns>
        </member>
        <member name="M:NCDK.Layout.StructureDiagramGenerator.MakeIonicBonds(System.Collections.Generic.IEnumerable{NCDK.IAtomContainer})">
            <summary>
            Alternative method name "Humpty Dumpty" (a la. R Sayle).
            </summary>
            <remarks>
            (Re)bonding of ionic fragments for improved layout. This method takes a list
            of two or more fragments and creates zero or more bonds (return value) that
            should be temporarily used for layout generation. In general this problem is
            difficult but since molecules will be laid out in a grid by default - any
            positioning is an improvement. Heuristics could be added if bad (re)bonds
            are seen.
            </remarks>
            <param name="frags">connected fragments</param>
            <returns>ionic bonds to make</returns>
        </member>
        <member name="M:NCDK.Layout.StructureDiagramGenerator.NullAsZero(System.Nullable{System.Int32})">
            <summary>
            Utility - safely access Object Integers as primitives, when we want the
            default value of null to be zero.
            </summary>
            <param name="x">number</param>
            <returns>the number primitive or zero if null</returns>
        </member>
        <member name="M:NCDK.Layout.StructureDiagramGenerator.GenerateCoordinates">
            <summary>
            The main method of this StructurDiagramGenerator. Assign a molecule to the
            StructurDiagramGenerator, call the GenerateCoordinates() method and get
            your molecule back.
            </summary>
            <exception cref="T:NCDK.CDKException">if an error occurs</exception>
        </member>
        <member name="M:NCDK.Layout.StructureDiagramGenerator.LookupRingSystem(NCDK.IRingSet,NCDK.IAtomContainer,System.Boolean)">
            <summary>
            Using a fast identity template library, lookup the the ring system and assign coordinates.
            The method indicates whether a match was found and coordinates were assigned.
            </summary>
            <param name="rs">the ring set</param>
            <param name="molecule">the rest of the compound</param>
            <param name="anon">check for anonmised templates</param>
            <returns>coordinates were assigned</returns>
        </member>
        <member name="M:NCDK.Layout.StructureDiagramGenerator.IsHydrogen(NCDK.IAtom)">
            <summary>
            Is an atom a hydrogen atom.
            </summary>
            <param name="atom">an atom</param>
            <returns>the atom is a hydrogen</returns>
        </member>
        <member name="M:NCDK.Layout.StructureDiagramGenerator.ClearHydrogenCounts(NCDK.IAtomContainer)">
            <summary>
            Simple helper function that sets all hydrogen counts to 0.
            </summary>
            <param name="container">a structure representation</param>
            <returns>the input container</returns>
        </member>
        <member name="M:NCDK.Layout.StructureDiagramGenerator.LayoutRingSet(NCDK.Numerics.Vector2,NCDK.IRingSet)">
            <summary>
            Layout a set of connected rings (ring set/ring system). 
            <para>
            Current Scheme:
              1. Lookup the entire ring system for a known template.
              2. If first (most complex) ring is macrocycle,
                 2a. Assign coordinates from macro cycle templates
              3. If first is not-macrocycle (or currently doesn't match out templates)
                 3a. Layout as regular polygon
              4. Sequentially connected layout rings <see cref="T:NCDK.Layout.RingPlacer"/>
             </para>
            </summary>
            <param name="firstBondVector">A vector giving the placement for the first bond</param>
            <param name="rs">The connected RingSet to layout</param>
        </member>
        <member name="M:NCDK.Layout.StructureDiagramGenerator.GetRingSetCore(NCDK.IRingSet)">
            <summary>
            Peel back terminal rings to the complex 'core': <token>cdk-cite-Helson99</token>, <token>cdk-cite-Clark06</token>.
            </summary>
            <param name="rs">ring set</param>
            <returns>the ring set core</returns>
        </member>
        <member name="M:NCDK.Layout.StructureDiagramGenerator.IsMacroCycle(NCDK.IRing,NCDK.IChemObjectSet{NCDK.IRing})">
            <summary>
            Check if a ring in a ring set is a macro cycle. We define this as a
            ring with >= 10 atom and has at least one bond that isn't contained
            in any other rings.
            </summary>
            <param name="ring">ring to check</param>
            <param name="rs">rest of ring system</param>
            <returns>ring is a macro cycle</returns>
        </member>
        <member name="M:NCDK.Layout.StructureDiagramGenerator.LayoutAcyclicParts">
            <summary>
            Does a layout of all aliphatic parts connected to the parts of the molecule
            that have already been laid out. Starts at the first bond with unplaced
            neighbours and stops when a ring is encountered.
            </summary>
            <exception cref="T:NCDK.CDKException">if an error occurs</exception>
        </member>
        <member name="M:NCDK.Layout.StructureDiagramGenerator.LayoutCyclicParts">
            <summary>
            Does the layout for the next RingSystem that is connected to those parts of
            the molecule that have already been laid out. Finds the next ring with an
            unplaced ring atom and lays out this ring. Then lays out the ring substituents
            of this ring. Then moves and rotates the laid out ring to match the position
            of its attachment bond to the rest of the molecule.
            </summary>
            <exception cref="T:NCDK.CDKException">if an error occurs</exception>
        </member>
        <member name="M:NCDK.Layout.StructureDiagramGenerator.GetUnplacedAtoms(NCDK.IAtom)">
            <summary>
            Returns an AtomContainer with all unplaced atoms connected to a given atom
            </summary>
            <param name="atom">The Atom whose unplaced bonding partners are to be returned</param>
            <returns>an AtomContainer with all unplaced atoms connected to a given atom</returns>
        </member>
        <member name="M:NCDK.Layout.StructureDiagramGenerator.GetPlacedAtoms(NCDK.IAtom)">
            <summary>
            Returns an AtomContainer with all placed atoms connected to a given atom
            </summary>
            <param name="atom">The Atom whose placed bonding partners are to be returned</param>
            <returns>an AtomContainer with all placed atoms connected to a given atom</returns>
        </member>
        <member name="M:NCDK.Layout.StructureDiagramGenerator.GetNextAtomWithAliphaticUnplacedNeigbors">
            <summary>
            Returns the next atom with unplaced aliphatic neighbors
            </summary>
            <returns>the next atom with unplaced aliphatic neighbors</returns>
        </member>
        <member name="M:NCDK.Layout.StructureDiagramGenerator.GetNextBondWithUnplacedRingAtom">
            <summary>
            Returns the next bond with an unplaced ring atom
            </summary>
            <returns>the next bond with an unplaced ring atom</returns>
        </member>
        <member name="M:NCDK.Layout.StructureDiagramGenerator.PlaceFirstBond(NCDK.IBond,NCDK.Numerics.Vector2)">
            <summary>
            Places the first bond of the first ring such that one atom is at (0,0) and
            the other one at the position given by bondVector
            </summary>
            <param name="bondVector">A 2D vector to point to the position of the second bond atom</param>
            <param name="bond">the bond to lay out</param>
            <returns>an IAtomContainer with the atoms of the bond and the bond itself</returns>
        </member>
        <member name="M:NCDK.Layout.StructureDiagramGenerator.AllPlaced(NCDK.IRingSet)">
            <summary>
            Are all rings in the Vector placed?
            </summary>
            <param name="rings">The Vector to be checked</param>
            <returns>true if all rings are placed, false otherwise</returns>
        </member>
        <member name="M:NCDK.Layout.StructureDiagramGenerator.GetRingAtom(NCDK.IBond)">
            <summary>
            Get the unplaced ring atom in this bond
            </summary>
            <param name="bond">the bond to be search for the unplaced ring atom</param>
            <returns>the unplaced ring atom in this bond</returns>
        </member>
        <member name="M:NCDK.Layout.StructureDiagramGenerator.GetRingSystemOfAtom(System.Collections.Generic.IList{NCDK.IRingSet},NCDK.IAtom)">
            <summary>
            Get the ring system of which the given atom is part of
            </summary>
            <param name="ringSystems">a List of ring systems to be searched</param>
            <param name="ringAtom">the ring atom to be search in the ring system.</param>
            <returns>the ring system the given atom is part of</returns>
        </member>
        <member name="M:NCDK.Layout.StructureDiagramGenerator.ResetUnplacedRings">
            <summary>
            Set all the atoms in unplaced rings to be unplaced
            </summary>
        </member>
        <member name="M:NCDK.Layout.StructureDiagramGenerator.GetOtherBondAtom(NCDK.IAtom,NCDK.IBond)">
            <summary>
            Returns the other atom of the bond.
            Expects bond to have only two atoms.
            Returns null if the given atom is not part of the given bond.
            </summary>
            <param name="atom">the atom we already have</param>
            <param name="bond">the bond</param>
            <returns>the other atom of the bond</returns>
        </member>
        <member name="M:NCDK.Layout.StructureDiagramGenerator.PlaceMultipleGroups(NCDK.IAtomContainer)">
            <summary>
            Multiple groups need special placement by overlaying the repeat part coordinates.
            </summary>
            coordinates on each other.
            <param name="mol">molecule to place the multiple groups of</param>
        </member>
        <member name="M:NCDK.Layout.StructureDiagramGenerator.PlaceSgroupBrackets(NCDK.IAtomContainer)">
            <summary>
            Place and update brackets for polymer Sgroups.
            </summary>
            <param name="mol">molecule</param>
        </member>
        <member name="M:NCDK.Layout.StructureDiagramGenerator.NewCrossingBracket(NCDK.IBond,NCDK.Common.Collections.IMultiDictionary{NCDK.IBond,NCDK.SGroups.Sgroup},System.Collections.Generic.IDictionary{NCDK.IBond,System.Int32},System.Boolean)">
            <summary>
            Generate a new bracket across the provided bond.
            </summary>
            <param name="bond">bond</param>
            <param name="bonds">bond map to Sgroups</param>
            <param name="counter">count how many brackets this group has already</param>
            <param name="vert">vertical align bonds</param>
            <returns>the new bracket</returns>
        </member>
        <member name="M:NCDK.Layout.StructureDiagramGenerator.HasBrackets(NCDK.SGroups.Sgroup)">
            <summary>
            Determine whether and Sgroup type has brackets to be placed.
            </summary>
            <param name="sgroup">the Sgroup</param>
            <returns>brackets need to be placed</returns>
        </member>
        <member name="T:NCDK.Layout.TemplateHandler">
            <summary>
            Helper class for Structure Diagram Generation. Handles templates. This is
            our layout solution for ring systems which are notoriously difficult to
            layout, like cubane, adamantane, porphyrin, etc.
            </summary>
        </member>
        <member name="M:NCDK.Layout.TemplateHandler.#ctor(NCDK.IChemObjectBuilder)">
            <summary>
            Creates a new TemplateHandler with default templates loaded.
            </summary>
        </member>
        <member name="M:NCDK.Layout.TemplateHandler.#ctor">
            <summary>
            Creates a new TemplateHandler without any default templates.
            </summary>
        </member>
        <member name="M:NCDK.Layout.TemplateHandler.LoadTemplates(NCDK.IChemObjectBuilder)">
            <summary>
            Loads all existing templates into memory. To add templates to be used in
            SDG, place a drawing with the new template in org/openscience/cdk/layout/templates and add the
            template filename to org/openscience/cdk/layout/templates/template.list
            </summary>
        </member>
        <member name="M:NCDK.Layout.TemplateHandler.AddMolecule(NCDK.IAtomContainer)">
            <summary>
            Adds a Molecule to the list of templates use by this TemplateHandler.
            </summary>
            <param name="molecule">The molecule to be added to the TemplateHandler</param>
        </member>
        <member name="M:NCDK.Layout.TemplateHandler.MapTemplateExact(NCDK.IAtomContainer)">
            <summary>
            Checks if one of the loaded templates is isomorph to the given
            Molecule. If so, it assigns the coordinates from the template to the
            respective atoms in the Molecule, and marks the atoms as ISPLACED.
            </summary>
            <param name="molecule">The molecule to be check for potential templates</param>
            <returns>True if there was a possible mapping</returns>
        </member>
        <member name="M:NCDK.Layout.TemplateHandler.MapTemplates(NCDK.IAtomContainer)">
            <summary>
            Checks if one of the loaded templates is a substructure in the given
            Molecule. If so, it assigns the coordinates from the template to the
            respective atoms in the Molecule, and marks the atoms as ISPLACED.
            </summary>
            <param name="molecule">The molecule to be check for potential templates</param>
            <returns>True if there was a possible mapping</returns>
        </member>
        <member name="P:NCDK.Layout.TemplateHandler.TemplateCount">
            <summary>
            The templateCount attribute of the <see cref="T:NCDK.Layout.TemplateHandler"/> object.
            </summary>
        </member>
        <member name="M:NCDK.Layout.TemplateHandler.GetTemplateAt(System.Int32)">
            <summary>
            Gets the templateAt attribute of the TemplateHandler object
            </summary>
            <param name="position">Description of the Parameter</param>
            <returns>The templateAt value</returns>
        </member>
        <member name="M:NCDK.Layout.TemplateHandler.GetMappedSubstructures(NCDK.IAtomContainer)">
            <summary>
            Checks if one of the loaded templates is a substructure in the given
            Molecule and returns all matched substructures in a IAtomContainerSet.
            This method does not assign any coordinates.
            </summary>
            <param name="molecule">The molecule to be check for potential templates</param>
            <returns>an IAtomContainerSet of all matched substructures of the molecule</returns>
            <exception cref="T:NCDK.CDKException">if an error occurs</exception>
        </member>
        <member name="M:NCDK.Layout.TemplateHandler.CreateSingleton(NCDK.IAtomContainer)">
             <summary>
             Singleton template instance, mainly useful for aligning molecules. If the template
             does not have coordinates an error is thrown.
            
             For safety we clone the molecule.
             </summary>
             <param name="template">the molecule</param>
             <returns>new template handler</returns>
        </member>
        <member name="M:NCDK.Layout.TemplateHandler.CreateFromSubstructure(NCDK.Isomorphisms.Pattern,System.Collections.Generic.IEnumerable{NCDK.IAtomContainer})">
            <summary>
            Create a template from a substructure pattern. Using this template handler in the diagram
            generator then allows us to align to common reference.
            </summary>
            <param name="ptrn">the structure pattern to match</param>
            <param name="mols">list of molecules</param>
            <returns>new template handler</returns>
        </member>
        <member name="M:NCDK.Layout.TemplateHandler.CreateFromSubstructure(NCDK.Isomorphisms.Pattern,NCDK.IAtomContainer)">
            <summary>
            Create a template from a substructure pattern. Using this template handler in the diagram
            generator then allows us to align to common reference.
            </summary>
            <param name="ptrn">the structure pattern to match</param>
            <param name="mol">molecule</param>
            <returns>new template handler</returns>
        </member>
        <member name="M:NCDK.Layout.TemplateHandler.ToIdentityTemplateLibrary">
            <summary>
            Convert to an identity template library.
            </summary>
            <returns>identity template library</returns>
        </member>
        <member name="T:NCDK.StructGen.MathTools">
            <summary>
            Class providing convenience methods for simple mathematical operations.
            </summary>
        </member>
        <member name="M:NCDK.StructGen.MathTools.Max(System.Double[])">
            <summary>
            Analog of <see cref="M:System.Math.Max(System.Double,System.Double)"/>  that returns the largest double value in an array of doubles.
            </summary>
            <param name="values">the values to be searched for the largest value among them</param>
            <returns>the largest value among a set of given values</returns>
        </member>
        <member name="M:NCDK.StructGen.MathTools.Min(System.Double[])">
            <summary>
            Analog of <see cref="M:System.Math.Min(System.Double,System.Double)"/> that returns the largest double value in an array of double.
            </summary>
            <param name="values">the values to be searched for the smallest value among them</param>
            <returns>the smallest value among a set of given values</returns>
        </member>
        <member name="M:NCDK.StructGen.MathTools.Max(System.Int32[])">
            <summary>
            Analog of <see cref="M:System.Math.Max(System.Int32,System.Int32)"/> that returns the largest int value in an array of ints.
            </summary>
        </member>
        <member name="M:NCDK.StructGen.MathTools.Min(System.Int32[])">
            <summary>
            Analog of <see cref="M:System.Math.Min(System.Int32,System.Int32)"/> that returns the largest int value in an array of ints.
            </summary>
        </member>
        <member name="T:NCDK.StructGen.RandomGenerator">
            <summary>
            RandomGenerator is a generator of constitutional isomers. It needs to be
            provided with a starting constitution and it makes random moves in
            constitutional space from there.
            This generator was first suggested by J.-L. Faulon <token>cdk-cite-FAU96</token>.
            </summary>
            <remarks>
            <para>Unlike the VicinitySampler, this methods does not sample
            the full Faulon vicinity.</para>
            </remarks>
            <seealso cref="T:NCDK.StructGen.VicinitySampler"/>
        </member>
        <member name="M:NCDK.StructGen.RandomGenerator.#ctor(NCDK.IAtomContainer)">
            <summary>
            Constructs a RandomGenerator with a given starting structure.
            </summary>
            <param name="molecule">The starting structure</param>
        </member>
        <member name="M:NCDK.StructGen.RandomGenerator.ProposeStructure">
            <summary>
            Proposes a structure which can be accepted or rejected by an external
            entity. If rejected, the structure is not used as a starting point
            for the next random move in structure space.
            </summary>
            <returns>A proposed molecule</returns>
        </member>
        <member name="M:NCDK.StructGen.RandomGenerator.AcceptStructure">
            <summary>
            Tell the RandomGenerator to accept the last structure that had been proposed.
            </summary>
        </member>
        <member name="M:NCDK.StructGen.RandomGenerator.Mutate(NCDK.IAtomContainer)">
            <summary>
            Randomly chooses four atoms and alters the bonding
            pattern between them according to rules described
            in "Faulon, JCICS 1996, 36, 731".
            </summary>
        </member>
        <member name="M:NCDK.StructGen.RandomGenerator.SetMolecule(NCDK.IAtomContainer)">
            <summary>
            Assigns a starting structure to this generator.
            </summary>
            <param name="molecule">a starting structure for this generator</param>
        </member>
        <member name="P:NCDK.StructGen.RandomGenerator.Molecule">
            <summary>
            Returns the molecule which reflects the current state of this
            stochastic structure generator.
            </summary>
            <returns>The molecule</returns>
        </member>
        <member name="T:NCDK.StructGen.SingleStructureRandomGenerator">
            <summary>
            Randomly generates a single, connected, correctly bonded structure for
            a given molecular formula.
            To see it working run the graphical
            test org.openscience.cdk.test.SingleStructureRandomGeneratorTest
            and add more structures to the panel using the "More" button.
            In order to use this class, use MFAnalyser to get an AtomContainer from
            a molecular formula string.
            </summary>
            <remarks>
            <para>Assign hydrogen counts to each heavy atom. The hydrogens should not be
            in the atom pool but should be assigned implicitly to the heavy atoms in
            order to reduce computational cost.
            Assign this AtomContainer to the
            SingleStructureRandomGenerator and retrieve a randomly generated, but correctly bonded
            structure by using the Generate() method. You can then repeatedly call
            the Generate() method in order to retrieve further structures.</para>
            <para>
            Agenda:
            <list type="bullet">
             <item>add a method for randomly adding hydrogens to the atoms</item>
             <item>add a seed for random generator for reproducability</item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:NCDK.StructGen.SingleStructureRandomGenerator.#ctor(System.Int64)">
            <summary>
            Constructor for the SingleStructureRandomGenerator object.
            </summary>
        </member>
        <member name="M:NCDK.StructGen.SingleStructureRandomGenerator.#ctor">
            <summary>
            Constructor for the SingleStructureRandomGenerator object.
            </summary>
        </member>
        <member name="M:NCDK.StructGen.SingleStructureRandomGenerator.SetAtomContainer(NCDK.IAtomContainer)">
             <summary>
             Sets the AtomContainer attribute of the SingleStructureRandomGenerator object.
            
             <param name="ac">The new AtomContainer value</param>
             </summary>
        </member>
        <member name="M:NCDK.StructGen.SingleStructureRandomGenerator.Generate">
            <summary>
            Generates a random structure based on the atoms in the given IAtomContainer.
            </summary>
        </member>
        <member name="M:NCDK.StructGen.SingleStructureRandomGenerator.GetAnotherUnsaturatedNode(NCDK.IAtom)">
            <summary>
            Gets the AnotherUnsaturatedNode attribute of the SingleStructureRandomGenerator object.
            </summary>
            <returns>The AnotherUnsaturatedNode value</returns>
        </member>
        <member name="T:NCDK.StructGen.Stochastic.Operator.CrossoverMachine">
            <summary>
            Modified molecular structures by applying crossover operator on a pair of parent structures
            and generate a pair of offspring structures. Each of the two offspring structures inherits
            a certain fragments from both of its parents.
            </summary>
        </member>
        <member name="T:NCDK.StructGen.Stochastic.Operator.CrossoverMachine.SplitModes">
            <summary>
            Indicates which mode <see cref="T:NCDK.StructGen.Stochastic.Operator.CrossoverMachine"/> is using.
            </summary>
        </member>
        <member name="F:NCDK.StructGen.Stochastic.Operator.CrossoverMachine.SplitModes.Random">
            <summary>Random mode.</summary>
        </member>
        <member name="F:NCDK.StructGen.Stochastic.Operator.CrossoverMachine.SplitModes.DepthFirst">
            <summary>Depth first mode.</summary>
        </member>
        <member name="F:NCDK.StructGen.Stochastic.Operator.CrossoverMachine.SplitModes.BreadthFirst">
            <summary>Breadth first mode.</summary>
        </member>
        <member name="F:NCDK.StructGen.Stochastic.Operator.CrossoverMachine.splitMode">
            <summary>selects a partitioning mode</summary>
        </member>
        <member name="F:NCDK.StructGen.Stochastic.Operator.CrossoverMachine.numatoms">
            <summary>selects a partitioning scale</summary>
        </member>
        <member name="M:NCDK.StructGen.Stochastic.Operator.CrossoverMachine.#ctor">
            <summary>Constructs a new CrossoverMachine operator.</summary>
        </member>
        <member name="M:NCDK.StructGen.Stochastic.Operator.CrossoverMachine.DoCrossover(NCDK.IAtomContainer,NCDK.IAtomContainer)">
            <summary>
            Performs the n point crossover of two <see cref="T:NCDK.IAtomContainer"/>.
            Precondition: The atoms in the molecules are ordered by properties to
            preserve (e. g. atom symbol). Due to its randomized nature, this method
            fails in around 3% of all cases. A CDKException with message "Could not
            mate these properly" will then be thrown.
            </summary>
            <returns>The children.</returns>
            <exception cref="T:NCDK.CDKException">if it was not possible to form offsprings.</exception>
        </member>
        <member name="T:NCDK.StructGen.Stochastic.PartialFilledStructureMerger">
            <summary>
            Randomly generates a single, connected, correctly bonded structure from
            a number of fragments.
            <para>Assign hydrogen counts to each heavy atom. The hydrogens should not be
            in the atom pool but should be assigned implicitly to the heavy atoms in
            order to reduce computational cost.</para>
            </summary>
        </member>
        <member name="M:NCDK.StructGen.Stochastic.PartialFilledStructureMerger.#ctor">
            <summary>
            Constructor for the PartialFilledStructureMerger object.
            </summary>
        </member>
        <member name="M:NCDK.StructGen.Stochastic.PartialFilledStructureMerger.Generate(NCDK.IChemObjectSet{NCDK.IAtomContainer})">
            <summary>
            Randomly generates a single, connected, correctly bonded structure from
            a number of fragments.  IMPORTANT: The AtomContainers in the set must be
            connected. If an AtomContainer is disconnected, no valid result will
            be formed
            </summary>
            <param name="atomContainers">The fragments to generate for.</param>
            <returns>The newly formed structure.</returns>
            <exception cref="T:NCDK.CDKException">No valid result could be formed.</exception>"
        </member>
        <member name="M:NCDK.StructGen.Stochastic.PartialFilledStructureMerger.GetAnotherUnsaturatedNode(NCDK.IAtom,NCDK.IAtomContainer,NCDK.IChemObjectSet{NCDK.IAtomContainer})">
            <summary>
             Gets a randomly selected unsaturated atom from the set. If there are any, it will be from another
             container than exclusionAtom.
            </summary>
            <returns>The unsaturated atom.</returns>
        </member>
        <member name="T:NCDK.StructGen.VicinitySampler">
            <summary>
            The VicinitySampler is a generator of constitutional isomers. It needs to be
            provided with a starting constitution and it makes random moves in
            constitutional space from there. This generator was first suggested by
            Faulon <token>cdk-cite-FAU96</token>.
            </summary>
        </member>
        <member name="M:NCDK.StructGen.VicinitySampler.Sample(NCDK.IAtomContainer)">
            <summary>
            Choose any possible quadruple of the set of atoms
            in ac and establish all of the possible bonding schemes according to
            Faulon's equations.
            </summary>
        </member>
        <member name="T:NCDK.Modelings.Builder3D.AtomPlacer3D">
            <summary>
            Place aliphatic <b>chains</b> with Z matrix method. Please use <see cref="T:NCDK.Modelings.Builder3D.ModelBuilder3D"/> 
            to place general molecules.
            </summary>
            <seealso cref="T:NCDK.Modelings.Builder3D.ModelBuilder3D"/>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.AtomPlacer3D.Initilize(System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
             Initialize the atomPlacer class.
            </summary>
            <param name="parameterSet">Force Field parameter as Dictionary</param>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.AtomPlacer3D.FindHeavyAtomsInChain(NCDK.IAtomContainer,NCDK.IAtomContainer)">
            <summary>
             Count and find first heavy Atom(s) (non Hydrogens) in a chain.
            </summary>
            <param name="molecule">the reference molecule for searching the chain</param>
            <param name="chain">chain to be searched</param>
            <returns>the atom number of the first heavy atom the number of heavy atoms in the chain</returns>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.AtomPlacer3D.MarkPlaced(NCDK.IAtomContainer)">
            <summary>
             Mark all atoms in chain as placed. (<see cref="P:NCDK.IChemObject.IsPlaced"/>)
            </summary>
            <param name="ac">chain</param>
            <returns>chain all atoms marked as placed</returns>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.AtomPlacer3D.PlaceAliphaticHeavyChain(NCDK.IAtomContainer,NCDK.IAtomContainer)">
            <summary>
             Method assigns 3D coordinates to the heavy atoms in an aliphatic chain.
            </summary>
            <param name="molecule">the reference molecule for the chain</param>
            <param name="chain">the atoms to be assigned, must be connected</param>
            <exception cref="T:NCDK.CDKException">the 'chain' was not a chain</exception>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.AtomPlacer3D.ZMatrixChainToCartesian(NCDK.IAtomContainer,System.Boolean)">
            <summary>
            Takes the given Z Matrix coordinates and converts them to cartesian coordinates.
            The first Atom end up in the origin, the second on on the x axis, and the third
            one in the XY plane. The rest is added by applying the Zmatrix distances, angles
            and dihedrals. Assign coordinates directly to the atoms.
            </summary>
            <param name="molecule">the molecule to be placed in 3D</param>
            <param name="flagBranched">marks branched chain</param>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.AtomPlacer3D.GetHybridisationState(NCDK.IAtom)">
            <summary>
             Gets the hybridisation state of an atom.
            </summary>
            <param name="atom1">atom</param>
            <returns>The hybridisationState value (sp=1;sp2=2;sp3=3)</returns>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.AtomPlacer3D.GetDoubleBondConfiguration2D(NCDK.IBond,System.Nullable{NCDK.Numerics.Vector2},System.Nullable{NCDK.Numerics.Vector2},System.Nullable{NCDK.Numerics.Vector2},System.Nullable{NCDK.Numerics.Vector2})">
            <summary>
             Gets the doubleBondConfiguration2D attribute of the AtomPlacer3D object
             using existing 2D coordinates.
            </summary>
            <param name="bond">the double bond</param>
            <param name="aa">coordinates (Vector2) of atom1 connected to bond</param>
            <param name="bb">coordinates (Vector2) of atom2 connected to bond</param>
            <param name="cc">coordinates (Vector2) of atom3 connected to bond</param>
            <param name="dd">coordinates (Vector2) of atom4 connected to bond</param>
            <returns>The doubleBondConfiguration2D value</returns>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.AtomPlacer3D.GetBondLengthValue(System.String,System.String)">
            <summary>
             Gets the distanceValue attribute of the parameter set.
            </summary>
            <param name="id1">atom1 id</param>
            <param name="id2">atom2 id</param>
            <returns>The distanceValue value from the force field parameter set</returns>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.AtomPlacer3D.GetAngleValue(System.String,System.String,System.String)">
            <summary>
             Gets the angleKey attribute of the AtomPlacer3D object.
            </summary>
            <param name="id1">Description of the Parameter</param>
            <param name="id2">Description of the Parameter</param>
            <param name="id3">Description of the Parameter</param>
            <returns>The angleKey value</returns>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.AtomPlacer3D.GetNextUnplacedHeavyAtomWithAliphaticPlacedNeighbour(NCDK.IAtomContainer)">
            <summary>
             Gets the nextUnplacedHeavyAtomWithAliphaticPlacedNeighbour from an atom container or molecule.
            </summary>
            <param name="molecule"></param>
            <returns>The <see cref="M:NCDK.Modelings.Builder3D.AtomPlacer3D.GetNextUnplacedHeavyAtomWithAliphaticPlacedNeighbour(NCDK.IAtomContainer)"/> value</returns>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.AtomPlacer3D.GetUnplacedHeavyAtom(NCDK.IAtomContainer)">
            <summary>
            Find the first unplaced atom.
            </summary>
            <param name="molecule">molecule being built</param>
            <returns>an unplaced heavy atom, null if none.</returns>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.AtomPlacer3D.GetNextPlacedHeavyAtomWithUnplacedAliphaticNeighbour(NCDK.IAtomContainer)">
            <summary>
             Gets the nextPlacedHeavyAtomWithAliphaticPlacedNeigbor from an atom container or molecule.
            </summary>
            <param name="molecule"></param>
            <returns><see cref="M:NCDK.Modelings.Builder3D.AtomPlacer3D.GetNextUnplacedHeavyAtomWithAliphaticPlacedNeighbour(NCDK.IAtomContainer)"/></returns>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.AtomPlacer3D.GetNextPlacedHeavyAtomWithUnplacedRingNeighbour(NCDK.IAtomContainer)">
            <summary>
             Gets the nextPlacedHeavyAtomWithUnplacedRingNeighbour attribute of the AtomPlacer3D object.
            </summary>
            <param name="molecule">The atom container under consideration</param>
            <returns>The <see cref="M:NCDK.Modelings.Builder3D.AtomPlacer3D.GetNextPlacedHeavyAtomWithUnplacedRingNeighbour(NCDK.IAtomContainer)"/> value</returns>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.AtomPlacer3D.GetFarthestAtom(NCDK.Numerics.Vector3,NCDK.IAtomContainer)">
            <summary>
             Gets the farthestAtom attribute of the AtomPlacer3D object.
            </summary>
            <param name="refAtomPoint">Description of the Parameter</param>
            <param name="ac">Description of the Parameter</param>
            <returns>The farthestAtom value</returns>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.AtomPlacer3D.GetUnplacedRingHeavyAtom(NCDK.IAtomContainer,NCDK.IAtom)">
            <summary>
             Gets the unplacedRingHeavyAtom attribute of the AtomPlacer3D object.
            </summary>
            <param name="molecule">/// <param name="atom">Description of the Parameter</param></param>
            <returns>The unplacedRingHeavyAtom value</returns>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.AtomPlacer3D.GeometricCenterAllPlacedAtoms(NCDK.IAtomContainer)">
            <summary>
             Calculates the geometric center of all placed atoms in the atomcontainer.
            </summary>
            <param name="molecule"></param>
            <returns><see cref="T:NCDK.Numerics.Vector3"/> the geometric center</returns>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.AtomPlacer3D.GetPlacedHeavyAtom(NCDK.IAtomContainer,NCDK.IAtom)">
            <summary>
             Returns a placed atom connected to a given atom.
            </summary>
            <param name="molecule"></param>
            <param name="atom">The Atom whose placed bonding partners are to be returned</param>
            <returns>a placed heavy atom connected to a given atom</returns>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.AtomPlacer3D.GetPlacedHeavyAtom(NCDK.IAtomContainer,NCDK.IAtom,NCDK.IAtom)">
            <summary>
             Gets the first placed Heavy Atom around atomA which is not atomB.
            </summary>
            <param name="molecule"></param>
            <param name="atomA">Description of the Parameter</param>
            <param name="atomB">Description of the Parameter</param>
            <returns>The placedHeavyAtom value</returns>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.AtomPlacer3D.GetPlacedHeavyAtoms(NCDK.IAtomContainer,NCDK.IAtom)">
            <summary>
             Gets the placed Heavy Atoms connected to an atom.
            </summary>
            <param name="molecule"></param>
            <param name="atom">The atom the atoms must be connected to.</param>
            <returns>The placed heavy atoms.</returns>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.AtomPlacer3D.NumberOfUnplacedHeavyAtoms(NCDK.IAtomContainer)">
            <summary>
            Gets numberOfUnplacedHeavyAtoms (no Flag ISPLACED, no Hydrogens)
            </summary>
            <param name="ac">AtomContainer</param>
            <returns>Number of <see cref="M:NCDK.Modelings.Builder3D.AtomPlacer3D.GetUnplacedHeavyAtom(NCDK.IAtomContainer)"/></returns>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.AtomPlacer3D.GetAllPlacedAtoms(NCDK.IAtomContainer)">
            <summary>
             Gets the allPlacedAtoms attribute of the AtomPlacer3D object.
            </summary>
            <returns>The allPlacedAtoms value</returns>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.AtomPlacer3D.AllHeavyAtomsPlaced(NCDK.IAtomContainer)">
            <summary>
             True is all the atoms in the given AtomContainer have been placed.
            </summary>
            <param name="ac">The AtomContainer to be searched</param>
            <returns>True is all the atoms in the given AtomContainer have been placed</returns>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.AtomPlacer3D.IsUnplacedHeavyAtom(NCDK.IAtom)">
            <summary>
             Determine if the atom is non-hydrogen and has not been placed.
            </summary>
            <param name="atom">The atom to be checked</param>
            <returns>True if the atom is non-hydrogen and has not been placed</returns>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.AtomPlacer3D.IsPlacedHeavyAtom(NCDK.IAtom)">
            <summary>
             Determine if the atom is non-hydrogen and has been placed.
            </summary>
            <param name="atom">The atom to be checked</param>
            <returns>True if the atom is non-hydrogen and has been placed</returns>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.AtomPlacer3D.IsAliphaticHeavyAtom(NCDK.IAtom)">
            <summary>
             Determine if the atom is non-hydrogen and is aliphatic.
            </summary>
            <param name="atom">The atom to be checked</param>
            <returns>True if the atom is non-hydrogen and is aliphatic</returns>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.AtomPlacer3D.IsRingHeavyAtom(NCDK.IAtom)">
            <summary>
            Determine if the atom is non-hydrogen and is in a ring.
            Ring membership is determined from a property flag only, rather than a ring
            membership test
            </summary>
            <param name="atom">The atom to be checked</param>
            <returns>True if the atom is non-hydrogen and is in a ring</returns>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.AtomPlacer3D.IsHeavyAtom(NCDK.IAtom)">
            <summary>
            Determine if the atom is heavy (non-hydrogen).
            </summary>
            <param name="atom">The atom to be checked</param>
            <returns>True if the atom is non-hydrogen</returns>
        </member>
        <member name="T:NCDK.Modelings.Builder3D.AtomTetrahedralLigandPlacer3D">
            <summary>
             A set of static utility classes for geometric calculations on Atoms.
            </summary>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.AtomTetrahedralLigandPlacer3D.#ctor">
            <summary>
             Constructor for the AtomTetrahedralLigandPlacer3D object.
            </summary>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.AtomTetrahedralLigandPlacer3D.SetParameterSet(System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
             Constructor for the setParameterSet object.
            </summary>
            <param name="moleculeParameter">Description of the Parameter</param>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.AtomTetrahedralLigandPlacer3D.Add3DCoordinatesForSinglyBondedLigands(NCDK.IAtomContainer)">
            <summary>
             Generate coordinates for all atoms which are singly bonded and have no
             coordinates. This is useful when hydrogens are present but have no coordinates.
             It knows about C, O, N, S only and will give tetrahedral or trigonal
             geometry elsewhere. Bond lengths are computed from covalent radii or taken
             out of a parameter set if available. Angles are tetrahedral or trigonal
            </summary>
            <param name="atomContainer">the set of atoms involved</param>
            <exception cref="T:NCDK.CDKException"></exception>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.AtomTetrahedralLigandPlacer3D.RescaleBondLength(NCDK.IAtom,NCDK.IAtom,NCDK.Numerics.Vector3)">
            <summary>
             Rescales Point2 so that length 1-2 is sum of covalent radii.
             If covalent radii cannot be found, use bond length of 1.0
            </summary>
            <param name="atom1">stationary atom</param>
            <param name="atom2">movable atom</param>
            <param name="point2">coordinates for atom 2</param>
            <returns>new coordinates for atom 2</returns>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.AtomTetrahedralLigandPlacer3D.Get3DCoordinatesForLigands(NCDK.IAtom,NCDK.IAtomContainer,NCDK.IAtomContainer,NCDK.IAtom,System.Int32,System.Double,System.Double)">
            <summary>
             Adds 3D coordinates for singly-bonded ligands of a reference atom (A).
             Initially designed for hydrogens. The ligands of refAtom are identified and
             those with 3D coordinates used to generate the new points. (This allows
             structures with partially known 3D coordinates to be used, as when groups
             are added.) "Bent" and "non-planar" groups can be formed by taking a subset
             of the calculated points. Thus R-NH2 could use 2 of the 3 points calculated
             from (1,iii) nomenclature: A is point to which new ones are "attached". A
             may have ligands B, C... B may have ligands J, K.. points X1, X2... are
             returned The cases (see individual routines, which use idealised geometry
             by default): (0) zero ligands of refAtom. The resultant points are randomly
             oriented: (i) 1 points required; +x,0,0 (ii) 2 points: use +x,0,0 and
             -x,0,0 (iii) 3 points: equilateral triangle in xy plane (iv) 4 points
             x,x,x, x,-x,-x, -x,x,-x, -x,-x,x (1a) 1 Ligand(B) of refAtom which itself
             has a ligand (J) (i) 1 points required; vector along AB vector (ii) 2
             points: 2 vectors in ABJ plane, staggered and eclipsed wrt J (iii) 3
             points: 1 staggered wrt J, the others +- gauche wrt J (1b) 1 Ligand(B) of
             refAtom which has no other ligands. A random J is generated and (1a)
             applied (2) 2 Ligands(B, C) of refAtom A (i) 1 points required; vector in
             ABC plane bisecting AB, AC. If ABC is linear, no points (ii) 2 points: 2
             vectors at angle ang, whose resultant is 2i (3) 3 Ligands(B, C, D) of
             refAtom A (i) 1 points required; if A, B, C, D coplanar, no points. else
             vector is resultant of BA, CA, DA fails if atom itself has no coordinates
             or &gt;4 ligands
            </summary>
            <param name="refAtom">(A) to which new ligands coordinates could be added</param>
            <param name="length">A-X length</param>
            <param name="angle">B-A-X angle (used in certain cases)</param>
            <param name="nwanted">Description of the Parameter</param>
            <param name="noCoords">Description of the Parameter</param>
            <param name="withCoords">Description of the Parameter</param>
            <param name="atomC">Description of the Parameter</param>
            <returns>Point3D[] points calculated. If request could not be
                 fulfilled (e.g. too many atoms, or strange geometry, returns empty
                 array (zero length, not null)</returns>
            <exception cref="T:NCDK.CDKException"></exception>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.AtomTetrahedralLigandPlacer3D.Get3DCoordinatesForSP2Ligands(NCDK.IAtom,NCDK.IAtomContainer,NCDK.IAtomContainer,NCDK.IAtom,System.Double,System.Double)">
            <summary>
             Main method for the calculation of the ligand coordinates for sp2 atoms.
             Decides if one or two coordinates should be created
            </summary>
            <param name="refAtom">central atom (Atom)</param>
            <param name="noCoords">Description of the Parameter</param>
            <param name="withCoords">Description of the Parameter</param>
            <param name="atomC">Description of the Parameter</param>
            <param name="length">Description of the Parameter</param>
            <param name="angle">Description of the Parameter</param>
            <returns>coordinates as Points3d []</returns>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.AtomTetrahedralLigandPlacer3D.Get3DCoordinatesForSP3Ligands(NCDK.IAtom,NCDK.IAtomContainer,NCDK.IAtomContainer,NCDK.IAtom,System.Int32,System.Double,System.Double)">
            <summary>
             Main method for the calculation of the ligand coordinates for sp3 atoms.
             Decides how many coordinates should be created
            </summary>
            <param name="refAtom">central atom (Atom)</param>
            <param name="nwanted">how many ligands should be created</param>
            <param name="length">bond length</param>
            <param name="angle">angle in a B-A-(X) system; a=central atom;
                 x=ligand with unknown coordinates</param>
            <param name="noCoords">Description of the Parameter</param>
            <param name="withCoords">Description of the Parameter</param>
            <param name="atomC">Description of the Parameter</param>
            <returns>Description of the Return Value</returns>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.AtomTetrahedralLigandPlacer3D.Calculate3DCoordinates0(NCDK.Numerics.Vector3,System.Int32,System.Double)">
            <summary>
             Calculates substituent points. Calculate substituent points for (0) zero
             ligands of aPoint. The resultant points are randomly oriented: (i) 1 points
             required; +x,0,0 (ii) 2 points: use +x,0,0 and -x,0,0 (iii) 3 points:
             equilateral triangle in the xy plane (iv) 4 points x,x,x, x,-x,-x, -x,x,-x,
             -x,-x,x where 3x**2 = bond length
            </summary>
            <param name="aPoint">to which substituents are added</param>
            <param name="nwanted">number of points to calculate (1-4)</param>
            <param name="length">from aPoint</param>
            <returns>Vector3[] nwanted points (or zero if failed)</returns>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.AtomTetrahedralLigandPlacer3D.Calculate3DCoordinates1(NCDK.Numerics.Vector3,NCDK.Numerics.Vector3,System.Nullable{NCDK.Numerics.Vector3},System.Int32,System.Double,System.Double)">
            <summary>
             Calculate new Point(s) X in a B-A system to form B-A-X. Use C as reference
             for * staggering about the B-A bond (1a) 1 Ligand(B) of refAtom (A) which
             itself has a ligand (C) (i) 1 points required; vector along AB vector (ii)
             2 points: 2 vectors in ABC plane, staggered and eclipsed wrt C (iii) 3
             points: 1 staggered wrt C, the others +- gauche wrt C If C is null, a
             random non-colinear C is generated
            </summary>
            <param name="aPoint">to which substituents are added</param>
            <param name="nwanted">number of points to calculate (1-3)</param>
            <param name="length">A-X length</param>
            <param name="angle">B-A-X angle</param>
            <param name="bPoint">Description of the Parameter</param>
            <param name="cPoint">Description of the Parameter</param>
            <returns>Vector3[] nwanted points (or zero if failed)</returns>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.AtomTetrahedralLigandPlacer3D.Calculate3DCoordinates2(NCDK.Numerics.Vector3,NCDK.Numerics.Vector3,NCDK.Numerics.Vector3,System.Int32,System.Double,System.Double)">
            <summary>
             Calculate new Point(s) X in a B-A-C system, it forms a B-A(-C)-X
             system. (2) 2 Ligands(B, C) of refAtom A (i) 1 points required; vector in
             ABC plane bisecting AB, AC. If ABC is linear, no points (ii) 2 points: 2
             points X1, X2, X1-A-X2 = angle about 2i vector
            </summary>
            <param name="aPoint">to which substituents are added</param>
            <param name="bPoint">first ligand of A</param>
            <param name="cPoint">second ligand of A</param>
            <param name="nwanted">number of points to calculate (1-2)</param>
            <param name="length">A-X length</param>
            <param name="angle">B-A-X angle</param>
            <returns>Vector3[] nwanted points (or zero if failed)</returns>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.AtomTetrahedralLigandPlacer3D.Calculate3DCoordinates3(NCDK.Numerics.Vector3,NCDK.Numerics.Vector3,NCDK.Numerics.Vector3,NCDK.Numerics.Vector3,System.Double)">
            <summary>
             Calculate new point X in a B-A(-D)-C system. It forms a B-A(-D)(-C)-X
             system. (3) 3 Ligands(B, C, D) of refAtom A (i) 1 points required; if A, B,
             C, D coplanar, no points. else vector is resultant of BA, CA, DA
            </summary>
            <param name="aPoint">to which substituents are added</param>
            <param name="bPoint">first ligand of A</param>
            <param name="cPoint">second ligand of A</param>
            <param name="dPoint">third ligand of A</param>
            <param name="length">A-X length</param>
            <returns>Vector3 nwanted points (or null if failed (coplanar))</returns>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.AtomTetrahedralLigandPlacer3D.Calculate3DCoordinatesSP2_1(NCDK.Numerics.Vector3,NCDK.Numerics.Vector3,NCDK.Numerics.Vector3,System.Double,System.Double)">
            <summary>
             Calculate new point in B-A-C system. It forms B-A(-X)-C system, where A is sp2
            </summary>
            <param name="aPoint">central point A (Vector3)</param>
            <param name="bPoint">B (Vector3)</param>
            <param name="cPoint">C (Vector3)</param>
            <param name="length">bond length</param>
            <param name="angle">angle between B(C)-A-X</param>
            <returns>new Point (Vector3)</returns>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.AtomTetrahedralLigandPlacer3D.Calculate3DCoordinatesSP2_2(NCDK.Numerics.Vector3,NCDK.Numerics.Vector3,System.Nullable{NCDK.Numerics.Vector3},System.Double,System.Double)">
            <summary>
             Calculate two new points in B-A system. It forms B-A(-X)(-X) system, where A is sp2
            </summary>
            <param name="aPoint">central point A (Vector3)</param>
            <param name="bPoint">B (Vector3)</param>
            <param name="cPoint">C (Vector3)</param>
            <param name="length">bond length</param>
            <param name="angle">angle between B(C)-A-X</param>
            <returns>new Points (Vector3 [])</returns>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.AtomTetrahedralLigandPlacer3D.GetNonColinearVector(NCDK.Numerics.Vector3)">
            <summary>
             Gets the nonColinearVector attribute of the AtomLigandPlacer3D class
            </summary>
            <param name="ab">Description of the Parameter</param>
            <returns>The nonColinearVector value</returns>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.AtomTetrahedralLigandPlacer3D.Rotate(NCDK.Numerics.Vector3,NCDK.Numerics.Vector3,System.Double)">
            <summary>
             Rotates a vector around an axis.
            </summary>
            <param name="vector">vector to be rotated around axis</param>
            <param name="axis">axis of rotation</param>
            <param name="angle">angle to vector rotate around</param>
            <returns>rotated vector</returns>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.AtomTetrahedralLigandPlacer3D.GetDistanceValue(System.String,System.String)">
            <summary>
            Gets the distance between two atoms out of the parameter set.
            </summary>
            <param name="id1">id of the parameter set for atom1 (atom1.AtomTypeName)</param>
            <param name="id2">id of the parameter set for atom2</param>
            <returns>The distanceValue value</returns>
            <exception cref="T:System.Exception"> Description of the Exception</exception>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.AtomTetrahedralLigandPlacer3D.GetAngleValue(System.String,System.String,System.String)">
            <summary>
             Gets the angleKey attribute of the AtomPlacer3D object.
            </summary>
            <param name="id1">Description of the Parameter</param>
            <param name="id2">Description of the Parameter</param>
            <param name="id3">Description of the Parameter</param>
            <returns>The angleKey value</returns>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.AtomTetrahedralLigandPlacer3D.MakeStereocenter(NCDK.Numerics.Vector3,NCDK.IBond,NCDK.Numerics.Vector3,NCDK.Numerics.Vector3,NCDK.Numerics.Vector3[])">
            <summary>
             set Atoms in respect to stereoinformation.
               take placed neighbours to stereocenter
                   create a x b
                    if right handed system (spatproduct &gt;0)
                       if unplaced is not up (relative to stereocenter)
                           n=b x a
                    Determine angle between n and possible ligand place points
                    if angle smaller than 90 degrees take this branch point
            </summary>
            <param name="atomA">placed Atom - stereocenter</param>
            <param name="ax">bond between stereocenter and unplaced atom</param>
            <param name="atomB">neighbour of atomA (in plane created by atomA, atomB and atomC)</param>
            <param name="atomC">neighbour of atomA</param>
            <param name="branchPoints">the two possible placement points for unplaced atom (up and down)</param>
            <returns>int value of branch point position</returns>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.AtomTetrahedralLigandPlacer3D.GetSpatproduct(NCDK.Numerics.Vector3,NCDK.Numerics.Vector3,NCDK.Numerics.Vector3)">
            <summary>
             Gets the spatproduct of three vectors.
            </summary>
            <param name="a">vector a</param>
            <param name="b">vector b</param>
            <param name="c">vector c</param>
            <returns>double value of the spatproduct</returns>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.AtomTetrahedralLigandPlacer3D.GetTorsionAngle(NCDK.Numerics.Vector3,NCDK.Numerics.Vector3,NCDK.Numerics.Vector3,NCDK.Numerics.Vector3)">
            <summary>
             Calculates the torsionAngle of a-b-c-d.
            </summary>
            <param name="a">Vector3</param>
            <param name="b">Vector3</param>
            <param name="c">Vector3</param>
            <param name="d">Vector3</param>
            <returns>The torsionAngle value</returns>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.AtomTetrahedralLigandPlacer3D.GetPlacedAtomsInAtomContainer(NCDK.IAtom,NCDK.IAtomContainer)">
            <summary>
             Gets all placed neighbouring atoms of a atom.
            </summary>
            <param name="atom">central atom (Atom)</param>
            <param name="ac">the molecule</param>
            <returns>all connected and placed atoms to the central atom (AtomContainer)</returns>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.AtomTetrahedralLigandPlacer3D.GetUnsetAtomsInAtomContainer(NCDK.IAtom,NCDK.IAtomContainer)">
            <summary>
             Gets the unsetAtomsInAtomContainer attribute of the
             AtomTetrahedralLigandPlacer3D object.
            </summary>
            <param name="atom">Description of the Parameter</param>
            <param name="ac">Description of the Parameter</param>
            <returns>The unsetAtomsInAtomContainer value</returns>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.AtomTetrahedralLigandPlacer3D.GetPlacedHeavyAtomInAtomContainer(NCDK.IAtom,NCDK.IAtom,NCDK.IAtomContainer)">
            <summary>
            Returns a placed neighbouring atom of a central atom atomA, which is not atomB.
            </summary>
            <param name="atomA">central atom (Atom)</param>
            <param name="atomB">atom connected to atomA (Atom)</param>
            <param name="ac">molecule</param>
            <returns>returns a connected atom (Atom)</returns>
        </member>
        <member name="T:NCDK.Modelings.Builder3D.ForceFieldConfigurator">
             <summary>
              Reads in a force field configuration file, set the atom types into a vector, and the data into a hashtable
              Therefore, it uses the class <see cref="T:NCDK.Modelings.Builder3D.MM2BasedParameterSetReader"/>.
              private Dictionary parameterSet;
              key=nameofdatafield+atomid1+;atomid2;atomxid
            
              <para>MM2 and MMFF94 force field are implemented
              With force field data it configures the cdk atom (assign atomtype, van der Waals radius, charge...)
             </para>
             </summary>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.ForceFieldConfigurator.SetInputStream(System.IO.Stream)">
            <summary>
            the inputStream attribute of the ForceFieldConfigurator object
            </summary>
            <param name="ins">The new inputStream value</param>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.ForceFieldConfigurator.GetFfTypes">
            <summary>
            gives a list of possible force field types
            </summary>
            <returns>the list</returns>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.ForceFieldConfigurator.CheckForceFieldType(System.String)">
            <summary>
             Sets the forceFieldType attribute of the ForceFieldConfigurator object
            </summary>
            <param name="ffname">The new forceFieldType name</param>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.ForceFieldConfigurator.SetForceFieldConfigurator(System.String,NCDK.IChemObjectBuilder)">
             <summary>
            Constructor for the ForceFieldConfigurator object
             </summary>
             <param name="ffname">name of the force field data file</param>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.ForceFieldConfigurator.SetAtomTypes(System.Collections.Generic.List{NCDK.IAtomType})">
            <summary>
             Sets the atomTypes attribute of the ForceFieldConfigurator object
            </summary>
            <param name="atomtypes">The new atomTypes</param>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.ForceFieldConfigurator.SetParameters(System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
             Sets the parameters attribute of the ForceFieldConfigurator object
            </summary>
            <param name="parameterset">The new parameter values</param>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.ForceFieldConfigurator.SetMM2Parameters(NCDK.IChemObjectBuilder)">
            <summary>Sets the parameters attribute of the ForceFieldConfigurator object, default is mm2 force field</summary>
        </member>
        <member name="P:NCDK.Modelings.Builder3D.ForceFieldConfigurator.AtomTypes">
            <summary>
             Gets the atomTypes attribute of the ForceFieldConfigurator object
            </summary>
            <returns>The atomTypes vector</returns>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.ForceFieldConfigurator.GetParameterSet">
            <summary>
             Gets the parameterSet attribute of the ForceFieldConfigurator object
            </summary>
            <returns>The parameterSet hashtable</returns>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.ForceFieldConfigurator.GetAtomType(System.String)">
            <summary>
             Find the atomType for a id
            </summary>
            <param name="ID">Atomtype id of the forcefield</param>
            <returns>The atomType</returns>
            <exception cref="T:NCDK.NoSuchAtomTypeException"> atomType is not known.</exception>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.ForceFieldConfigurator.AssignAtomTyps(NCDK.IAtomContainer)">
            <summary>
             Method assigns atom types to atoms (calculates sssr and aromaticity)
            </summary>
            <returns>sssrf set</returns>
            <exception cref="T:NCDK.CDKException"> Problems detecting aromaticity or making hose codes.</exception>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.ForceFieldConfigurator.IsHeteroRingSystem(NCDK.IAtomContainer)">
            <summary>
             Returns true if atom is in hetero ring system
            </summary>
            <param name="ac">AtomContainer</param>
            <returns>true/false</returns>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.ForceFieldConfigurator.SetAtom(NCDK.IAtom,System.String)">
            <summary>
             Assigns an atom type to an atom
            </summary>
            <param name="atom">The atom to be aasigned</param>
            <param name="ID">the atom type id</param>
            <exception cref="T:NCDK.NoSuchAtomTypeException"> atomType is not known</exception>
            <returns>the assigned atom</returns>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.ForceFieldConfigurator.ConfigureMM2BasedAtom(NCDK.IAtom,System.String,System.Boolean)">
            <summary>
            Configures an atom to a mm2 based atom type
            </summary>
            <param name="atom">atom to be configured</param>
            <param name="hoseCode">the 4 sphere hose code of the atom</param>
            <returns>atom</returns>
            <exception cref="T:NCDK.NoSuchAtomTypeException"> atomType is not known</exception>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.ForceFieldConfigurator.ConfigureMMFF94BasedAtom(NCDK.IAtom,System.String,System.Boolean)">
            <summary>
             Configures an atom to a mmff94 based atom type
            </summary>
            <param name="atom">atom to be configured</param>
            <param name="hoseCode">the 4 sphere hose code of the atom</param>
            <returns>atom</returns>
            <exception cref="T:NCDK.NoSuchAtomTypeException"> atomType is not known</exception>
        </member>
        <member name="T:NCDK.Modelings.Builder3D.MM2BasedAtomTypePattern">
            <summary>
             Class stores hose code patterns to identify mm2 force field atom types.
            </summary>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.MM2BasedAtomTypePattern.#ctor">
            <summary>
            Constructor for the MM2BasedAtomTypePattern object
            </summary>
        </member>
        <member name="P:NCDK.Modelings.Builder3D.MM2BasedAtomTypePattern.AtomTypePatterns">
            <summary>
            Gets the atomTypePatterns attribute of the MM2BasedAtomTypePattern object
            </summary>
            <returns>The atomTypePatterns as a vector</returns>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.MM2BasedAtomTypePattern.CreatePattern">
            <summary>
             Creates the atom type pattern
            </summary>
        </member>
        <member name="T:NCDK.Modelings.Builder3D.MM2BasedParameterSetReader">
            <summary>
            AtomType list configurator that uses the ParameterSet originally
            defined in mm2.prm from tinker. This class was added to be able to port
            mm2 to CDK.
            </summary>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.MM2BasedParameterSetReader.#ctor">
            <summary>
            Constructor for the MM2BasedParameterSetReader object.
            </summary>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.MM2BasedParameterSetReader.SetInputStream(System.IO.Stream)">
            <summary>
            Sets the file containing the config data.
            </summary>
            <param name="ins">The new inputStream type Stream</param>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.MM2BasedParameterSetReader.SetForceFieldDefinitions">
            <summary>
            Read a text based configuration file out of the force field mm2 file
            </summary>
            <exception cref="T:System.Exception"> Description of the Exception</exception>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.MM2BasedParameterSetReader.SetAtomTypes(NCDK.IChemObjectBuilder)">
            <summary>
             Read and stores the atom types in a vector
            </summary>
            <exception cref="T:System.Exception"> Description of the Exception</exception>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.MM2BasedParameterSetReader.SetvdWaals">
            <summary>
             Read vdw radius, stored into the parameter set
            </summary>
            <exception cref="T:System.Exception"> Description of the Exception</exception>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.MM2BasedParameterSetReader.SetvdWaalpr">
            <summary>
             Read vdW pair radius,stored into the parameter set
            </summary>
            <exception cref="T:System.Exception"> Description of the Exception</exception>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.MM2BasedParameterSetReader.SetBond">
            <summary>
             Sets the bond attribute stored into the parameter set
            </summary>
            <exception cref="T:System.Exception"> Description of the Exception</exception>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.MM2BasedParameterSetReader.SetBond3">
            <summary>
             Sets the bond3 attribute stored into the parameter set
            </summary>
            <exception cref="T:System.Exception"> Description of the Exception</exception>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.MM2BasedParameterSetReader.SetBond4">
            <summary>
             Sets the bond4 attribute stored into the parameter set
            </summary>
            <exception cref="T:System.Exception"> Description of the Exception</exception>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.MM2BasedParameterSetReader.SetAngle">
            <summary>
             Sets the angle attribute stored into the parameter set
            </summary>
            <exception cref="T:System.Exception"> Description of the Exception</exception>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.MM2BasedParameterSetReader.SetAngle3">
            <summary>
             Sets the angle3 attribute stored into the parameter set
            </summary>
            <exception cref="T:System.Exception"> Description of the Exception</exception>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.MM2BasedParameterSetReader.SetAngle4">
            <summary>
             Sets the angle4 attribute stored into the parameter set
            </summary>
            <exception cref="T:System.Exception"> Description of the Exception</exception>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.MM2BasedParameterSetReader.SetStrBnd">
            <summary>
             Sets the strBnd attribute stored into the parameter set
            </summary>
            <exception cref="T:System.Exception"> Description of the Exception</exception>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.MM2BasedParameterSetReader.SetOpBend">
            <summary>
             Sets the opBend attribute stored into the parameter set
            </summary>
            <exception cref="T:System.Exception"> Description of the Exception</exception>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.MM2BasedParameterSetReader.SetTorsion">
            <summary>
             Sets the torsion attribute stored into the parameter set
            </summary>
            <exception cref="T:System.Exception"> Description of the Exception</exception>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.MM2BasedParameterSetReader.SetTorsion4">
            <summary>
             Sets the torsion4 attribute stored into the parameter set
            </summary>
            <exception cref="T:System.Exception"> Description of the Exception</exception>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.MM2BasedParameterSetReader.SetCharge">
            <summary>
             Sets the charge attribute stored into the parameter set
            </summary>
            <exception cref="T:System.Exception"> Description of the Exception</exception>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.MM2BasedParameterSetReader.SetDipole">
            <summary>
             Sets the dipole attribute stored into the parameter set
            </summary>
            <exception cref="T:System.Exception"> Description of the Exception</exception>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.MM2BasedParameterSetReader.SetDipole3">
            <summary>
             Sets the dipole3 attribute stored into the parameter set
            </summary>
            <exception cref="T:System.Exception"> Description of the Exception</exception>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.MM2BasedParameterSetReader.SetPiAtom">
            <summary>
             Sets the piAtom attribute stored into the parameter set
            </summary>
            <exception cref="T:System.Exception"> Description of the Exception</exception>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.MM2BasedParameterSetReader.SetPiBond">
            <summary>
             Sets the piBond attribute stored into the parameter set
            </summary>
            <exception cref="T:System.Exception"> Description of the Exception</exception>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.MM2BasedParameterSetReader.ReadParameterSets(NCDK.IChemObjectBuilder)">
            <summary>
            The main method which parses through the force field configuration file
            </summary>
            <exception cref="T:System.Exception"> Description of the Exception</exception>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.MM2BasedParameterSetReader.MassNumber(System.Int32,System.Double)">
            <summary>
            Mass number for a atom with a given atomic number and exact mass.
            </summary>
            <param name="atomicNumber">atomic number</param>
            <param name="exactMass">exact mass</param>
            <returns>the mass number (or null) if no mass number was found</returns>
            <exception cref="T:System.IO.IOException">isotope configuration could not be loaded</exception>
        </member>
        <member name="T:NCDK.Modelings.Builder3D.MMFF94BasedAtomTypePattern">
            <summary>
             Class stores hose code patterns to identify mm2 force field atom types
            </summary>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.MMFF94BasedAtomTypePattern.#ctor">
             <summary>
            Constructor for the MM2BasedAtomTypePattern object
             </summary>
        </member>
        <member name="P:NCDK.Modelings.Builder3D.MMFF94BasedAtomTypePattern.AtomTypePatterns">
            <summary>
             Gets the atomTypePatterns attribute of the MM2BasedAtomTypePattern object
            </summary>
            <returns>The atomTypePatterns as a vector</returns>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.MMFF94BasedAtomTypePattern.CreatePattern">
            <summary>
            Creates the atom type pattern
            </summary>
        </member>
        <member name="T:NCDK.Modelings.Builder3D.MMFF94BasedParameterSetReader">
            <summary>
            AtomType list configurator that uses the ParameterSet originally defined in
            mmff94.prm from moe. This class was added to be able to port mmff94 to CDK.
            </summary>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.MMFF94BasedParameterSetReader.#ctor">
            <summary>
            Constructor for the MM2BasedParameterSetReader object
            </summary>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.MMFF94BasedParameterSetReader.SetInputStream(System.IO.Stream)">
            <summary>
            Sets the file containing the config data
            </summary>
            <param name="ins">The new inputStream type Stream</param>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.MMFF94BasedParameterSetReader.SetAtomTypeData">
            <summary>
            Read a text based configuration file out of the force field mm2 file
            </summary>
            <exception cref="T:System.Exception">Description of the Exception</exception>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.MMFF94BasedParameterSetReader.SetAtomTypes(NCDK.IChemObjectBuilder)">
            <summary>
            Read and stores the atom types in a vector
            </summary>
            <exception cref="T:System.Exception">Description of the Exception</exception>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.MMFF94BasedParameterSetReader.SetBond">
            <summary>
            Sets the bond attribute stored into the parameter set
            </summary>
            <exception cref="T:System.Exception">Description of the Exception</exception>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.MMFF94BasedParameterSetReader.SetAngle">
            <summary>
            Sets the angle attribute stored into the parameter set
            </summary>
            <exception cref="T:System.Exception">Description of the Exception</exception>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.MMFF94BasedParameterSetReader.SetStrBnd">
            <summary>
            Sets the strBnd attribute stored into the parameter set
            </summary>
            <exception cref="T:System.Exception">Description of the Exception</exception>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.MMFF94BasedParameterSetReader.SetTorsion">
            <summary>
            Sets the torsion attribute stored into the parameter set
            </summary>
            <exception cref="T:System.Exception">Description of the Exception</exception>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.MMFF94BasedParameterSetReader.SetOpBend">
            <summary>
            Sets the opBend attribute stored into the parameter set
            </summary>
            <exception cref="T:System.Exception">Description of the Exception</exception>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.MMFF94BasedParameterSetReader.SetDefaultStrBnd">
            <summary>
            Sets the Default Stretch-Bend Parameters into the parameter set
            </summary>
            <exception cref="T:System.Exception">Description of the Exception</exception>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.MMFF94BasedParameterSetReader.ReadParameterSets(NCDK.IChemObjectBuilder)">
            <summary>
            The main method which parses through the force field configuration file
            </summary>
            <exception cref="T:System.Exception">Description of the Exception</exception>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.MMFF94BasedParameterSetReader.MassNumber(System.Int32,System.Double)">
            <summary>
            Mass number for a atom with a given atomic number and exact mass.
            </summary>
            <param name="atomicNumber">atomic number</param>
            <param name="exactMass">exact mass</param>
            <returns>the mass number (or null) if no mass number was found</returns>
            <exception cref="T:System.IO.IOException">isotope configuration could not be loaded</exception>
        </member>
        <member name="T:NCDK.Modelings.Builder3D.MMFF94ParametersCall">
            <summary>
            Set the right atoms order to get the parameters.
            </summary>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.MMFF94ParametersCall.Initialize(System.Collections.Generic.IDictionary{System.String,System.Collections.IList})">
            <summary>
            Initialize the AtomOrder class.
            </summary>
            <param name="parameterSet">Force Field parameter as Map</param>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.MMFF94ParametersCall.GetBondData(System.String,System.String,System.String)">
             <summary>
              Gets the bond parameter set.
            
             <param name="id1">atom1 id</param>
             <param name="id2">atom2 id</param>
             <returns>The distance value from the force field parameter set</returns>
             <exception cref="T:System.Exception"> Description of the Exception</exception>
             </summary>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.MMFF94ParametersCall.GetAngleData(System.String,System.String,System.String,System.String)">
            <summary>
             Gets the angle parameter set.
            </summary>
            <param name="id1">ID from Atom 1.</param>
            <param name="id2">ID from Atom 2.</param>
            <param name="id3">ID from Atom 3.</param>
            <returns>The angle data from the force field parameter set</returns>
            <exception cref="T:System.Exception"> Description of the Exception</exception>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.MMFF94ParametersCall.GetBondAngleInteractionData(System.String,System.String,System.String,System.String)">
            <summary>
            Gets the bond-angle interaction parameter set.
            </summary>
            <param name="id1">ID from Atom 1.</param>
            <param name="id2">ID from Atom 2.</param>
            <param name="id3">ID from Atom 3.</param>
            <returns>The bond-angle interaction data from the force field parameter set</returns>
            <exception cref="T:System.Exception"> Description of the Exception</exception>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.MMFF94ParametersCall.GetDefaultStretchBendData(System.Int32,System.Int32,System.Int32)">
            <summary>
            Gets the bond-angle interaction parameter set.
            </summary>
            <param name="iR">ID from Atom 1.</param>
            <param name="jR">ID from Atom 2.</param>
            <param name="kR">ID from Atom 3.</param>
            <returns>The bond-angle interaction data from the force field parameter set</returns>
            <exception cref="T:System.Exception"> Description of the Exception</exception>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.MMFF94ParametersCall.GetTorsionData(System.String,System.String,System.String,System.String,System.String)">
            <summary>
             Gets the bond parameter set.
            </summary>
            <param name="id1">atom1 id</param>
            <param name="id2">atom2 id</param>
            <returns>The distance value from the force field parameter set</returns>
            <exception cref="T:System.Exception"> Description of the Exception</exception>
        </member>
        <member name="T:NCDK.Modelings.Builder3D.ModelBuilder3D">
            <summary>
             The main class to generate the 3D coordinates of a molecule ModelBuilder3D.
            </summary>
            <example>
             Its use looks like:
            <code>            ModelBuilder3D mb3d = ModelBuilder3D.GetInstance(Default.ChemObjectBuilder.Instance);
            IAtomContainer molecule = mb3d.Generate3DCoordinates(mol, false);
</code>
            </example>
            <remarks>
            Standing problems:
            <list type="bullet">
               <item>condensed ring systems which are unknown for the template class</item>
               <item>vdWaals clashes</item>
               <item>stereochemistry</item>
               <item>chains running through ring systems</item>
            </list>
            </remarks>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.ModelBuilder3D.#ctor(NCDK.Modelings.Builder3D.TemplateHandler3D,System.String,NCDK.IChemObjectBuilder)">
            <summary>
            Constructor for the ModelBuilder3D object.
            </summary>
            <param name="templateHandler">templateHandler Object</param>
            <param name="ffname">name of force field</param>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.ModelBuilder3D.GetFfTypes">
            <summary>
            Gives a list of possible force field types.
            </summary>
            <returns>the list</returns>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.ModelBuilder3D.SetForceField(System.String,NCDK.IChemObjectBuilder)">
            <summary>
            Sets the forceField attribute of the ModeSetForceFieldConfigurator(lBuilder3D object.
            </summary>
            <param name="ffname">forceField name</param>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.ModelBuilder3D.Generate3DCoordinates(NCDK.IAtomContainer,System.Boolean)">
            <summary>
            Generate 3D coordinates with force field information.
            </summary>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.ModelBuilder3D.GetRingSetOfAtom(System.Collections.Generic.IList{NCDK.IRingSet},NCDK.IAtom)">
            <summary>
            Gets the ringSetOfAtom attribute of the ModelBuilder3D object.
            </summary>
            <returns>The ringSetOfAtom value</returns>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.ModelBuilder3D.LayoutMolecule(System.Collections.Generic.IList{NCDK.IRingSet},NCDK.IAtomContainer,NCDK.Modelings.Builder3D.AtomPlacer3D,NCDK.Modelings.Builder3D.AtomTetrahedralLigandPlacer3D,NCDK.Layout.AtomPlacer)">
            <summary>
            Layout the molecule, starts with ring systems and than aliphatic chains.
            </summary>
            <param name="ringSetMolecule">ringSystems of the molecule</param>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.ModelBuilder3D.LayoutRingSystem(NCDK.Numerics.Vector3,NCDK.IAtom,NCDK.IRingSet,NCDK.Numerics.Vector3,NCDK.IAtom,NCDK.Modelings.Builder3D.AtomPlacer3D)">
            <summary>
            Layout the ring system, rotate and translate the template.
            </summary>
            <param name="originalCoord">coordinates of the placedRingAtom from the template</param>
            <param name="placedRingAtom">placedRingAtom</param>
            <param name="ringSet">ring system which placedRingAtom is part of</param>
            <param name="centerPlacedMolecule">the geometric center of the already placed molecule</param>
            <param name="atomB">placed neighbour atom of  placedRingAtom</param>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.ModelBuilder3D.SetBranchAtom(NCDK.IAtomContainer,NCDK.IAtom,NCDK.IAtom,NCDK.IAtomContainer,NCDK.Modelings.Builder3D.AtomPlacer3D,NCDK.Modelings.Builder3D.AtomTetrahedralLigandPlacer3D)">
            <summary>
            Sets a branch atom to a ring or aliphatic chain.
            </summary>
            <param name="unplacedAtom">The new branchAtom</param>
            <param name="atomA">placed atom to which the unplaced atom is connected</param>
            <param name="atomNeighbours">placed atomNeighbours of atomA</param>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.ModelBuilder3D.SearchAndPlaceBranches(NCDK.IAtomContainer,NCDK.IAtomContainer,NCDK.Modelings.Builder3D.AtomPlacer3D,NCDK.Modelings.Builder3D.AtomTetrahedralLigandPlacer3D,NCDK.Layout.AtomPlacer)">
            <summary>
            Search and place branches of a chain or ring.
            </summary>
            <param name="chain">AtomContainer if atoms in an aliphatic chain or ring system</param>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.ModelBuilder3D.PlaceLinearChains3D(NCDK.IAtomContainer,NCDK.IAtomContainer,NCDK.Modelings.Builder3D.AtomPlacer3D,NCDK.Modelings.Builder3D.AtomTetrahedralLigandPlacer3D,NCDK.Layout.AtomPlacer)">
            <summary>
            Layout all aliphatic chains with ZMatrix.
            </summary>
            <param name="startAtoms">AtomContainer of possible start atoms for a chain</param>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.ModelBuilder3D.TranslateStructure(NCDK.Numerics.Vector3,NCDK.Numerics.Vector3,NCDK.IAtomContainer)">
            <summary>
            Translates the template ring system to new coordinates.
            </summary>
            <param name="originalCoord">original coordinates of the placed ring atom from template</param>
            <param name="newCoord">new coordinates from branch placement</param>
            <param name="ac">AtomContainer contains atoms of ring system</param>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.ModelBuilder3D.CheckAllRingAtomsHasCoordinates(NCDK.IAtomContainer)">
            <summary>
            Returns the largest (number of atoms) ring set in a molecule.
            </summary>
            <param name="ac">AtomContainer</param>
            <returns>bool</returns>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.ModelBuilder3D.SetAtomsToPlace(NCDK.IAtomContainer)">
            <summary>
            Sets the atomsToPlace attribute of the ModelBuilder3D object.
            </summary>
            <param name="ac">The new atomsToPlace value</param>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.ModelBuilder3D.SetAtomsToUnplaced(NCDK.IAtomContainer)">
            <summary>
            Sets the atomsToUnplaced attribute of the ModelBuilder3D object.
            </summary>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.ModelBuilder3D.SetAtomsToUnVisited(NCDK.IAtomContainer)">
            <summary>
            Sets the atomsToUnVisited attribute of the ModelBuilder3D object.
            </summary>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.ModelBuilder3D.SetTemplateHandler(NCDK.Modelings.Builder3D.TemplateHandler3D)">
            <summary>
            Sets the templateHandler attribute of the ModelBuilder3D object.
            </summary>
            <param name="templateHandler">The new templateHandler value</param>
        </member>
        <member name="P:NCDK.Modelings.Builder3D.ModelBuilder3D.TemplateCount">
            <summary>
            Returns the number of loaded templates. Note that it may return 0 because
            templates are lazy loaded, that is upon the first ring being laid out.
            </summary>
            <returns>0, if not templates are loaded</returns>
        </member>
        <member name="T:NCDK.Modelings.Builder3D.TemplateExtractor">
            <summary>
            Helper class that help setup a template library of CDK's Builder3D.
            </summary>
        </member>
        <member name="T:NCDK.Modelings.Builder3D.TemplateHandler3D">
            <summary>
            Helper class for ModelBuilder3D. Handles templates. This is
            our layout solution for 3D ring systems
            </summary>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.TemplateHandler3D.LoadTemplates">
            <summary>
            Load ring template
            </summary>
            <exception cref="T:NCDK.CDKException">The template file cannot be loaded</exception>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.TemplateHandler3D.GetLargestRingSet(System.Collections.Generic.List{NCDK.IRingSet})">
            <summary>
            Returns the largest (number of atoms) ring set in a molecule.
            </summary>
            <param name="ringSystems">RingSystems of a molecule</param>
            <returns>The largestRingSet</returns>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.TemplateHandler3D.MapTemplates(NCDK.IAtomContainer,System.Int32)">
            <summary>
            Checks if one of the loaded templates is a substructure in the given
            Molecule. If so, it assigns the coordinates from the template to the
            respective atoms in the Molecule.
            </summary>
            <param name="mol">AtomContainer from the ring systems.</param>
            <param name="numberOfRingAtoms">Number of atoms in the specified ring</param>
        </member>
        <member name="P:NCDK.Modelings.Builder3D.TemplateHandler3D.TemplateCount">
            <summary>
            Gets the templateCount attribute of the TemplateHandler object.
            </summary>
            <returns>The templateCount value</returns>
        </member>
        <member name="M:NCDK.Modelings.Builder3D.TemplateHandler3D.GetTemplateAt(System.Int32)">
            <summary>
             Gets the templateAt attribute of the TemplateHandler object.
            </summary>
            <param name="position">Description of the Parameter</param>
            <returns>The templateAt value</returns>
        </member>
        <member name="T:NCDK.Normalizers.Normalizer">
            <summary>
            Adjusts parts of an AtomContainer to the configuration of a fragment.
            </summary>
        </member>
        <member name="M:NCDK.Normalizers.Normalizer.Normalize(NCDK.IAtomContainer,System.Xml.Linq.XDocument)">
            <summary>
             The method takes an XML files like the following:
             <pre>
             &lt;replace-set&gt;
             &lt;replace&gt;O=N=O&lt;/replace&gt;
             &lt;replacement&gt;[O-][N+]=O&lt;/replacement&gt;
             &lt;/replace-set&gt;
             </pre>
            </summary>
            <remarks>
             All parts in ac which are the same as replace will be changed according to replacement.
             Currently the following changes are done: BondOrder, FormalCharge.
             For detection of fragments like replace, we rely on <see cref="T:NCDK.Isomorphisms.UniversalIsomorphismTester"/>.
             doc may contain several replace-sets and a replace-set may contain several replace fragments, which will all be normalized according to replacement.
             </remarks>
            <param name="ac">The atomcontainer to normalize.</param>
            <param name="doc">The configuration file.</param>
            <returns>Did a replacement take place?</returns>
            <exception cref="T:NCDK.InvalidSmilesException"> doc contains an invalid smiles.</exception>
        </member>
        <member name="T:NCDK.Normalizers.SMSDNormalizer">
            <summary>
            This class containes set of modules required to clean a molecule
            before subjecting it for MCS search. eg. aromatizeMolecule
            </summary>
        </member>
        <member name="M:NCDK.Normalizers.SMSDNormalizer.MakeDeepCopy(NCDK.IAtomContainer)">
            <summary>
            Returns deep copy of the molecule
            </summary>
            <param name="container"></param>
            <returns>deep copy of the mol</returns>
        </member>
        <member name="M:NCDK.Normalizers.SMSDNormalizer.AromatizeMolecule(NCDK.IAtomContainer)">
            <summary>
            This function finds rings and uses aromaticity detection code to
            aromatize the molecule.
            </summary>
            <param name="mol">input molecule</param>
        </member>
        <member name="M:NCDK.Normalizers.SMSDNormalizer.GetExplicitHydrogenCount(NCDK.IAtomContainer,NCDK.IAtom)">
            <summary>
            Returns The number of explicit hydrogens for a given IAtom.
            </summary>
            <returns>The number of explicit hydrogens on the given IAtom.</returns>
        </member>
        <member name="M:NCDK.Normalizers.SMSDNormalizer.GetImplicitHydrogenCount(NCDK.IAtomContainer,NCDK.IAtom)">
            <summary>
            Returns The number of Implicit Hydrogen Count for a given IAtom.
            </summary>
            <returns>Implicit Hydrogen Count</returns>
        </member>
        <member name="M:NCDK.Normalizers.SMSDNormalizer.GetHydrogenCount(NCDK.IAtomContainer,NCDK.IAtom)">
            <summary>
            The summed implicit + explicit hydrogens of the given IAtom.
            <returns>The summed implicit + explicit hydrogens of the given IAtom.</returns>
            </summary>
        </member>
        <member name="M:NCDK.Normalizers.SMSDNormalizer.RemoveHydrogensAndPreserveAtomID(NCDK.IAtomContainer)">
            <summary>
            Returns IAtomContainer without Hydrogen. If an AtomContainer has atom single atom which
            is atom Hydrogen then its not removed.
            </summary>
            <returns>IAtomContainer without Hydrogen. If an AtomContainer has atom single atom which is atom Hydrogen then its not removed.</returns>
        </member>
        <member name="M:NCDK.Normalizers.SMSDNormalizer.ConvertExplicitToImplicitHydrogens(NCDK.IAtomContainer)">
            <summary>
            Returns IAtomContainer without Hydrogen. If an AtomContainer has atom single atom which
            is atom Hydrogen then its not removed.
            </summary>
            <returns>IAtomContainer without Hydrogen. If an AtomContainer has atom single atom which is atom Hydrogen then its not removed.</returns>
        </member>
        <member name="M:NCDK.Normalizers.SMSDNormalizer.PercieveAtomTypesAndConfigureAtoms(NCDK.IAtomContainer)">
            <summary>
            Convenience method to perceive atom types for all <see cref="T:NCDK.IAtom"/>s in the
            <see cref="T:NCDK.IAtomContainer"/>, using the <see cref="T:NCDK.AtomTypes.CDKAtomTypeMatcher"/>. If the
            matcher finds atom matching atom type, the <see cref="T:NCDK.IAtom"/> will be configured
            to have the same properties as the <see cref="T:NCDK.IAtomType"/>. If no matching atom
            type is found, no configuration is performed.
            <param name="container"></param>
            </summary>
            <exception cref="T:NCDK.CDKException"></exception>
        </member>
        <member name="T:NCDK.Pharmacophore.PharmacophoreAngleBond">
            <summary>
            Represents an angle relationship between three pharmacophore groups.
            </summary>
            <seealso cref="T:NCDK.Pharmacophore.PharmacophoreAtom"/>
        </member>
        <member name="M:NCDK.Pharmacophore.PharmacophoreAngleBond.#ctor(NCDK.Pharmacophore.PharmacophoreAtom,NCDK.Pharmacophore.PharmacophoreAtom,NCDK.Pharmacophore.PharmacophoreAtom)">
            <summary>
            Create a pharmacophore distance constraint.
            </summary>
            <param name="patom1">The first pharmacophore group</param>
            <param name="patom2">The second pharmacophore group</param>
            <param name="patom3">The third pharmacophore group</param>
        </member>
        <member name="P:NCDK.Pharmacophore.PharmacophoreAngleBond.BondLength">
            <summary>
            The angle between the three pharmacophore groups that make up the constraint.
            </summary>
            <returns>The angle in degrees between the two groups</returns>
        </member>
        <member name="T:NCDK.Pharmacophore.PharmacophoreAtom">
            <summary>
            A representation of a pharmacophore group.
            <para>
            In general this class is used internally for pharmacophore matchin and does not be instantiated
            by the user. However after a successful match the user will get access to objects of this class
            which match parts of a query.
            </para>
            <para>
            The main features of a pharmacophore group are the SMARTS pattern defining what the group
            is meant to identify and the atoms of a molecule that correspond to the SMARTS pattern.
            </para>
            </summary>
            <seealso cref="T:NCDK.Pharmacophore.PharmacophoreMatcher"/>
            <seealso cref="T:NCDK.Pharmacophore.PharmacophoreBond"/>
        </member>
        <member name="M:NCDK.Pharmacophore.PharmacophoreAtom.#ctor(System.String,System.String,NCDK.Numerics.Vector3)">
            <summary>
            Create a pharmacophore group.
            </summary>
            <param name="smarts">The SMARTS pattern for the group</param>
            <param name="symbol">The label for this group.</param>
            <param name="coordinates">The coordinates for the group. Note that since a pharmacophore group may match
                               multiple atoms (say a c1ccccc1 group), the coordinates for the group are the effective coordinates
                               of all the atoms for the group. In effect this means that for multi-atom groups, the coordinate
                               is simply the mean of the coordinates of the individual atoms for the group.</param>
        </member>
        <member name="M:NCDK.Pharmacophore.PharmacophoreAtom.#ctor(NCDK.Pharmacophore.PharmacophoreAtom)">
            <summary>
            Create a pharmacophore group.
            </summary>
            <param name="pharmacophoreAtom">A previously created pharmacophore group</param>
        </member>
        <member name="P:NCDK.Pharmacophore.PharmacophoreAtom.Smarts">
            <summary>
            The SMARTS for the group.
            </summary>
        </member>
        <member name="M:NCDK.Pharmacophore.PharmacophoreAtom.SetMatchingAtoms(System.Int32[])">
            <summary>
            Set the atoms of a target molecule that correspond to this group.
            <para>
            This method is generally only useful in the context of pharmacophore matching
            </para>
            </summary>
            <param name="atomIndices">The indicies of the atoms in a molecule that match the pattern for this group.</param>
            <seealso cref="M:NCDK.Pharmacophore.PharmacophoreAtom.GetMatchingAtoms"/>
            <seealso cref="T:NCDK.Pharmacophore.PharmacophoreMatcher"/>
        </member>
        <member name="M:NCDK.Pharmacophore.PharmacophoreAtom.GetMatchingAtoms">
            <summary>
            Get the atoms of a target molecule that correspond to this group.
            <para>
            This method is generally only useful in the context of pharmacophore matching
            </para>
            </summary>
            <returns>The indices of the atoms, in a molecule, that match the pattern for this group.</returns>
            <seealso cref="M:NCDK.Pharmacophore.PharmacophoreAtom.SetMatchingAtoms(System.Int32[])"/>
            <seealso cref="T:NCDK.Pharmacophore.PharmacophoreMatcher"/>
        </member>
        <member name="T:NCDK.Pharmacophore.PharmacophoreBond">
            <summary>
            Represents a distance relationship between two pharmacophore groups.
            </summary>
            <seealso cref="T:NCDK.Pharmacophore.PharmacophoreAtom"/>
        </member>
        <member name="M:NCDK.Pharmacophore.PharmacophoreBond.#ctor(NCDK.Pharmacophore.PharmacophoreAtom,NCDK.Pharmacophore.PharmacophoreAtom)">
            <summary>
            Create a pharmacophore distance constraint.
            </summary>
            <param name="patom1">The first pharmacophore group</param>
            <param name="patom2">The second pharmacophore group</param>
        </member>
        <member name="P:NCDK.Pharmacophore.PharmacophoreBond.BondLength">
            <summary>
            The distance between the two pharmacophore groups that make up the constraint.
            </summary>
            <returns>The distance between the two groups</returns>
        </member>
        <member name="T:NCDK.Pharmacophore.PharmacophoreMatcher">
            <summary>
            Identifies atoms whose 3D arrangement matches a specified pharmacophore query.
            <para>
            A pharmacophore is defined by a set of atoms and distances between them. More generically
            we can restate this as a set of pharmacophore groups and the distances between them. Note
            that a pharmacophore group may consist of one or more atoms and the distances can be
            specified as a distance range rather than an exact distance.
            </para>
            <para>
            The goal of a pharmacophore query is to identify atom in a molecule whose 3D arrangement
            match a specified query.
            </para>
            <para>
            To perform a query one must first create a set of pharmacophore groups and specify the
            distances between them. Each pharmacophore group is represented by a <see cref="T:NCDK.Pharmacophore.PharmacophoreAtom" /> 
            and the distances between them are represented by a <see cref="T:NCDK.Pharmacophore.PharmacophoreBond" /> .
            These are collected in a <see cref="T:NCDK.Isomorphisms.Matchers.QueryAtomContainer" />.
            </para>
            <para>
            Given the query pharmacophore one can use this class to check with it occurs in a specified molecule.
            Note that for full generality pharmacophore searches are performed using conformations of molecules.
            This can easily be accomplished using this class together with the <see cref="T:NCDK.ConformerContainer" /> 
            class.  See the example below.
            </para>
            <para>
            Currently this class will allow you to perform pharmacophore searches using triads, quads or any number
            of pharmacophore groups. However, only distances and angles between pharmacophore groups are considered, so
            alternative constraints such as torsions and so on cannot be considered at this point.
            </para>
            <para>
            After a query has been performed one can retrieve the matching groups (as opposed to the matching atoms
            of the target molecule). However since a pharmacophore group (which is an object of class <see cref="T:NCDK.Pharmacophore.PharmacophoreAtom" />)
            allows you to access the indices of the corresponding atoms in the target molecule, this is not very
            difficult.
            </para>
            </summary> 
            <example>
            <code>            QueryAtomContainer query = new QueryAtomContainer(Default.ChemObjectBuilder.Instance);

            PharmacophoreQueryAtom o = new PharmacophoreQueryAtom("D", "[OX1]");
            PharmacophoreQueryAtom n1 = new PharmacophoreQueryAtom("A", "[N]");
            PharmacophoreQueryAtom n2 = new PharmacophoreQueryAtom("A", "[N]");

            query.Atoms.Add(o);
            query.Atoms.Add(n1);
            query.Atoms.Add(n2);

            PharmacophoreQueryBond b1 = new PharmacophoreQueryBond(o, n1, 4.0, 4.5);
            PharmacophoreQueryBond b2 = new PharmacophoreQueryBond(o, n2, 4.0, 5.0);
            PharmacophoreQueryBond b3 = new PharmacophoreQueryBond(n1, n2, 5.4, 5.8);

            query.Bonds.Add(b1);
            query.Bonds.Add(b2);
            query.Bonds.Add(b3);

            string filename = "/Users/rguha/pcore1.sdf";
            using (var srm = new FileStream(filename, FileMode.Open))
            {
                foreach (var conformers in new IEnumerableMDLConformerReader(srm, Default.ChemObjectBuilder.Instance))
                {
                    bool firstTime = true;
                    foreach (var conf in conformers)
                    {
                        bool status;
                        if (firstTime)
                        {
                            status = matcher.Matches(conf, true);
                            firstTime = false;
                        }
                        else status = matcher.Matches(conf, false);
                        if (status)
                        {
                            // OK, matched. Do something
                        }
                    }
</code>
            </example>
            <remarks>
            <para>Extensions to SMARTS</para>
            <para>
            The pharmacophore supports some extentions to the SMARTS language that lead
            to flexible pharmacophore definitions  Note that these extensions are specific to
            pharmacophore usage and are not generally provided by the SMARTS parser itself.
            </para>
            <b>|</b> - this allows one to perform a logical OR between two or more SMARTS patterns. An example might
            be a pharmacophore group that is meant to match a 5 membered ring or a 6 membered ring. This cannot be
            written in a single ordinary SMARTS pattern. However using this one extension one can write
            <pre>A1AAAA1|A1AAAAA1</pre>.
            </remarks>
            <seealso cref="T:NCDK.Pharmacophore.PharmacophoreAtom" />
            <seealso cref="T:NCDK.Pharmacophore.PharmacophoreBond" />
            <seealso cref="T:NCDK.Pharmacophore.PharmacophoreQueryAtom" />
            <seealso cref="T:NCDK.Pharmacophore.PharmacophoreQueryBond" />
        </member>
        <member name="M:NCDK.Pharmacophore.PharmacophoreMatcher.#ctor">
            <summary>
            An empty constructor.
            <para>
            You should set the query before performing a match
            </para>
            </summary>
        </member>
        <member name="M:NCDK.Pharmacophore.PharmacophoreMatcher.#ctor(NCDK.Pharmacophore.PharmacophoreQuery)">
            <summary>
            Initialize the matcher with a query.
            </summary>
            <param name="pharmacophoreQuery">The query pharmacophore</param>
            <seealso cref="T:NCDK.Pharmacophore.PharmacophoreQueryAtom"/>
            <seealso cref="T:NCDK.Pharmacophore.PharmacophoreQueryBond"/>
        </member>
        <member name="M:NCDK.Pharmacophore.PharmacophoreMatcher.Matches(NCDK.IAtomContainer)">
            <summary>
            Performs the pharmacophore matching.
            <para>
            This method will analyze the specified target molecule to identify pharmacophore
            groups. If dealing with conformer data it is probably more efficient to use
            the other form of this method which allows one to skip the pharmacophore group
            identification step after the first conformer.
            </para>
            </summary>
            <param name="atomContainer">The target molecule. Must have 3D coordinates</param>
            <returns>true is the target molecule contains the query pharmacophore</returns>
            <exception cref="T:NCDK.CDKException">if the query pharmacophore was not set or the query is invalid or if the molecule does not have 3D coordinates</exception>
            <seealso cref="M:NCDK.Pharmacophore.PharmacophoreMatcher.Matches(NCDK.IAtomContainer,System.Boolean)"/>
        </member>
        <member name="M:NCDK.Pharmacophore.PharmacophoreMatcher.Matches(NCDK.IAtomContainer,System.Boolean)">
            <summary>
            Performs the pharmacophore matching.
            </summary>
            <param name="atomContainer">The target molecule. Must have 3D coordinates</param>
            <param name="initializeTarget">If <see langword="true"/>, the target molecule specified in the
                                    first argument will be analyzed to identify matching pharmacophore groups. If <see langword="false"/>
                                    this is not performed. The latter case is only useful when dealing with conformers
                                    since for a given molecule, all conformers will have the same pharmacophore groups
                                    and only the constraints will change from one conformer to another.</param>
            <returns><see langword="true"/> is the target molecule contains the query pharmacophore</returns>
            <exception cref="T:NCDK.CDKException">
                     if the query pharmacophore was not set or the query is invalid or if the molecule
                     does not have 3D coordinates</exception>
        </member>
        <member name="M:NCDK.Pharmacophore.PharmacophoreMatcher.GetMatchingPharmacophoreBonds">
            <summary>
            Get the matching pharmacophore constraints.
            </summary>
            <remarks>
            The method should be called after performing the match, otherwise the return value is null.
            The method returns a List of List's. Each List represents the pharmacophore constraints in the
            target molecule that matched the query. Since constraints are conceptually modeled on bonds
            the result is a list of list of IBond. You should coerce these to the appropriate pharmacophore
            bond to get at the underlying grops.
            </remarks>
            <returns>a List of a List of pharmacophore constraints in the target molecule that match the query</returns>
            <seealso cref="T:NCDK.Pharmacophore.PharmacophoreBond"/>
            <seealso cref="T:NCDK.Pharmacophore.PharmacophoreAngleBond"/>
        </member>
        <member name="M:NCDK.Pharmacophore.PharmacophoreMatcher.GetTargetQueryBondMappings">
            <summary>
            Return a list of HashMap's that allows one to get the query constraint for a given pharmacophore bond.
            </summary>
            <remarks>
            If the matching is successful, the return value is a List of HashMaps, each
            HashMap corresponding to a separate match. Each HashMap is keyed on the <see cref="T:NCDK.Pharmacophore.PharmacophoreBond"/>
            in the target molecule that matched a constraint (<see cref="T:NCDK.Pharmacophore.PharmacophoreQueryBond"/> or
            <see cref="T:NCDK.Pharmacophore.PharmacophoreQueryAngleBond"/>. The value is the corresponding query bond.
            </remarks>
            <returns>A List of HashMaps, identifying the query constraint corresponding to a matched constraint in the target molecule.</returns>
        </member>
        <member name="M:NCDK.Pharmacophore.PharmacophoreMatcher.GetMatchingPharmacophoreAtoms">
            <summary>
            Get the matching pharmacophore groups.
            </summary>
            <remarks>
            The method should be called after performing the match, otherwise the return value is null.
            The method returns a List of List's. Each List represents the pharmacophore groups in the
            target molecule that matched the query. Each pharmacophore group contains the indices of the
            atoms (in the target molecule) that correspond to the group.
            </remarks>
            <returns>a List of a List of pharmacophore groups in the target molecule that match the query</returns>
            <seealso cref="T:NCDK.Pharmacophore.PharmacophoreAtom"/>
        </member>
        <member name="M:NCDK.Pharmacophore.PharmacophoreMatcher.GetUniqueMatchingPharmacophoreAtoms">
            <summary>
            Get the uniue matching pharmacophore groups.
            </summary>
            <remarks>
            <para>
            The method should be called after performing the match, otherwise the return value is null.
            The method returns a List of List's. Each List represents the pharmacophore groups in the
            target molecule that matched the query. Each pharmacophore group contains the indices of the
            atoms (in the target molecule) that correspond to the group.
            </para>
            <para>
            This is analogous to the USA form of return value from a SMARTS match.
            </para>
            </remarks>
            <returns>a List of a List of pharmacophore groups in the target molecule that match the query</returns>
            <seealso cref="T:NCDK.Pharmacophore.PharmacophoreAtom"/>
        </member>
        <member name="M:NCDK.Pharmacophore.PharmacophoreMatcher.GetPharmacophoreQuery">
            <summary>
            Get the query pharmacophore.
            </summary>
            <returns>The query</returns>
        </member>
        <member name="M:NCDK.Pharmacophore.PharmacophoreMatcher.SetPharmacophoreQuery(NCDK.Pharmacophore.PharmacophoreQuery)">
            <summary>
            Set a pharmacophore query.
            </summary>
            <param name="query">The query</param>
        </member>
        <member name="M:NCDK.Pharmacophore.PharmacophoreMatcher.GetPharmacophoreMolecule(NCDK.IAtomContainer)">
            <summary>
            Convert the input into a pcore molecule.
            </summary>
            <param name="input">the compound being converted from</param>
            <returns>pcore molecule </returns>
            <exception cref="T:NCDK.CDKException">match failed</exception>
        </member>
        <member name="T:NCDK.Pharmacophore.PharmacophoreQuery">
            <summary>
            Represents a colleciton of pharmacophore groups and constraints.
            <para>
            This : <see cref="T:NCDK.Isomorphisms.Matchers.QueryAtomContainer"/> since
            we need to be able to support things such as exclusion volumes, which cannot (easily)
            be represented as atom or bond analogs.
            </para>
            </summary>
        </member>
        <member name="M:NCDK.Pharmacophore.PharmacophoreQuery.ToString">
            <summary>
            string representation of this query.
            </summary>
            <returns>string representation of this query</returns>
        </member>
        <member name="T:NCDK.Pharmacophore.PharmacophoreQueryAngleBond">
            <summary>
            Represents a pharmacophore query angle constraint.
            </summary>
            <seealso cref="T:NCDK.Pharmacophore.PharmacophoreQueryAtom"/>
            <seealso cref="T:NCDK.Pharmacophore.PharmacophoreMatcher"/>
            <seealso cref="T:NCDK.Isomorphisms.Matchers.QueryAtomContainer"/>
        </member>
        <member name="M:NCDK.Pharmacophore.PharmacophoreQueryAngleBond.#ctor(NCDK.Pharmacophore.PharmacophoreQueryAtom,NCDK.Pharmacophore.PharmacophoreQueryAtom,NCDK.Pharmacophore.PharmacophoreQueryAtom,System.Double,System.Double)">
            <summary>
            Create a query angle constraint between three query groups.
            </summary>
            <remarks>
            Note that the angle is only considered upto 2 decimal places.
            </remarks>
            <param name="atom1">The first pharmacophore group</param>
            <param name="atom2">The second pharmacophore group</param>
            <param name="atom3">The third pharmacophore group</param>
            <param name="lower">The lower bound of the angle between the three groups</param>
            <param name="upper">The upper bound of the angle between the three groups</param>
        </member>
        <member name="M:NCDK.Pharmacophore.PharmacophoreQueryAngleBond.#ctor(NCDK.Pharmacophore.PharmacophoreQueryAtom,NCDK.Pharmacophore.PharmacophoreQueryAtom,NCDK.Pharmacophore.PharmacophoreQueryAtom,System.Double)">
            <summary>
            Create a query angle constraint between three query groups.
            <para>
            This constructor allows you to define a query angle constraint
            such that the angle between the three query groups is exact
            (i.e., not a range).
            </para>
            </summary>
            <remarks>
            Note that the angle is only considered upto 2 decimal places.
            </remarks>
            <param name="atom1">The first pharmacophore group</param>
            <param name="atom2">The second pharmacophore group</param>
            <param name="atom3">The third pharmacophore group</param>
            <param name="angle">The exact angle between the two groups</param>
        </member>
        <member name="M:NCDK.Pharmacophore.PharmacophoreQueryAngleBond.Matches(NCDK.IBond)">
            <summary>
            Checks whether the query angle constraint matches a target distance.
            <para>
            This method checks whether a query constraint is satisfied by an observed
            angle (represented by a <see cref="T:NCDK.Pharmacophore.PharmacophoreAngleBond"/> in the target molecule.
            </para>
            </summary>
            <remarks>
            Note that angles are compared upto 2 decimal places.
            </remarks>
            <param name="bond">The angle relationship in a target molecule</param>
            <returns>true if the target angle lies within the range of the query constraint</returns>
        </member>
        <member name="M:NCDK.Pharmacophore.PharmacophoreQueryAngleBond.ToString">
            <summary>
            string representation of an angle constraint.
            </summary>
            <returns>string representation of and angle constraint</returns>
        </member>
        <member name="T:NCDK.Pharmacophore.PharmacophoreQueryAtom">
            <summary>
            Represents a query pharmacophore group.
            <para>
            This class is meant to be used to construct pharmacophore queries in conjunction
            </para>
            with <see cref="T:NCDK.Pharmacophore.PharmacophoreQueryBond"/> and an <see cref="T:NCDK.Isomorphisms.Matchers.QueryAtomContainer"/>.
            </summary>
            <seealso cref="T:NCDK.Pharmacophore.PharmacophoreQueryBond"/>
            <seealso cref="T:NCDK.Isomorphisms.Matchers.QueryAtomContainer"/>
            <seealso cref="T:NCDK.Pharmacophore.PharmacophoreMatcher"/>
        </member>
        <member name="M:NCDK.Pharmacophore.PharmacophoreQueryAtom.#ctor(System.String,System.String)">
            <summary>
            Creat a new query pharmacophore group
            </summary>
            <param name="symbol">The symbol for the group</param>
            <param name="smarts">The SMARTS pattern to be used for matching</param>
        </member>
        <member name="P:NCDK.Pharmacophore.PharmacophoreQueryAtom.Smarts">
            <summary>
            The SMARTS pattern for this pharmacophore group.
            </summary>
        </member>
        <member name="P:NCDK.Pharmacophore.PharmacophoreQueryAtom.CompiledSmarts">
            <summary>
            Accessed the compiled SMARTS for this pcore query atom.  
            </summary>
        </member>
        <member name="M:NCDK.Pharmacophore.PharmacophoreQueryAtom.Matches(NCDK.IAtom)">
            <summary>
            Checks whether this query atom matches a target atom.
            <para>
            Currently a query pharmacophore atom will match a target pharmacophore group if the
            symbols of the two groups match. This is based on the assumption that
            pharmacophore groups with the same symbol will have the same SMARTS
            pattern.
            </para>
            </summary>
            <param name="atom">A target pharmacophore group</param>
            <returns>true if the current query group has the same symbol as the target group</returns>
        </member>
        <member name="M:NCDK.Pharmacophore.PharmacophoreQueryAtom.ToString">
            <summary>
            string representation of this pharmacophore group.
            </summary>
            <returns>string representation of this pharmacophore group</returns>
        </member>
        <member name="T:NCDK.Pharmacophore.PharmacophoreQueryBond">
            <summary>
            Represents a pharmacophore query distance constraint.
            </summary>
            <seealso cref="T:NCDK.Pharmacophore.PharmacophoreQueryAtom"/>
            <seealso cref="T:NCDK.Pharmacophore.PharmacophoreMatcher"/>
            <seealso cref="T:NCDK.Isomorphisms.Matchers.QueryAtomContainer"/>
        </member>
        <member name="M:NCDK.Pharmacophore.PharmacophoreQueryBond.#ctor(NCDK.Pharmacophore.PharmacophoreQueryAtom,NCDK.Pharmacophore.PharmacophoreQueryAtom,System.Double,System.Double)">
            <summary>
            Create a query distance constraint between two query groups.
            </summary>
            <remarks>
            Note that the distance is only considered upto 2 decimal places.
            </remarks>
            <param name="atom1">The first pharmacophore group</param>
            <param name="atom2">The second pharmacophore group</param>
            <param name="lower">The lower bound of the distance between the two groups</param>
            <param name="upper">The upper bound of the distance between the two groups</param>
            <seealso cref="M:NCDK.Pharmacophore.PharmacophoreQueryBond.#ctor(NCDK.Pharmacophore.PharmacophoreQueryAtom,NCDK.Pharmacophore.PharmacophoreQueryAtom,System.Double)"/>
        </member>
        <member name="M:NCDK.Pharmacophore.PharmacophoreQueryBond.#ctor(NCDK.Pharmacophore.PharmacophoreQueryAtom,NCDK.Pharmacophore.PharmacophoreQueryAtom,System.Double)">
            <summary>
            Create a query distance constraint between two query groups.
            <para>
            This constructor allows you to define a query distance constraint
            such that the distance between the two query groups is exact
            (i.e., not a range).
            </para>
            </summary>
            <remarks>
            Note that the distance is only considered upto 2 decimal places.
            </remarks>
            <param name="atom1">The first pharmacophore group</param>
            <param name="atom2">The second pharmacophore group</param>
            <param name="distance">The exact distance between the two groups</param>
            <seealso cref="M:NCDK.Pharmacophore.PharmacophoreQueryBond.#ctor(NCDK.Pharmacophore.PharmacophoreQueryAtom,NCDK.Pharmacophore.PharmacophoreQueryAtom,System.Double,System.Double)"/>
        </member>
        <member name="M:NCDK.Pharmacophore.PharmacophoreQueryBond.Matches(NCDK.IBond)">
            <summary>
            Checks whether the query distance constraint matches a target distance.
            <para>
            This method checks whether a query constraint is satisfied by an observed
            distance (represented by a <see cref="T:NCDK.Pharmacophore.PharmacophoreBond"/> in the target molecule.
            Note that distance are compared upto 2 decimal places.
            </para>
            </summary>
            <param name="bond">The distance relationship in a target molecule</param>
            <returns>true if the target distance lies within the range of the query constraint</returns>
        </member>
        <member name="M:NCDK.Pharmacophore.PharmacophoreQueryBond.ToString">
            <summary>
            string representation of a distance constraint.
            </summary>
            <returns>string representation of a distance constraint</returns>
        </member>
        <member name="T:NCDK.Pharmacophore.PharmacophoreUtils">
            <summary>
            Provides some utility methods for pharmacophore handling.
            </summary>
        </member>
        <member name="M:NCDK.Pharmacophore.PharmacophoreUtils.ReadPharmacophoreDefinitions(System.IO.Stream)">
            <summary>
            Read in a set of pharmacophore definitions to create pharmacophore queries.
            <para>
            Pharmacophore queries can be saved in an XML format which is described XXX. The
            file can contain multiple definitions. This method will process all the definitions
            and return a list of <see cref="T:NCDK.Pharmacophore.PharmacophoreQuery" />  objects which can be used with
            the <see cref="T:NCDK.Pharmacophore.PharmacophoreMatcher" /> class.
            </para>
            <para>
            The current schema for the document allows one to specify angle and distance
            constraints. Currently the CDK does not support angle constraints, so they are
            ignored.
            </para>
            <para>
            The schema also specifies a <i>units</i> attribute for a given constraint. The
            current reader ignores this and assumes that all distances are in Angstroms.
            </para>
            <para>
            Finally, if there is a description associated with a pharmacophore definition, it is
            available as the <i>"description"</i> property of the <see cref="T:NCDK.Pharmacophore.PharmacophoreQuery" /> object.
            </para>
            </summary>
            <example>
            <code>            using (var srm = new FileStream("mydefs.xml", FileMode.Open))
            {
                IList&lt;PharmacophoreQuery&gt; defs = PharmacophoreUtils.ReadPharmacophoreDefinitions(srm);
                Console.Out.WriteLine("Number of definitions = " + defs.Count);
                for (int i = 0; i &lt; defs.Count; i++) {
                    Console.Out.WriteLine($"Desc: {defs[i].GetProperty&lt;string&gt;("description")}");
                }
            }
</code>
            </example>
            <param name="ins">The stream to read the definitions from</param>
            <returns>A <see cref="T:System.Collections.Generic.IList`1" /> of <see cref="T:NCDK.Pharmacophore.PharmacophoreQuery" /> objects</returns>
            <exception cref="T:NCDK.CDKException">if there is an error in the format</exception>
            <exception cref="T:System.IO.IOException"> if there is an error in opening the file</exception>
            <see cref="T:NCDK.Pharmacophore.PharmacophoreQueryAtom" />
            <see cref="T:NCDK.Pharmacophore.PharmacophoreQueryBond" />
            <see cref="T:NCDK.Pharmacophore.PharmacophoreQuery" />
            <see cref="T:NCDK.Pharmacophore.PharmacophoreMatcher" />
        </member>
        <member name="M:NCDK.Pharmacophore.PharmacophoreUtils.WritePharmacophoreDefinition(NCDK.Pharmacophore.PharmacophoreQuery,System.IO.Stream)">
            <summary>
            Write out one or more pharmacophore queries in the CDK XML format.
            </summary>
            <param name="query">The pharmacophore queries</param>
            <param name="output">The Stream to write to</param>
            <exception cref="T:System.IO.IOException">if there is a problem writing the XML document</exception>
        </member>
        <member name="M:NCDK.Pharmacophore.PharmacophoreUtils.WritePharmacophoreDefinition(System.Collections.Generic.IList{NCDK.Pharmacophore.PharmacophoreQuery},System.IO.Stream)">
            <summary>
            Write out one or more pharmacophore queries in the CDK XML format.
            </summary>
            <param name="queries">The pharmacophore queries</param>
            <param name="output">The Stream to write to</param>
            <exception cref="T:System.IO.IOException">if there is a problem writing the XML document</exception>
        </member>
        <member name="M:NCDK.Pharmacophore.PharmacophoreUtils.WritePharmacophoreDefinition(NCDK.Pharmacophore.PharmacophoreQuery[],System.IO.Stream)">
            <summary>
            Write out one or more pharmacophore queries in the CDK XML format.
            </summary>
            <param name="queries">The pharmacophore queries</param>
            <param name="output">The Stream to write to</param>
            <exception cref="T:System.IO.IOException">if there is a problem writing the XML document</exception>
        </member>
        <member name="M:NCDK.Pharmacophore.PharmacophoreUtils.GetGroupDefinitions(System.Xml.Linq.XElement)">
            <summary>
            find all &lt;group&gt; elements that are directly under the supplied element so
            this wont recurse through sub elements that may contain group elements
            </summary>
        </member>
        <member name="T:NCDK.Signatures.AtomSignature">
             <summary>
             The signature <token>cdk-cite-FAU03</token>; <token>cdk-cite-FAU04</token> for a molecule rooted at a particular atom.
             </summary>
             <remarks>
            
             <para>
             A signature is a description of the connectivity of a molecule, in the form
             of a tree-like structure called a directed acyclic graph (DAG). This DAG can
             be written out as a string, for example ethane:
             </para>
            
             <pre>
               [C]([C]([H][H][H])[H][H][H])
             </pre>
            
             <para>
             where each atom is represented by an atom symbol in square brackets. The
             branching of the tree is indicated by round brackets. When the molecule has a
             cycle, the signature string will have numbers after the atom symbol, like:
             </para>
            
             <pre>
             [C]([C]([C,0])[C]([C,0]))
             </pre>
            
             <para>
             these are known as 'colors' and indicate ring closures, in a roughly similar
             way to SMILES notation. Note that the colors start from 0 in this
             implementation, in contrast to the examples in <token>cdk-cite-FAU04</token>.
             </para>
            
             <para>
             Multiple bonds are represented by symbols in front of the opening square
             bracket of an atom. Double bonds are '=', triple are '#'. Since there is a
             defined direction for the signature tree, only the child node will have the
             bond symbol, and the relevant bond is to the parent.
             </para>
             </remarks>
        </member>
        <member name="F:NCDK.Signatures.AtomSignature.molecule">
            <summary>
            The atom container to make signatures from.
            </summary>
        </member>
        <member name="M:NCDK.Signatures.AtomSignature.#ctor(System.Int32,NCDK.IAtomContainer)">
            <summary>
            Create an atom signature starting at <paramref name="atomIndex"/>.
            </summary>
            <param name="atomIndex">the index of the atom that roots this signature</param>
            <param name="molecule">the molecule to create the signature from</param>
        </member>
        <member name="M:NCDK.Signatures.AtomSignature.#ctor(NCDK.IAtom,NCDK.IAtomContainer)">
            <summary>
            Create an atom signature for the atom <paramref name="atom"/>.
            </summary>
            <param name="atom">the atom to make the signature for</param>
            <param name="molecule">the molecule to create the signature from</param>
        </member>
        <member name="M:NCDK.Signatures.AtomSignature.#ctor(System.Int32,System.Int32,NCDK.IAtomContainer)">
            <summary>
            Create an atom signature starting at <paramref name="atomIndex"/> and with a
            maximum height of <paramref name="height"/>.
            </summary>
            <param name="atomIndex">the index of the atom that roots this signature</param>
            <param name="height">the maximum height of the signature</param>
            <param name="molecule">the molecule to create the signature from</param>
        </member>
        <member name="M:NCDK.Signatures.AtomSignature.#ctor(NCDK.IAtom,System.Int32,NCDK.IAtomContainer)">
            <summary>
            Create an atom signature for the atom <paramref name="atom"/> and with a
            maximum height of <paramref name="height"/>.
            </summary>
            <param name="atom">the index of the atom that roots this signature</param>
            <param name="height">the maximum height of the signature</param>
            <param name="molecule">the molecule to create the signature from</param>
        </member>
        <member name="M:NCDK.Signatures.AtomSignature.#ctor(System.Int32,System.Int32,NCDK.FaulonSignatures.AbstractVertexSignature.InvariantTypes,NCDK.IAtomContainer)">
            <summary>
            Create an atom signature starting at <paramref name="atomIndex"/>, with maximum
            height of <paramref name="height"/>, and using a particular invariant type.
            </summary>
            <param name="atomIndex">the index of the atom that roots this signature</param>
            <param name="height">the maximum height of the signature</param>
            <param name="invariantType">the type of invariant (int, string, ...)</param>
            <param name="molecule">the molecule to create the signature from</param>
        </member>
        <member name="M:NCDK.Signatures.AtomSignature.#ctor(NCDK.IAtom,System.Int32,NCDK.FaulonSignatures.AbstractVertexSignature.InvariantTypes,NCDK.IAtomContainer)">
            <summary>
            Create an atom signature for the atom <paramref name="atom"/>, with maximum
            height of <paramref name="height"/>, and using a particular invariant type.
            </summary>
            <param name="atom">the index of the atom that roots this signature</param>
            <param name="height">the maximum height of the signature</param>
            <param name="invariantType">the type of invariant (int, string, ...)</param>
            <param name="molecule">the molecule to create the signature from</param>
        </member>
        <member name="M:NCDK.Signatures.AtomSignature.GetIntLabel(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Signatures.AtomSignature.GetConnected(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Signatures.AtomSignature.GetEdgeLabel(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Signatures.AtomSignature.GetVertexSymbol(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Signatures.AtomSignature.ConvertEdgeLabelToColor(System.String)">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Signatures.MoleculeFromSignatureBuilder">
            <summary>
            Builds a molecule from a signature.
            </summary>
        </member>
        <member name="F:NCDK.Signatures.MoleculeFromSignatureBuilder.builder">
            <summary>
            The chem object builder
            </summary>
        </member>
        <member name="F:NCDK.Signatures.MoleculeFromSignatureBuilder.container">
            <summary>
            The container that is being constructed
            </summary>
        </member>
        <member name="M:NCDK.Signatures.MoleculeFromSignatureBuilder.#ctor(NCDK.IChemObjectBuilder)">
            <summary>
            Uses the chem object builder for making molecules.
            </summary>
            <param name="builder">a builder for CDK molecules.</param>
        </member>
        <member name="M:NCDK.Signatures.MoleculeFromSignatureBuilder.MakeEdge(System.Int32,System.Int32,System.String,System.String,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Signatures.MoleculeFromSignatureBuilder.MakeGraph">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Signatures.MoleculeFromSignatureBuilder.MakeVertex(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Signatures.MoleculeFromSignatureBuilder.GetAtomContainer">
            <summary>
            Gets the atom container.
            </summary>
            <returns>the constructed atom container</returns>
        </member>
        <member name="T:NCDK.Signatures.MoleculeSignature">
             <summary>
             <para>
             A molecule signature is a way to produce <see cref="T:NCDK.Signatures.AtomSignature" />s and to get
             the canonical <token>cdk-cite-FAU04</token> signature string for a molecule. There are
             several possible uses for a molecule signature.
             </para>
             </summary>
             <remarks>
             <para>
             Firstly, a signature with a height greater than the diameter of a molecule
             can be used to reconstruct the molecule. In this sense, the signature string
             is like a SMILES <token>cdk-cite-WEI88</token>; <token>cdk-cite-WEI89</token> string. It is more verbose, but it
             will work for all molecules.
             </para>
            
             <para>
             Secondly, the set of signatures for a molecule partition the atoms into
             equivalence classes (or 'orbits' - see the <see cref="T:NCDK.Signatures.Orbit" /> class). This is
             similar to partitioning atoms by Morgan number <token>cdk-cite-MOR65</token> except that
             it works for 3-regular graphs like fullerenes.
             </para>
            
             <para>
             Thirdly, signatures can be calculated at different heights to give
             descriptions of the connectivity around atoms. 'Height' is the same as the
             idea of a 'sphere' in HOSE codes, and signatures are also path descriptors in
             this sense.
             </para>
             </remarks>
             <example>
             So, for example, to get the canonical signature for a molecule:
             <code>             IAtomContainer diamantane = TestMoleculeFactory.MakeBenzene();
             MoleculeSignature moleculeSignature = new MoleculeSignature(diamantane);
             string canonicalSignature = moleculeSignature.ToCanonicalString();
            
             // to get the orbits of this molecule
            IList&lt;Orbit&gt; orbits = moleculeSignature.CalculateOrbits();
            
             // and to get the height-2 signature string of just atom 5:
             string hSignatureForAtom5 = moleculeSignature.SignatureStringForVertex(5, 2);
</code>
             it is also possible to get AtomSignatures using the <see cref="M:NCDK.Signatures.MoleculeSignature.SignatureForVertex(System.Int32)" /> method
             - which is just a convenience method equivalent to calling the constructor of
             an <see cref="T:NCDK.Signatures.AtomSignature" /> class.
             </example>
        </member>
        <member name="F:NCDK.Signatures.MoleculeSignature.molecule">
            <summary>
            The molecule to use when making atom signatures
            </summary>
        </member>
        <member name="M:NCDK.Signatures.MoleculeSignature.#ctor(NCDK.IAtomContainer)">
            <summary>
            Creates a signature that represents this molecule.
            </summary>
            <param name="molecule">the molecule to convert to a signature</param>
        </member>
        <member name="M:NCDK.Signatures.MoleculeSignature.#ctor(NCDK.IAtomContainer,System.Int32)">
            <summary>
            Creates a signature with a maximum height of <paramref name="height"/>
            for molecule <paramref name="molecule"/>.
            </summary>
            <param name="molecule">the molecule to convert to a signature</param>
            <param name="height">the maximum height of the signature</param>
        </member>
        <member name="M:NCDK.Signatures.MoleculeSignature.GetVertexCount">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Signatures.MoleculeSignature.SignatureStringForVertex(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Signatures.MoleculeSignature.SignatureStringForVertex(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Signatures.MoleculeSignature.SignatureForVertex(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Signatures.MoleculeSignature.CalculateOrbits">
            <summary>
            Calculates the orbits of the atoms of the molecule.
            </summary>
            <returns>a list of orbits</returns>
        </member>
        <member name="M:NCDK.Signatures.MoleculeSignature.FromSignatureString(System.String,NCDK.IChemObjectBuilder)">
            <summary>
            Builder for molecules (rather, for atom containers) from signature
            strings.
            </summary>
            <param name="signatureString">the signature string to use</param>
            <param name="coBuilder"><see cref="T:NCDK.IChemObjectBuilder"/> to build the returned atom container from</param>
            <returns>an atom container</returns>
        </member>
        <member name="M:NCDK.Signatures.MoleculeSignature.ToCanonicalSignatureString(System.Int32)">
            <summary>
            Make a canonical signature string of a given height.
            </summary>
            <param name="height">the maximum height to make signatures</param>
            <returns>the canonical signature string</returns>
        </member>
        <member name="T:NCDK.Signatures.Orbit">
            <summary>
            A list of atom indices, and the label of the orbit.
            </summary>
        </member>
        <member name="F:NCDK.Signatures.Orbit.atomIndices">
            <summary>
            The atom indices in this orbit
            </summary>
        </member>
        <member name="F:NCDK.Signatures.Orbit.label">
            <summary>
            The label that all the atoms in the orbit share
            </summary>
        </member>
        <member name="F:NCDK.Signatures.Orbit.height">
            <summary>
            The maximum height of the signature string
            </summary>
        </member>
        <member name="M:NCDK.Signatures.Orbit.Sort">
            <summary>
            Sorts the atom indices in this orbit.
            </summary>
        </member>
        <member name="P:NCDK.Signatures.Orbit.Height">
            <summary>
            The height of the signature of this orbit.
            </summary>
        </member>
        <member name="P:NCDK.Signatures.Orbit.AtomIndices">
            <summary>
            All the atom indices as a list.
            </summary>
        </member>
        <member name="M:NCDK.Signatures.Orbit.AddAtomAt(System.Int32)">
            <summary>
            Adds an atom index to the orbit.
            </summary>
            <param name="atomIndex">the atom index</param>
        </member>
        <member name="M:NCDK.Signatures.Orbit.HasLabel(System.String)">
            <summary>
            Checks to see if the orbit has this string as a label.
            </summary>
            <param name="otherLabel">the label to compare with</param>
            <returns> if it has this label</returns>
        </member>
        <member name="M:NCDK.Signatures.Orbit.IsEmpty">
            <summary>
            Checks to see if the orbit is empty.
            </summary>
            <returns><see langword="true"/> if there are no atom indices in the orbit</returns>
        </member>
        <member name="P:NCDK.Signatures.Orbit.FirstAtom">
            <summary>
            The first atom index of the orbit.
            </summary>
        </member>
        <member name="M:NCDK.Signatures.Orbit.Remove(System.Int32)">
            <summary>
            Removes an atom index from the orbit.
            </summary>
            <param name="atomIndex">the atom index to remove</param>
        </member>
        <member name="P:NCDK.Signatures.Orbit.Label">
            <summary>
            The label of the orbit.
            </summary>
        </member>
        <member name="M:NCDK.Signatures.Orbit.Contains(System.Int32)">
            <summary>
            Checks to see if the orbit contains this atom index.
            </summary>
            <param name="atomIndex">the atom index to look for</param>
            <returns><see langword="true"/> if the orbit contains this atom index</returns>
        </member>
        <member name="T:NCDK.Signatures.SignatureQuotientGraph">
            <summary>
            A signature quotient graph has a vertex for every signature symmetry class
            and an edge for each bond in the molecule between atoms in their class.
            </summary>
            <remarks>
            So a structure where all the atoms are in the same symmetry class will have a
            quotient graph with one vertex and one loop edge. At the other extreme, a
            structure where every atom is in a different class will have a quotient
            graph the same as the molecule.
            </remarks>
        </member>
        <member name="F:NCDK.Signatures.SignatureQuotientGraph.atomContainer">
            <summary>
            The atom container to work on
            </summary>
        </member>
        <member name="M:NCDK.Signatures.SignatureQuotientGraph.#ctor(NCDK.IAtomContainer)">
            <summary>
            Construct a quotient graph from the symmetry classes generated from the
            atom container.
            </summary>
            <param name="atomContainer">the structure to use</param>
        </member>
        <member name="M:NCDK.Signatures.SignatureQuotientGraph.#ctor(NCDK.IAtomContainer,System.Int32)">
            <summary>
            Construct a quotient graph using symmetry classes defined by signatures
            of height <paramref name="height"/>.
            </summary>
            <param name="atomContainer">the structure to use</param>
            <param name="height">the height of the signatures</param>
        </member>
        <member name="M:NCDK.Signatures.SignatureQuotientGraph.IsConnected(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Similarity.DistanceMoment">
            <summary>
            Fast similarity measure for 3D structures.
            </summary>
            <remarks>
            <para>
            This class implements a fast descriptor based 3D similarity measure described by Ballester et al
            (<token>cdk-cite-BALL2007</token>). The approach calculates the distances of each atom to four specific points: the
            centroid of the molecule, the atom that is closest to the centroid, the atom that is farthest from the
            centroid and the atom that is farthest from the previous atom. Thus we get 4 sets of distance distributions.
            The final descriptor set is generated by evaluating the first three moments of each distance distribution.
            </para>
            <para>
            The similarity between two molecules is then evaluated using the inverse of a normalized
            Manhattan type metric.
            </para>
            <para>
            This class allows you to evaluate the 3D similarity between two specified molecules as well as
            generate the 12 descriptors used to characterize the 3D structure which can then be used for a
            variety of purposes such as storing in a database.
            </para>
            <note type="note">
            The methods of this class do not perform hydrogen removal. If you want to
            do the calculations excluding hydrogens, you'll need to do it yourself. Also, if the molecule has
            disconnected components, you should consider one (usually the largest), otherwise all components
            are considered in the calculation.
            </note>
            </remarks>
        </member>
        <member name="M:NCDK.Similarity.DistanceMoment.GenerateMoments(NCDK.IAtomContainer)">
            <summary>
            Evaluate the 12 descriptors used to characterize the 3D shape of a molecule.
            </summary>
            <param name="atomContainer">The molecule to consider, should have 3D coordinates</param>
            <returns>A 12 element array containing the descriptors.</returns>
            <exception cref="T:NCDK.CDKException">if there are no 3D coordinates</exception>
        </member>
        <member name="M:NCDK.Similarity.DistanceMoment.Calculate(NCDK.IAtomContainer,NCDK.IAtomContainer)">
            <summary>
            Evaluate the 3D similarity between two molecules.
            </summary>
            <remarks>
            The method does not remove hydrogens. If this is required, remove them from the
            molecules before passing them here.
            </remarks>
            <param name="query">The query molecule</param>
            <param name="target">The target molecule</param>
            <returns>The similarity between the two molecules (ranging from 0 to 1)</returns>
            <exception cref="T:NCDK.CDKException">if either molecule does not have 3D coordinates</exception>
        </member>
        <member name="T:NCDK.Similarity.LingoSimilarity">
            <summary>
            A class to evaluate the similarity between two LINGO's as described in <token>cdk-cite-Vidal2005</token>.
            </summary>
            <remarks>
            The similarity calculation is a variant of the Tanimoto coefficient and hence its
            value ranges from 0 to 1
            </remarks>
        </member>
        <member name="M:NCDK.Similarity.LingoSimilarity.Calculate(System.Collections.Generic.IDictionary{System.String,System.Int32},System.Collections.Generic.IDictionary{System.String,System.Int32})">
            <summary>
            Evaluate the LINGO similarity between two key,value sty;e fingerprints.
            The value will range from 0.0 to 1.0.
            </summary>
            <returns>similarity</returns>
        </member>
        <member name="T:NCDK.Similarity.Tanimoto">
             <summary>
              Calculates the Tanimoto coefficient for a given pair of two
              fingerprint bitsets or real valued feature vectors.
             </summary>
             <remarks>
             The Tanimoto coefficient is one way to
             quantitatively measure the "distance" or similarity of
             two chemical structures.
             <para>You can use the FingerPrinter class to retrieve two fingerprint bitsets.
             We assume that you have two structures stored in cdk.Molecule objects.
             A tanimoto coefficient can then be calculated like:
             <code>            BitArray fingerprint1 = fingerprinter.GetBitFingerprint(molecule1).AsBitSet();
            BitArray fingerprint2 = fingerprinter.GetBitFingerprint(molecule2).AsBitSet();
            double tanimoto_coefficient = Tanimoto.Calculate(fingerprint1, fingerprint2);
</code>
             </para>
             <para>The FingerPrinter assumes that hydrogens are explicitely given, if this
             is desired!</para>
             <para>Note that the continuous Tanimoto coefficient does not lead to a metric space</para>
             </remarks>
            @author         steinbeck
        </member>
        <member name="M:NCDK.Similarity.Tanimoto.Calculate(System.Collections.BitArray,System.Collections.BitArray)">
            <summary>
            Evaluates Tanimoto coefficient for two bit sets.
            </summary>
            <param name="bitset1">A bitset (such as a fingerprint) for the first molecule</param>
            <param name="bitset2">A bitset (such as a fingerprint) for the second molecule</param>
            <returns>The Tanimoto coefficient</returns>
            <exception cref="T:NCDK.CDKException"> if bitsets are not of the same length</exception>
        </member>
        <member name="M:NCDK.Similarity.Tanimoto.Calculate(NCDK.Fingerprints.IBitFingerprint,NCDK.Fingerprints.IBitFingerprint)">
            <summary>
            Evaluates Tanimoto coefficient for two <see cref="T:NCDK.Fingerprints.IBitFingerprint"/>.
            </summary>
            <param name="fingerprint1">fingerprint for the first molecule</param>
            <param name="fingerprint2">fingerprint for the second molecule</param>
            <returns>The Tanimoto coefficient</returns>
            <exception cref="T:System.ArgumentException">if bitsets are not of the same length</exception>
        </member>
        <member name="M:NCDK.Similarity.Tanimoto.Calculate(System.Double[],System.Double[])">
            <summary>
            Evaluates the continuous Tanimoto coefficient for two real valued vectors.
            </summary>
            <param name="features1">The first feature vector</param>
            <param name="features2">The second feature vector</param>
            <returns>The continuous Tanimoto coefficient</returns>
            <exception cref="T:NCDK.CDKException"> if the features are not of the same length</exception>
        </member>
        <member name="M:NCDK.Similarity.Tanimoto.Calculate(System.Collections.Generic.IDictionary{System.String,System.Int32},System.Collections.Generic.IDictionary{System.String,System.Int32})">
            <summary>
            Evaluate continuous Tanimoto coefficient for two feature, count fingerprint representations.
            </summary>
            <remarks>
            Note that feature/count type fingerprints may be of different length.
            Uses Tanimoto method from 10.1021/ci800326z
            </remarks>
            <param name="features1">The first feature map</param>
            <param name="features2">The second feature map</param>
            <returns>The Tanimoto coefficient</returns>
        </member>
        <member name="M:NCDK.Similarity.Tanimoto.Calculate(NCDK.Fingerprints.ICountFingerprint,NCDK.Fingerprints.ICountFingerprint)">
            <summary>
            Evaluate continuous Tanimoto coefficient for two feature, count fingerprint representations.
            </summary>
            <remarks>
            Note that feature/count type fingerprints may be of different length.
            Uses Tanimoto method from 10.1021/ci800326z
            </remarks>
            <param name="fp1">The first fingerprint</param>
            <param name="fp2">The second fingerprint</param>
            <returns>The Tanimoto coefficient</returns>
            <seealso cref="M:NCDK.Similarity.Tanimoto.Method1(NCDK.Fingerprints.ICountFingerprint,NCDK.Fingerprints.ICountFingerprint)"/>
            <seealso cref="M:NCDK.Similarity.Tanimoto.Method2(NCDK.Fingerprints.ICountFingerprint,NCDK.Fingerprints.ICountFingerprint)"/>
        </member>
        <member name="M:NCDK.Similarity.Tanimoto.Method1(NCDK.Fingerprints.ICountFingerprint,NCDK.Fingerprints.ICountFingerprint)">
            <summary>
            Calculates Tanimoto distance for two count fingerprints using method 1.
            </summary>
            <remarks>
            The feature/count type fingerprints may be of different length.
            Uses Tanimoto method from <token>cdk-cite-Steffen09</token>.
            </remarks>
            <param name="fp1">count fingerprint 1</param>
            <param name="fp2">count fingerprint 2</param>
            <returns>a Tanimoto distance</returns>
        </member>
        <member name="M:NCDK.Similarity.Tanimoto.Method2(NCDK.Fingerprints.ICountFingerprint,NCDK.Fingerprints.ICountFingerprint)">
            <summary>
            Calculates Tanimoto distance for two count fingerprints using method 2.
            </summary>
            <remarks>
            <token>cdk-cite-Grant06</token>.
            </remarks>
            <param name="fp1">count fingerprint 1</param>
            <param name="fp2">count fingerprint 2</param>
            <returns>a Tanimoto distance</returns>
        </member>
        <member name="T:NCDK.Tautomers.InChITautomerGenerator">
            <summary>
            Creates tautomers for a given input molecule, based on the mobile H atoms listed in the InChI.
            Algorithm described in <token>cdk-cite-Thalheim2010</token>.
            <para>
            <b>Provide your input molecules in Kekule form, and make sure atom type are perceived.</b>
            </para>
            <para>
            When creating an input molecule by reading an MDL file, make sure to set implicit hydrogens. See the
            InChITautomerGeneratorTest test case.</para>
            </summary>
        </member>
        <member name="F:NCDK.Tautomers.InChITautomerGenerator.KETO_ENOL">
            <summary>Generate InChI with -KET (keto-enol tautomers) option.</summary>
        </member>
        <member name="F:NCDK.Tautomers.InChITautomerGenerator.ONE_FIVE_SHIFT">
            <summary>Generate InChI with -15T (1,5-shift tautomers) option.</summary>
        </member>
        <member name="M:NCDK.Tautomers.InChITautomerGenerator.#ctor(System.Int32)">
            <summary>
            Create a tautomer generator specifygin whether to enable, keto-enol (-KET) and 1,5-shifts (-15T).
            
            <pre><code>// enabled -KET option
            InChITautomerGenerator tautgen = new InChITautomerGenerator(InChITautomerGenerator.KETO_ENOL);
            // enabled both -KET and -15T
            InChITautomerGenerator tautgen = new InChITautomerGenerator(InChITautomerGenerator.KETO_ENOL | InChITautomerGenerator.ONE_FIVE_SHIFT);
            </code></pre>
            </summary>
            <param name="flags">the options</param>
        </member>
        <member name="M:NCDK.Tautomers.InChITautomerGenerator.#ctor">
            <summary>
            Create a tautomer generator, keto-enol (-KET) and 1,5-shifts (-15T) are disabled.
            </summary>
        </member>
        <member name="M:NCDK.Tautomers.InChITautomerGenerator.GetTautomers(NCDK.IAtomContainer)">
            <summary>
            Public method to get tautomers for an input molecule, based on the InChI which will be calculated by .NET prot of JNI-InChI..
            </summary>
            <param name="mol">molecule for which to generate tautomers</param>
            <returns>a list of tautomers, if any</returns>
            <exception cref="T:NCDK.CDKException"></exception>
        </member>
        <member name="M:NCDK.Tautomers.InChITautomerGenerator.GetTautomers(NCDK.IAtomContainer,System.String)">
            <summary>
            This method is slower than recalculating the InChI with <see cref="M:NCDK.Tautomers.InChITautomerGenerator.GetTautomers(NCDK.IAtomContainer)"/> as the mapping
            between the two can be found more efficiently.
            </summary>
            <param name="mol"></param>
            <param name="inchi"></param>
            <returns></returns>
            <exception cref="T:NCDK.CDKException"></exception>
        </member>
        <member name="M:NCDK.Tautomers.InChITautomerGenerator.GetTautomers(NCDK.IAtomContainer,System.String,System.Int64[])">
            <summary>
            Overloaded <see cref="M:NCDK.Tautomers.InChITautomerGenerator.GetTautomers(NCDK.IAtomContainer)"/> to get tautomers for an input molecule with the InChI already
            provided as input argument.
            </summary>
            <param name="mol">and input molecule for which to generate tautomers</param>
            <param name="inchi">InChI for the input molecule</param>
            <param name="amap">ordering of the molecules atoms in the InChI</param>
            <returns>a list of tautomers</returns>
            <exception cref="T:NCDK.CDKException"></exception>
        </member>
        <member name="M:NCDK.Tautomers.InChITautomerGenerator.GetElementsByPosition(System.String,NCDK.IAtomContainer)">
            <summary>
            Parses the InChI's formula (ignoring hydrogen) and returns a map
            with with a position for each atom, increasing in the order
            of the elements as listed in the formula.
            </summary>
            <param name="inputInchi">user input InChI</param>
            <param name="inputMolecule">user input molecule</param>
            <returns><see cref="T:System.Collections.Generic.IDictionary`2"/> indicating position and atom</returns>
        </member>
        <member name="M:NCDK.Tautomers.InChITautomerGenerator.ConnectAtoms(System.String,NCDK.IAtomContainer,System.Collections.Generic.IDictionary{System.Int32,NCDK.IAtom})">
            <summary>
            Pops and pushes its ways through the InChI connection table to build up a simple molecule.
            </summary>
            <param name="inputInchi">user input InChI</param>
            <param name="inputMolecule">user input molecule</param>
            <param name="inchiAtomsByPosition"></param>
            <returns>molecule with single bonds and no hydrogens.</returns>
        </member>
        <member name="M:NCDK.Tautomers.InChITautomerGenerator.MapInputMoleculeToInchiMolgraph(NCDK.IAtomContainer,NCDK.IAtomContainer)">
            <summary>
            Atom-atom mapping of the input molecule to the bare container constructed from the InChI connection table.
            This makes it possible to map the positions of the mobile hydrogens in the InChI back to the input molecule.
            </summary>
            <param name="inchiMolGraph">molecule (bare) as defined in InChI</param>
            <param name="mol">user input molecule</param>
            <exception cref="T:NCDK.CDKException"></exception>
        </member>
        <member name="M:NCDK.Tautomers.InChITautomerGenerator.ParseMobileHydrogens(System.Collections.Generic.List{System.Int32},System.String)">
            <summary>
            Parses mobile H Group(s) in an InChI string.
            <para>
            Multiple InChI sequences of mobile hydrogens are joined into a single sequence (list),
            see step 1 of algorithm in paper.
            </para>
            <para>
            Mobile H group has syntax (H[n][-[m]],a1,a2[,a3[,a4...]])
            Brackets [ ] surround optional terms.
            <list type="bullet">
             <item>Term H[n] stands for 1 or, if the number n (n>1) is present, n mobile hydrogen atoms.</item>
             <item>Term [-[m]], if present, stands for 1 or, if the number m (m>1) is present, m mobile negative charges.</item>
             <item>a1,a2[,a3[,a4...]] are canonical numbers of atoms in the mobile H group.</item>
             <item>no two mobile H groups may have an atom (a canonical number) in common.</item>
            </list>
            </para>
            </summary>
            <param name="mobHydrAttachPositions">list of positions where mobile H can attach</param>
            <param name="inputInchi">InChI input</param>
            <returns>overall count of hydrogens to be dispersed over the positions</returns>
        </member>
        <member name="M:NCDK.Tautomers.InChITautomerGenerator.ConstructTautomers(NCDK.IAtomContainer,System.Collections.Generic.List{System.Int32},System.Int32)">
            <summary>
            Constructs tautomers following (most) steps of the algorithm in <token>cdk-cite-Thalheim2010</token>.
            </summary>
            <param name="inputMolecule">input molecule</param>
            <param name="mobHydrAttachPositions">mobile H positions</param>
            <param name="totalMobHydrCount">count of mobile hydrogens in molecule</param>
            <returns>tautomers</returns>
        </member>
        <member name="M:NCDK.Tautomers.InChITautomerGenerator.RemoveDuplicates(System.Collections.Generic.List{NCDK.IAtomContainer})">
            <summary>
            Removes duplicates from a molecule set. Uses canonical SMILES to detect identical molecules.
            An example of pruning can be a case where double bonds are placed in different positions in
            an aromatic (Kekule) ring, which all amounts to one same aromatic ring.
            </summary>
            <param name="tautomers">molecule set of tautomers with possible duplicates</param>
            <returns>tautomers same set with duplicates removed</returns>
            <exception cref="T:NCDK.CDKException">unable to calculate canonical SMILES</exception>
        </member>
        <member name="M:NCDK.Tautomers.InChITautomerGenerator.CombineHydrogenPositions(System.Collections.Generic.IList{System.Int32},System.Collections.Generic.List{System.Collections.Generic.IList{System.Int32}},NCDK.IAtomContainer,System.Int32,System.Collections.Generic.IList{System.Int32})">
            <summary>
            Makes combinations recursively of all possible mobile Hydrogen positions.
            </summary>
            <param name="taken">positions taken by hydrogen</param>
            <param name="combinations">combinations made so far</param>
            <param name="skeleton">container to work on</param>
            <param name="totalMobHydrCount"></param>
            <param name="mobHydrAttachPositions"></param>
        </member>
        <member name="M:NCDK.Tautomers.InChITautomerGenerator.FindAtomByPosition(NCDK.IAtomContainer,System.Int32)">
            <summary>
            Helper method that locates an atom based on its InChI atom table
            position, which has been set as ID.
            </summary>
            <param name="container">input container</param>
            <param name="position">InChI atom table position</param>
            <returns>atom on the position</returns>
        </member>
        <member name="M:NCDK.Tautomers.InChITautomerGenerator.TryDoubleBondCombinations(NCDK.IAtomContainer,System.Int32,System.Int32,System.Int32,System.Collections.Generic.List{NCDK.IAtom})">
            <summary>
            Tries double bond combinations for a certain input container of which the double bonds have been stripped
            around the mobile hydrogen positions. Recursively.
            </summary>
            <param name="container"></param>
            <param name="dblBondsAdded">counts double bonds added so far</param>
            <param name="bondOffSet">offset for next double bond position to consider</param>
            <param name="doubleBondMax">maximum number of double bonds to add</param>
            <param name="atomsInNeedOfFix">atoms that require more bonds</param>
            <returns>a list of double bond positions (index) that make a valid combination, null if none found</returns>
        </member>
        <member name="M:NCDK.Tautomers.InChITautomerGenerator.GetConnectivity(NCDK.IAtom,NCDK.IAtomContainer)">
            <summary>
            Sums the number of bonds (counting order) an atom is hooked up with.
            </summary>
            <param name="atom">an atom in the container</param>
            <param name="container">the container</param>
            <returns>valence (bond order sum) of the atom</returns>
        </member>
        <member name="T:NCDK.Features.MoleculeFeaturesTool">
            <summary>
            Utility that helps determine which data features are present.
            </summary>
        </member>
        <member name="M:NCDK.Features.MoleculeFeaturesTool.HasGraphRepresentation(NCDK.IAtomContainer)">
            <summary>
            Checks whether all bonds have exactly two atoms.
            </summary>
        </member>
    </members>
</doc>
